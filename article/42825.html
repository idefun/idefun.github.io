<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">

<script>
    (function () {
        if ('') {
            if (prompt('请输入文章密码') !== '') {
                alert('密码错误！');
                if (history.length === 1) {
                    location.replace("http://www.idefun.com/blog"); // 这里替换成你的首页
                } else {
                    history.back();
                }
            }
        }
    })();
</script>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="gbB1uigphP0qWh_VtMmhQ2-LGLPmOFHuwcKrQ31yGXk">
  <meta name="msvalidate.01" content="0506017C2467A2086FFB31327D64F9DD">
  <meta name="baidu-site-verification" content="code-iOAnQ9ZrIU">

  <meta name="sogou_site_verification" content="gk7ca2RMLQ"/>


<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=EB Garamond:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-mac-osx.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.idefun.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true,"b2t":false,"scrollpercent":true},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本文旨在记录数据结构与算法学习中所获(C语言)">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法总结">
<meta property="og:url" content="http://blog.idefun.com/article/42825.html">
<meta property="og:site_name" content="IdeFun Blog">
<meta property="og:description" content="本文旨在记录数据结构与算法学习中所获(C语言)">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/01/11/qoiHNkTzsJxjBGD.png">
<meta property="og:image" content="https://i.loli.net/2021/01/11/a3LdovfMAlmkNxE.png">
<meta property="og:image" content="https://i.loli.net/2021/01/11/c7e6tdFC3w1NAlo.png">
<meta property="og:image" content="https://i.loli.net/2021/01/11/nGcsUypoHmbizL9.png">
<meta property="article:published_time" content="2021-01-11T07:36:41.000Z">
<meta property="article:modified_time" content="2021-03-01T23:05:20.127Z">
<meta property="article:author" content="IdeFun">
<meta property="article:tag" content="数据结构与算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/01/11/qoiHNkTzsJxjBGD.png">

<link rel="canonical" href="http://blog.idefun.com/article/42825.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<script> 
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>

  <title>数据结构与算法总结 | IdeFun Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-Y0WRGPLW2R"></script>
    <script data-pjax>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-Y0WRGPLW2R');
      }
    </script>


  <script data-pjax>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f3e54559a18afd6cd8a648ff0740cc8b";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="IdeFun Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">IdeFun Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">暗透了,更能看得见星光</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-photos">

    <a href="/photos/" rel="section"><i class="fas fa-camera-retro fa-fw"></i>相册</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程</a>

  </li>
        <li class="menu-item menu-item-links">

    <a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友链</a>

  </li>
        <li class="menu-item menu-item-language">

    <a href="https://blog.idefun.com/en" rel="section"><i class="fa fa-language fa-fw"></i>English</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.idefun.com/article/42825.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://i.loli.net/2021/01/05/Gf1qZ9szBp7tISF.jpg">
      <meta itemprop="name" content="IdeFun">
      <meta itemprop="description" content="IdeFun的小破站,记录生活,分享知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IdeFun Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构与算法总结
        </h1>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-11 15:36:41" itemprop="dateCreated datePublished" datetime="2021-01-11T15:36:41+08:00">2021-01-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-02 07:05:20" itemprop="dateModified" datetime="2021-03-02T07:05:20+08:00">2021-03-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/article/42825.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/article/42825.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>
            <div class="post-description">本文旨在记录数据结构与算法学习中所获(C语言)</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="一-绪论"><a href="#一-绪论" class="headerlink" title="一.绪论"></a>一.绪论</h2><p>算法是为了解决实际问题而设计的.数据结构是算法需要处理的问题载体.</p>
<h3 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语:"></a>基本概念和术语:</h3><ul>
<li><p>数据:数据是指能输入到计算机中并能够被计算机处理的一切对象.</p>
</li>
<li><p>数据元素:数据元素是数据的基本单位.</p>
</li>
<li><p>数据项:一个数据元素可由若干数据项组成.</p>
</li>
<li><p>数据对象:数据对象是具有相同性质的数据元素的集合.</p>
</li>
</ul>
<ul>
<li>数据结构:数据结构是指互相之间存在着一种或多种关系的数据元素的集合.</li>
</ul>
<hr>
<h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构:"></a>逻辑结构:</h3><p>1.集合结构:数据元素同属一个集合，单个数据元素之间没有任何关系</p>
<p><img src="https://i.loli.net/2021/01/11/qoiHNkTzsJxjBGD.png" alt=""></p>
<p>​    2.线性结构:类似于线性关系,数据元素之间是一对一的关系</p>
<p><img src="https://i.loli.net/2021/01/11/a3LdovfMAlmkNxE.png" alt=""></p>
<p>​    3.树形结构:树形结构中的数据元素之间存在一对多的关系</p>
<p><img src="https://i.loli.net/2021/01/11/c7e6tdFC3w1NAlo.png" alt=""></p>
<p>​    4.图形结构:数据元素之间是多对多的关系</p>
<p><img src="https://i.loli.net/2021/01/11/nGcsUypoHmbizL9.png" alt=""></p>
<hr>
<h3 id="存储结构-物理结构"><a href="#存储结构-物理结构" class="headerlink" title="存储结构(物理结构):"></a>存储结构(物理结构):</h3><p>(数据结构种类很多， 甚至你也可以发明自己的数据结构， 但是底层存储无非数组或者链表 ,那些多样化的数据结构， 究其源头， 都是在链表或者数组上的特殊操作 )</p>
<p>1.顺序存储:一段连续的内存空间</p>
<ul>
<li>优点：随机访问</li>
</ul>
<ul>
<li>缺点：插入删除效率低，大小固定</li>
</ul>
<p>2.链式存储:不连续的内存空间</p>
<ul>
<li>优点：大小动态扩展，插入删除效率高</li>
</ul>
<ul>
<li>缺点：不能随机访问</li>
</ul>
<p>3.索引:为了方便查找，整体无序，但索引块之间有序，需要额外空间存储索引表</p>
<ul>
<li><p>优点：对顺序查找的一种改进，查找效率高</p>
</li>
<li><p>缺点：需额外空间存储索引</p>
</li>
</ul>
<p>4.散列:选取某个函数，数据元素根据函数计算存储位置,可能存在多个数据元素存储在同一位置，引起地址冲突</p>
<ul>
<li>优点：查找基于数据本身即可找到，查找效率高，存取效率高</li>
</ul>
<ul>
<li>缺点：存取随机，不便于顺序查找</li>
</ul>
<p>队列,栈这两种数据结构既可以使用链表也可以使用数组实现.用数组实现,就要处理扩容缩容的问题; 用链表实现,则没有这个问题,但需要更多的内存空间存储节点指针</p>
<p>图的两种表示方法,邻接表就是链表,邻接矩阵就是二维数组.邻接矩阵判断连通性迅速,并可以进行矩阵运算解决一些问题,但是如果图比较稀疏的话很耗费空间.邻接表比较节省空间,但是很多操作的效率上肯定比不过邻接矩阵。</p>
<p>散列表就是通过散列函数把键映射到一个大数组里,而且对于解决散列冲突的方法,拉链法需要链表特性,操作简单,但需要额外的空间存储指针;线性探查法就需要数组特性,以便连续寻址,不需要指针的存储空间,但操作稍微复些.  </p>
<hr>
<h3 id="影响算法运行时间的因素"><a href="#影响算法运行时间的因素" class="headerlink" title="影响算法运行时间的因素:"></a>影响算法运行时间的因素:</h3><p>1.运行程序的计算机的机器指令的品质与速度</p>
<p>2.书写程序的语言(一般实现语言级别越高,其执行效率越低)</p>
<p>3.编译程序所生成目标代码的质量</p>
<p>4.问题的规模</p>
<hr>
<h3 id="大O表示法-用来表示时间复杂度函数的增长率的上界"><a href="#大O表示法-用来表示时间复杂度函数的增长率的上界" class="headerlink" title="大O表示法:用来表示时间复杂度函数的增长率的上界"></a>大O表示法:用来表示时间复杂度函数的增长率的上界</h3><p>时间复杂度:嵌套(求积),并列(求和),只关注最高次项</p>
<p>空间复杂度:算法运行所需存储空间:</p>
<p>1.程序本身占用的空间</p>
<p>2.算法的输入,输出占用的空间</p>
<p>3.算法运行中占用的空间</p>
<p>评价一个算法的空间复杂度一般只考虑算法运行中所占用的临时空间.</p>
<p>对于一个算法,其时间复杂度和空间复杂度往往是相互影响的.</p>
<h2 id="二-线性表"><a href="#二-线性表" class="headerlink" title="二.线性表"></a>二.线性表</h2><p>线性结构的特点是在数据元素的非空有限集合中,存在唯一的首元素和唯一的尾元素,首元素无直接前驱,尾元素无直接后继,集合中其他数据元素都有唯一的直接前驱和唯一的直接后继.线性表是最简单,最基本,也是最常用的一种线性结构.</p>
<hr>
<p>线性表是具有相同数据类型的n(n&gt;=0)个数据元素的有限序列.</p>
<h3 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构:"></a>线性表的顺序存储结构:</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20  <span class="comment">//存储空间初始分配量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType; <span class="comment">//ElemType类型根据实际情况而定,这里假设为int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data[MAXSIZE]; <span class="comment">//数组存储数据元素,最大值为MAXSIZE</span></span><br><span class="line">    <span class="keyword">int</span> length;  <span class="comment">//线性表当前长度</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>
<p>线性表顺序存储结构需要三个属性:</p>
<ul>
<li>存储空间的起始位置</li>
<li>线性表的最大存储容量(数组的长度)</li>
<li>线性表的当前长度(小于等于数组长度)</li>
</ul>
<p>顺序表的初始化:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SqList *<span class="title">init_SqList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqList *L;</span><br><span class="line">    L=(SqList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SqList)); <span class="comment">//动态分配内存空间</span></span><br><span class="line">    <span class="keyword">if</span>(!L) <span class="built_in">exit</span>(<span class="number">1</span>);  <span class="comment">//如果存储分配失败,运行exit()函数终止程序运行</span></span><br><span class="line">    L-&gt;length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺序表的插入运算:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SqList *<span class="title">Insert_SqList</span><span class="params">(SqList *L,<span class="keyword">int</span> i,ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在顺序表L第i个位置插入值为x的元素</span></span><br><span class="line">    <span class="keyword">if</span>(L-&gt;length&gt;=MAXSIZE<span class="number">-1</span>)<span class="comment">//判断表是否满</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;顺序表已满!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;L-&gt;length+<span class="number">1</span>)<span class="comment">//判断插入位置是否合理</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入位置i不合理!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> m=L-&gt;length<span class="number">-1</span>;m&gt;=i<span class="number">-1</span>;m--)</span><br><span class="line">    &#123;</span><br><span class="line">        L-&gt;data[m+<span class="number">1</span>]=L-&gt;data[m];<span class="comment">//节点后移</span></span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;data[i<span class="number">-1</span>]=x;<span class="comment">//新元素插入</span></span><br><span class="line">    L-&gt;length++;<span class="comment">//表长加1</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺序表的删除运算:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SqList *<span class="title">Delete_SqList</span><span class="params">(SqList *L,<span class="keyword">int</span> i,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//删除顺序表L中第i个元素,删除元素的值保存在e中</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;L-&gt;length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入位置i不合理!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    e=L-&gt;data[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i;i&lt;=L-&gt;length<span class="number">-1</span>;++i)</span><br><span class="line">        L-&gt;data[i<span class="number">-1</span>]=L-&gt;data[i];</span><br><span class="line">    L-&gt;length--;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺序表按值查找运算:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem_Sq</span><span class="params">(SqList *L,ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在顺序表中查找值为x的元素,查找成功返回元素存储位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L-&gt;data[i]==x)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺序表合并算法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SqList *<span class="title">Merge_SqList</span><span class="params">(SqList *A,SqList *B)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//将两个非递减次序排列的顺序表A和B合并为一个新的有序顺序表C</span></span><br><span class="line">    SqList *C;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    i=<span class="number">0</span>;j=<span class="number">0</span>;k=<span class="number">0</span>;</span><br><span class="line">    C=(SqList *)<span class="built_in">malloc</span>(<span class="number">2</span>*MAXSIZE*<span class="keyword">sizeof</span>(SqList));</span><br><span class="line">    <span class="keyword">if</span>(!C) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    C-&gt;length=A-&gt;length+B-&gt;length;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=A-&gt;length<span class="number">-1</span>&amp;&amp;j&lt;=B-&gt;length)</span><br><span class="line">        <span class="keyword">if</span>(A-&gt;data[i]&lt;B-&gt;data[j])</span><br><span class="line">        &#123;</span><br><span class="line">            C-&gt;data[k]=A-&gt;data[i];k++;i++;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            C-&gt;data[k]=B-&gt;data[j];k++;j++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//前面部分是先将A,B中较短的填入C,后面再填入另一个</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=A-&gt;length<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        C-&gt;data[k]=A-&gt;data[i];k++;i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;B-&gt;length<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        C-&gt;data[k]=B-&gt;data[j];k++;j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构:"></a>线性表的链式存储结构:</h3><h4 id="1-单链表-动态链表"><a href="#1-单链表-动态链表" class="headerlink" title="1.单链表(动态链表)"></a>1.单链表(动态链表)</h4><p>静态链表是用类似于数组方法实现的，是顺序的存储结构，在物理地址上是连续的，而且需要预先分配地址空间大小。所以静态链表的初始长度一般是固定的，在做插入和删除操作时不需要移动元素，仅需修改指针</p>
<p>单链表节点数据类型:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">LinkList</span>;</span></span><br></pre></td></tr></table></figure>
<p>头插入法建立单链表:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">CreatList_L1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList L;</span><br><span class="line">    LinkList P;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    L=(LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p=(LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        p-&gt;data=x;</span><br><span class="line">        p-&gt;next=L-&gt;next;</span><br><span class="line">        L-&gt;next=p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尾插入法建立单链表:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">CreatList_L2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList L,p,r;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    r=L=(LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p=(LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        p-&gt;data=x;</span><br><span class="line">        p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        r-&gt;next=p;</span><br><span class="line">        r=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求链表长度的算法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Listlength</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找操作:</p>
<p>​            1.按序号查找</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">Get_LinkList</span><span class="params">(LinkList L,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在链表L中查找第i个元素,找到返回其指针,否则返回空</span></span><br><span class="line">    LinkList p;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j==i)<span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​            2.按值查找</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">Locate_LinkList</span><span class="params">(LinkList L,ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>&amp;&amp;p-&gt;data!=x)</span><br><span class="line">       p=p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入运算:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">ListInsert</span><span class="params">(LinkList L,<span class="keyword">int</span> i,ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在单链表第i个节点前插入新元素x</span></span><br><span class="line">    LinkList p,s;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>&amp;&amp;j&lt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||j&gt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;<span class="built_in">printf</span>(<span class="string">&quot;参数i错误!&quot;</span>);<span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line">    s=(LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除运算:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">ListDelete</span><span class="params">(LinkList L,<span class="keyword">int</span> i,ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//删除单链表L中第i个元素</span></span><br><span class="line">    LinkList p,q;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>&amp;&amp;j&lt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next=<span class="literal">NULL</span>||j&gt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;参数i错误!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    q=p-&gt;next;</span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    *e=q-&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有序链表归并算法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">Merge_LinkList</span><span class="params">(LinkList A,LinkList B)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//A,B均为带头节点的单链表</span></span><br><span class="line">    LinkList C,p,q,s;</span><br><span class="line">    p=A-&gt;next;</span><br><span class="line">    q=B-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">    C=A;</span><br><span class="line">    C-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data&lt;q-&gt;data)&#123;s=p;p=p-&gt;next;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;s=q;q=q-&gt;next;&#125;</span><br><span class="line">        s-&gt;next=C-&gt;next;</span><br><span class="line">        C-&gt;next=s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)p=q;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        s=p;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        s-&gt;next=C-&gt;next;</span><br><span class="line">        C-&gt;next=s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-循环链表"><a href="#2-循环链表" class="headerlink" title="2.循环链表"></a>2.循环链表</h4><p>1.单向循环链表</p>
<p>单链表尾节点的指针域是空指针.而单向循环链表的最后一个节点的指针指向链表头节点.</p>
<p>对于单链表,从一已知节点只能访问该节点及其后继节点,无法访问该节点之前的节点;而对于单向循环链表,只要知道表中任一节点的地址,就可搜寻到所有其他节点的地址,遍历整个链表.</p>
<p>单向循环链表的数据类型定义与单链表相同.在单循环链表上的操作也与单链表基本相同,二者主要区别在于:判断是否达到表尾的条件不同.在单链表中,用指针域是否为NULL作为判断表尾节点的条件;而在循环链表中,则以节点指针域是否等于表头节点(头指针)作为判断到达表尾的条件.</p>
<p>2.双向链表</p>
<p>双向链表的结构:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLnode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span></span><br><span class="line">&#125;DuLnode;</span><br><span class="line"><span class="keyword">typedef</span> DuLnode *DuLinkList;</span><br></pre></td></tr></table></figure>
<p>双向链表的插入运算:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DuLinkList <span class="title">ListInsert_Dul</span><span class="params">(DuLinkList L,<span class="keyword">int</span> i,ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在双向链表的第i个节点前插入一个新元素x</span></span><br><span class="line">	DuLinkList p,s;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    p=L;</span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)</span><br><span class="line">    &#123;p=p-&gt;next;j++&#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||j&lt;i)</span><br><span class="line">    &#123;<span class="built_in">printf</span>(<span class="string">&quot;参数i错误!&quot;</span>);<span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line">    <span class="keyword">if</span>(!(s=(DuLinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DuLnode))))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;prior=p-&gt;prior;p-&gt;prior-&gt;next=s;</span><br><span class="line">    s-&gt;next=p;p-&gt;prior=s;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双向链表的删除运算:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DuLinkList <span class="title">ListDelete_Dul</span><span class="params">(DuLinkList L,<span class="keyword">int</span> i,ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//删除双向链表中第i数据元素</span></span><br><span class="line">    DuLinkList p;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    p=L;</span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)</span><br><span class="line">    &#123;p=p-&gt;next;j++;&#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||j&gt;i)</span><br><span class="line">    &#123;<span class="built_in">printf</span>(<span class="string">&quot;参数i错误!&quot;</span>);<span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        e=p-&gt;data;</span><br><span class="line">        p-&gt;prior-&gt;next=p-&gt;next;</span><br><span class="line">        p-&gt;next-&gt;prior=p-&gt;prior;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三-栈与队列"><a href="#三-栈与队列" class="headerlink" title="三.栈与队列"></a>三.栈与队列</h2><p>栈和队列是在程序设计中被广泛使用的两种数据结构.由于从数据结构角度看,栈和队列是两种特殊的线性表.它们的逻辑结构和线性表相同,只是其运算规则较线性表有更多的限制,因此,也可以将栈和队列称为操作受限的线性表.</p>
<p>栈是限定仅在表尾进行插入和删除操作的线性表.队列是只允许在一端进行插入操作,而在另一端进行删除操作的线性表.</p>
<h3 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h3><ul>
<li>栈是一种特殊的线性表,是一种只允许在表的一端进行插入或删除操作的线性表.把栈中允许进行插入,删除操作的一端称为栈顶,栈的另一端称为栈底.</li>
<li>当栈中没有数据元素时,称之为空栈.栈顶是动态的,对栈顶位置的标记称为栈顶指针.栈的插入操作通常称为进栈(入栈或压栈),栈的删除操作通常称为退栈或出栈.</li>
<li>根据栈的定义,每次进栈的数据元素都放在当前栈顶元素之前而成为新的栈顶元素,每次退栈的数据元素都是当前栈顶元素.这样,最后进入栈的数据元素总是最先退出栈,因此,栈具有”后进先出”的特性,所以栈又称为后进先出的线性表,简称LIFO表.</li>
</ul>
<h3 id="栈的存储结构"><a href="#栈的存储结构" class="headerlink" title="栈的存储结构"></a>栈的存储结构</h3><p>栈有两种存储表示方法,即顺序存储和链式存储.顺序存储的栈称为顺序栈,链式存储的栈称为链式栈.</p>
<h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><p>顺序栈的存储结构:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> StackInitSize 100;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> StackElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    StackElementType data[StackInitSize];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125;SeqStack;</span><br></pre></td></tr></table></figure>
<p>顺序栈的初始化:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SeqStack *<span class="title">InitStack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SeqStack *s;</span><br><span class="line">    s=(SeqStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SeqStack));</span><br><span class="line">    <span class="keyword">if</span>(s!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;s-&gt;top=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> s;&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;没有足够的内存空间,申请失败,程序运行终止!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断栈空的函数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(SeqStack *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(s-&gt;top==<span class="number">-1</span>)?<span class="number">1</span>:<span class="number">0</span>;<span class="comment">//栈空返回1,否则返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>销毁栈的函数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestoryStack</span><span class="params">(SeqStack *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈已销毁!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进栈操作:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(SeqStack *s,StackElementType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;top==StackInitSize)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈满!栈发生上溢,程序停止运行!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        s-&gt;top++;</span><br><span class="line">        s-&gt;data[s-&gt;top]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>退栈操作:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">StackElementType <span class="title">Pop</span><span class="params">(SeqStack *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StackElementType temp;</span><br><span class="line">    <span class="keyword">if</span>(IsElpty(s))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈空!栈发生下溢,程序停止运行!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        temp=s-&gt;data[s-&gt;top];</span><br><span class="line">        s-&gt;top--;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取栈顶元素:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">StackElementType <span class="title">GetTop</span><span class="params">(SeqStack *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;空栈,程序停止运行!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> s-&gt;data[s-&gt;top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>栈浮动技术:</p>
<p>当一个程序中同时使用多个顺序栈时,为了防止上溢错误,需要为每个栈分配较大的存储空间.在多栈使用过程中通常会出现:在某一栈发生上溢的同时,其余栈尚有大量未用空间存在,这样不利于内存空间的共享,会降低内存空间的使用效率.如果将多个栈安排在同一个连续的存储空间中,这样多个栈共享存储空间,并使它们根据实际情况互相调节余缺.如此既节省了存储空间的开销,又降低了上溢现象发生的概率.这种多栈共享空间的技术,通常称为栈浮动技术.</p>
<p>当程序中同时使用两个栈时,两个栈可以共享同一存储空间.此时,将两个栈的栈底分别设在同一存储空间的两端,让两个栈各自向中间延伸.这样只有当整个共享空间被两个栈占满(两个栈的栈顶相遇)时,才会发生上溢.</p>
<p>两栈共享空间的结构:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    StackElementType data[StackInitSize];</span><br><span class="line">    <span class="keyword">int</span> top1;<span class="comment">//栈1栈顶指针</span></span><br><span class="line">    <span class="keyword">int</span> top2;<span class="comment">//栈2栈顶指针</span></span><br><span class="line">&#125;SqDoubleStack;</span><br></pre></td></tr></table></figure>
<p>对于两栈共享空间的进栈方法,我们除了要插入元素值参数外,还需要有一个判断是栈1还是栈2的栈号参数stackNumber</p>
<h4 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h4><p>链式栈的存储结构:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> StackElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    StackElementType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkStack;</span><br></pre></td></tr></table></figure>
<p>链式栈的进栈操作:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkStack *<span class="title">Push</span><span class="params">(LinkStack *top,StackElementType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkStack *p;</span><br><span class="line">    p=(LinkStack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkStack));</span><br><span class="line">    <span class="keyword">if</span>(p)&#123;p-&gt;data=x;</span><br><span class="line">         p-&gt;next=top;</span><br><span class="line">         top=p;</span><br><span class="line">         <span class="keyword">return</span> top;&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;内存不足,程序运行停止!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链式栈的退栈操作:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkStack *<span class="title">Pop</span><span class="params">(LinkStack *top,StackElementType *elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkStack *temp;</span><br><span class="line">    <span class="keyword">if</span>(top)</span><br><span class="line">    &#123;</span><br><span class="line">        temp=top;</span><br><span class="line">        *elem=top-&gt;data;</span><br><span class="line">        top=top-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链式栈读取栈顶元素:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">StackElementType <span class="title">GetTop</span><span class="params">(LinkStack *top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> top?top-&gt;data:<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h3><ul>
<li>队列(Queue)是一种只允许在一端进行插入,另一端进行删除的运算受限的线性表,允许删除的一端叫队头(front),允许插入的一端叫队尾(rear).</li>
<li>队列的插入操作通常称为入队,删除操作通常称为出队,当队列中没有元素时称为空队列.</li>
<li>队列具有”先进先出”(FIFO)特性,简称为FIFO表.</li>
</ul>
<h4 id="队列的存储结构"><a href="#队列的存储结构" class="headerlink" title="队列的存储结构"></a>队列的存储结构</h4><h5 id="循环队列-顺序队列"><a href="#循环队列-顺序队列" class="headerlink" title="循环队列(顺序队列)"></a>循环队列(顺序队列)</h5><p>在顺序队列中,进行入队和出队操作时可能产生溢出现象:</p>
<p>1.”下溢”现象</p>
<p>当队列为空时,进行出队运算产生的溢出现象,称为”下溢”.可通过判断队列是否为空来控制</p>
<p>2.”真上溢”现象</p>
<p>当队列满时,进行入队运算时产生空间溢出的现象,称为”真上溢”.可通过判断队列是否满来控制</p>
<p>3.”假上溢”现象</p>
<p>由于在入队和出队操作中,队头指针与队尾指针只增加不减小,致使被删元素的空间永远无法重新利用.当队列中实际的元素个数远远小于存储空间的规模时,也可能由于队尾指针已超越队列空间的上界而不能做入队操作.这种现象称为”假下溢”.</p>
<p>为防止假溢出现象发生,充分利用存储空间,最巧妙的解决方法就是把队列存储空间看作首尾相连的环,而这种队列的循环顺序存储结构称为循环队列.</p>
<p>循环队列存储结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QueueElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    QueueElementType *base;<span class="comment">//base指向队列存储区首地址</span></span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">&#125;SeqQueue;</span><br></pre></td></tr></table></figure>
<p>循环队列的特点</p>
<ul>
<li>队头,队尾指针加1时从MaxSize-1直接进到0,这种变化可用C语言的取模(余数)运算实现</li>
<li>队空与队满时头尾指针均相等,无法通过front==rear来判断队列的”空”和”满”,解决此问题有两种方法:<ol>
<li>另设一个状态标志位来区别”队空”和”队满”</li>
<li>少用一个存储空间,约定以队头指针在队尾指针的下一位置上作为队列满的标志</li>
</ol>
</li>
</ul>
<p>采用第二种处理方法:</p>
<p>循环队列空的标志:front==rear</p>
<p>循环队列满的标志:(rear+1)%MaxSize==front</p>
<p>循环队列初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SeqQueue <span class="title">InitQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SeqQueue Q;</span><br><span class="line">    Q.base=(QueueElementType*)<span class="built_in">malloc</span>(MaxSize*<span class="keyword">sizeof</span>(QueueElementType));</span><br><span class="line">    <span class="keyword">if</span>(!Q.base)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;申请存储空间失败,程序运行终止!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Q.front=<span class="number">0</span>;</span><br><span class="line">    Q.rear=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断循环队列为空</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueEmpty</span><span class="params">(SeqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front==Q.rear)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断循环队列为满</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueFull</span><span class="params">(SeqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front==(Q.rear+<span class="number">1</span>)%MaxSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入队操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SeqQueue <span class="title">EnQUeue</span><span class="params">(SeqQueue Q,QueueElementType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(QueueFull(Q)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;队满!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        *(Q.base+Q.rear)=x;</span><br><span class="line">        Q.rear=(Q.rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出队操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SeqQueue <span class="title">DeQueue</span><span class="params">(SeqQueue Q,QueueElementType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(QueueEmpty(Q))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队空!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        *e=*(Q.base+Q.front);</span><br><span class="line">        Q.front=(Q.front+<span class="number">1</span>)%MaxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取队头元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">QueueElementType <span class="title">GetHead</span><span class="params">(SeqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(QueueEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队空!读取失败!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> *(Q.base+Q.front);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>销毁队列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestoryQueue</span><span class="params">(SeqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(Q.base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队列已被销毁!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>队列遍历操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueueDisplay</span><span class="params">(SeqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(QueueEmpty(Q))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队空!队列遍历完成!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列遍历(队头-&gt;队尾):\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=Q.front;i!=Q.rear;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>,*(Q.base+i));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\b\b \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h5><p>一个链式队列由一个头指针和一个尾指针唯一地确定.</p>
<p>链式队列节点类型定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QueueElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    QueueElementType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QueueNode;</span><br></pre></td></tr></table></figure>
<p>链式队列数据类型定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    QueueNode *front;</span><br><span class="line">    QueueNode *rear;</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>
<p>链式队列的初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkQueue <span class="title">InitQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    QueueNode *p;</span><br><span class="line">    p=(QueueNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">    <span class="keyword">if</span>(p)&#123;</span><br><span class="line">        Q.front=Q.rear=p;</span><br><span class="line">        Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> Q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;初始化失败!程序运行终止!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断链式队列是否为空</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueEmpty</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front=Q.rear)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入队操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkQueue <span class="title">EnQueue</span><span class="params">(LinkQueue Q,QueueElementType x)</span></span>&#123;</span><br><span class="line">    QueueNode *p;</span><br><span class="line">    p=(QueueNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">    <span class="keyword">if</span>(!p)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;申请空间失败!程序运行终止!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        p-&gt;data=x;</span><br><span class="line">        p-&gt;next=<span class="literal">NULL</span>;<span class="comment">//尾节点的next置空</span></span><br><span class="line">        Q.rear-&gt;next=p;</span><br><span class="line">        Q.rear=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出队操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkQueue <span class="title">DeQueue</span><span class="params">(LinkQueue Q,QueueELementType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QueueNode *p;</span><br><span class="line">    <span class="keyword">if</span>(QueueEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空!出队失败!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        p=Q.front-&gt;next;</span><br><span class="line">        *e=p-&gt;data;</span><br><span class="line">        Q.front-&gt;next=p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(Q.rear==p)</span><br><span class="line">            Q.rear=Q.front;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取队头操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">QueueElementType <span class="title">GetHead</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(QueueEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;队列为空!读取队头失败!\n&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (Q.front-&gt;next.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四-矩阵的压缩存储"><a href="#四-矩阵的压缩存储" class="headerlink" title="四.矩阵的压缩存储"></a>四.矩阵的压缩存储</h2><h2 id="五-递归"><a href="#五-递归" class="headerlink" title="五.递归"></a>五.递归</h2><h2 id="六-树与二叉树"><a href="#六-树与二叉树" class="headerlink" title="六.树与二叉树"></a>六.树与二叉树</h2><h2 id="七-图"><a href="#七-图" class="headerlink" title="七.图"></a>七.图</h2><p>图形结构是一种比树形结构更复杂的非线性结构.在树形结构中,节点间具有分支层次关系,每一层上的节点只能和上一层中的至多一个节点相关,但可能和下一层的多个节点相关.而在图形结构中,任意两个节点之间都可能相关,即节点之间的邻接关系可以是任意的.</p>
<h3 id="图及其相关概念"><a href="#图及其相关概念" class="headerlink" title="图及其相关概念"></a>图及其相关概念</h3><ul>
<li>图是由顶点(vertex)集合及顶点间的关系组成的一种数据结构.</li>
<li>图分为无向图和有向图.具有n个顶点,n(n-1)/2条边的无向图,称为完全无向图.具有n个顶点,n(n-1)条弧的有向图称为完全有向图.完全无向图和完全有向图统称为完全图.</li>
<li>当一个图接近完全图时,称它为稠密图.相反称为稀疏图.</li>
<li>与边有关的数据信息称为权.带权图又称为网络.如果边是有方向的带权图,则是一个有向网络.</li>
<li>在无向图中,一个顶点依附的边的数目称为该顶点的度.在有向图中,指向顶点的弧的数目称为该顶点的入度(这种弧也称为入弧).从顶点发出的弧的数目称为该顶点的出度.有向图的某个顶点的入度和出度之和称为该顶点的度.</li>
<li>除第一个顶点与最后一个顶点之外,其它顶点不重复出现的回路称为简单回路(简单环).</li>
<li>若G中任意两个顶点都是连通的,则称G为连通图,否则称为非连通图.</li>
</ul>
<h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><h4 id="邻接矩阵表示法"><a href="#邻接矩阵表示法" class="headerlink" title="邻接矩阵表示法"></a>邻接矩阵表示法</h4><p>在图的邻接矩阵表示中,除用一个一维数组存放顶点本身的信息外,还用一个n×n的矩阵表示各个顶点之间的邻接关系.即若(i,j)或<i,j>属于边集E,则矩阵中第i行,第j列元素值为1,否则为0.</p>
<p>从无向图的邻接矩阵存储方法可以看出:</p>
<ol>
<li>无向图的邻接矩阵一定是一个对称矩阵</li>
<li>第i行或第i列中1的个数是顶点i的度</li>
<li>矩阵中1的个数的一半为图中边的数目</li>
</ol>
<p>从有向图的邻接矩阵存储方法可以看出:</p>
<ol>
<li>有向图的邻接矩阵不一定是一个对称矩阵</li>
<li>第i行中1的个数为顶点i的出度</li>
<li>第i列中1的个数为顶点i的入度</li>
<li>矩阵中1的个数为图中弧的数目</li>
</ol>
<p>从无向网络的邻接矩阵存储方法可以看出:</p>
<ol>
<li>无向网络的邻接矩阵一定是一个对称矩阵</li>
<li>第i行或第i列中非∞元素的个数为顶点i的度</li>
<li>矩阵中非∞元素的个数的一半为网络中边的数目</li>
</ol>
<p>从有向网络的邻接矩阵存储方法可以看出:</p>
<ol>
<li>有向网络的邻接矩阵不一定是一个对称矩阵</li>
<li>第i行中非∞元素的个数为顶点i的出度</li>
<li>第i列中非∞元素的个数为顶点i的入度</li>
<li>矩阵中非∞元素的个数为网络中弧的数目</li>
</ol>
<p>邻接矩阵的存储结构:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITY 65535 <span class="comment">//用65535表示∞</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVEX 100 <span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;<span class="comment">//顶点类型由用户定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType;<span class="comment">//边上的权值类型由用户定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    VertexType vexs[MAXVEX];<span class="comment">//顶点表</span></span><br><span class="line">    EdgeType arc[MAXVEX][MAXVEX];<span class="comment">//邻接矩阵,可看作边表</span></span><br><span class="line">    <span class="keyword">int</span> numVertexs,numEdges;<span class="comment">//图中当前的顶点和边数</span></span><br><span class="line">&#125;Mgraph;</span><br></pre></td></tr></table></figure>
<p>无向网图的邻接矩阵表示:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatMGraph</span><span class="params">(MGraph *G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k,w;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入顶点数和边数:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;G-&gt;numVertexs,&amp;G-&gt;numEdges);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;numVertexs;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(&amp;G-&gt;vexs[i]);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;numVertexs;i++)</span><br><span class="line">        <span class="keyword">for</span>(j<span class="number">-0</span>;j&lt;G-&gt;numVertexs;j++)</span><br><span class="line">            G-&gt;arc[i][j]=INFINITY;<span class="comment">//邻接矩阵初始化</span></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G-&gt;numEdges;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入边(vi,vj)上的下标i,下标j和权w:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d,%d&quot;</span>,&amp;i,&amp;j,&amp;w);</span><br><span class="line">        G-&gt;arc[i][j]=w;</span><br><span class="line">        G-&gt;arc[j][i]=G-&gt;arc[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="邻接表表示法"><a href="#邻接表表示法" class="headerlink" title="邻接表表示法"></a>邻接表表示法</h4><h2 id="八-查找"><a href="#八-查找" class="headerlink" title="八.查找"></a>八.查找</h2><h2 id="九-排序"><a href="#九-排序" class="headerlink" title="九.排序"></a>九.排序</h2><h3 id="排序的概念"><a href="#排序的概念" class="headerlink" title="排序的概念"></a>排序的概念</h3><p>排序(Sorting)就是按照某种规则,将一组数据对象(记录)排列次序,其主要目的是提高数据检索的效率.</p>
<h3 id="排序的分类"><a href="#排序的分类" class="headerlink" title="排序的分类"></a>排序的分类</h3><p>按照排序过程中所使用存储器情况,可将排序方法分为两大类:</p>
<p>1.内部排序</p>
<p>在排序过程中,整个待排序列都是存放于内存中进行处理,无内外存储器之间的数据交换问题.内部排序速度快,适合少量数据的排序处理.</p>
<p>2.外部排序</p>
<p>在排序过程中,由于待排序记录数据量相当大,不可能也不允许全部驻留在内存中,而必须存放在外部存储器上,然后根据排序过程中的要求,不断在内外存之间进行数据交换来完成排序工作.外部排序速度慢,适合大量数据的排序问处理.</p>
<p>内部排序的方法较多,按照实现策略的不同,可以将内部排序分五大类.</p>
<ol>
<li>插入排序.直接插入排序,希尔排序.</li>
<li>交换排序.冒泡排序,快速排序.</li>
<li>选择排序.直接选择排序,堆排序.</li>
<li>归并排序.</li>
<li>基数排序.</li>
</ol>
<p>假设待排序序列中记录的数据类型定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    ElementType otherinfo;<span class="comment">//排序记录中的其他所有数据项</span></span><br><span class="line">&#125;RecordType;</span><br><span class="line"><span class="keyword">typedef</span> RecordType SeqList[MaxSize+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>数组的第0个元素既可以用来作暂存空间使用,也可以作”监测哨兵”使用,但不用其存放待排序记录.在本章均要求排成递增序.</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p>思想:</p>
<p>1.将待排序序列分为有序区和无序区,初始时,有序区为[R1],无序区为[R2…Rn],令i指向无序区第一个元素,初值i=2</p>
<p>2.当i&lt;=n时,重复执行:将当前无序区第一个记录插入到有序区合适位置</p>
<p>3.当i&gt;n时,排序结束</p>
<p>算法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(SeqList R,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//length为待排序列长度</span></span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(R[i].key&lt;R[i<span class="number">-1</span>].key)</span><br><span class="line">        &#123;</span><br><span class="line">            R[<span class="number">0</span>]=R[i];</span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;R[<span class="number">0</span>].key&lt;R[j].key;j--)</span><br><span class="line">                R[j+<span class="number">1</span>]=R[j];<span class="comment">//记录后移</span></span><br><span class="line">            R[j+<span class="number">1</span>]=R[<span class="number">0</span>];</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哨兵的作用:</p>
<p>1.进入查找(插入位置)循环之前,它保存了R[i]的副本,使不至于记录后移而丢失R[i]的内容.</p>
<p>2.在查找循环中”监视”下标j是否越界.</p>
<p>直接插入排序的时间复杂度为O(n^2),空间复杂度为O(1),直接插入排序是稳定的</p>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>希尔排序也叫缩小增量排序,是插入排序的一种,在时间复杂度上比直接插入排序好.</p>
<p>思想:</p>
<p>1.先将整个待排序列以d1(d1&lt;n)为步长分成若干子序列,把所有相隔为d1的记录放在同一组</p>
<p>2.在每个分组内进行直接插入排序</p>
<p>3.再将整个待排序记录以d2(d2&lt;d1&lt;n)为步长重新分组,并在每组内进行直接插入排序</p>
<p>4.重复上步,直至dt=1,即所有记录放进一个组中进行直接插入排序,其最终结果为有序序列</p>
<p>算法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellPass</span><span class="params">(SeqList R,<span class="keyword">int</span> length,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//希尔排序的一次排序,length为待排序列长度,d为当前增量</span></span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=d+<span class="number">1</span>;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(R[i].key&lt;R[i-d].key)&#123;</span><br><span class="line">            R[<span class="number">0</span>]=R[i];</span><br><span class="line">            j=i-d;</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                R[j+d]=R[j];</span><br><span class="line">                j=j-d;</span><br><span class="line">            &#125;<span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;R[<span class="number">0</span>].key&lt;R[j].key)</span><br><span class="line">                R[j+d]=R[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(SeqList R,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//对序列R进行希尔排序,length为待排序长度</span></span><br><span class="line">    <span class="keyword">int</span> increment=length;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        increment=(increment+<span class="number">1</span>)/<span class="number">3</span>;</span><br><span class="line">        ShellPass(R,length,increment);</span><br><span class="line">    &#125;<span class="keyword">while</span>(increment&gt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>希尔排序时间复杂度可达到O(n^1.25),空间复杂度为O(1),希尔排序不稳定</p>
<h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><p>交换排序的基本思想是两两比较待排序记录的关键字,如果发现两个关键字逆序,则将两个记录位置互换,重复此过程,直到该系列所有关键字都有序为止.</p>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>思想:</p>
<p>1.将第一个记录的关键字与第二个记录的关键字比较,若二者为逆序(R[1].key&gt;R[2].key),则交换两记录位置,然后比较第二个记录与第三个记录,若两关键字为逆序,同样交换位置</p>
<p>2.依次类推,直至第n-1个记录与第n个记录比较完为止.上述过程称为第一趟冒泡排序,其结果使n个记录中关键字最大的记录被移动到最后一个位置</p>
<p>3.然后进行第二次冒泡排序,即对前n-1个记录重复与第一趟冒泡排序类似的过程,结果使关键字次大的记录被移到第n-1个记录位置</p>
<p>4.重复上述过程,直到”在一趟排序过程中没有进行交换记录的操作”为止</p>
<p>算法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(SeqList R,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,exchange=<span class="number">1</span>;<span class="comment">//exchange为发生交换的标志</span></span><br><span class="line">    <span class="keyword">for</span>(i=length;i&gt;<span class="number">1</span>&amp;&amp;exchange;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        exchange=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(R[j].key&lt;R[j+<span class="number">1</span>].key)</span><br><span class="line">            &#123;</span><br><span class="line">                R[<span class="number">0</span>]=R[j];</span><br><span class="line">                R[j]=R[j+<span class="number">1</span>];</span><br><span class="line">                R[j+<span class="number">1</span>]=R[<span class="number">0</span>];</span><br><span class="line">                exchange=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冒泡排序时间复杂度为O(n²),空间复杂度为O(1),且冒泡排序是稳定的</p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>快速排序采用一种分治的策略,通常称为分治法.分治的基本思想是:将原问题分解为若干规模更小但将结构与原问题相似的子问题,采用递归方法求解这些子问题,然后将这些子问题的解组合成原问题的解.</p>
<p>思想:</p>
<p>1.从待排序列中任取一个记录(例如)的关键字作为枢轴(pivot),按照枢轴,将整个待排序列划分为左右两个子序列,其中左子序列中所有关键字都小于等于枢轴,而右子序列中所有的关键字都大于枢轴,枢轴记录则排在这两个子序列中间(这也是该记录的最终位置).此过程称为一趟快速排序(或一次划分).</p>
<p>2.对左右两个子序列分别重复实施上述方法,直到所有的记录都排在相应的位置上为止(每个子序列只含一个记录)</p>
<p>算法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuickPass</span><span class="params">(SeqList R,<span class="keyword">int</span> b,<span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//对R[b],...R[e]作一趟划分,并返回枢轴记录的位置</span></span><br><span class="line">    <span class="keyword">int</span> i=b,j=e;</span><br><span class="line">    R[<span class="number">0</span>]=R[i];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">while</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

   

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="IdeFun 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="IdeFun 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>IdeFun
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://blog.idefun.com/article/42825.html" title="数据结构与算法总结">http://blog.idefun.com/article/42825.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <div>
        
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
        
      </div>

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag"><i class="fa fa-tag"></i> 数据结构与算法</a>
          </div>

        
  <div class="post-widgets">
    <div class="wp_rating">
      <div id="wpac-rating"></div>
    </div>
  </div>


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/article/34877.html" rel="prev" title="Linux C编程">
      <i class="fa fa-chevron-left"></i> Linux C编程
    </a></div>
      <div class="post-nav-item">
    <a href="/article/13804.html" rel="next" title="BurpSuite的设置及使用">
      BurpSuite的设置及使用 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="nav-text">数据结构与算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-%E7%BB%AA%E8%AE%BA"><span class="nav-text">一.绪论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD"><span class="nav-text">基本概念和术语:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="nav-text">逻辑结构:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="nav-text">存储结构(物理结构):</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%B1%E5%93%8D%E7%AE%97%E6%B3%95%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E7%9A%84%E5%9B%A0%E7%B4%A0"><span class="nav-text">影响算法运行时间的因素:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7O%E8%A1%A8%E7%A4%BA%E6%B3%95-%E7%94%A8%E6%9D%A5%E8%A1%A8%E7%A4%BA%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF%E7%8E%87%E7%9A%84%E4%B8%8A%E7%95%8C"><span class="nav-text">大O表示法:用来表示时间复杂度函数的增长率的上界</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="nav-text">二.线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">线性表的顺序存储结构:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">线性表的链式存储结构:</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%8D%95%E9%93%BE%E8%A1%A8-%E5%8A%A8%E6%80%81%E9%93%BE%E8%A1%A8"><span class="nav-text">1.单链表(动态链表)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="nav-text">2.循环链表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="nav-text">三.栈与队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">栈的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">栈的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88"><span class="nav-text">顺序栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E6%A0%88"><span class="nav-text">链式栈</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">队列的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">队列的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97-%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97"><span class="nav-text">循环队列(顺序队列)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97"><span class="nav-text">链式队列</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B-%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="nav-text">四.矩阵的压缩存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94-%E9%80%92%E5%BD%92"><span class="nav-text">五.递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">六.树与二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83-%E5%9B%BE"><span class="nav-text">七.图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="nav-text">图及其相关概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">图的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-text">邻接矩阵表示法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-text">邻接表表示法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB-%E6%9F%A5%E6%89%BE"><span class="nav-text">八.查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%9D-%E6%8E%92%E5%BA%8F"><span class="nav-text">九.排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">排序的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">排序的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-text">插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-text">直接插入排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-text">希尔排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="nav-text">交换排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-text">快速排序</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="IdeFun"
      src="https://i.loli.net/2021/01/05/Gf1qZ9szBp7tISF.jpg">
  <p class="site-author-name" itemprop="name">IdeFun</p>
  <div class="site-description" itemprop="description">IdeFun的小破站,记录生活,分享知识</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wxpsjhhd" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wxpsjhhd" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>




<div style="">
  <canvas id="canvas" style="width:60%;"> 当前浏览器不支持 canvas，请更换浏览器后再试 </canvas>
</div>
<script>
(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    // 声明 canvas 的宽高 
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    // 存储时间数据 
    var data = [];
    // 存储运动的小球 
    var balls = [];
    // 设置粒子半径 
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        // 存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这 7 个数字组成 
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /* 生成点阵数字 */
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    //cxt.fillStyle = '#f00';/* 红色数字 */
                    cxt.fillStyle = '#6ce2f2';/* 白色数字 */
                    //cxt.fillStyle = '#FAF0BB';/* 代码黄数字 */
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /* 更新时钟 */
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            // 时间发生变化 
            if(NewData[i] !== data[i]){
                // 将变化的数字值和在 data 数组中的索引存储在 changeNumArray 数组中 
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        // 增加小球 
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /* 更新小球状态 */
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /* 增加要运动的小球 */
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /* 渲染 */
    function render(){
        // 重置画布宽度，达到清空画布的效果 
        canvas.height = 100;
        // 渲染时钟 
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        // 渲染小球 
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        // 更新时钟 
        updateDigitTime();
        // 更新小球状态 
        updateBalls();
        // 渲染 
        render();
    },50);
}

})();
</script>





  <div class="links-of-recent-posts motion-element">
    <div class="links-of-recent-posts-title">
      <i class="fa fa-history fa-fw"></i>
      最近文章
    </div>
    <ul class="links-of-recent-posts-list">
        <li class="links-of-recent-posts-item">
          <a href="/article/fe55cae0.html" title="article&#x2F;fe55cae0.html">git报错及解决方法盘点</a>
        </li>
        <li class="links-of-recent-posts-item">
          <a href="/article/a1a28d7.html" title="article&#x2F;a1a28d7.html">教你定时发送天气邮件</a>
        </li>
        <li class="links-of-recent-posts-item">
          <a href="/article/99e78227.html" title="article&#x2F;99e78227.html">Hexo的next主题实现双语功能</a>
        </li>
    </ul>
  </div>
      </div>
      <div id="days"></div>
</script>
<script language="javascript">
function show_date_time(){
window.setTimeout("show_date_time()", 1000);
BirthDay=new Date("01/01/2021 20:00:00");
today=new Date();
timeold=(today.getTime()-BirthDay.getTime());
sectimeold=timeold/1000
secondsold=Math.floor(sectimeold);
msPerDay=24*60*60*1000
e_daysold=timeold/msPerDay
daysold=Math.floor(e_daysold);
e_hrsold=(e_daysold-daysold)*24;
hrsold=setzero(Math.floor(e_hrsold));
e_minsold=(e_hrsold-hrsold)*60;
minsold=setzero(Math.floor((e_hrsold-hrsold)*60));
seconds=setzero(Math.floor((e_minsold-minsold)*60));
document.getElementById('days').innerHTML="已运行"+daysold+"天"+hrsold+"时"+minsold+"分"+seconds+"秒";
}
function setzero(i){
if (i<10)
{i="0" + i};
return i;
}
show_date_time();
</script>
    </div>
    
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">IdeFun</span>
</div>

<div class="translate-style">
繁/简：<a id="translateLink" href="javascript:translatePage();" rel="external nofollow noreferrer">繁体
</a>
</div>
<script type="text/javascript" src="/js/tw_cn.js"></script>
<script type="text/javascript">
var defaultEncoding = 2; //网站编写字体是否繁体，1-繁体，2-简体
var translateDelay = 0; //延迟时间,若不在前, 要设定延迟翻译时间, 如100表示100ms,默认为0
var cookieDomain = "https://blog.idefun.com/"; //Cookie地址, 一定要设定, 通常为你的网址
var msgToTraditionalChinese = "繁体"; //此处可以更改为你想要显示的文字
var msgToSimplifiedChinese = "简体"; //同上，但两处均不建议更改
var translateButtonId = "translateLink"; //默认互换id
translateInitilization();
</script>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>


  <script defer src="/lib/three/three.min.js"></script>


  
  <script data-pjax>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>



  <script data-pjax>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id    : 28855,
      el    : 'wpac-rating',
      color : 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>

  
<script src="/js/local-search.js"></script>






  <script src="//code.tidio.co/63puqgsrscxyzgqbosntsv6ezkbqgoiq.js"></script>







    <div id="pjax">
  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '3k1pRldiEm5Bav29gwwSR0Xs-MdYXbMMI',
      appKey     : 'sh1CkfaV42luCnQN7TosRDtc',
      placeholder: "来都来了，不撩一句嘛~，留言记得在上面留下【邮箱】，方便收到回复通知~",
      avatar     : 'wavatar',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-CN' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

    </div>
  <!-- 樱花特效 -->
  
      <script async src="/js/src/fairyDustCursor.js"></script>
  
  <script type="text/javascript" src="/js/src/linkcard.js"></script>
  <script src="https://myhkw.cn/player/js/player.js" id="myhk" key="160118543544" m="1"></script>
</body>
</html>
