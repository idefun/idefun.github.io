<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BurpSuite的设置及使用</title>
    <url>/article/13804.html</url>
    <content><![CDATA[<h1 id="BurpSuite的设置及使用"><a href="#BurpSuite的设置及使用" class="headerlink" title="BurpSuite的设置及使用"></a>BurpSuite的设置及使用</h1><h2 id="1-BurpSuite安装与配置"><a href="#1-BurpSuite安装与配置" class="headerlink" title="1.BurpSuite安装与配置"></a>1.BurpSuite安装与配置</h2><h3 id="BurpSuite功能介绍"><a href="#BurpSuite功能介绍" class="headerlink" title="BurpSuite功能介绍"></a>BurpSuite功能介绍</h3><p>BurpSuite是用于攻击web应用程序的集成平台，包含了许多工具。BurpSuite为这些工具设计了许多接口，以加快攻击应用程序的过程。所有工具都共享一个请求，并能处理对应的HTTP消息、持久性、认证、代理、日志、警报。</p>
<p>Burpsuite是由JAVA语言编写,所以Burpsuite是-款跨平台的软件。但是在测试过程中Buripsuite不像其他自动化测试工具不需要输入任何内容即可完成测试，而需要手动的配置某些参数触发对应的行为才会完成测试。</p>
<h2 id="2-BurpSuite-Proxy模块"><a href="#2-BurpSuite-Proxy模块" class="headerlink" title="2.BurpSuite Proxy模块"></a>2.BurpSuite Proxy模块</h2><p>Burp Proxy 是Burp Suite以用户驱动测试流程功能的核心，通过代理模式，可以让我们拦截、查看、修改所有在客户端和服务端之间传输的数据。</p>
<h3 id="1-Intercept"><a href="#1-Intercept" class="headerlink" title="1.Intercept"></a>1.Intercept</h3><p>Forward表示将截断的HTTP或HTTPS请求发送到服务器。<br>Drop表示将截断的HTTP或HTTPS请求丢弃。<br>Intercept is on和Intercept is off表示开启或关闭代理截断功能。<br>Action表示将代理截断的HTTP或HTTPS请求发送到其他模块或做其他处理。<br>对Intercept进行Raw Hex Params Header切换查看不同的数据格式。</p>
<h3 id="2-HTTP-history"><a href="#2-HTTP-history" class="headerlink" title="2.HTTP history"></a>2.HTTP history</h3><p>HTTP history用来查看提交过的HTTP请求。<br>Fiter可以过滤显示某些HTTP请求。点击Filter就可以打开。对于指定URL可以选中右键点击,执行其他操作。WebSockets history与HTTP history功能类似。</p>
<h3 id="3-options"><a href="#3-options" class="headerlink" title="3.options"></a>3.options</h3><p>Options具有的功能:代理监听设置、戳断客户端请求、截断服务器响应、截断WebSocket通信、服务端响应修改(绕过JS验证文件上传)、匹配与替换HTTP消息中的内容、通过SSL连接Web服务器配置、其他配置选项。</p>
<h3 id="4-设置proxy-listener"><a href="#4-设置proxy-listener" class="headerlink" title="4.设置proxy listener"></a>4.设置proxy listener</h3><p>通过设置Proxy Listeners来截断数据流量。比如设置监听端口等。BurpSuite默认监听8080端口.</p>
<p>修改端口:</p>
<p>1.关闭截断</p>
<p>2.options-&gt;edit</p>
<p>3.修改端口,点击running</p>
<p>4.修改浏览器端口</p>
<p>5.Internet选项-&gt;连接-&gt;局域网设置</p>
<p>6.修改端口</p>
<h3 id="5-设置intercept-client-requests"><a href="#5-设置intercept-client-requests" class="headerlink" title="5.设置intercept client requests"></a>5.设置intercept client requests</h3><p>通过设置Intercept Client Requests来截断符合条件的HTTP请求。</p>
<h3 id="6-设置Intercept-Server-Response"><a href="#6-设置Intercept-Server-Response" class="headerlink" title="6.设置Intercept Server Response"></a>6.设置Intercept Server Response</h3><p>通过设置Intercept Server Response来筛选出符合条件的HTTP响应。</p>
<h3 id="7-设置截断Websocket通信以及修改Response的内容"><a href="#7-设置截断Websocket通信以及修改Response的内容" class="headerlink" title="7.设置截断Websocket通信以及修改Response的内容"></a>7.设置截断Websocket通信以及修改Response的内容</h3><h3 id="8-匹配以及修改HTTP消息"><a href="#8-匹配以及修改HTTP消息" class="headerlink" title="8.匹配以及修改HTTP消息"></a>8.匹配以及修改HTTP消息</h3><p>可以修改HTTP请求和HTTP响应中的内容。</p>
<h2 id="3-Burpsuite抓取手机APP流量"><a href="#3-Burpsuite抓取手机APP流量" class="headerlink" title="3.Burpsuite抓取手机APP流量"></a>3.Burpsuite抓取手机APP流量</h2><p>目前WebApp(手机App)的通信任然使用HTTP协议进行对应的通信.可以通过Burp设置代理,然后手机设置网络代理,通过Burp截断手机APP流量.</p>
<p>1.Burpsuite设置截断所有网卡的流量，那么局城网中所有的主机都可以通过该代理进行网络访问。</p>
<p><img src="https://i.loli.net/2021/01/24/n1owBAfCMJXqvhW.png" alt=""></p>
<p><img src="https://i.loli.net/2021/01/24/Cu6NGxn2SI57hBs.png" alt=""></p>
<p>2.查看电脑ip</p>
<p>3.在手机网络设置中，填写对应的代理。</p>
<p><img src="https://i.loli.net/2021/01/24/gcYyFBzhjZEKOev.png" alt=""></p>
<p><img src="https://i.loli.net/2021/01/24/US7BIW1oNuXlHhJ.png" alt=""></p>
<p><img src="https://i.loli.net/2021/01/24/o8hED3xYzjUlvC9.png" alt=""></p>
<p>4.Burpsuite开启截断</p>
<p><img src="https://i.loli.net/2021/01/24/nU8QWAlJGESgP96.png" alt=""></p>
<h2 id="4-Burpsuite剔除JS脚本-绕过JS文件上传验证"><a href="#4-Burpsuite剔除JS脚本-绕过JS文件上传验证" class="headerlink" title="4.Burpsuite剔除JS脚本(绕过JS文件上传验证)"></a>4.Burpsuite剔除JS脚本(绕过JS文件上传验证)</h2><p>JavaScript—-种直译式脚本语言，是一种动态类型、 弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML (标准通用标记语言下的一个应用)网页上使用，用来给HTML网页增加动态功能。例如:对于上传文件进行JS验证。</p>
<p><img src="https://i.loli.net/2021/01/25/P1A6G4zFDUpbRs3.png" alt=""></p>
<p>也可以使用浏览器审计工具直接删除JS</p>
<h2 id="5-Burpsuite-Target介绍"><a href="#5-Burpsuite-Target介绍" class="headerlink" title="5.Burpsuite Target介绍"></a>5.Burpsuite Target介绍</h2><p>Burp Target组件主要包含站点地图、目标域、Target 工具三部分组成，他们帮助渗透测试人员更好地了解目标应用的整体状况、当前的工作涉及哪些目标域、分析可能存在的攻击面等信息</p>
<p>Target Scope中作用域的定义比较宽泛，通常来说，当我们对某个产品进行渗透测试时，可以通过域名或者主机名去限制拦截内容，这里域名或主机名就是我们说的作用域;如果我们想限制得更为细粒度化，比如，你只想拦截login目录下的所有请求，这时我们也可以在此设置，此时，作用域就是目录。</p>
<h3 id="Target站点地图Sitemap介绍"><a href="#Target站点地图Sitemap介绍" class="headerlink" title="Target站点地图Sitemap介绍"></a>Target站点地图Sitemap介绍</h3><p>Site Map的左边为访问的URL,按照网站的层级和深度，树形展示整个应用系统的结构和关联其他域的url情况;右边显示的是某一个url被访问的明细列表，共访问哪些url,请求和应答内容分别是什么，都有着详实的记录。基于左边的树形结构，我们可以选择某个分支，对指定的路径进行扫描和抓取</p>
<h2 id="6-Burpsuite-站点地图介绍"><a href="#6-Burpsuite-站点地图介绍" class="headerlink" title="6.Burpsuite 站点地图介绍"></a>6.Burpsuite 站点地图介绍</h2><h3 id="目标分析"><a href="#目标分析" class="headerlink" title="目标分析"></a>目标分析</h3><p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708061126089.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708061243107.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708061313124.png" alt=""></p>
<h3 id="站点地图比较"><a href="#站点地图比较" class="headerlink" title="站点地图比较"></a>站点地图比较</h3><p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708061805978.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708061858034.png" alt=""></p>
<h2 id="7-BurpSuite-爬虫介绍"><a href="#7-BurpSuite-爬虫介绍" class="headerlink" title="7.BurpSuite 爬虫介绍"></a>7.BurpSuite 爬虫介绍</h2><p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708072254485.png" alt=""></p>
<h3 id="BurpSuite-spider-control介绍"><a href="#BurpSuite-spider-control介绍" class="headerlink" title="BurpSuite spider control介绍"></a>BurpSuite spider control介绍</h3><p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708072433387.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708074243626.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708074425977.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708074440370.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708074847766.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708085028692.png" alt=""></p>
<h2 id="8-BurpSuite-漏洞扫描介绍"><a href="#8-BurpSuite-漏洞扫描介绍" class="headerlink" title="8.BurpSuite 漏洞扫描介绍"></a>8.BurpSuite 漏洞扫描介绍</h2><p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708090758906.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708091157848.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708091209413.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708091304387.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708091509730.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708092032622.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708092618118.png" alt=""></p>
<h2 id="9-BurpSuite-Intruder模块介绍"><a href="#9-BurpSuite-Intruder模块介绍" class="headerlink" title="9.BurpSuite Intruder模块介绍"></a>9.BurpSuite Intruder模块介绍</h2><p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708093712409.png" alt=""></p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708093804196.png" alt="image-20210708093804196"></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708094507606.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708153113545.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708153201596.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708154420924.png" alt=""></p>
<h2 id="10-BurpSuite-repeater介绍"><a href="#10-BurpSuite-repeater介绍" class="headerlink" title="10.BurpSuite repeater介绍"></a>10.BurpSuite repeater介绍</h2><p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708155215613.png" alt=""></p>
]]></content>
      <categories>
        <category>Hack</category>
      </categories>
      <tags>
        <tag>BurpSuite</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中length()、size()、sizeof()三者的区别</title>
    <url>/article/21ddb368.html</url>
    <content><![CDATA[<h1 id="C-中length-、size-、sizeof-三者的区别"><a href="#C-中length-、size-、sizeof-三者的区别" class="headerlink" title="C++中length()、size()、sizeof()三者的区别"></a>C++中length()、size()、sizeof()三者的区别</h1><a id="more"></a>
<h2 id="一、length-函数"><a href="#一、length-函数" class="headerlink" title="一、length()函数"></a>一、length()函数</h2><p>c++中，length()只是用来获取<strong>字符串</strong>的长度。</p>
<blockquote>
<p>例如：string str = “absdhffhf”,则str.length() = 9。</p>
</blockquote>
<h2 id="二、size-函数"><a href="#二、size-函数" class="headerlink" title="二、size()函数"></a>二、size()函数</h2><p>c++中，在获取字符串长度时，<strong>size()函数与length()函数作用相同</strong>。除此之外，size()函数还可以<strong>获取vector类型的长度</strong>。</p>
<blockquote>
<p>例如：vector \<int> num(15,2),则num.size() = 15。</p>
<p>例如：string str = “abcd”,则 str.size()=4。</p>
</blockquote>
<h2 id="三、sizeof-运算符"><a href="#三、sizeof-运算符" class="headerlink" title="三、sizeof()运算符"></a>三、sizeof()运算符</h2><p>sizeof()运算符用来<strong>求对象所占内存空间的大小</strong>。</p>
<blockquote>
<p>char c[] = “asdsds”;<br> char* cc = c;<br> char cn[40] = “asdsds”;<br> int a[] = {1,2,3,4,5,6};<br> int* aa = a;<br> cout &lt;&lt; sizeof(c) &lt;&lt; sizeof(cc) &lt;&lt; sizeof(<em>cc) &lt;&lt; sizeof(cn);<br> cout &lt;&lt; sizeof(a) &lt;&lt; sizeof(aa) &lt;&lt; sizeof(</em>aa);</p>
<p>结果输出：<br> sizeof(c) = 7          //c是数组，计算到’\0’位置，结果为6 * 1+1=7<br> sizeof(cc) = 8         //cc为指针类型，大小为8<br> sizeof(<em>cc) = 1        //</em>cc指向c的第一个字符，大小为1<br> sizeof(cn) = 40        //开辟40个char空间，大小为40 * 1=40<br> sizeof(a) = 24         //a是数组，但不需计算到’\0’，结果为6* 4=24<br> sizeof(aa) = 8         //aa为指针类型，大小为8<br> sizeof(<em>aa) = 4        //</em>aa指向a的第一个数字，大小为4</p>
</blockquote>
<p>需要注意的是，如果不使用Vector作为数组进行参数传递，那么在传递数组引用是需要再传递一个数组的大小，否则在函数中无法根据首地址计算出数组大小。</p>
]]></content>
      <categories>
        <category>c&amp;c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Kail Linux虚拟机安装配置Nessus漏洞扫描器</title>
    <url>/article/57445.html</url>
    <content><![CDATA[<h1 id="Kail-Linux虚拟机安装配置Nessus漏洞扫描器"><a href="#Kail-Linux虚拟机安装配置Nessus漏洞扫描器" class="headerlink" title="Kail Linux虚拟机安装配置Nessus漏洞扫描器"></a>Kail Linux虚拟机安装配置Nessus漏洞扫描器</h1><a id="more"></a>
<h2 id="1-获取激活码"><a href="#1-获取激活码" class="headerlink" title="1.获取激活码"></a>1.获取激活码</h2><p>前往<a href="https://www.tenable.com/products/nessus/nessus-essentials">官网</a>进行注册</p>
<p><img src="https://i.loli.net/2021/01/26/HVptOeBDnJZlF6w.png" alt=""></p>
<h2 id="2-下载nessus"><a href="#2-下载nessus" class="headerlink" title="2.下载nessus"></a>2.下载nessus</h2><p>注册完毕后前往下载页面</p>
<p><img src="https://i.loli.net/2021/01/26/SaI7x2nDEHRfMOu.png" alt=""></p>
<p>选择deb结尾的(我选择的64位)</p>
<p><img src="https://i.loli.net/2021/01/26/hPzGvds7T2bXirE.png" alt=""></p>
<p>官网下载较慢,这里我准备了一份,<a href="https://idefun.lanzous.com/iQnR4kvm5oh">点击下载</a></p>
<h2 id="3-安装nessus"><a href="#3-安装nessus" class="headerlink" title="3.安装nessus"></a>3.安装nessus</h2><p>将nessus拖入kail linux虚拟机</p>
<p><img src="https://i.loli.net/2021/01/26/Mca54FXCQuY6x7p.png" alt=""></p>
<p>打开终端,切换至桌面</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd 桌面</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/26/ekf7ri8R54ZuwDW.png" alt=""></p>
<p>安装nessus(需要密码)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i Nessus-8.13.1-debian6_amd64.deb</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/26/hYk1gFqJplIuQw9.png" alt=""></p>
<p>安装完成</p>
<p><img src="https://i.loli.net/2021/01/26/KWfAuHosZB7vJ1F.png" alt=""></p>
<h2 id="4-启动nessus"><a href="#4-启动nessus" class="headerlink" title="4.启动nessus"></a>4.启动nessus</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/bin/systemctl start nessusd.service</span><br></pre></td></tr></table></figure>
<p>同样需要密码</p>
<p><img src="https://i.loli.net/2021/01/26/1Wjf7rMiImHSk4A.png"  /></p>
<p>在浏览器中访问</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">https://kali:8834/</span><br></pre></td></tr></table></figure>
<p>选择Managed Scanner</p>
<p><img src="https://i.loli.net/2021/01/26/Y9wajpE7ye1JhVv.png" alt=""></p>
<p>选择Tenable.sc</p>
<p><img src="https://i.loli.net/2021/01/26/ONiI4T2EJeylcZ5.png" alt=""></p>
<p>创建账号</p>
<p><img src="https://i.loli.net/2021/01/26/1KLS8misZR7DVCI.png" alt=""></p>
]]></content>
      <categories>
        <category>Hack</category>
      </categories>
      <tags>
        <tag>Nessus</tag>
        <tag>Kail</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo的next主题实现双语功能</title>
    <url>/article/99e78227.html</url>
    <content><![CDATA[<h1 id="Hexo的next主题实现双语功能"><a href="#Hexo的next主题实现双语功能" class="headerlink" title="Hexo的next主题实现双语功能"></a>Hexo的next主题实现双语功能</h1><a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前不久,给博客添加了Google Analytics,通过数据显示,发现我这小破站寥寥无几的流量大部分竟然是国外朋友贡献的,心中便想着将博客国际化—-搞个英文版本.说干就干,经过我的一番折腾,终于给搞出来了,但我要说明一下文章的内容是要自己转换为英文,具体效果大家可以点击下面链接前往查看</p>
<p><a href="https://en.idefun.com/" class="LinkCard" target="_blank">英文版本</a></p>
<h2 id="诉求"><a href="#诉求" class="headerlink" title="诉求"></a>诉求</h2><p>首先说说我对英文网站的诉求:</p>
<ol>
<li>英文网站要与原网站的结构外观基本保持一致(我看到有的小伙伴直接换支持双语的主题了,我可不想让自己的心血白流)</li>
<li>我希望原网站和英文网站有个切换按钮,很容易切换</li>
</ol>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>在hexo本地目录创建英文文件夹(名字自定义),我的是en</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320154606919.png" alt=""></p>
<p>复制hexo目录的内容(node_modules除外)到en文件夹,复制后en文件夹如下</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320154912791.png" alt=""></p>
<p>安装相关插件,在en文件夹使用命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>修改en文件夹中_config.yml文件,将下图中的language改为en,可以比对着hexo本地目录的_config.yml文件将中文改为相应的英文(如下图的title,subtitle等)</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320155305119.png" alt=""></p>
<p>修改hexo目录next主题配置文件_config.yml文件,找到menu字段,增添language菜单,注意链接要换成自己的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">language: https:&#x2F;&#x2F;en.idefun.com&#x2F; || fa fa-language</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320155819757.png" alt=""></p>
<p>修改next主题文件夹下的languages中的zh-CN.yml,找到menu,添加language:English</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320160213558.png" alt=""></p>
<p>可以在hexo目录使用hexo s查看效果</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320160423212.png" alt=""></p>
<p>同理,修改en文件夹中next主题配置文件_config.yml文件,找到menu字段,增添中文菜单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">中文: https:&#x2F;&#x2F;www.idefun.com&#x2F; || fa fa-language</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320160547373.png" alt=""></p>
<p>修改en文件夹下themes中next主题文件夹下的languages中的en.yml,找到menu,添加language:中文</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320160801285.png" alt=""></p>
<p>可以在en目录使用hexo s查看效果</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320160357274.png" alt=""></p>
<h3 id="部署配置"><a href="#部署配置" class="headerlink" title="部署配置"></a>部署配置</h3><p>下面提供两种部署方法,第一种不用再创建仓库,第二种要再创建仓库,若想要给英文博客绑定域名建议选择第二种,关于创建仓库及打开github page就不多说了</p>
<h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>在en文件夹生成英文博客,并将生成的public文件夹中的内容复制到hexo目录下的public文件夹中的en文件夹,推送时只需在hexo目录下推送</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>使用下面命令即可实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; cd en &amp;&amp;  hexo clean &amp;&amp; hexo g &amp;&amp; cd ..&#x2F; &amp;&amp; cp -r en&#x2F;public&#x2F;. public&#x2F;en&#x2F; &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<p>可以写成shell脚本,我这里提供一份简单的脚本供大家参考</p>
<p><a href="https://idefun.lanzous.com/i4cz6n4ov7e" class="LinkCard">点击下载</a></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320162843893.png" alt=""></p>
<p>下载后改后缀为sh即可双击运行</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320162956255.png" alt=""></p>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p>在en文件夹生成英文博客,将生成英文博客推送到一个新的仓库,需要分别推送,可以编写相应脚本来简化操作</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><p>修改en文件夹在_config.yml文件,找到deploy字段,修改为自己的仓库即可</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320163232780.png" alt=""></p>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>为大家提供一种思路,希望有帮助</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题:135.分发糖果</title>
    <url>/article/b47abe2.html</url>
    <content><![CDATA[<h1 id="LeetCode刷题-135-分发糖果"><a href="#LeetCode刷题-135-分发糖果" class="headerlink" title="LeetCode刷题:135.分发糖果"></a>LeetCode刷题:135.分发糖果</h1><a id="more"></a>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p>
<p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p>
<p>每个孩子至少分配到 1 个糖果。<br>评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。<br>那么这样下来，老师至少需要准备多少颗糖果呢？</p>
<p><strong>示例 1：</strong></p>
<p>输入：[1,0,2]<br>输出：5<br>解释：你可以分别给这三个孩子分发 2、1、2 颗糖果。</p>
<p><strong>示例 2：</strong></p>
<p>输入：[1,2,2]<br>输出：4<br>解释：你可以分别给这三个孩子分发 1、2、1 颗糖果。<br>第三个孩子只得到 1 颗糖果，这已满足上述两个条件。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>把所有孩子的糖果数初始化为1；先从左往右遍历一遍，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的糖果数加1；再从右往左遍历一遍，如果左边孩子的评分比右边的高，且左边孩子当前的糖果数不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加1。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = ratings.size();</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">num</span><span class="params">(size, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ratings[i] &gt; ratings[i<span class="number">-1</span>]) &#123;</span><br><span class="line">    num[i] = num[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ratings[i] &lt; ratings[i<span class="number">-1</span>]) &#123;</span><br><span class="line">    num[i<span class="number">-1</span>] = max(num[i<span class="number">-1</span>], num[i] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> accumulate(num.begin(), num.end(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题:435.无重叠区间</title>
    <url>/article/4886200.html</url>
    <content><![CDATA[<h1 id="LeetCode刷题-435-无重叠区间"><a href="#LeetCode刷题-435-无重叠区间" class="headerlink" title="LeetCode刷题:435.无重叠区间"></a>LeetCode刷题:435.无重叠区间</h1><a id="more"></a>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>
<p>注意:</p>
<p>可以认为区间的终点总是大于它的起点。<br>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</p>
<p><strong>示例 1:</strong></p>
<p>输入: [ [1,2], [2,3], [3,4], [1,3] ]</p>
<p>输出: 1</p>
<p>解释: 移除 [1,3] 后，剩下的区间没有重叠。</p>
<p><strong>示例 2:</strong></p>
<p>输入: [ [1,2], [1,2], [1,2] ]</p>
<p>输出: 2</p>
<p>解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</p>
<p><strong>示例 3:</strong></p>
<p>输入: [ [1,2], [2,3] ]</p>
<p>输出: 0</p>
<p>解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在选择要保留区间时，区间的结尾十分重要：选择的区间结尾越小，余留给其它区间的空间就越大，就越能保留更多的区间。因此，我们采取的贪心策略为，优先保留结尾小且不相交的区间。<br>具体实现方法为，先把区间按照结尾的大小进行增序排序，每次选择结尾最小且和前一个选<br>择的区间不重叠的区间。我们这里使用C++ 的Lambda，结合std::sort() 函数进行自定义排序。</p>
<p>需要根据实际情况判断按区间开头排序还是按区间结尾排序。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        if (intervals.empty()) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n &#x3D; intervals.size();</span><br><span class="line">        sort(intervals.begin(), intervals.end(), [](vector&lt;int&gt; a, vector&lt;int&gt; b) &#123;</span><br><span class="line">        return a[1] &lt; b[1];</span><br><span class="line">        &#125;);</span><br><span class="line">        int total &#x3D; 0, prev &#x3D; intervals[0][1];</span><br><span class="line">        for (int i &#x3D; 1; i &lt; n; ++i) &#123;</span><br><span class="line">        if (intervals[i][0] &lt; prev) &#123;</span><br><span class="line">        ++total;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        prev &#x3D; intervals[i][1];</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题:605.种花问题</title>
    <url>/article/d4783519.html</url>
    <content><![CDATA[<h1 id="LeetCode刷题-605-种花问题"><a href="#LeetCode刷题-605-种花问题" class="headerlink" title="LeetCode刷题:605.种花问题"></a>LeetCode刷题:605.种花问题</h1><a id="more"></a>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p>
<p>给你一个整数数组  flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false。</p>
<p><strong>示例 1：</strong></p>
<p>输入：flowerbed = [1,0,0,0,1], n = 1<br>输出：true</p>
<p><strong>示例 2：</strong></p>
<p>输入：flowerbed = [1,0,0,0,1], n = 2<br>输出：false</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题:455.分发饼干</title>
    <url>/article/4d94effd.html</url>
    <content><![CDATA[<h1 id="LeetCode刷题-455-分发饼干"><a href="#LeetCode刷题-455-分发饼干" class="headerlink" title="LeetCode刷题:455.分发饼干"></a>LeetCode刷题:455.分发饼干</h1><a id="more"></a>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<p><strong>示例 1:</strong></p>
<p>输入: g = [1,2,3], s = [1,1]<br>输出: 1<br>解释:<br>你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。<br>虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。<br>所以你应该输出1。<br><strong>示例 2:</strong></p>
<p>输入: g = [1,2], s = [1,2,3]<br>输出: 2<br>解释:<br>你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。<br>你拥有的饼干数量和尺寸都足以让所有孩子满足。<br>所以你应该输出2.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为饥饿度最小的孩子最容易吃饱，所以我们先考虑这个孩子。为了尽量使得剩下的饼干可以满足饥饿度更大的孩子，所以我们应该把大于等于这个孩子饥饿度的、且大小最小的饼干给这个孩子。满足了这个孩子之后，我们采取同样的策略，考虑剩下孩子里饥饿度最小的孩子，直到没有满足条件的饼干存在。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; g, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        sort(g.begin(),g.end());</span><br><span class="line">        sort(s.begin(),s.end());</span><br><span class="line">        <span class="keyword">while</span>(i&lt;g.size()&amp;&amp;j&lt;s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[i]&lt;=s[j])i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux C编程</title>
    <url>/article/34877.html</url>
    <content><![CDATA[<h1 id="Linux-C编程"><a href="#Linux-C编程" class="headerlink" title="Linux C编程"></a>Linux C编程</h1><p>C语言的源代码文件是一个普通的文本文件,但扩展名是c.而且源代码文件是不能直接执行的,需要编译,编译后的可执行文件只能在指定操作系统下运行.</p>
<p>Linux编译后的可执行程序只能在linux运行,windows编译后的程序只能在windows下运行</p>
<p>64位的linux编译后的程序只能在64位linux下运行,32位linux编译后的程序只能在32位的linux运行.</p>
<p>64位的windows编译后的程序只能在64位windows下运行,32位windows编译后的程序可以在64位的windows运行.</p>
<h2 id="头文件包含"><a href="#头文件包含" class="headerlink" title="头文件包含"></a>头文件包含</h2><p>include有两种写法</p>
<p>#include &lt;文件名&gt;,如果文件在系统目录下,那么需要用&lt;&gt;</p>
<p>#include “文件名”,如果文件在当前目录下，那么用””</p>
<h2 id="System系统调用"><a href="#System系统调用" class="headerlink" title="System系统调用"></a>System系统调用</h2><p>在使用system之前需要包含stdlib.h这个头文件,system主要的功能是通过程序执行另外一个程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">system(<span class="string">&quot;命令&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>如果在命令行执行一个程序，那么这个程序的调用者就是操作系统，如果在代码中通过system执行一个程序，那么这个程序的调用者就是自己写的代码本身.</p>
<p>C语言所有的库函数调用，只能保证语法是一致的，但不能保证执行结果是一致的，同样的库函数在不同的操作系统下执行结果可能是一样的，也可能是不一样的。</p>
<h2 id="POSIX标准"><a href="#POSIX标准" class="headerlink" title="POSIX标准"></a>POSIX标准</h2><p>POSIX是一个标准，只要符合这个标准的函数，在不同的系统下执行的结果就可以一致。</p>
<p>Unix和Linux很多库函数都是支持POSIX的，但windows支持的比较差。</p>
<p>如果将unix代码移植到linux一般代价很小，如果把windows代码移植到unix或者linux就比较麻烦.</p>
<h2 id="C语言处理过程"><a href="#C语言处理过程" class="headerlink" title="C语言处理过程"></a>C语言处理过程</h2><p>C代码编译成可执行程序经过4步:<br>1)预处理:宏定义展开、头文件展开、条件编译等，同时将代码中的注释删除，这里并不会检查语法<br>2)编译:检查语法，将预处理后文件编译生成汇编文件<br>3)汇编:将汇编文件生成目标文件(二进制文件)<br>4)链接: C语言写的程序是需要依赖各种库的，所以编译之后还需要把库链接到最终的可执行程序中去</p>
<p>预处理:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure>
<p>编译:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure>
<p>汇编:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure>
<p>链接:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc hello.o -o hello</span><br></pre></td></tr></table></figure>
<p>查看程序所需动态库:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ldd hello   //linux</span><br></pre></td></tr></table></figure>
<p>交换文件说明:<br>1) vi写文件，没有保存就关闭，自动生成一个后缀为. swp交换文件， 保存了之前写的内容<br>2)先恢复，再删除.swp交换文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi -r &#123;your file name&#125; //恢复</span><br><span class="line">rm &#123;your file name&#125;.swp   //删除</span><br></pre></td></tr></table></figure>
<h2 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h2><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p><strong>C的关键字共有32个</strong></p>
<ul>
<li><p>数据类型关键字(12个)</p>
<p>char, short, int, long, float, double,unsigned, signed, struct, union, enum, void</p>
</li>
<li><p>控制语句关键字(12个)</p>
<p>if, else, switch, case, default,for , do, while, break, continue, goto, return</p>
</li>
<li><p>存储类关键字(5个)</p>
<p>auto,extern,register, static,const</p>
</li>
<li><p>其他关键字(3个)</p>
<p>sizeof, typedef, volatile</p>
</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>数据类型的作用:编译器预算对象(变量)分配的内存空间大小</p>
<p><img src="https://i.loli.net/2021/01/11/JgoTpVBjXIPWQLD.png" alt="image-20210111193755278"></p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul>
<li>在程序运行过程中，其值不能被改变的量</li>
<li>常量一般出现在表达式或赋值语句中</li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul>
<li>在程序运行过程中，其值可以改变</li>
<li>变量在使用前必须先定义，定义变量前必须有相应的数据类型</li>
</ul>
<p>标识符命名规则:</p>
<ul>
<li><p>标识符不能是关键字</p>
</li>
<li><p>标识符只能由字母、数字、下划线组成</p>
</li>
<li>第一个字符必须为字母或下划线</li>
<li>标识符中字母区分大小写</li>
</ul>
<p>变量特点:</p>
<ul>
<li>变量在编译时为其分配相应的内存空间</li>
<li>可以通过其名字和地址访问相应内存</li>
</ul>
<p>声明和定义区别:</p>
<ul>
<li>声明变量不需要建立存储空间，如: extern int a;(a不能赋值)</li>
<li>定义变量需要建立存储空间，如: int b;</li>
<li>-般的情况下，把建立存储空间的声明称之为“定义”，而把不需要建立存储空间的声明称之为”声明”.</li>
</ul>
<h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h3><h4 id="C语言如何表示相应的进制数"><a href="#C语言如何表示相应的进制数" class="headerlink" title="C语言如何表示相应的进制数"></a>C语言如何表示相应的进制数</h4><div class="table-container">
<table>
<thead>
<tr>
<th>十进制</th>
<th>以正常数字1-9开头,如123</th>
</tr>
</thead>
<tbody>
<tr>
<td>八进制</td>
<td>以0(零)开头,如0123</td>
</tr>
<tr>
<td>十六进制</td>
<td>以0x开头,如0x123</td>
</tr>
<tr>
<td>二进制</td>
<td>C语言不能直接书写二进制数</td>
</tr>
</tbody>
</table>
</div>
<h3 id="计算机内存数值存储方式"><a href="#计算机内存数值存储方式" class="headerlink" title="计算机内存数值存储方式"></a>计算机内存数值存储方式</h3><p>在计算机系统中，数值一律用补码来存储。</p>
<h4 id="原码"><a href="#原码" class="headerlink" title="原码:"></a>原码:</h4><p>最高位为符号位:0代表正数,1代表负数​</p>
<p>原码存储导致2个问题:</p>
<ol>
<li>0有两种存储方式</li>
<li>正数和负数相加结果不正确</li>
</ol>
<h4 id="反码"><a href="#反码" class="headerlink" title="反码:"></a>反码:</h4><p>反码是为了算补码.正数的原码和反码是一样的,负数的反码在原码基础上,符号位不变,其它位取反(0为1,1变0 ).</p>
<p>反码存储导致1个问题:</p>
<ol>
<li>0有两种存储方式</li>
</ol>
<h4 id="补码"><a href="#补码" class="headerlink" title="补码:"></a>补码:</h4><p>正数的原码,反码,补码都一样</p>
<p>负数的补码为其反码加1</p>
<p>十进制数,站在用户角度看,<strong>原码</strong>;二进制,八进制,十六进制,要站在计算机角度看,<strong>补码</strong>.</p>
<p>原码求补码:</p>
<ol>
<li>正数原,反,补码均相同</li>
<li>负数原码最高位不变,其他位取反得反码</li>
<li>反码加1得补码</li>
</ol>
<p>补码求原码(同上面类似):</p>
<ol>
<li>正数原,反,补码均相同</li>
<li>负数补码最高位不变,其他位取反得反码</li>
<li>反码加1得原码</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> a=<span class="number">0x81</span>;<span class="comment">//a是值为十六进制数的字符,在计算机看来是补码</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);<span class="comment">//%d为输出十进制数,在用户看来是原码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序运行结果如下:</p>
<p><img src="https://i.loli.net/2021/01/12/l23jvtQaPwTHyWG.png" alt=""></p>
<p>按照十六进制转十进制,0x81等于129而不是-127</p>
<p>分析:</p>
<ol>
<li>0x81在计算机角度看来应为补码存储,其二进制形式为10000001</li>
<li>输出%d即输出十进制数,十进制数在用户角度为原码</li>
<li>由(1)(2)知,该程序即将0x81的补码转换为原码</li>
<li>其原码为11111111,即-127</li>
</ol>
<p>有符号和无符号的区别:</p>
<ul>
<li>%d,默认以有符号的方式打印</li>
<li>%u,默认以无符号的方式打印</li>
<li>有符号，最高位是符号位，如果是1代表为负数，如果为0代表为正数</li>
<li>无符号，最高位不是符号位，是数的一部分，无符号不可能是负数</li>
</ul>
<p>数据类型范围:</p>
<p>char    1个字节</p>
<p><img src="https://i.loli.net/2021/01/12/UNxsfOjRD2cu9eY.png" alt="image-20210112214358475" style="zoom:80%;" /></p>
<p>数值越界:</p>
<p>通过以下代码解释</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">//情况1 有符号</span></span><br><span class="line">        <span class="comment">//char 范围 -128~127</span></span><br><span class="line">        <span class="keyword">char</span> a=<span class="number">127</span>+<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/* a=129,转换二进制为1000 0001,</span></span><br><span class="line"><span class="comment">          二进制(1000 0001)以补码形式存储,</span></span><br><span class="line"><span class="comment">          输出为%d,要求得原码(11111111),</span></span><br><span class="line"><span class="comment">          即-127</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);<span class="comment">//输出-127</span></span><br><span class="line">        <span class="comment">//情况2 无符号</span></span><br><span class="line">        <span class="comment">//无符号 范围 0~255</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> b=<span class="number">255</span>+<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/* b=257,转换二进制为1 0000 0001,</span></span><br><span class="line"><span class="comment">           舍弃最高位为0000 0001,</span></span><br><span class="line"><span class="comment">           二进制(0000 0001)以补码形式存储,</span></span><br><span class="line"><span class="comment">           转为原码(0000 0001),</span></span><br><span class="line"><span class="comment">           即1</span></span><br><span class="line"><span class="comment">           注意编译时会警告,之后./文件名运行即可</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>,b);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下:</p>
<p><img src="https://i.loli.net/2021/01/13/GL8cpTQzUtFu7n1.png" alt="image-20210113191321188"></p>
<h4 id="sizeof关键字"><a href="#sizeof关键字" class="headerlink" title="sizeof关键字"></a>sizeof关键字</h4><ul>
<li>sizeof不是函数，所以不需要包含任何头文件，它的功能是计算一个数据类型的大小，单位为字节</li>
<li>sizeof的返回值为size_ t</li>
<li>size_t 类型在32位操作系统下是unsigned int,是一个无符号的整数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*数据类型的作用:告诉编译器,</span></span><br><span class="line"><span class="comment">    定义此类型变量需要分配多大空间*/</span>					<span class="built_in">printf</span>(<span class="string">&quot;sizeof(char)=%lu\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">   	<span class="built_in">printf</span>(<span class="string">&quot;sizeof(a)=%lu\n&quot;</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下:</p>
<p><img src="https://i.loli.net/2021/01/13/3VmSN7iDcPkwLsY.png" style="zoom:150%;" /></p>
<p>%d,%o,%x,%u等均以四个字节形式打印.</p>
<p>short占两个字节,short a;与short int a;等价.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据类型</th>
<th>占用空间</th>
</tr>
</thead>
<tbody>
<tr>
<td>short (短整型)</td>
<td>2字节</td>
</tr>
<tr>
<td>int (整型)</td>
<td>4字节</td>
</tr>
<tr>
<td>1ong(长整形)</td>
<td>Windows为4字节，Linux为 4字节(32位)，8字节(64位)</td>
</tr>
<tr>
<td>long long (长长整形)</td>
<td>8字节</td>
</tr>
</tbody>
</table>
</div>
<h3 id="字符型变量"><a href="#字符型变量" class="headerlink" title="字符型变量"></a>字符型变量</h3><p>字符型变量用于存储一个单一字符，在C语言中用char 表示，其中每个字符变量都会占用1个字节。在给字符型变量赋值时，需要用一对英文半角格式的单引号(‘ ‘)把字符括起来。<br>字符变量实际上并不是把该字符本身放到变量的内存单元中去，而是将该字符对应的ASCII 编码放到变量的存储单元中。char 的本质就是一个1 字节大小的整型。</p>
<p>使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man ascii</span><br></pre></td></tr></table></figure>
<p>查看ASCII码</p>
<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>字符在单引号内,原则上’ ‘内部只有一个字符,转义字符除外,不能char a=’abc’</p>
<p>转义字符由反斜杠\组成的多个字符</p>
<p>例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> a=<span class="string">&#x27;\r&#x27;</span>;<span class="comment">//光标移到句首</span></span><br><span class="line">        <span class="keyword">char</span> b=<span class="string">&#x27;\b&#x27;</span>;<span class="comment">//退格</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;12345%c6789\n&quot;</span>,a);<span class="comment">//先打印12345,之后光标移到句首再依次打印6789,其中1234被覆盖,留下5,结果为67895</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;abcde%cfghi\n&quot;</span>,b);<span class="comment">//先打印abcde之后打印\b,退一格,e就没了,结果为abcdfghi</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/22/wYUVzd2mpNqX3LQ.png" alt=""></p>
<h3 id="浮点型-实型"><a href="#浮点型-实型" class="headerlink" title="浮点型(实型)"></a>浮点型(实型)</h3><p>实型变量也可以称为浮点型变量，浮点型变量是用来存储小数数值的。在C语言中，浮点型变量分为两种:单精度浮点数(float)、双精度浮点数(double)，但是double型变量所表示的浮点数比float 型变量更精确。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据类型</th>
<th>占用空间</th>
<th>有效数字范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>float</td>
<td>4字节</td>
<td>7位有效数字</td>
</tr>
<tr>
<td>double</td>
<td>8字节</td>
<td>15~ 16位有效数字</td>
</tr>
</tbody>
</table>
</div>
<p>float存储不准确</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">float</span> a=<span class="number">100.9</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,a);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/22/pT1JRNYS97IyjM4.png" alt=""></p>
<h3 id="类型限定符"><a href="#类型限定符" class="headerlink" title="类型限定符"></a>类型限定符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>限定符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>extern</td>
<td>声明一个变量，extexn 声明的变量没有建立存储空间。extern int a;</td>
</tr>
<tr>
<td>const</td>
<td>定义一个常量，常量的值不能修改。const int a 10;</td>
</tr>
<tr>
<td>vo1atile</td>
<td>防止编译器优化代码</td>
</tr>
<tr>
<td>register</td>
<td>定义寄存器变量，提高效率。 register是建议型的指令，而不是命令型的指令，如果CPU有空闲寄存器，那么register就生效， 如果没有空闲寄存器，那么register无效。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>字符串常量与字符常量的不同:<br>‘a’为字符常量，”a”为字符串常量</p>
<p><img src="https://i.loli.net/2021/01/22/hAXpsqiEMktCuyn.png" alt="image-20210113191321188"></p>
<p>每个字符串的结尾，编译器会自动的添加一一个结束标志位’\0’,即”a” 包含<br>两个字符’a’和’\0’。</p>
<p>%%在屏幕输出一个%，后面的d也会输出</p>
<p>%5d,以5个字符输出,没有的字符以空字符填充,默认是右对齐</p>
<p>%05d,以5个字符输出,没有的字符以0填充,默认是右对齐</p>
<p>%-5d,以5个字符输出,没有的字符以空字符填充,-代表指定为左对齐</p>
<p>0和-不能同时使用</p>
<p><img src="https://i.loli.net/2021/01/22/ts6idzBZGxWJveY.png" alt=""></p>
<h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><blockquote>
<p>遇到”\0”停止</p>
</blockquote>
<h3 id="puts"><a href="#puts" class="headerlink" title="puts()"></a>puts()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[]=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">puts</span>(buf);<span class="comment">//把buf内容输出到屏幕,自动在屏幕加换行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);<span class="comment">//没有加换行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/29/u4frlgbByp9IMoT.png" alt=""></p>
<h3 id="fputs"><a href="#fputs" class="headerlink" title="fputs()"></a>fputs()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[]=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="comment">//向stdout(代表屏幕,标准输出)输出buf的内容</span></span><br><span class="line">    <span class="built_in">fputs</span>(buf,<span class="built_in">stdout</span>);<span class="comment">//没有加换行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/29/r64eO1HkSZt9JXd.png" alt="image-20210129141616052"></p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><h3 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h3><p>scanf()的缺陷，不做越界检查,不允许有空格</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入字符串:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%s\n&quot;</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/29/foM25d9lpc8aQUR.png" alt=""></p>
<h3 id="gets"><a href="#gets" class="headerlink" title="gets()"></a>gets()</h3><p>gets()从键盘读取字符串，放在指定的数组<br>gets()允许有空格，不做越界检查，此函数不安全</p>
<h3 id="fgets"><a href="#fgets" class="headerlink" title="fgets()"></a>fgets()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">//从stdin(代表标准输入,键盘)读取内容</span></span><br><span class="line">        <span class="comment">/*如果输入内容大于sizeof(buf)-1,只取	</span></span><br><span class="line"><span class="comment">        sizeof(buf)-1,放在buf所在数组;</span></span><br><span class="line"><span class="comment">        当不足sizeof(buf)-1,会把换行符读进去*/</span></span><br><span class="line">        fgets(buf,<span class="keyword">sizeof</span>(buf),<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buf=%s\n&quot;</span>,buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/29/qgh4QbsSC7MvWfd.png" alt=""></p>
<p>fgets()允许有空格</p>
<p><img src="https://i.loli.net/2021/01/29/6vIXpuY7SQeEKUM.png" alt=""></p>
<p>当不足sizeof(buf)-1,会把换行符读进去</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    fgets(buf,<span class="keyword">sizeof</span>(buf),<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf=#%s#\n&quot;</span>,buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/29/3gJLWmkOlP8fQKI.png" alt=""></p>
<h3 id="输入字符"><a href="#输入字符" class="headerlink" title="输入字符"></a>输入字符</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入字符:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;a);<span class="comment">//假设输入c</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a=&#x27;%c&#x27;\n&quot;</span>,a);</span><br><span class="line">        <span class="keyword">char</span> b;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入字符:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;b);<span class="comment">//假设输入d</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;b=&#x27;%c&#x27;\n&quot;</span>,b);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个程序看似简单,结果为a=c,b=d,其实不然,结果如下:</p>
<p><img src="https://i.loli.net/2021/01/22/itzxmayI15d6uqO.png" alt=""></p>
<p>无需输入d直接出结果</p>
<p>原因:</p>
<p>当用户输入字符时,编译器默认把输入的内容先放在一块内存中(缓冲区) , scanf()自动在缓冲区读内容(只读一个字符).第一次输入时输入了c\n(回车),scanf取走了c,留下\n还在缓存区,第2次scanf ,由于缓冲区还有内容,所以直接取内容,无需再输入</p>
<p>所以,上面的程序可以这样写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入字符:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;a);<span class="comment">//假设输入c</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a=&#x27;%c&#x27;\n&quot;</span>,a);</span><br><span class="line">        <span class="comment">//吃掉上一步的\n,不做处理</span></span><br><span class="line">        <span class="keyword">char</span> b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;b);</span><br><span class="line">        <span class="keyword">char</span> t;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入字符:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;t);<span class="comment">//假设输入d</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;t=&#x27;%c&#x27;\n&quot;</span>,t);</span><br><span class="line">    	<span class="comment">//或者都在一个scanf中写</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输入字符串"><a href="#输入字符串" class="headerlink" title="输入字符串"></a>输入字符串</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入字符串a:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);<span class="comment">//假设输入hello world</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%s\n&quot;</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入字符串b:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b=%s\n&quot;</span>,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下:</p>
<p><img src="https://i.loli.net/2021/01/29/OUtFhK74fAaNsj5.png" alt=""></p>
<p>原因:</p>
<p>当输入hello world时,第一个scanf取走第一个空格前的字符串,即hello;第二个scanf取第一个空格后第二个空格前的内容,\\n不取</p>
<p>switch语句</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">        <span class="comment">//1、switch是关键字， switch() 后面没有分号</span></span><br><span class="line">        <span class="comment">//2、switch()中() 里只能放整型变量或字符型变量</span></span><br><span class="line">        <span class="keyword">switch</span>(num)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;1楼\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;2楼\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;3楼\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;其他楼层\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>goto语句</p>
<p>goto(只能跳转到同一作用域)任意地方都能使用,无条件跳转,不能滥用,代码会很乱</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">goto</span> hello;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1111111111\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2222222222\n&quot;</span>);</span><br><span class="line">        hello:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;3333333333\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/28/fNUX46T5h1YqSc9.png" alt="image-20210122205440917" style="zoom:150%;" /></p>
<p>类型转换:</p>
<p>1.隐式转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> a;</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//编译器自动转换，把b转 换为double类型后， 再给a赋值(隐式转换)</span></span><br><span class="line">a= b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>，b) ;</span><br></pre></td></tr></table></figure>
<p>2.强制类型转换  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="comment">//a只有在此语句执行时，才强制转换为double类型，其它地址还是为int类型</span></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%lf\n&quot;</span>，(<span class="keyword">double</span>)a) ;<span class="comment">//(类型)变量名</span></span><br></pre></td></tr></table></figure>
<p>转换原则:占用内存字节数少(值域小)的类型，向占用内存字节数多(值域大)的类型转换，以保证精度不降低。</p>
<p>3.浮点型和整型打印问题<br>a)不要直接通过%d，打印一个浮点型变量，得不到想要的结果，要想得到结果，强制类型转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> a = <span class="number">11.11</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(<span class="keyword">int</span>)a) ;</span><br></pre></td></tr></table></figure>
<p>b)不要直接通过%f或%lf，打印一个整型变量，得不到想要的结果，要想得到结果，强制类型转换</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol>
<li>数组内部的变量或数组,不初始化,它的值为随机数</li>
<li>部分初始化，其它自动初始化为0<br>0~2(前3个元素)分别为1，2， 3， 其 它初始化为0<br>int a1[10] = {1, 2, 3};</li>
<li>数组全部元素初始化为0<br>int a2[10] = {0} ;</li>
<li>如果定义时同时初始化，第1个[]内部可以不写内容<br>编译器会根据用户初始化的元素来确定数组的大小<br>int a3[]={1,2,3,4,5,6,7,8,9,10};</li>
<li>如果第1个[]内容不写，必须初始化，否则语法错误</li>
</ol>
<h3 id="数组名"><a href="#数组名" class="headerlink" title="数组名"></a>数组名</h3><ul>
<li>数组名是常量,不能修改</li>
<li>数组名是数组首元素地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a=%p,&amp;a[0]=%p\n&quot;</span>,a,&amp;a[<span class="number">0</span>]);<span class="comment">//%p输出地址</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sizeof(a)=%lu\n&quot;</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/23/EFTYRgCKmLP263d.png" alt=""></p>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>内存中没有多维,只有一维,多维数组是特殊的一维数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果定义时，同时初始化，第1个[]可以不写内容</span></span><br><span class="line"><span class="keyword">int</span> a1[][<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;<span class="comment">//正确</span></span><br><span class="line"><span class="comment">//如果第1个[]不写，必须初始化</span></span><br><span class="line"><span class="keyword">int</span> a3[][<span class="number">4</span>]; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3><ol>
<li>C语言没有字符串类型,用字符数组模拟</li>
<li>字符串一定是字符数组,字符数组就不一定是字符串</li>
<li>如果字符数组以字符’\0’ (‘\0’等级于数字0)结尾,那么这个字符数组就是字符串</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、C语言没有字符串类型，用字符数组模拟</span></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//2、字符串一定是字符数组，字符数组就不一定是字符串</span></span><br><span class="line"><span class="comment">//3、如果字符数组以字符&#x27;\0&#x27;(&#x27;\0&#x27;等级于数字0)结尾，那么这个字符数组就是字符串</span></span><br><span class="line"><span class="keyword">char</span> b[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;; <span class="comment">//字符数组,方括号中不能填数字,否则会自动补零,就变成字符串</span></span><br><span class="line"><span class="keyword">char</span> c[<span class="number">10</span>] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;; <span class="comment">//字符串</span></span><br><span class="line"><span class="keyword">char</span> d[<span class="number">10</span>] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="number">0</span>&#125;; <span class="comment">//字符串</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[]=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%s\n&quot;</span>,a);<span class="comment">//会乱码,没有结束符</span></span><br><span class="line">    <span class="keyword">char</span> b[]=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b=%s\n&quot;</span>,b);<span class="comment">//输出abc,遇到\0就停止</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/27/Re83qQAwDB7K42Y.png" alt=""></p>
<p>字符数组初始化(常用)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>]=<span class="string">&quot;abcde&quot;</span>;<span class="comment">//最多写9个字符,留一个放结束符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%s\n&quot;</span>,a);</span><br><span class="line"><span class="keyword">char</span> b[]=<span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b=%s\n&quot;</span>,b);<span class="comment">//sizeof()测数据类型大小，不会因为结束符提前结束</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(b)=%lu\n&quot;</span>,<span class="keyword">sizeof</span>(b));<span class="comment">//输出6,b这个数组有5个字符,会自动补加结束符(隐藏)</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/27/iDy86UJt1X2r3ZK.png" alt=""></p>
<p>\0后面最好不要跟数字,有可能组成转义字符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[]=<span class="string">&quot;\0abc&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%s\n&quot;</span>,a);<span class="comment">//输出为空,含有结束符\0</span></span><br><span class="line">    <span class="keyword">char</span> b[]=<span class="string">&quot;\0417abcde&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b=%s\n&quot;</span>,b);<span class="comment">//输出非空,\0与其后数字组成转义字符\041,通过man ascii命令查到\041对应!(感叹号)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/27/VJXSilNmnR6wyhB.png" alt=""></p>
<p>函数的调用:产生随机数</p>
<p>当调用函数时，需要关心5要素:</p>
<ul>
<li>头文件:包含指定的头文件</li>
<li>函数名字:函数名字必须和头文件声明的名字一样</li>
<li>功能:需要知道此函数功能后再调用</li>
<li>参数:参数类型要匹配</li>
<li>返回值:根据需要接收返回值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;//产生随机数的函数包含在此</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;//获取当前系统时间的函数包含在此</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">//先设置种子,种子设置一次即可</span></span><br><span class="line">        <span class="comment">//srand(10);</span></span><br><span class="line">        <span class="comment">/*如果srand()参数一样,则每次产生的随机数一样,</span></span><br><span class="line"><span class="comment">        每次启动计算机以后，种子就是定值了，</span></span><br><span class="line"><span class="comment">        所以根据公式推算出来的结果</span></span><br><span class="line"><span class="comment">        （也就是生成的随机数）就是固定的*/</span></span><br><span class="line">        <span class="comment">/*time(NULL)用来获取系统当前时间,</span></span><br><span class="line"><span class="comment">        由于时间会变,srand()也会改变*/</span></span><br><span class="line">        srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">                num=rand();<span class="comment">//rand()产生随机数</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;num=%d\n&quot;</span>,num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/27/lTzVDuG41P6RUr7.png" alt=""></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h3><blockquote>
<p>strlen需要使用返回值,返回值就是字符串的长度,从首元素开始,到结束符为止的长度,结束符不算(遇到’\0’结束)</p>
</blockquote>
<h3 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h3><blockquote>
<p>拷贝原理:从首元素开始,到结束符(\0)为止的长度</p>
</blockquote>
<h3 id="strncpy"><a href="#strncpy" class="headerlink" title="strncpy"></a>strncpy</h3><blockquote>
<p>可以把”\0”拷贝过去,但是”\0”后面的就不能了</p>
</blockquote>
]]></content>
      <categories>
        <category>C&amp;C++</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Nmap的使用</title>
    <url>/article/44a199f9.html</url>
    <content><![CDATA[<h1 id="Nmap的使用"><a href="#Nmap的使用" class="headerlink" title="Nmap的使用"></a>Nmap的使用</h1><a id="more"></a>
<p>Nmap是主机扫描工具，他的图形化界面是Zenmap，分布式框架为Dnamp。</p>
<p>Nmap可以完成以下任务：</p>
<blockquote>
<ul>
<li>主机探测</li>
<li>端口扫描</li>
<li>版本检测</li>
<li>系统检测</li>
<li><p>支持探测脚本的编写</p>
</li>
<li><p>Nmap在实际中应用场合如下：</p>
</li>
<li>通过对设备或者防火墙的探测来审计它的安全性</li>
<li>探测目标主机所开放的端口</li>
<li>通过识别新的服务器审计网络的安全性</li>
<li>探测网络上的主机</li>
</ul>
</blockquote>
<p>端口扫描工具，即借助工具，试图了解所扫描IP提供的计算机网络服务类型（网络服务均与端口号相关），从而发现攻击弱点，常见服务对应端口号：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>服务</th>
<th>端口号</th>
</tr>
</thead>
<tbody>
<tr>
<td>HTTP</td>
<td>80</td>
</tr>
<tr>
<td>HTTPS</td>
<td>443</td>
</tr>
<tr>
<td>Telnet</td>
<td>23</td>
</tr>
<tr>
<td>FTP</td>
<td>21</td>
</tr>
<tr>
<td>SSH（安全登录）、SCP（文件传输）、端口重定向</td>
<td>22</td>
</tr>
<tr>
<td>SMTP</td>
<td>25</td>
</tr>
<tr>
<td>POP3</td>
<td>110</td>
</tr>
<tr>
<td>WebLogic</td>
<td>7001</td>
</tr>
<tr>
<td>TOMCAT</td>
<td>8080</td>
</tr>
<tr>
<td>WIN2003远程登录</td>
<td>3389</td>
</tr>
<tr>
<td>Oracle数据库</td>
<td>1521</td>
</tr>
<tr>
<td>MS SQL* SEVER数据库sever</td>
<td>1433</td>
</tr>
<tr>
<td>MySQL 数据库sever</td>
<td>3306</td>
</tr>
</tbody>
</table>
</div>
<p>Nmap进行完整全面的扫描<br>nmap –T4 –A –v</p>
<p>其中-A选项用于使用进攻性（Aggressive）方式扫描；-T4指定扫描过程使用的时序（Timing），总有6个级别（0-5），级别越高，扫描速度越快，但也容易被防火墙或IDS检测并屏蔽掉，在网络通讯状况良好的情况推荐使用T4；-v表示显示冗余（verbosity）信息，在扫描过程中显示扫描的细节，从而让用户了解当前的扫描状态。</p>
<h3 id="Nmap用于主机发现的一些用法"><a href="#Nmap用于主机发现的一些用法" class="headerlink" title="Nmap用于主机发现的一些用法"></a><strong>Nmap用于主机发现的一些用法</strong></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-sL: List Scan 列表扫描，仅将指定的目标的IP列举出来，不进行主机发现。  </span><br><span class="line">  </span><br><span class="line">-sn: Ping Scan 只进行主机发现，不进行端口扫描。  </span><br><span class="line">  </span><br><span class="line">-Pn: 将所有指定的主机视作开启的，跳过主机发现的过程。  </span><br><span class="line">  </span><br><span class="line">-PS/PA/PU/PY[portlist]: 使用TCPSYN/ACK或SCTP INIT/ECHO方式进行发现。  </span><br><span class="line">  </span><br><span class="line">-PE/PP/PM: 使用ICMP echo, timestamp, and netmask 请求包发现主机。-PO[protocollist]: 使用IP协议包探测对方主机是否开启。  </span><br><span class="line">  </span><br><span class="line">-n/-R: -n表示不进行DNS解析；-R表示总是进行DNS解析。  </span><br><span class="line">  </span><br><span class="line">--dns-servers &lt;serv1[,serv2],...&gt;: 指定DNS服务器。  </span><br><span class="line">  </span><br><span class="line">--system-dns: 指定使用系统的DNS服务器  </span><br><span class="line">  </span><br><span class="line">--traceroute: 追踪每个路由节点 </span><br></pre></td></tr></table></figure>
<h3 id="Nmap用于端口扫描的一些用法"><a href="#Nmap用于端口扫描的一些用法" class="headerlink" title="Nmap用于端口扫描的一些用法"></a><strong>Nmap用于端口扫描的一些用法</strong></h3><p>1、扫描方式选项</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-sS/sT/sA/sW/sM:指定使用 TCP SYN/Connect()/ACK/Window/Maimon scans的方式来对目标主机进行扫描。  </span><br><span class="line">  </span><br><span class="line">  -sU: 指定使用UDP扫描方式确定目标主机的UDP端口状况。  </span><br><span class="line">  </span><br><span class="line">  -sN/sF/sX: 指定使用TCP Null, FIN, and Xmas scans秘密扫描方式来协助探测对方的TCP端口状态。  </span><br><span class="line">  </span><br><span class="line">  --scanflags &lt;flags&gt;: 定制TCP包的flags。  </span><br><span class="line">  </span><br><span class="line">  -sI &lt;zombiehost[:probeport]&gt;: 指定使用idle scan方式来扫描目标主机（前提需要找到合适的zombie host）  </span><br><span class="line">  </span><br><span class="line">  -sY/sZ: 使用SCTP INIT/COOKIE-ECHO来扫描SCTP协议端口的开放的情况。  </span><br><span class="line">  </span><br><span class="line">  -sO: 使用IP protocol 扫描确定目标机支持的协议类型。  </span><br><span class="line">  </span><br><span class="line">  -b &lt;FTP relay host&gt;: 使用FTP bounce scan扫描方式  </span><br></pre></td></tr></table></figure>
<p>2、 端口参数与扫描顺序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[plain] view plain copy</span><br><span class="line">-p &lt;port ranges&gt;: 扫描指定的端口  </span><br><span class="line">  </span><br><span class="line">实例: -p22; -p1-65535; -p U:53,111,137,T:21-25,80,139,8080,S:9（其中T代表TCP协议、U代表UDP协议、S代表SCTP协议）  </span><br><span class="line">  </span><br><span class="line">-F: Fast mode – 快速模式，仅扫描TOP 100的端口  </span><br><span class="line">  </span><br><span class="line">-r: 不进行端口随机打乱的操作（如无该参数，nmap会将要扫描的端口以随机顺序方式扫描，以让nmap的扫描不易被对方防火墙检测到）。  </span><br><span class="line">  </span><br><span class="line">--top-ports &lt;number&gt;:扫描开放概率最高的number个端口（nmap的作者曾经做过大规模地互联网扫描，以此统计出网络上各种端口可能开放的概率。以此排列出最有可能开放端口的列表，具体可以参见文件：nmap-services。默认情况下，nmap会扫描最有可能的1000个TCP端口）  </span><br><span class="line">  </span><br><span class="line">--port-ratio &lt;ratio&gt;: 扫描指定频率以上的端口。与上述--top-ports类似，这里以概率作为参数，让概率大于--port-ratio的端口才被扫描。显然参数必须在在0到1之间，具体范围概率情况可以查看nmap-services文件。  </span><br></pre></td></tr></table></figure>
<p>3、 版本侦测的用法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">版本侦测方面的命令行选项比较简单。</span><br><span class="line">[plain] view plain copy</span><br><span class="line">-sV: 指定让Nmap进行版本侦测  </span><br><span class="line">  </span><br><span class="line">--version-intensity &lt;level&gt;: 指定版本侦测强度（0-9），默认为7。数值越高，探测出的服务越准确，但是运行时间会比较长。  </span><br><span class="line">  </span><br><span class="line">--version-light: 指定使用轻量侦测方式 (intensity 2)  </span><br><span class="line">  </span><br><span class="line">--version-all: 尝试使用所有的probes进行侦测 (intensity 9)  </span><br><span class="line">  </span><br><span class="line">--version-trace: 显示出详细的版本侦测过程信息。  </span><br></pre></td></tr></table></figure>
<p>具体操作演示如下<br>1、用Nmap扫描特定IP地址<br><img src="https://i.loli.net/2021/05/12/D6NC24enStuVZw9.png" alt=""></p>
<p>2、用<code>-vv</code>对结果进行详细输出<br><img src="https://i.loli.net/2021/05/12/LipcJ541fxHPXAE.png" alt=""></p>
<p>3、自行设置端口范围进行扫描<br><img src="https://images2015.cnblogs.com/blog/1028836/201703/1028836-20170319215030354-1196652527.png" alt=""></p>
<p>4、指定端口号进行扫描</p>
<p><img src="https://i.loli.net/2021/05/12/2ZIgiOs3Bvbr9h6.png" alt=""><br>5、对目标进行Ping扫描</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -sP &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/05/12/U72Gd3ypHFNljrm.png" alt=""><br>6、路由跟踪</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -traceroute &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/05/12/LE9fDp7j2JiPeZG.png" alt=""></p>
<p>7、扫描一个段的主机在线状况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -sP &lt;network address &gt; &lt;/CIDR&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/05/12/CX5gaR2iNUqLnb6.png" alt=""></p>
<p>8、操作系统探测</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -O &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/05/12/6xVY5q4mNZP82JG.png" alt=""></p>
<p>9、万能开关扫描</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -A &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/05/12/z1FwyGNB6meqf4D.png" alt=""></p>
<p>10、其他扫描方式<br><strong>SYN扫描</strong>：利用基本的SYN扫描方式测试其端口开放状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">namp -sS -T4 &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
<p><strong>FIN扫描</strong>：利用FIN扫描方式探测防火墙状态。FIN扫描方式用于识别端口是否关闭，收到RST回复说明该端口关闭，否则说明是open或filtered状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">namp -sF -T4 &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
<p><strong>ACK扫描</strong>：利用ACK扫描判断端口是否被过滤。针对ACK探测包，为被过滤的端口（无论打开或关闭）会回复RST包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">namp -sA -T4 &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
<p>扫描前不进行Ping扫描测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -Pn &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
<p>如果有一个ip地址列表，将这个保存为一个txt文件，和nmap在同意目录下，扫描这个txt的所有主机，命令为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -iL target.txt</span><br></pre></td></tr></table></figure>
<p>版本检测扫描</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -sV &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/05/12/mzHTuabVEJFo2Av.png" alt=""></p>
<p>Nmap的帮助文档<br><img src="https://i.loli.net/2021/05/12/eRQIHwjkcuvAtoZ.png" alt=""><br><img src="https://i.loli.net/2021/05/12/8FSLDtPyUIGlXo6.png" alt=""></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.csdn.net/aspirationflow/article/details/7694274">Nmap扫描原理与用法</a></p>
]]></content>
      <categories>
        <category>Hack</category>
      </categories>
      <tags>
        <tag>Hack</tag>
        <tag>Namp</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习笔记</title>
    <url>/article/34487.html</url>
    <content><![CDATA[<h1 id="Linux学习笔记"><a href="#Linux学习笔记" class="headerlink" title="Linux学习笔记"></a>Linux学习笔记</h1><a id="more"></a>
<h2 id="Linux注意事项"><a href="#Linux注意事项" class="headerlink" title="Linux注意事项"></a>Linux注意事项</h2><p>Ctrl+a  快速回到行首</p>
<p>Ctrl+e  快速回到行末</p>
<p>Linux严格区分大小写.</p>
<p>Linux中所有内容以文件形式保存，包括硬件</p>
<ul>
<li>硬盘文件是/dev/sd[a-p]</li>
<li>光盘文件是/dev/sr0</li>
</ul>
<p>Linux不靠扩展名区分文件类型(扩展名便于用户使用),靠文件权限</p>
<ul>
<li>压缩包: “*.gz”、”*.bz2”、”*.tar.bz2”、”*.tgz”等</li>
<li>二进制软件包: “*.rpm”</li>
<li>网页文件: “*.html”、”*.php”</li>
<li>脚本文件: “*.sh”</li>
<li>配置文件: “*.conf”</li>
</ul>
<p>Linux所有的存储设备都必须挂载,之后用户才能使用,包括硬盘、U盘和光盘</p>
<p>Windows下的程序不能直接在Iinux中安装和运行</p>
<h2 id="服务器管理和维护"><a href="#服务器管理和维护" class="headerlink" title="服务器管理和维护"></a>服务器管理和维护</h2><h3 id="目录及作用"><a href="#目录及作用" class="headerlink" title="目录及作用"></a>目录及作用</h3><div class="table-container">
<table>
<thead>
<tr>
<th>目录名</th>
<th>目录作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>/bin/</td>
<td>存放系统命令的目录，普通用户和超级用户都可以执行。不过放在/bin下的命令在单用户模式下也可以执行</td>
</tr>
<tr>
<td>/sbin/</td>
<td>保存和系统环境设置相关的命令，只有超级用户可以使用这些命令进行系统环境设置，但是有些命令可以允许普通用户查看</td>
</tr>
<tr>
<td>/usr/bin/</td>
<td>存放系统命令的目录，普通用户和超级用户都可以执行。这些命令和系统启动无关，在单用户模式下不能执行</td>
</tr>
<tr>
<td>/usr/sbin/</td>
<td>存放根文件系统不必要的系统管理命令，例如多数服务程序。只有超级用户可以使用。大家其实可以注意到Linux的系统，在所有“sbin” 目录中保存的命令只有超级用户可以使用，“bin”目录中保存的命令所有用户都可以使用</td>
</tr>
<tr>
<td>/boot/</td>
<td>系统启动目录，保存系统启动相关的文件，如内核文件和启动引导程序( grub)文件等</td>
</tr>
<tr>
<td>/dev/</td>
<td>设备文件保存位置。我们已经说过Linux中所有内容以文件形式保存，包括硬件。那么这个目录就是用来保存所有硬件设备文件的</td>
</tr>
<tr>
<td>/etc/</td>
<td>配置文件保存位置。系统内所有采用默认安装方式(rpm安装)的服务的配置文件全部都保存在这个目录当中，如用户账户和密码，服务的启动脚本，常用服务的配置文件等</td>
</tr>
<tr>
<td>/home/</td>
<td>普通用户的家目录。建立每个用户时，每个用户要有一个默认登录位置，这个位置就是这个用户的家目录，所有普通用户的家目录就是在/home下建立一个和用户名相同的目录。如用户user1 的家目录就是home/user1</td>
</tr>
<tr>
<td>/lib/</td>
<td>系统调用的函数库保存位置</td>
</tr>
<tr>
<td>/lost+found/</td>
<td>当系统意外崩溃或机器意外关机，而产生一些文件碎片放在这里。当系统启动的过程中fsck工具会检查这里，并修复已经损坏的文件系统。这个目录只在每个分区中出现，例如/lost+found就是根分区的备份恢复目录，/boot/lost+ found就是/boot分区的备份恢复目录</td>
</tr>
<tr>
<td>/media/</td>
<td>挂载目录。系统建议是用来挂载媒体设备的，例如软盘和光盘</td>
</tr>
<tr>
<td>/mnt/</td>
<td>挂载目录，早期Linux中只有这一个挂载目录，并没有细分。现在这个目录系统建议挂载额外设备，如U盘，移动硬盘和其他操作系统的分区</td>
</tr>
<tr>
<td>/misc/</td>
<td>挂载目录。系统建议用来挂载NFS服务的共享目录。只要是一个已经建立的空目录就可以作为挂载点。那么系统虽然准备了三个默认挂载目录/media、/mnt、 /misc, 但是到底在哪个目录中挂载什么设备都可以由管理员自己决定。例如在/mnt下建立不同目录挂载不同设备。如/mnt/cdrom挂载光盘，/mnt/usb挂载U盘</td>
</tr>
<tr>
<td>/opt/</td>
<td>第三方安装的软件保存位置。这个目录就是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录当中。/usr/local目录也可以用来安装软件(更为常用)</td>
</tr>
<tr>
<td>/proc/</td>
<td>虚拟文件系统，该目录中的数据并不保存到硬盘当中，而是保存到内存当中。主要保存系统的内核，进程，外部设备状态和网络状态灯。如/proc/cpuinfo是保存CPU信息的，/proc/devices是保存设备驱动的列表的，/proc/filesystems是保存文件系统列表的，/proc/net/是保存网络协议信息的</td>
</tr>
<tr>
<td>/sys/</td>
<td>虚拟文件系统。和/proc 目录相似，都是保存在内存当中的，主要是保存于内核相关信息的</td>
</tr>
<tr>
<td>/root/</td>
<td>超级用户的家目录。普通用户家目录在“home”下，超级用户家目录直接在“/”下</td>
</tr>
<tr>
<td>/srv/</td>
<td>服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据</td>
</tr>
<tr>
<td>/tmp/</td>
<td>临时目录。系统存放临时文件的目录，该目录下所有用户都可以访问和写入。建议此目录中不能保存重要数据，最好每次开机都把该目录清空</td>
</tr>
<tr>
<td>/usr/</td>
<td>系统软件资源目录。注意usr不是user的缩写，而是“Unix Softwre Resource”的缩写，所以不是存放用户数据，而是存放系统软件资源的目录。系统中安装的软件大多数保存在这里</td>
</tr>
<tr>
<td>/var/</td>
<td>动态数据保存位置。主要保存缓存、日志以及软件运行所产生的文件</td>
</tr>
</tbody>
</table>
</div>
<h3 id="服务器注意事项"><a href="#服务器注意事项" class="headerlink" title="服务器注意事项"></a>服务器注意事项</h3><ul>
<li>远程服务器不允许关机，只能重启</li>
<li>重启时应该正确关闭服务</li>
<li>不要在服务器访问高峰运行高负载命令(搜索)</li>
<li>远程配置防火墙时不要把自己踢出服务器</li>
<li>指定合理的密码规范并定期更新</li>
<li>合理分配权限</li>
<li>定期备份重要数据和日志</li>
</ul>
<h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><h3 id="文件处理命令"><a href="#文件处理命令" class="headerlink" title="文件处理命令"></a>文件处理命令</h3><h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>命令格式:命令 [-选项] [参数]<br>例:ls -la /etc<br>说明:</p>
<ol>
<li>个别命令使用不遵循此格式</li>
<li>当有多个选项时，可以写在一起,绝大多数顺序也可以改变</li>
<li>简化选项与完整选项<br>-a等于--all</li>
</ol>
<h4 id="目录处理命令"><a href="#目录处理命令" class="headerlink" title="目录处理命令"></a>目录处理命令</h4><h5 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h5><p>命令名称: ls<br>命令英文原意:list<br>命令所在路径: /bin/ls<br>执行权限:所有用户<br>功能描述:显示目录文件<br>语法: ls 选项[-ald] [文件或目录]<br>    -a  显示所有文件，包括隐藏文件<br>    -1  详细信息显示<br>    -d  查看目录属性<br>    -i  查看i节点(linux中，文件查找不是通过文件名称来查找的。实际上是通过i节点来实现文件的查找定位的。)</p>
<p>-rw-r--r--</p>
<ul>
<li>- 文件类型(-二进制文件 d目录 l软链接文件)</li>
<li>rw- r-- r--<br>u     g    o<br>u所有者 g所属组 o其他人<br>r读 w写 x执行</li>
</ul>
<h5 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h5><p>命令名称: mkdir<br>命令英文原意: make directories<br>命令所在路径: /bin/mkdir<br>执行权限: 所有用户<br>语法: mkdir -p [目录名]<br>功能描述:创建新目录<br>      -p  递归创建(不加-p只能在已有目录创建一个新目录,而不能创建一个带有子目录的目录)</p>
<p>mkdir可同时创建多个目录  </p>
<h5 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h5><p>命令名称: cd<br>命令英文原意: change directory<br>命令所在路径: shell内置命令<br>执行权限: 所有用户<br>语法: cd [目录]<br>功能描述: 切换目录</p>
<h5 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h5><p>命令名称: pwd<br>命令英文原意: print working directory<br>命令所在路径: /bin/pwd<br>执行权限: 所有用户<br>语法: pwd<br>功能描述: 显示当前目录</p>
<h5 id="rmdir命令"><a href="#rmdir命令" class="headerlink" title="rmdir命令"></a>rmdir命令</h5><p>命令名称: rmdir<br>命令英文原意: remove empty directories<br>命令所在路径: /bin/rmdir<br>执行权限: 所有用户<br>语法: rmdir [目录名]<br>功能描述: 只能删除空目录</p>
<h5 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h5><p>命令名称: cp<br>命令英文原意: copy<br>命令所在路径: /bin/cp<br>执行权限: 所有用户<br>语法: cp -rp [原文件或目录] [目标目录]<br>    -r  复制目录<br>    -p  保留文件属性(不加-p时会改变文件的修改时间)<br>功能描述: 复制文件或目录到另一个文件(改名)或目录</p>
<p>cp命令可以同时复制多个目录或文件,可以复制并同时改名</p>
<h5 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h5><p>命令名称: mv<br>命令英文原意: move<br>命令所在路径: /bin/mv<br>执行权限: 所有用户<br>语法: mv [原文件或目录] [目标目录]<br>功能描述: 剪切文件、改名</p>
<h5 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h5><p>命令名称: rm<br>命令英文原意: remove<br>命令所在路径: /bin/rm<br>执行权限: 所有用户<br>语法: rm -rf [文件或目录]<br>    -r  删除目录<br>    -f  强制执行<br>    -i  询问删除<br>功能描述: 删除文件</p>
<p>Linux没有回收站概念,删除文件要谨慎.删除文件前要备份,一旦发现误删除情况,尽量不要对硬盘做过多的读写或查找操作.</p>
<h4 id="文件处理命令-1"><a href="#文件处理命令-1" class="headerlink" title="文件处理命令"></a>文件处理命令</h4><h5 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h5><p>命令名称: touch<br>命令所在路径: /bin/touch<br>执行权限: 所有用户<br>语法: touch [文件名]<br>功能描述: 创建空文件</p>
<h5 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h5><p>命令名称: cat<br>命令所在路径: /bin/cat<br>执行权限: 所有用户<br>语法: cat -n [文件名]<br>功能描述: 显示文件内容(只能用于查看内容较少的文件,否则滚动条会一直滚动,只显示最后一页,内容较多用more命令)<br>    -n  显示行号<br>    -A  查询所有文件内容,包括隐藏字符</p>
<h5 id="tac命令"><a href="#tac命令" class="headerlink" title="tac命令"></a>tac命令</h5><p>命令名称: tac<br>命令所在路径: /usr/bin/tac<br>执行权限: 所有用户<br>语法: tac [文件名]<br>功能描述: 显示文件内容(反向列示,与cat相反)</p>
<h5 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h5><p>命令名称: more<br>命令所在路径: /bin/more<br>执行权限: 所有用户<br>语法: more [文件名]<br>    (空格)或f  翻页<br>    (Enter)  换行<br>    q或Q  退出<br>功能描述: 分页显示文件内容(无法向上翻页)</p>
<h5 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h5><p>命令名称: less<br>命令所在路径: /usr/bin/less<br>执行权限: 所有用户<br>语法: less [文件名]<br>    (空格)或f  翻页<br>    (Enter)  换行<br>    q或Q  退出<br>    pgup  向上翻页<br>    pgdn  向下翻页<br>    /[关键词]  搜索<br>    n  搜索下一个<br>功能描述: 分页显示文件内容(可向上翻页),可进行搜索</p>
<h5 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a>head命令</h5><p>命令名称: head<br>命令所在路径: /usr/bin/head<br>执行权限: 所有用户<br>语法: head -n [行数] [文件名]<br>功能描述: 显示文件前面几行<br>    -n  指定行数(不加默认显示前10行)</p>
<h5 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h5><p>命令名称: tail<br>命令所在路径: /usr/bin/tail<br>执行权限: 所有用户<br>语法: tail -n [行数] [文件名]<br>功能描述: 显示文件后面几行<br>    -n  指定行数(不加默认显示后10行)<br>    -f  动态显示文件末尾内容(监控日志)</p>
<h4 id="链接命令"><a href="#链接命令" class="headerlink" title="链接命令"></a>链接命令</h4><h5 id="ln命令"><a href="#ln命令" class="headerlink" title="ln命令"></a>ln命令</h5><p>命令名称: ln<br>命令英文原意: link<br>命令所在路径: /bin/ln<br>执行权限: 所有用户<br>语法: ln -s [原文件] [目标文件]<br>    -s  创建软链接(不加创建硬链接)<br>功能描述: 生成链接文件</p>
<h5 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h5><ol>
<li>软链接全部都为lrwxrwxrwx,软链接权限不决定源文件权限,用户对软链接操作时具有什么权限由软链接对应的源文件确定</li>
<li>文件大小只是符号链接</li>
<li>软链接有箭头指向源文件</li>
<li>源文件删除,软链接失效</li>
</ol>
<h5 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h5><ol>
<li>拷贝(保留文件属性)cp -p + 同步更新</li>
<li>通过i节点识别(ls -i [文件名])(一个文件对应一个i节点,一个i节点可以对应多个文件)</li>
<li>不能跨分区(类似将windowsC盘的文件硬链接到D盘)</li>
<li>不能针对目录使用</li>
<li>源文件删除,硬链接依旧存在</li>
</ol>
<h3 id="权限管理命令"><a href="#权限管理命令" class="headerlink" title="权限管理命令"></a>权限管理命令</h3><h4 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h4><p>命令名称: chmod<br>命令英文原意: change the permissions mode of a file<br>命令所在路径: /bin/chmod<br>执行权限: 所有用户<br>语法: chmod [{ugoa} {+-=} {rwx}] [文件或目录]<br>                        [mode=421(rwx)] [文件或目录]<br>                        -R  递归修改主目录及主目录下所有目录或文件的权限<br>功能描述:改变文件或目录权限</p>
<p>如果有几个类型的用户需要同时设置权限,用逗号分隔</p>
<h4 id="文件目录权限总结"><a href="#文件目录权限总结" class="headerlink" title="文件目录权限总结"></a>文件目录权限总结</h4><div class="table-container">
<table>
<thead>
<tr>
<th>代表字符</th>
<th>权限</th>
<th>对文件的含义</th>
<th>对目录的含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>读权限</td>
<td>可以查看文件内容</td>
<td>可以列出目录中内容</td>
</tr>
<tr>
<td>w</td>
<td>写权限</td>
<td>可以修改文件内容</td>
<td>可以在目录中创建、删除文件</td>
</tr>
<tr>
<td>x</td>
<td>执行权限</td>
<td>可以执行文件</td>
<td>可以进入目录</td>
</tr>
</tbody>
</table>
</div>
<p>只有文件所有者和root可以改变文件权限</p>
<h4 id="其他权限管理命令"><a href="#其他权限管理命令" class="headerlink" title="其他权限管理命令"></a>其他权限管理命令</h4><h5 id="chown命令"><a href="#chown命令" class="headerlink" title="chown命令"></a>chown命令</h5><p>命令名称: chown<br>命令英文原意: change file ownership<br>命令所在路径: /bin/chown<br>执行权限: 所有用户<br>语法: chown [用户] [文件或目录]<br>功能描述: 改变文件或目录的所有者</p>
<p>只有root可以改变文件或目录的所有者</p>
<h5 id="chgrp命令"><a href="#chgrp命令" class="headerlink" title="chgrp命令"></a>chgrp命令</h5><p>命令名称: chgrp<br>命令英文原意: change file group ownership<br>命令所在路径: /bin/chgrp<br>执行权限: 所有用户<br>语法: chgrp [用户组] [文件或目录]<br>功能描述: 改变文件或目录的所属组</p>
<h5 id="umask命令"><a href="#umask命令" class="headerlink" title="umask命令"></a>umask命令</h5><p>命令名称: umask<br>命令英文原意: the user file-creation mask<br>命令所在路径: Shell内置命令<br>执行权限: 所有用户<br>语法: umask [-S]<br>    -S  以rwx形式显示新建文件缺省(默认)权限<br>功能描述:显示、设置文件的缺省权限(默认)</p>
<p>新建文件默认不具有可执行权限;使用umask命令会显示0022,其中,0表示特殊权限,022为权限掩码,真正的权限(缺省)为777-022=755;修改默认权限可以通过下面方式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">umask 权限掩码</span><br></pre></td></tr></table></figure>
<h3 id="文件搜索命令"><a href="#文件搜索命令" class="headerlink" title="文件搜索命令"></a>文件搜索命令</h3><p>搜索会占用大量的系统资源</p>
<h4 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h4><p>命令名称: find<br>命令所在路径: /bin/find<br>执行权限: 所有用户<br>语法: find [搜索范围] [匹配条件]<br>    -name  根据文件名搜索(严格区分大小写)<br>    -iname  根据文件名搜索(不区分大小写)<br>    -size  根据文件大小搜索<br>    -user  根据所有者搜索<br>    -group  根据所属组搜索<br>    -amin  访问时间(access)<br>    -cmin  文件属性(change)<br>    -mmin  文件内容(modify)<br>    -a  两个条件同时满足(and)<br>    -o  两个条件满足任意一个即可(or)<br>    -type  根据文件类型查找(f文件 d目录 l软链接文件)<br>    -exec/-ok 命令 {} \;  对搜索结果执行操作(花括号表示对搜索结果做替换,反斜杠表示转义符,分号表示结束;-ok和-exec最大的区别是有一个询问确认的环节)<br>    -inum  根据i节点搜索<br>功能描述: 文件搜索</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;etc -name init &#x2F;&#x2F;在etc目录搜索文件名为init的文件和目录(精准搜索)</span><br><span class="line">find &#x2F;etc -name *init*  &#x2F;&#x2F;在etc目录搜索文件名中包含init的文件和目录(模糊搜索)</span><br><span class="line">find &#x2F;etc -name init*  &#x2F;&#x2F;在etc目录搜索以init开头的文件和目录(*匹配任意字符)</span><br><span class="line">find &#x2F;etc -name init???  &#x2F;&#x2F;在etc目录搜索以init开头并且后面还有三个字母的文件或目录(问号匹配单个字符)</span><br><span class="line">find &#x2F; -size +204800  &#x2F;&#x2F;在根目录下查找大于100MB的文件和目录  </span><br><span class="line">+n 大于    -n 小于    n 等于  1数据块&#x3D;512字节&#x3D;0.5k</span><br><span class="line">find &#x2F;etc -cmin -5 &#x2F;&#x2F;在&#x2F;etc下查找5分钟内被修改过属性的文件和目录</span><br><span class="line">find &#x2F;etc -mmin +5 &#x2F;&#x2F;在&#x2F;etc下查找5分钟前被修改过内容的文件和目录</span><br><span class="line">find &#x2F;etc -size +163840 -a -size -204800  &#x2F;&#x2F;在&#x2F;etc下查找大于8OMB小于100MB的文件和目录</span><br><span class="line">find &#x2F;etc -name init* -a -type f &#x2F;&#x2F;在etc目录搜索以init开头的文件(没有目录)</span><br><span class="line">find &#x2F;etc -name inittab -exec ls -l &#123;&#125; \;  &#x2F;&#x2F;在&#x2F;etc下查找inittab文件并显示其详细信息</span><br><span class="line">find . -inum 123 -exec rm &#123;&#125; \;  &#x2F;&#x2F;在当前目录搜索i节点为123的文件和目录并删除</span><br></pre></td></tr></table></figure>
<p>不要在服务器高峰期使用find命令;搜索范围越小越好,搜索条件越精准越好</p>
<h4 id="其他搜索命令"><a href="#其他搜索命令" class="headerlink" title="其他搜索命令"></a>其他搜索命令</h4><h5 id="locate命令"><a href="#locate命令" class="headerlink" title="locate命令"></a>locate命令</h5><p>命令名称: locate<br>命令所在路径: /usr/bin/locate<br>执行权限: 所有用户<br>语法: locate 文件名<br>功能描述: 在文件资料库(自动定期更新)中查找文件(比find快)<br>    -i  不区分大小写(不加区分大小写)</p>
<p>如果一个新建立的文件没有被收录,就查找不到,可以使用updatedb更新文件资料库;/tmp存放临时文件,(存放临时文件的目录)不在locate文件资料库收录范围,无法查找/tmp中文件</p>
<h5 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h5><p>命令名称: which<br>命令所在路径: /usr/bin/which<br>执行权限: 所有用户<br>语法: which 命令名称<br>功能描述: 搜索命令所在目录及别名信息</p>
<h5 id="whereis命令"><a href="#whereis命令" class="headerlink" title="whereis命令"></a>whereis命令</h5><p>命令名称: whereis<br>命令所在路径: /usr/bin/whereis<br>执行权限: 所有用户<br>语法: whereis [命令名称]<br>功能描述: 搜索命令所在目录及帮助文档路径(配置文件)</p>
<h5 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h5><p>命令名称: grep<br>命令所在路径: /bin/grep<br>执行权限: 所有用户<br>语法: grep -iv [指定字串] [文件]<br>功能描述: 在文件中搜寻字串匹配的行并输出<br>    -i  不区分大小写<br>    -v  排除指定字串<br>    -n  输出行号<br>    --color=auto   搜索出的关键字用颜色显示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -v ^# &#x2F;etc&#x2F;inittab  &#x2F;&#x2F;搜索时去掉以#号开头的内容</span><br></pre></td></tr></table></figure>
<h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><h4 id="man命令"><a href="#man命令" class="headerlink" title="man命令"></a>man命令</h4><p>命令名称: man<br>命令英文原意: manual<br>命令所在路径: /usr/bin/man<br>执行权限: 所有用户<br>语法: man [命令或配置文件]<br>功能描述: 获得(命令或配置文件的)帮助信息</p>
<p>man命令与more和less类似;man查看配置文件的帮助信息不要加绝对路径,只要加配置文件名称即可;1表示命令的帮助,5表示配置文件的帮助</p>
<h4 id="whatis命令"><a href="#whatis命令" class="headerlink" title="whatis命令"></a>whatis命令</h4><p>命令名称: whatis<br>命令所在路径: /usr/bin/whatis<br>执行权限: 所有用户<br>语法: whatis [命令]<br>功能描述: 获得命令(相对man命令更为简短)的帮助信息</p>
<h4 id="apropos命令"><a href="#apropos命令" class="headerlink" title="apropos命令"></a>apropos命令</h4><p>命令名称: apropos<br>命令所在路径: /usr/bin/apropos<br>执行权限: 所有用户<br>语法: apropos [配置文件]<br>功能描述: 获得配置文件(相对man命令更为简短)的帮助信息</p>
<h4 id="info命令"><a href="#info命令" class="headerlink" title="info命令"></a>info命令</h4><p>命令名称: info<br>命令英文原意: information<br>命令所在路径: /usr/bin/info<br>执行权限: 所有用户<br>语法: info [命令或配置文件]<br>功能描述: 获得(命令或配置文件的)帮助信息</p>
<p>info命令与man命令类似,只是显示方式不同</p>
<h4 id="help"><a href="#help" class="headerlink" title="--help"></a>--help</h4><p>命令名称: --help<br>执行权限: 所有用户<br>语法: 命令 --help<br>功能描述: 获得命令主要选项的帮助信息(适用于外部命令)</p>
<h4 id="help命令"><a href="#help命令" class="headerlink" title="help命令"></a>help命令</h4><p>命令名称: help<br>命令所在路径: Shell内置命令<br>执行权限: 所有用户<br>语法: help 命令<br>功能描述: 获得Shell(命令解释器)内置命令(找不到路径)的帮助信息(不能使用man查看)</p>
<p>可以使用type [命令名称],来查看是外部命令还是内置命令</p>
<h3 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h3><h4 id="useradd命令"><a href="#useradd命令" class="headerlink" title="useradd命令"></a>useradd命令</h4><p>命令名称: useradd<br>命令所在路径: /usr/sbin/useradd<br>执行权限: root<br>语法: useradd 用户名<br>功能描述: 添加新用户</p>
<h4 id="passwd命令"><a href="#passwd命令" class="headerlink" title="passwd命令"></a>passwd命令</h4><p>命令名称: passwd<br>命令所在路径: /usr/bin/passwd<br>执行权限: 所有用户<br>语法: passwd 用户名<br>功能描述: 设置用户密码</p>
<p>root用户更改密码不用遵循密码复杂度要求;普通用户更改密码必须遵循密码复杂度要求.root可以更改任何人的密码,普通用户只能更改自己的密码</p>
<h4 id="who命令"><a href="#who命令" class="headerlink" title="who命令"></a>who命令</h4><p>命令名称: who<br>命令所在路径: /usr/bin/who<br>执行权限: 所有用户<br>语法: who<br>功能描述: 查看登录用户信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">登录用户名 登录终端(tty本地终端,pts远程终端) 登录时间 登录ip</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/30/FzxVm3KoPpfQLXJ.png" alt=""></p>
<h4 id="w命令"><a href="#w命令" class="headerlink" title="w命令"></a>w命令</h4><p>命令名称: w<br>命令所在路径: /usr/bin/w<br>执行权限: 所有用户<br>语法: w<br>功能描述: 查看登录用户详细信息(比who更详细)</p>
<p><img src="https://i.loli.net/2021/01/30/CF9i24xHXTBqMKs.png" alt=""></p>
<h3 id="压缩解压命令"><a href="#压缩解压命令" class="headerlink" title="压缩解压命令"></a>压缩解压命令</h3><h4 id="du命令"><a href="#du命令" class="headerlink" title="du命令"></a>du命令</h4><p>命令名称: du<br>命令英文原意: disk usage<br>命令所在路径: /usr/bin/du<br>执行权限: 所有用户<br>语法: du [文件或目录] -h<br>    -h  以K,M,G为单位,提高信息的可读性<br>    -s  仅显示每个参数的总计<br>功能描述: 显示文件或目录的大小</p>
<h4 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h4><p>命令名称: tar<br>命令所在路径: /bin/tar<br>执行权限:所有用户<br>语法: tar 选项[-cvf] 打包文件 源文件(可以有多个源文件,只打包解包不压缩)<br>    -c  创建tar包<br>    -x  解tar包<br>    -v  显示详细信息(进度)<br>    -f  备份文件(f必须放在后面)<br>    -C  解包到指定路径<br>    -z  压缩为.gz文件(将.gz文件解压)<br>    -j   压缩为.bz2文件(将.bz2文件解压)<br>功能描述: 归档管理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -cvf xxx.tar 1.c 2.c 3.c    &#x2F;&#x2F;将1.c,2.c,3.c打包至tar文件(* 全部打包)</span><br><span class="line">tar -xvf xxx.tar -C 路径    &#x2F;&#x2F;指定目录解包,不指定路径,默认在当前路径解包</span><br><span class="line">tar -czvf xxx.tar.gz 1.c 2.c   &#x2F;&#x2F;打包同时压缩为.gz文件</span><br><span class="line">tar -xzvf xxx.tar.gz      &#x2F;&#x2F;解压并解包</span><br><span class="line">tar -cjvf xxx.tar.bz2 1.c 2.c   &#x2F;&#x2F;打包同时压缩为.bz2文件</span><br><span class="line">tar -xjvf xxx.tar.bz2      &#x2F;&#x2F;解压并解包</span><br></pre></td></tr></table></figure>
<h4 id="gzip命令"><a href="#gzip命令" class="headerlink" title="gzip命令"></a>gzip命令</h4><p>命令名称: gzip<br>命令英文原意: GNU zip<br>命令所在路径: /bin/gzip<br>执行权限: 所有用户<br>语法: gzip [文件]<br>功能描述: 压缩文件(自动生成.gz文件,且不保留源文件)<br>    -d  解压文件<br>    -r  压缩所有子目录中文件(不能压缩目录)<br>压缩后文件格式: .gz</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip -r 目录(假设为test) &#x2F;&#x2F;将test目录及其子目录下所有文件压缩为.gz文件</span><br><span class="line">gzip -d -r 目录(假设为test) &#x2F;&#x2F;将test目录及其子目录下所有文件解压</span><br></pre></td></tr></table></figure>
<h4 id="gunzip命令"><a href="#gunzip命令" class="headerlink" title="gunzip命令"></a>gunzip命令</h4><p>命令名称: gunzip<br>命令英文原意: GNU unzip<br>命令所在路径: /bin/gunzip<br>执行权限: 所有用户<br>语法: gunzip [压缩文件]<br>功能描述: 解压.gz的压缩文件</p>
<h4 id="bzip2命令"><a href="#bzip2命令" class="headerlink" title="bzip2命令"></a>bzip2命令</h4><p>命令名称: bzip2<br>命令所在路径: /usr/bin/bzip2<br>执行权限: 所有用户<br>语法: bzip2 [文件]<br>功能描述: 压缩文件(自动生成.bz2文件,且不保留源文件,不能压缩目录,没有-r选项)<br>    -d  解压文件<br>    -k  产生压缩文件后保留源文件<br>压缩后文件格式: .bz2</p>
<h4 id="bunzip2命令"><a href="#bunzip2命令" class="headerlink" title="bunzip2命令"></a>bunzip2命令</h4><p>命令名称: bunzip2<br>命令所在路径: /usr/bin/bunzip2<br>执行权限: 所有用户<br>语法: bunzip2 选项[-k] [压缩文件]<br>    -k  解压后保留原文件<br>功能描述: 解压.bz2文件</p>
<h4 id="zip命令"><a href="#zip命令" class="headerlink" title="zip命令"></a>zip命令</h4><p>命令名称: zip<br>命令所在路径: /usr/bin/zip<br>执行权限: 所有用户<br>语法: zip 选项[-r] [压缩后文件名] [文件或目录]<br>    -r  压缩目录<br>功能描述: 压缩文件或目录(能保留源文件)<br>压缩后文件格式: .zip</p>
<h4 id="unzip命令"><a href="#unzip命令" class="headerlink" title="unzip命令"></a>unzip命令</h4><p>命令名称: unzip<br>命令所在路径: /usr/bin/unzip<br>执行权限: 所有用户<br>语法: unzip [压缩文件]<br>功能描述: 解压.zip的压缩文件</p>
<h3 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h3><h4 id="write命令"><a href="#write命令" class="headerlink" title="write命令"></a>write命令</h4><p>命令名称: write<br>命令所在路径: /usr/bin/write<br>执行权限: 所有用户<br>语法: write &lt;用户名&gt;<br>功能描述: 给指定在线用户发信息,以Ctrl+D保存结束</p>
<h4 id="wall命令"><a href="#wall命令" class="headerlink" title="wall命令"></a>wall命令</h4><p>命令名称: wall<br>命令英文原意: write all<br>命令所在路径: /usr/bin/yvall<br>执行权限: 所有用户<br>语法: wall [message]<br>功能描述: 发广播信息(给所有在线用户发送)</p>
<h4 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h4><p>命令名称: ping<br>命令所在路径: /bin/ping<br>执行权限: 所有用户<br>语法: ping 选项 IP地址<br>    -c  指定发送次数<br>功能描述: 测试网络连通性<br>范例: ping -c 3 ip地址  //ping三次</p>
<h4 id="ifconfig命令"><a href="#ifconfig命令" class="headerlink" title="ifconfig命令"></a>ifconfig命令</h4><p>命令名称: ifconfig<br>命令英文原意: interface configure<br>命令所在路径: /sbin/ifconfig<br>执行权限: root<br>语法: ifconfig 网卡名称 IP地址<br>功能描述:查看和设置网卡信息<br>范例: #ifconfig eth0 192.168.8.250</p>
<h4 id="mail-命令"><a href="#mail-命令" class="headerlink" title="mail 命令"></a>mail 命令</h4><p>命令名称: mail<br>命令所在路径: /bin/mail<br>执行权限: 所有用户<br>语法: mail [用户名]<br>功能描述: 查看发送电子邮件(以Ctrl+D保存结束)(查看邮件时直接使用mail,按q退出)</p>
<h4 id="last命令"><a href="#last命令" class="headerlink" title="last命令"></a>last命令</h4><p>命令名称: last<br>命令所在路径: /usr/bin/last<br>执行权限: 所有用户<br>语法: last<br>功能描述: 列出目前与过去登入系统的用户信息</p>
<h4 id="lastlog命令"><a href="#lastlog命令" class="headerlink" title="lastlog命令"></a>lastlog命令</h4><p>命令名称: lastlog<br>命令所在路径: /usr/bin/lastlog<br>执行权限: 所有用户<br>语法: lastlog<br>    -u 用户uid  查看指定用户登录<br>功能描述:检查某特定用户上次登录的时间</p>
<h4 id="traceroute命令"><a href="#traceroute命令" class="headerlink" title="traceroute命令"></a>traceroute命令</h4><p>命令名称: traceroute<br>命令所在路径: /bin/traceroute<br>执行权限: 所有用户<br>语法: traceroute<br>功能描述:显示数据包到主机间的路径</p>
<h4 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h4><p>命令名称: netstat<br>命令所在路径: /bin/netstat<br>执行权限: 所有用户<br>语法: netstat [选项]<br>    -a  全部信息<br>    -t  TCP协议<br>    -u  UDP协议<br>    -l  监听<br>    -r  路由(网关)<br>    -n  显示IP地址和端口号<br>功能描述: 显示网络相关信息<br>范例:<br>    netstat -tlun       查看本机监听的端口<br>    netstat -an          查看本机所有的网络连接<br>    netstat -rn           查看本机路由表</p>
<h4 id="setup命令-red-hat专有"><a href="#setup命令-red-hat专有" class="headerlink" title="setup命令(red hat专有)"></a>setup命令(red hat专有)</h4><p>命令名称: setup<br>命令所在路径: /usr/bin/setup<br>执行权限: root<br>语法: setup<br>功能描述:配置网络</p>
<h4 id="mount命令"><a href="#mount命令" class="headerlink" title="mount命令"></a>mount命令</h4><p>命令名称: mount<br>命令位置: /bin/mount<br>执行权限: 所有用户<br>命令语法: mount [-t 文件系统] 设备文件名 挂载点<br>功能描述: 挂载设备<br>范例: mount -t iso9660 /dev/sr0 /mnt/cdrom</p>
<h4 id="umount命令"><a href="#umount命令" class="headerlink" title="umount命令"></a>umount命令</h4><p>命令名称: umount<br>命令位置: /bin/umount<br>执行权限: 所有用户<br>命令语法: umount 设备文件名<br>功能描述: 卸载设备<br>范例: umount /dev/sr0</p>
<h3 id="关机重启命令"><a href="#关机重启命令" class="headerlink" title="关机重启命令"></a>关机重启命令</h3><h4 id="shutdown命令"><a href="#shutdown命令" class="headerlink" title="shutdown命令"></a>shutdown命令</h4><p>命令名称: shutdown<br>命令语法: shutdown [选项] 时间<br>    -c  取消前一个关机命令<br>    -h  关机<br>    -r  重启<br>功能描述: 关机重启<br>范例:<br>shutdown -h now   现在关机<br>shutdown -r 12:00   12:00重启<br>shutdown -c    取消前一个关机命令</p>
<h4 id="halt命令"><a href="#halt命令" class="headerlink" title="halt命令"></a>halt命令</h4><p>命令名称: halt<br>命令语法: halt<br>功能描述: 关机</p>
<h4 id="poweroff命令"><a href="#poweroff命令" class="headerlink" title="poweroff命令"></a>poweroff命令</h4><p>命令名称: poweroff<br>命令语法: poweroff<br>功能描述: 关机</p>
<p>相当于直接断电</p>
<h4 id="init-0命令"><a href="#init-0命令" class="headerlink" title="init 0命令"></a>init 0命令</h4><p>命令名称: init 0<br>命令语法: init 0<br>功能描述: 关机</p>
<h4 id="reboot命令"><a href="#reboot命令" class="headerlink" title="reboot命令"></a>reboot命令</h4><p>命令名称: reboot<br>命令语法: reboot<br>功能描述: 重启</p>
<h4 id="init-6命令"><a href="#init-6命令" class="headerlink" title="init 6命令"></a>init 6命令</h4><p>命令名称: init 6<br>命令语法: init 6<br>功能描述: 重启</p>
<h4 id="logout命令"><a href="#logout命令" class="headerlink" title="logout命令"></a>logout命令</h4><p>命令名称: logout<br>命令语法: logout<br>功能描述: 退出登录</p>
<h4 id="系统运行级别"><a href="#系统运行级别" class="headerlink" title="系统运行级别"></a>系统运行级别</h4><p>0  关机<br>1  单用户(root用户,与windows下安全模式类似,启动最少的核心程序进行修复)(无图形界面)<br>2  不完全多用户,不含NFS(网络文件系统)服务(NFS不太安全)(无图形界面)<br>3  完全多用户(无图形界面)<br>4  未分配<br>5  图形界面(X)<br>6  重启</p>
<h5 id="查看运行级别相关信息"><a href="#查看运行级别相关信息" class="headerlink" title="查看运行级别相关信息"></a>查看运行级别相关信息</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;inittab</span><br></pre></td></tr></table></figure>
<h5 id="查询系统当前运行级别"><a href="#查询系统当前运行级别" class="headerlink" title="查询系统当前运行级别"></a>查询系统当前运行级别</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">runlevel</span><br></pre></td></tr></table></figure>
<h2 id="文本编辑器Vim"><a href="#文本编辑器Vim" class="headerlink" title="文本编辑器Vim"></a>文本编辑器Vim</h2><p>Vim是一个功能强大的全屏幕文本编辑器,是Linux/UNIX上最常用的文本编辑器,它的作用是建立、编辑、显示文本文件.Vim没有菜单,只有命令.</p>
<p>Vim工作模式分为命令模式,插入模式和编辑模式.</p>
<h3 id="Vim常用命令"><a href="#Vim常用命令" class="headerlink" title="Vim常用命令"></a>Vim常用命令</h3><h4 id="插入命令"><a href="#插入命令" class="headerlink" title="插入命令"></a>插入命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>在光标所在字符后插入</td>
</tr>
<tr>
<td>A</td>
<td>在光标所在行行尾插入</td>
</tr>
<tr>
<td>i</td>
<td>在光标所在字符前插入</td>
</tr>
<tr>
<td>I</td>
<td>在光标所在行行首插入</td>
</tr>
<tr>
<td>o</td>
<td>在光标下插入新行</td>
</tr>
<tr>
<td>O</td>
<td>在光标上插入新行</td>
</tr>
</tbody>
</table>
</div>
<h4 id="定位命令"><a href="#定位命令" class="headerlink" title="定位命令"></a>定位命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>:set nu</td>
<td>设置行号</td>
</tr>
<tr>
<td>:set nonu</td>
<td>取消行号</td>
</tr>
<tr>
<td>gg<br />G</td>
<td>到第一行<br />到最后一行</td>
</tr>
<tr>
<td>nG</td>
<td>到第n行</td>
</tr>
<tr>
<td>:n</td>
<td>到第n行</td>
</tr>
<tr>
<td>$</td>
<td>移至行尾</td>
</tr>
<tr>
<td>0</td>
<td>移至行首</td>
</tr>
</tbody>
</table>
</div>
<h4 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>删除光标所在处字符</td>
</tr>
<tr>
<td>nx</td>
<td>删除光标所在处后n个字符</td>
</tr>
<tr>
<td>dd</td>
<td>删除光标所在行,ndd删除n行</td>
</tr>
<tr>
<td>dG</td>
<td>删除光标所在行到文件末尾内容</td>
</tr>
<tr>
<td>D</td>
<td>删除光标所在处到行尾内容</td>
</tr>
<tr>
<td>:x,yd</td>
<td>删除指定范围(x行到y行)的行</td>
</tr>
</tbody>
</table>
</div>
<h4 id="复制和剪切命令"><a href="#复制和剪切命令" class="headerlink" title="复制和剪切命令"></a>复制和剪切命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>yy</td>
<td>复制当前行</td>
</tr>
<tr>
<td>nyy</td>
<td>复制当前行(包括当前行)以下n行</td>
</tr>
<tr>
<td>dd</td>
<td>剪切当前行</td>
</tr>
<tr>
<td>ndd</td>
<td>剪切当前行(包括当前行)以下n行</td>
</tr>
<tr>
<td>p<br />P</td>
<td>粘贴在当前光标所在行下(p)<br />粘贴在当前光标所在行上(P)</td>
</tr>
</tbody>
</table>
</div>
<h4 id="替换和取消命令"><a href="#替换和取消命令" class="headerlink" title="替换和取消命令"></a>替换和取消命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>取代光标所在处字符</td>
</tr>
<tr>
<td>R</td>
<td>从光标所在处开始替换字符,按Esc结束</td>
</tr>
<tr>
<td>u</td>
<td>取消上一步操作</td>
</tr>
</tbody>
</table>
</div>
<h4 id="搜索和搜索替换命令"><a href="#搜索和搜索替换命令" class="headerlink" title="搜索和搜索替换命令"></a>搜索和搜索替换命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>/string</td>
<td>搜索指定字符串,搜索时忽略大小写:set ic(不忽略大小写:set noic)</td>
</tr>
<tr>
<td>n</td>
<td>搜索指定字符串的下一个出现位置</td>
</tr>
<tr>
<td>:%s/要被替换的字符串/新的字符串</td>
<td>全文替换指定字符串</td>
</tr>
<tr>
<td>:起始行,终止行s/要被替换的字符串/新的字符串</td>
<td>在一定范围内替换指定字符串</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:%s&#x2F;world&#x2F;世界&#x2F;g      &#x2F;&#x2F;在全文范围内,将world替换为世界(g表示不询问,c表示询问确认)</span><br><span class="line">:3,6s&#x2F;world&#x2F;世界&#x2F;c    &#x2F;&#x2F;在3到6行,将world替换为世界(&#x2F;g或&#x2F;c可加可不加)</span><br></pre></td></tr></table></figure>
<h4 id="保存和退出命令"><a href="#保存和退出命令" class="headerlink" title="保存和退出命令"></a>保存和退出命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>:w</td>
<td>保存修改</td>
</tr>
<tr>
<td>:w filename</td>
<td>另存为指定文件(可指定为某路径下的某文件)</td>
</tr>
<tr>
<td>:wq</td>
<td>保存修改并退出</td>
</tr>
<tr>
<td>ZZ</td>
<td>快捷键,保存修改并退出</td>
</tr>
<tr>
<td>:q!</td>
<td>不保存修改退出</td>
</tr>
<tr>
<td>:wq!</td>
<td>(只读文件强行保存)保存修改并退出(文件所有者及root可使用)</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Vim使用技巧"><a href="#Vim使用技巧" class="headerlink" title="Vim使用技巧"></a>Vim使用技巧</h3><h4 id="导入外部文件"><a href="#导入外部文件" class="headerlink" title="导入外部文件"></a>导入外部文件</h4><p>:r 文件位置   //导入文件到当前vim编辑的文件中</p>
<p><img src="https://i.loli.net/2021/01/31/THdxuBQmOfvpUSL.gif" alt=""></p>
<h4 id="不退出vim使用linux命令"><a href="#不退出vim使用linux命令" class="headerlink" title="不退出vim使用linux命令"></a>不退出vim使用linux命令</h4><p>:!命令      //不退出vim的情况下使用linux命令</p>
<p><img src="https://i.loli.net/2021/01/31/H71X9uAtVwZ5qkm.gif" alt=""></p>
<h4 id="将命令执行结果导入当前编辑文件"><a href="#将命令执行结果导入当前编辑文件" class="headerlink" title="将命令执行结果导入当前编辑文件"></a>将命令执行结果导入当前编辑文件</h4><p>:r !date(或其他命令)        //直接将date命令执行结果导入当前编辑文件   </p>
<p><img src="https://i.loli.net/2021/01/31/SNU56oP18fD3mrz.gif" alt=""></p>
<h4 id="自定义快捷键-单行注释"><a href="#自定义快捷键-单行注释" class="headerlink" title="自定义快捷键(单行注释)"></a>自定义快捷键(单行注释)</h4><p>:map 快捷键 触发命令   //自定义快捷键</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:map Ctrl+p I#&lt;ESC&gt;     &#x2F;&#x2F;将在首行(I)添加#并退出插入模式(ESC)设置为快捷键Ctrl+p</span><br><span class="line">:map Ctrl+b 0x          &#x2F;&#x2F;将光标移至行首并删除行首字符设置为快捷键Ctrl+b</span><br></pre></td></tr></table></figure>
<h4 id="连续行注释"><a href="#连续行注释" class="headerlink" title="连续行注释"></a>连续行注释</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:2,5s&#x2F;^&#x2F;#&#x2F;g        &#x2F;&#x2F;(类似于前面的替换)将2至5行的行首(^)增加#(g表示不询问)</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/31/yZJ6P3qH5NMKYef.gif" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:2,5s&#x2F;#&#x2F;&#x2F;g         &#x2F;&#x2F;将2至5行中所有#删除</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/31/n6IDdh45UkPYMgF.gif" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:2,5s&#x2F;^#&#x2F;&#x2F;g         &#x2F;&#x2F;将2至5行的行首的所有#删除</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/31/K9jXRYPFkE5VTJ2.gif" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:2,5s&#x2F;^&#x2F;\&#x2F;\&#x2F;&#x2F;g     &#x2F;&#x2F;将2至5行的行首添加双斜杠(&#x2F;&#x2F;),其中\&#x2F;代表一个斜杠(转义)</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/31/FYnkzh5iDVHycZK.gif" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:2,5s&#x2F;^\&#x2F;\&#x2F;&#x2F;&#x2F;g    &#x2F;&#x2F;将2至5行的行首的双斜杠(&#x2F;&#x2F;)删除</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/31/2itGncOdUS965N3.gif" alt=""></p>
<h4 id="文本替换"><a href="#文本替换" class="headerlink" title="文本替换"></a>文本替换</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ab mymail 5201314@qq.com   &#x2F;&#x2F;在文件中输入mymail,空格或回车后会自动替换为5201314@qq.com </span><br></pre></td></tr></table></figure>
<h2 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h2><h3 id="软件包管理简介"><a href="#软件包管理简介" class="headerlink" title="软件包管理简介"></a>软件包管理简介</h3><h4 id="软件包分类"><a href="#软件包分类" class="headerlink" title="软件包分类"></a>软件包分类</h4><ul>
<li>源码包(绝大多数是C语言)<ol>
<li>脚本安装包</li>
</ol>
</li>
<li>经过编译后的二进制包(RPM包,系统默认包)(现在更常用)</li>
</ul>
<h5 id="源码包"><a href="#源码包" class="headerlink" title="源码包"></a>源码包</h5><p>源码包的优点:</p>
<ul>
<li>开源,如果有足够的能力,可以修改源代码</li>
<li>可以自由选择所需的功能</li>
<li>软件是编译安装,所以更加适合自己的系统,更加稳定也效率更高</li>
<li>卸载方便(直接删除源码包)</li>
</ul>
<p>源码包的缺点:</p>
<ul>
<li>安装过程步骤较多,尤其安装较大的软件集合时( 如LAMP环境搭建),容易出现拼写错误</li>
<li>编译过程时间较长,安装比二进制包安装时间长</li>
<li>因为是编译安装,安装过程中一旦报错新手很难解决</li>
</ul>
<h5 id="二进制包"><a href="#二进制包" class="headerlink" title="二进制包"></a>二进制包</h5><p>二进制包的优点:</p>
<ul>
<li>包管理系统简单,只通过几个命令就可以实现包的安装、升级、查询和卸载</li>
<li>安装速度比源码包安装快的多</li>
</ul>
<p>二进制包的缺点:</p>
<ul>
<li>经过编译,不再可以看到源代码</li>
<li>功能选择不如源码包灵活</li>
<li>依赖性</li>
</ul>
<h3 id="RPM包管理"><a href="#RPM包管理" class="headerlink" title="RPM包管理"></a>RPM包管理</h3><h4 id="rpm命令管理"><a href="#rpm命令管理" class="headerlink" title="rpm命令管理"></a>rpm命令管理</h4><h5 id="包命名与依赖"><a href="#包命名与依赖" class="headerlink" title="包命名与依赖"></a>包命名与依赖</h5><h6 id="RPM包命名规则"><a href="#RPM包命名规则" class="headerlink" title="RPM包命名规则"></a>RPM包命名规则</h6><p>httpd-2.2.15-15.el6.centos.1.i686.rpm(包全名)<br>httpd          软件包名<br>2.2.15         软件版本<br>15                软件发布的次数<br>el6.centos  适合的Linux平台<br>i686             适合的硬件平台<br>rpm              rpm包扩展名</p>
<h6 id="RPM包依赖性"><a href="#RPM包依赖性" class="headerlink" title="RPM包依赖性"></a>RPM包依赖性</h6><ul>
<li>树形依赖: a-&gt;b-&gt;c</li>
<li>环形依赖: a-&gt;b-&gt;c-&gt;a(同时装即可)</li>
<li>模块依赖: <a href="https://www.rpmfind.net">模块依赖查询网站</a></li>
</ul>
<h5 id="安装升级与卸载"><a href="#安装升级与卸载" class="headerlink" title="安装升级与卸载"></a>安装升级与卸载</h5><h6 id="RPM包安装"><a href="#RPM包安装" class="headerlink" title="RPM包安装"></a>RPM包安装</h6><p>rpm -ivh 包全名</p>
<p>选项:<br>    -i (install)      安装<br>    -v (verbose)   显示详细信息<br>    -h (hash)        显示进度<br>    --nodeps        不检查依赖性</p>
<h6 id="RPM包升级"><a href="#RPM包升级" class="headerlink" title="RPM包升级"></a>RPM包升级</h6><p>rpm -Uvh 包全名</p>
<p>选项:<br>    -U (upgrade)      升级</p>
<h6 id="RPM包卸载"><a href="#RPM包卸载" class="headerlink" title="RPM包卸载"></a>RPM包卸载</h6><p>rpm -e 包名</p>
<p>选项:<br>    -e (erase)      卸载<br>    --nodeps       不检查依赖性</p>
<h5 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h5><h6 id="查询是否安装"><a href="#查询是否安装" class="headerlink" title="查询是否安装"></a>查询是否安装</h6><p>rpm -q 包名</p>
<p>选项:<br>    -q (query)      查询</p>
<p>rpm -qa</p>
<p>选项:<br>    -a (all)            全部</p>
<h6 id="查询软件包详细信息"><a href="#查询软件包详细信息" class="headerlink" title="查询软件包详细信息"></a>查询软件包详细信息</h6><p>rpm -qi 包名</p>
<p>选项:<br>    -i (information)      查询软件信息</p>
<p>rpm -qp 包全名</p>
<p>选项:<br>    -p (package)            查询未安装包信息 </p>
<h6 id="查询包中文件安装位置"><a href="#查询包中文件安装位置" class="headerlink" title="查询包中文件安装位置"></a>查询包中文件安装位置</h6><p>rpm -ql 包名</p>
<p>选项:<br>    -l (list)      查询文件安装位置列表</p>
<p>rpm -qlp 包全名</p>
<p>选项:<br>    -p (package)            查询未安装包的默认安装位置</p>
<h6 id="查询系统文件属于哪个RPM包"><a href="#查询系统文件属于哪个RPM包" class="headerlink" title="查询系统文件属于哪个RPM包"></a>查询系统文件属于哪个RPM包</h6><p>rpm -qf 系统文件名</p>
<p>选项:<br>    -f (file)            查询系统文件属于哪个RPM包</p>
<h6 id="查询软件包的依赖性"><a href="#查询软件包的依赖性" class="headerlink" title="查询软件包的依赖性"></a>查询软件包的依赖性</h6><p>rpm -q[p]R 包名[包全名]</p>
<p>选项:<br>    -R (requires)            查询软件包的依赖性<br>    -p (package)             查询未安装包的依赖性</p>
<h5 id="校验和文件提取"><a href="#校验和文件提取" class="headerlink" title="校验和文件提取"></a>校验和文件提取</h5><h6 id="RPM包校验"><a href="#RPM包校验" class="headerlink" title="RPM包校验"></a>RPM包校验</h6><p>判断系统文件是否更改</p>
<p>rpm -V 包名</p>
<p>选项:<br>    -V (verify)            校验指定RPM包中的文件</p>
<p>验证内容中的8个信息的具体内容如下:</p>
<ul>
<li>S  文件大小是否改变</li>
<li>M  文件的类型或文件的权限(rwx) 是否被改变</li>
<li>5    文件MD5校验和是否改变(可以看成文件内容是否<br>改变)</li>
<li>D  设备的主从代码是否改变</li>
<li>L  文件路径是否改变</li>
<li>U  文件的属主(所有者)是否改变</li>
<li>G  文件的属组是否改变</li>
<li>T  文件的修改时间是否改变</li>
</ul>
<p>文件类型:</p>
<ul>
<li>c  配置文件(config file)</li>
<li>d  普通文档(documentation)</li>
<li>g  “鬼”文件(ghost file),很少见,就是该文件不应该被这个RPM包包含</li>
<li>l  授权文件(license file)</li>
<li>r  描述文件(read me)</li>
</ul>
<h6 id="RPM包中文件提取"><a href="#RPM包中文件提取" class="headerlink" title="RPM包中文件提取"></a>RPM包中文件提取</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm2cpio 包全名 | \ cpio -idv .文件绝对路径</span><br></pre></td></tr></table></figure>
<p>“\\”代表一条命令没有输入完,(太长了)换行;”.”代表把指定路径的文件提取到当前路径下;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rmp2cpio &#x2F;mnt&#x2F;cdrom&#x2F;Package&#x2F;coreutils-8.4-19.el6.i686.rpm | cpio -idv .&#x2F;bin&#x2F;ls</span><br><span class="line">&#x2F;&#x2F;提取RPM包中ls命令到当前目录的&#x2F;bin&#x2F;ls下</span><br></pre></td></tr></table></figure>
<p>rpm2cpio     //将rpm包转换为cpio格式的命令</p>
<p>cpio    //是一个标准工具,它用于创建软件档案文件和从档案文件中提取文件</p>
<p>cpio 选项 &lt;[文件/设备]</p>
<p>选项:<br>    -i   copy-in模式,还原<br>    -d  还原时自动新建目录<br>    -v  显示还原过程<br>    &lt;    输入重定向</p>
<h4 id="yum在线管理"><a href="#yum在线管理" class="headerlink" title="yum在线管理"></a>yum在线管理</h4><h5 id="网络yum源"><a href="#网络yum源" class="headerlink" title="网络yum源"></a>网络yum源</h5><ul>
<li>[base]    容器名称,一定要放在[]中</li>
<li>name    容器说明,可以自己随便写</li>
<li>mirrorlist    镜像站点,这个可以注释掉</li>
<li>baseurl    yum源服务器的地址(为http)</li>
<li>enabled    此容器是否生效,如果不写或写成enable=1都是生效,写成enable=0就是不生效</li>
<li>gpgcheck    如果是1则指RPM的数字证书生效,如果是0则不生效</li>
<li>gpgkey    数字证书的公钥文件保存位置.不用修改</li>
</ul>
<h5 id="yum命令"><a href="#yum命令" class="headerlink" title="yum命令"></a>yum命令</h5><h6 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum list           &#x2F;&#x2F;查询所有可用软件包列表</span><br><span class="line">yum search 关键字   &#x2F;&#x2F;搜索服务器上所有和关键字相关的包</span><br></pre></td></tr></table></figure>
<h6 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install 包名</span><br></pre></td></tr></table></figure>
<p>选项:<br>    -y  自动回答yes</p>
<h6 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y update 包名   &#x2F;&#x2F;不加包名时,升级所有软件包(包括linux内核,linux内核升级完成后需要在本地做一定的配置才能正常使用)</span><br></pre></td></tr></table></figure>
<h6 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y remove 包名</span><br></pre></td></tr></table></figure>
<p>尽量不卸载</p>
<h6 id="yum软件组管理命令"><a href="#yum软件组管理命令" class="headerlink" title="yum软件组管理命令"></a>yum软件组管理命令</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum grouplist             &#x2F;&#x2F;列出所有可用的软件组列表</span><br><span class="line">yum groupinstall 软件组名  &#x2F;&#x2F;安装指定软件组,组名可以由group1ist查询出来(如果组名有空格,用双引号括起来)</span><br><span class="line">yum groupremove 软件组名   &#x2F;&#x2F;卸载指定软件组</span><br></pre></td></tr></table></figure>
<h5 id="光盘yum源搭建"><a href="#光盘yum源搭建" class="headerlink" title="光盘yum源搭建"></a>光盘yum源搭建</h5><p>1.挂载光盘</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount &#x2F;dev&#x2F;cdrom &#x2F;mnt&#x2F;cdrom</span><br></pre></td></tr></table></figure>
<p>2.让网络yum源文件失效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;etc&#x2F;yum&#x2F;repos.d&#x2F;</span><br><span class="line">将yum源文件(除了Centos-Meidia.repo)中改为enable&#x3D;0;或者将它们改名</span><br></pre></td></tr></table></figure>
<p>3.修改光盘yum源文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim Centos-Meidia.repo</span><br><span class="line">将baseurl&#x3D;http:&#x2F;&#x2F;修改baseurl&#x3D;file:&#x2F;&#x2F;光盘挂载的绝对路径</span><br><span class="line">注释多余的file:&#x2F;&#x2F;&#x2F;路径(不存在的地址)</span><br><span class="line">设置enable&#x3D;1</span><br></pre></td></tr></table></figure>
<h3 id="源码包管理"><a href="#源码包管理" class="headerlink" title="源码包管理"></a>源码包管理</h3><h4 id="源码包和RPM包的区别"><a href="#源码包和RPM包的区别" class="headerlink" title="源码包和RPM包的区别"></a>源码包和RPM包的区别</h4><ul>
<li>安装之前的区别: 概念上的区别</li>
<li>安装之后的区别: 安装位置不同</li>
</ul>
<h5 id="RPM包安装位置"><a href="#RPM包安装位置" class="headerlink" title="RPM包安装位置"></a>RPM包安装位置</h5><p>默认安装路径(绝大多数):</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>路径</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>/etc/</td>
<td>配置文件安装目录</td>
</tr>
<tr>
<td>/usr/bin/</td>
<td>可执行的命令安装目录</td>
</tr>
<tr>
<td>/usr/lib/</td>
<td>程序所使用的函数库保存位置</td>
</tr>
<tr>
<td>/usr/share/doc/</td>
<td>基本的软件使用手册保存位置</td>
</tr>
<tr>
<td>/usr/share/man/</td>
<td>帮助文件保存位置</td>
</tr>
</tbody>
</table>
</div>
<h5 id="源码包安装位置"><a href="#源码包安装位置" class="headerlink" title="源码包安装位置"></a>源码包安装位置</h5><p>安装在指定位置当中,一般是/usr/loca1/软件名/</p>
<h5 id="安装位置不同带来的影响"><a href="#安装位置不同带来的影响" class="headerlink" title="安装位置不同带来的影响"></a>安装位置不同带来的影响</h5><p>RPM包安装的服务可以使用系统服务管理命令(service)来管理,例如RPM包安装的apache的启动方法是:</p>
<ol>
<li>/etc/rc.d/init.d/httpd start    (方法1)</li>
<li>service httpd start    (方法2)</li>
</ol>
<p>而源码包安装的服务则不能被服务管理命令管理,因为没有安装到默认路径中.所以只能用绝对路径进行服务的管理,如:</p>
<ul>
<li>/usr/1oca1/apache2/bin/apachectl start</li>
</ul>
<h4 id="源码包安装过程"><a href="#源码包安装过程" class="headerlink" title="源码包安装过程"></a>源码包安装过程</h4><p>RPM包安装和源码包安装并不冲突(以apache为例)</p>
<h5 id="1-安装准备"><a href="#1-安装准备" class="headerlink" title="1.安装准备"></a>1.安装准备</h5><ol>
<li>安装gcc编译器</li>
<li>下载源码包</li>
</ol>
<h5 id="2-安装注意事项"><a href="#2-安装注意事项" class="headerlink" title="2.安装注意事项"></a>2.安装注意事项</h5><ul>
<li>源代码保存位置: /usr/local/src/</li>
<li>软件安装位置: /usr/local/</li>
<li>如何确定安装过程报错:<ul>
<li>安装过程停止</li>
<li>并出现error、warning或no的提示</li>
</ul>
</li>
</ul>
<h5 id="3-源码包安装过程"><a href="#3-源码包安装过程" class="headerlink" title="3.源码包安装过程"></a>3.源码包安装过程</h5><ol>
<li><p>解压下载的源码包</p>
</li>
<li><p>进入解压目录(INSTALL是安装说明,README是使用说明)</p>
</li>
<li><p>./configure —prefix=/usr/local/apache2(指定安装路径)</p>
<p>./configure  软件配置与检查</p>
<ul>
<li>定义需要的功能选项</li>
<li>检测系统环境是否符合安装要求</li>
<li>把定义好的功能选项和检测系统环境的信息都写入Makefile文件,用于后续的编辑</li>
</ul>
</li>
<li><p>make    编译</p>
</li>
<li><p>make install   编译安装(向真正的安装目录写入数据)</p>
</li>
<li><p>/usr/1oca1/apache2/bin/apachectl start    启动</p>
</li>
</ol>
<p>./configure和make都不会向真正的指定安装位置写任何数据,如果这两步报错不用删除软件包,只需执行make clean,清空编译产生的临时文件</p>
<h4 id="源码包的卸载"><a href="#源码包的卸载" class="headerlink" title="源码包的卸载"></a>源码包的卸载</h4><p>不需要卸载命令,直接删除安装目录即可,不会遗留任何垃圾文件.</p>
<h3 id="脚本安装包"><a href="#脚本安装包" class="headerlink" title="脚本安装包"></a>脚本安装包</h3><h4 id="脚本安装包简介"><a href="#脚本安装包简介" class="headerlink" title="脚本安装包简介"></a>脚本安装包简介</h4><ul>
<li>脚本安装包并不是独立的软件包类型,常见安装的是源码包</li>
<li>是人为把安装过程写成了自动安装的脚本,只要执行脚本,定义简单的参数,就可以完成安装</li>
<li>非常类似于Windows下软件的安装方式</li>
<li>主要是安装驱动</li>
</ul>
<h4 id="脚本安装包安装过程"><a href="#脚本安装包安装过程" class="headerlink" title="脚本安装包安装过程"></a>脚本安装包安装过程</h4><ol>
<li>下载脚本安装包</li>
<li>解压脚本安装包</li>
<li>进入解压目录</li>
<li>./setup.sh</li>
<li>可能会询问一些可选的选项(回车-&gt;默认),Ctrl+退格删除输入错误的字符</li>
</ol>
<h2 id="用户和用户组管理"><a href="#用户和用户组管理" class="headerlink" title="用户和用户组管理"></a>用户和用户组管理</h2><h3 id="用户配置文件"><a href="#用户配置文件" class="headerlink" title="用户配置文件"></a>用户配置文件</h3><h4 id="用户管理简介"><a href="#用户管理简介" class="headerlink" title="用户管理简介"></a>用户管理简介</h4><ul>
<li>越是对安全性要求高的服务器,越需要建立合理的用户权限等级制度和服务器操作规范</li>
<li>在Linux中主要是通过用户配置文件来查看和修改用户信息</li>
</ul>
<h4 id="用户信息文件"><a href="#用户信息文件" class="headerlink" title="用户信息文件"></a>用户信息文件</h4><p>用户信息文件/etc/passwd(使用man 5 passwd查看[注意:是文件名而不是绝对路径])(用冒号分开),7个字段</p>
<ol>
<li>第1字段: 用户名称</li>
<li>第2字段: 密码标志(x表示有密码,否则只允许本机登录,禁用ssh)</li>
<li><p>第3字段: UID (用户ID)</p>
<ul>
<li>0: 超级用户</li>
<li>1-499:系统用户(伪用户,不能登录,不能删除)</li>
<li>500-65535:普通用户</li>
</ul>
</li>
<li>第4字段: GID (用户初始组ID)</li>
<li>第5字段: 用户说明(备注)</li>
<li>第6字段: 家目录<ul>
<li>普通用户: /home/用户名/</li>
<li>超级用户: /root/</li>
</ul>
</li>
<li>第7字段: 登录之后的Shell</li>
</ol>
<h5 id="初始组和附加组"><a href="#初始组和附加组" class="headerlink" title="初始组和附加组"></a>初始组和附加组</h5><ul>
<li>初始组:就是指用户一登录就立刻拥有这个用户组的相关权限,每个用户的初始组必须有且只能有一个,一般就是和这个用户的用户名相同的组名作为这个用户的初始组</li>
<li>附加组:指用户可以加入多个其他的用户组,并拥有这些组的权限,附加组可以有多个</li>
</ul>
<h4 id="用户密码文件-影子文件"><a href="#用户密码文件-影子文件" class="headerlink" title="用户密码文件(影子文件)"></a>用户密码文件(影子文件)</h4><p>影子文件/etc/shadow(权限为000)(用冒号分隔),9个字段</p>
<ol>
<li>第1字段: 用户名称</li>
<li>第2字段: 加密密码<ul>
<li>加密算法升级为SHA512散列加密算法</li>
<li>如果密码位是”!!”或”*“代表没有密码,不能登录</li>
</ul>
</li>
<li><p>第3字段: 密码最后一次修改日期</p>
<ul>
<li>使用1970年1月1日作为标准时间,每过一天时间戳加1</li>
</ul>
</li>
<li>第4字段: 两次密码的修改间隔时间(和第3字段相比)(多少天后密码才能修改)</li>
<li>第5字段: 密码有效期(和第3字段相比)</li>
<li>第6字段: 密码修改到期前的警告天数(和第5字段相比)</li>
<li>第7字段: 密码过期后的宽限天数(和第5字段相比)(如果不改会禁止登陆)<ul>
<li>0: 代表密码过期后立即失效</li>
<li>-1: 代表密码永远不会失效</li>
</ul>
</li>
<li>第8字段: 账号失效时间<ul>
<li>要用时间戳表示</li>
</ul>
</li>
<li>第9字段: 保留</li>
</ol>
<h5 id="时间戳换算"><a href="#时间戳换算" class="headerlink" title="时间戳换算"></a>时间戳换算</h5><p>把时间戳换算为日期:</p>
<ul>
<li>date -d “1970-01-01 时间戳 days”</li>
</ul>
<p>把日期换算为时间戳:</p>
<ul>
<li>echo $(($(date —date=”日期” +%s)/86400+1))</li>
</ul>
<h4 id="组信息文件"><a href="#组信息文件" class="headerlink" title="组信息文件"></a>组信息文件</h4><p>组信息文件/etc/group,4个字段</p>
<ol>
<li>第1字段: 组名称</li>
<li>第2字段: 组密码标志(x)</li>
<li><p>第3字段: GID (初始组ID)</p>
</li>
<li><p>第4字段: 组中附加用户</p>
</li>
</ol>
<h4 id="组密码文件"><a href="#组密码文件" class="headerlink" title="组密码文件"></a>组密码文件</h4><p>组密码文件/etc/gshadow,4个字段</p>
<ol>
<li>第1字段: 组名称</li>
<li>第2字段: 组密码</li>
<li>第3字段: 组管理员用户名</li>
<li>第4字段: 组中附加用户</li>
</ol>
<h3 id="用户管理相关文件"><a href="#用户管理相关文件" class="headerlink" title="用户管理相关文件"></a>用户管理相关文件</h3><h4 id="用户家目录"><a href="#用户家目录" class="headerlink" title="用户家目录"></a>用户家目录</h4><ul>
<li>普通用户: /home/用户名/,所有者和所属组都是此用户,权限是700</li>
<li>超级用户: /root/, 所有者和所属组都是root用户,权限是550</li>
</ul>
<p>把普通用户变为超级用户可以修改UID,但家目录保持不变</p>
<h4 id="用户邮箱"><a href="#用户邮箱" class="headerlink" title="用户邮箱"></a>用户邮箱</h4><p>/var/spool/mail/用户名/</p>
<h4 id="用户模板目录"><a href="#用户模板目录" class="headerlink" title="用户模板目录"></a>用户模板目录</h4><p>/etc/skel/</p>
<p>创建新用户时,新用户家目录会包含这些模板</p>
<h3 id="用户管理命令-1"><a href="#用户管理命令-1" class="headerlink" title="用户管理命令"></a>用户管理命令</h3><h4 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h4><p>useradd [选项] 用户名</p>
<p>选项:<br>    -u UID               添加用户并指定用户的UID号<br>    -d 家目录          添加用户并指定用户的家目录<br>    -c 用户说明      添加用户并指定用户的说明<br>    -g 组名              添加用户并指定用户的初始组<br>    -G 组名             添加用户并指定用户的附加组(指定多个附加组用逗号分隔)<br>    -s shell              添加用户并指定用户的登录shell,默认是/bin/bash</p>
<h5 id="用户默认值文件"><a href="#用户默认值文件" class="headerlink" title="用户默认值文件"></a>用户默认值文件</h5><p>/etc/default/useradd</p>
<ul>
<li>GROUP=100            #用户默认组</li>
<li>HOME=/home        #用户家目录</li>
<li>INACTIVE=-1          #密码过期宽限天数(shadow文件第7字段)</li>
<li>EXPIRE=                   #密码失效时间(shadow文件第8字段)</li>
<li>SHELL=/bin/bash    #默认shell</li>
<li>SKEL=/etc/skel         #模板目录</li>
<li>CREATE_MAIL_SPOOL=yes    #是否建立邮箱</li>
</ul>
<p>/etc/login.defs</p>
<ul>
<li>PASS_MAX_DAYS 99999              #密码有效期(5)</li>
<li>PASS_MIN_DAYS 0                        #密码修改间隔(4)</li>
<li>PASS_MIN_LEN 5                          #密码最小5位(PAM)</li>
<li>PASS_WARN_AGE 7                      #密码到期警告(6)</li>
<li>UID_MIN        500                          #最小UID范围</li>
<li>GID_MAX      60000                       #最大UID范围</li>
<li>ENCRYPT_METHOD SHA512    #密码加密模式</li>
</ul>
<h4 id="修改用户密码"><a href="#修改用户密码" class="headerlink" title="修改用户密码"></a>修改用户密码</h4><p>passwd [选项] 用户名</p>
<p>选项:<br>    -S  查询用户密码的密码状态,仅root用户可用<br>    -l  暂时锁定用户,仅root用户可用(实际是在/etc/shadow中加密密码前添加!!)<br>    -u  解锁用户,仅root用户可用<br>    --stdin  可以通过管道符输出的数据作为用户的密码</p>
<p>root和普通用户可以使用passwd修改自己的密码,root也可以修改其他用户的密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;123&quot; | passwd --stdin user   &#x2F;&#x2F;将123作为用户user的密码</span><br></pre></td></tr></table></figure>
<h4 id="修改用户信息"><a href="#修改用户信息" class="headerlink" title="修改用户信息"></a>修改用户信息</h4><p>usermod [选项] 用户名</p>
<p>选项:<br>    -u UID               手工修改已存在用户的UID号<br>    -d 家目录          手工修改已存在用户的家目录<br>    -c 用户说明      手工修改已存在用户的说明<br>    -g 组名              手工修改已存在用户的初始组<br>    -G 组名             手工修改已存在用户的附加组(指定多个附加组用逗号分隔)<br>    -s shell              手工修改已存在用户的登录shell,默认是/bin/bash<br>    -L                       临时锁定已存在用户(Lock)<br>    -U                       解锁已存在用户锁定(Unlock)</p>
<p>usermod语法与useradd基本类似,usermod是修改已存在用户的信息,而useradd是添加一个新用户并修改相关信息(/etc/passwd)</p>
<h4 id="修改用户密码状态"><a href="#修改用户密码状态" class="headerlink" title="修改用户密码状态"></a>修改用户密码状态</h4><p>chage [选项] 用户名</p>
<p>选项:<br>    -l                   列出用户的详细密码状态<br>    -d 日期         修改密码最后一次更改日期(shadow3字段)<br>    -m 天数        两次密码修改间隔(4字段)<br>    -M 天数        密码有效期(5字段)<br>    -W 天数        密码过期前警告天数(6字段)<br>    -I 天数           密码过后宽限天数(7字段)<br>    -E 日期          账号失效时间(8字段)</p>
<p>(修改的是/etc/shadow)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chage -d 0 user   &#x2F;&#x2F;user登录后要求修改密码</span><br></pre></td></tr></table></figure>
<h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><p>userdel [-r] 用户名</p>
<p>选项:<br>    -r        删除用户的同时删除用户家目录</p>
<p>手工删除用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">手工删除用户user</span><br><span class="line">vi &#x2F;etc&#x2F;passwd    前4条命令是删除文件中与user相关的语句</span><br><span class="line">vi &#x2F;etc&#x2F;shadow</span><br><span class="line">vi &#x2F;etc&#x2F;group</span><br><span class="line">vi &#x2F;etc&#x2F;gshadow</span><br><span class="line">rm -rf &#x2F;var&#x2F;spool&#x2F;mail&#x2F;user</span><br><span class="line">rm -rf &#x2F;home&#x2F;user&#x2F;</span><br></pre></td></tr></table></figure>
<h4 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h4><p>su [选项] 用户名</p>
<p>选项:<br>    -                       选项只使用”-“代表连带用户的环境变量一起切换(这个不能省)<br>    -c 命令            仅执行一次命令,而不切换用户身份</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su -root -c &quot;useradd user&quot;  &#x2F;&#x2F;不切换成root,但是借助root执行useradd命令添加user用户</span><br></pre></td></tr></table></figure>
<h4 id="查看用户ID"><a href="#查看用户ID" class="headerlink" title="查看用户ID"></a>查看用户ID</h4><p>id 用户名</p>
<p>uid(用户id),gid(初始组id),group(附加组id)</p>
<h3 id="用户组管理命令"><a href="#用户组管理命令" class="headerlink" title="用户组管理命令"></a>用户组管理命令</h3><h4 id="添加用户组"><a href="#添加用户组" class="headerlink" title="添加用户组"></a>添加用户组</h4><p>groupadd [选项] 组名</p>
<p>选项:<br>    -g GID        指定组id(不加默认从500依次往后排)</p>
<h4 id="修改用户组"><a href="#修改用户组" class="headerlink" title="修改用户组"></a>修改用户组</h4><p>groupmod  [选项] 组名</p>
<p>选项:<br>    -g GID                           修改已存在组的组id<br>    -n 新组名 老组名        修改组名</p>
<h4 id="删除用户组"><a href="#删除用户组" class="headerlink" title="删除用户组"></a>删除用户组</h4><p>groupdel 组名</p>
<p>组中有初始用户则不能删除(必须先删除初始用户再删除组),组中只有附加用户则可以删除</p>
<h4 id="把用户添加入组或从组中删除"><a href="#把用户添加入组或从组中删除" class="headerlink" title="把用户添加入组或从组中删除"></a>把用户添加入组或从组中删除</h4><p>gpasswd 选项 组名</p>
<p>选项:<br>    -a 用户名      把用户加入组(附加用户)<br>    -d 用户名      把用户从组中删除</p>
<h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><h3 id="ACL权限"><a href="#ACL权限" class="headerlink" title="ACL权限"></a>ACL权限</h3><p>任何文件只能有一个所属组;当所有者,所属组,其他人身份不够用时,要用到ACL权限给用户分配权限</p>
<h4 id="ACL权限简介与开启"><a href="#ACL权限简介与开启" class="headerlink" title="ACL权限简介与开启"></a>ACL权限简介与开启</h4><h5 id="查看分区是否支持ACL权限"><a href="#查看分区是否支持ACL权限" class="headerlink" title="查看分区是否支持ACL权限"></a>查看分区是否支持ACL权限</h5><p>默认都支持,保险起见查一下</p>
<p>dumpe2fs -h 分区</p>
<h1 id="dumpe2fs命令是查询指定分区详细文件系统信息的命令-使用df-h查看分区信息-查看Default-mount-options处是否支持ACL"><a href="#dumpe2fs命令是查询指定分区详细文件系统信息的命令-使用df-h查看分区信息-查看Default-mount-options处是否支持ACL" class="headerlink" title="dumpe2fs命令是查询指定分区详细文件系统信息的命令(使用df -h查看分区信息),查看Default mount options处是否支持ACL"></a>dumpe2fs命令是查询指定分区详细文件系统信息的命令(使用df -h查看分区信息),查看Default mount options处是否支持ACL</h1><p>选项:<br>    -h             仅显示超级块中信息,而不显示磁盘块组的详细信息</p>
<h5 id="临时开启分区ACL权限"><a href="#临时开启分区ACL权限" class="headerlink" title="临时开启分区ACL权限"></a>临时开启分区ACL权限</h5><p>mount -o remount,acl</p>
<h1 id="重新挂载根分区-并挂载加入acl权限-o表示支持特殊挂载选项-remount重新挂载"><a href="#重新挂载根分区-并挂载加入acl权限-o表示支持特殊挂载选项-remount重新挂载" class="headerlink" title="重新挂载根分区,并挂载加入acl权限(-o表示支持特殊挂载选项,remount重新挂载)"></a>重新挂载根分区,并挂载加入acl权限(-o表示支持特殊挂载选项,remount重新挂载)</h1><h5 id="永久开启分区ACL权限"><a href="#永久开启分区ACL权限" class="headerlink" title="永久开启分区ACL权限"></a>永久开启分区ACL权限</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;fstab    #(fstab是系统开机自动挂载文件,改这个文件要谨慎)在UUID的defaults后面添加&quot;,acl&quot;,保存并重启   </span><br><span class="line">#如果不重启,将根分区重新挂载</span><br><span class="line">mount -o remount &#x2F;      #将根分区重新挂载</span><br></pre></td></tr></table></figure>
<h4 id="查看与设定ACL权限"><a href="#查看与设定ACL权限" class="headerlink" title="查看与设定ACL权限"></a>查看与设定ACL权限</h4><h5 id="查看ACL权限"><a href="#查看ACL权限" class="headerlink" title="查看ACL权限"></a>查看ACL权限</h5><p>getfacl 文件名       #查看ACL权限(不支持绝对路径,但不影响执行)</p>
<h5 id="设定ACL权限"><a href="#设定ACL权限" class="headerlink" title="设定ACL权限"></a>设定ACL权限</h5><p>setfacl 选项 文件名</p>
<p>选项:<br>    -m          设定ACL权限<br>    -x            删除指定的ACL权限<br>    -b            删除所有的ACL权限<br>    -d            设定默认ACL权限<br>    -k            删除默认ACL权限<br>    -R           递归设定ACL权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setfacl -m u:用户名:权限 文件名或目录    #其中u代表用户,g代表组</span><br><span class="line">setfacl -m u:user:rx &#x2F;project&#x2F;</span><br></pre></td></tr></table></figure>
<p>用ll命令查看会多个加号</p>
<h4 id="最大有效权限与删除ACL权限"><a href="#最大有效权限与删除ACL权限" class="headerlink" title="最大有效权限与删除ACL权限"></a>最大有效权限与删除ACL权限</h4><h5 id="最大有效权限mask"><a href="#最大有效权限mask" class="headerlink" title="最大有效权限mask"></a>最大有效权限mask</h5><p>mask是用来指定最大有效权限的.如果给用户赋予了ACL权限,是需要和mask的权限“相与”才能得到用户的真正权限</p>
<p>以读权限(r)为例</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>and</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>r</td>
<td>r</td>
</tr>
<tr>
<td>r</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>-</td>
<td>r</td>
<td>-</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<h6 id="修改最大有效权限"><a href="#修改最大有效权限" class="headerlink" title="修改最大有效权限"></a>修改最大有效权限</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setfacl -m m:权限 文件名或目录  #m表示最大有效权限mask(修改后可能会多出#effective注释,代表实际权限)</span><br></pre></td></tr></table></figure>
<h5 id="删除ACL权限"><a href="#删除ACL权限" class="headerlink" title="删除ACL权限"></a>删除ACL权限</h5><p>方法一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setfacl -x u:用户名 文件名或目录     #删除指定用户的ACL权限</span><br><span class="line">setfacl -x g:组名 文件名或目录      #删除指定用户组的ACL权限</span><br></pre></td></tr></table></figure>
<p>方法二</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setfacl -b 文件名或目录      #删除所有的ACL权限</span><br></pre></td></tr></table></figure>
<h4 id="默认ACL权限与递归ACL权限"><a href="#默认ACL权限与递归ACL权限" class="headerlink" title="默认ACL权限与递归ACL权限"></a>默认ACL权限与递归ACL权限</h4><h5 id="默认ACL权限"><a href="#默认ACL权限" class="headerlink" title="默认ACL权限"></a>默认ACL权限</h5><ul>
<li>默认ACL权限的作用是如果给父目录设定了默认ACL权限,那么父目录中所有新建的子文件都会继承父目录的ACL权限</li>
<li>setfacl -m d:u:用户名:权限 目录  (d表示设定默认ACL权限)</li>
</ul>
<h5 id="递归ACL权限"><a href="#递归ACL权限" class="headerlink" title="递归ACL权限"></a>递归ACL权限</h5><ul>
<li>递归是父目录在设定ACL权限时,所有的子文件和子目录也会拥有相同的ACL权限</li>
<li>setfacl -m u:用户名:权限 -R 目录  </li>
</ul>
<h3 id="文件特殊权限"><a href="#文件特殊权限" class="headerlink" title="文件特殊权限"></a>文件特殊权限</h3><h4 id="SetUID"><a href="#SetUID" class="headerlink" title="SetUID"></a>SetUID</h4><h5 id="SetUID的功能"><a href="#SetUID的功能" class="headerlink" title="SetUID的功能"></a>SetUID的功能</h5><ul>
<li>只有可以执行的二进制程序才能设定SUID权限(才有意义)</li>
<li>命令执行者要对该程序拥有x(执行)权限</li>
<li>命令执行者在执行该程序时获得该程序文件属主的身份(在执行程序的过程中灵魂附体为文件的属主)</li>
<li>SetUID权限只在该程序执行过程中有效,也就是说身份改变只在程序执行过程中有效</li>
<li>在所有者(u)范围拥有s权限(超级用户)</li>
<li>passwd命令拥有SetUID权限,所以普通可以修改自己的密码</li>
<li>cat命令没有SetUID权限,所以普通用户不能查看/etc/shadow文件内容</li>
</ul>
<h5 id="设定SetUID的方法"><a href="#设定SetUID的方法" class="headerlink" title="设定SetUID的方法"></a>设定SetUID的方法</h5><ol>
<li>chmod 4755 文件名     #4代表SUID,2代表SGID,1代表SBIT</li>
<li>chmod u+s 文件名     </li>
</ol>
<p>如果命令执行者对该程序没有x(执行)权限,设定后的s权限为S(大写),此时SUID不能生效</p>
<h5 id="取消SetUID的方法"><a href="#取消SetUID的方法" class="headerlink" title="取消SetUID的方法"></a>取消SetUID的方法</h5><ol>
<li>chmod 755 文件名</li>
<li>chmod u-s 文件名</li>
</ol>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li>关键目录应严格控制写权限.比如”/“、”/usr”等</li>
<li>用户的密码设置要严格遵守密码三原则</li>
<li>对系统中默认应该具有SetUID权限的文件作一列表,定时检查有没有这之外的文件被设置了SetUID权限</li>
</ul>
<h4 id="SetGID"><a href="#SetGID" class="headerlink" title="SetGID"></a>SetGID</h4><p>在所属组(g)范围拥有s权限(locate具有SGID)</p>
<h5 id="SetGID针对文件的作用"><a href="#SetGID针对文件的作用" class="headerlink" title="SetGID针对文件的作用"></a>SetGID针对文件的作用</h5><ul>
<li>只有可执行的二进制程序才能设置SGID权限</li>
<li>命令执行者要对该程序拥有x(执行)权限</li>
<li>命令执行在执行程序的时候,组身份升级为该程序文件的属组</li>
<li>SetGID权限同样只在该程序执行过程中有效,也就是说组身份改变只在程序执行过程中有效</li>
</ul>
<h5 id="SetGID针对目录的作用"><a href="#SetGID针对目录的作用" class="headerlink" title="SetGID针对目录的作用"></a>SetGID针对目录的作用</h5><ul>
<li>普通用户必须对此目录拥有r和x权限,才能进入此目录</li>
<li>普通用户在此目录中的有效组会变成此目录的属组</li>
<li>若普通用户对此目录拥有w权限时,新建的文件的默认属组是这个目录的属组</li>
</ul>
<h5 id="设定SetGID"><a href="#设定SetGID" class="headerlink" title="设定SetGID"></a>设定SetGID</h5><ol>
<li>chmod 2755 文件名  (2代表SGID)</li>
<li>chmod g+s 文件名</li>
</ol>
<h5 id="取消SetGID的方法"><a href="#取消SetGID的方法" class="headerlink" title="取消SetGID的方法"></a>取消SetGID的方法</h5><ol>
<li>chmod 755 文件名</li>
<li>chmod g-s 文件名</li>
</ol>
<h4 id="Sticky-BIT"><a href="#Sticky-BIT" class="headerlink" title="Sticky BIT"></a>Sticky BIT</h4><p>在其他人范围拥有t权限(/tmp)</p>
<h5 id="SBIT粘着位作用"><a href="#SBIT粘着位作用" class="headerlink" title="SBIT粘着位作用"></a>SBIT粘着位作用</h5><ul>
<li>粘着位目前只对目录有效</li>
<li>普通用户对该目录拥有w和x权限,即普通用户可以在此目录拥有写入权限</li>
<li>如果没有粘着位,因为普通用户拥有w权限,所以可以删除此目录下所有文件,包括其他用户建立的文件.一但赋予了粘着位,除了root可以删除所有文件,普通用户就算拥有w权限,也只能删除自己建立的文件,但是不能删除其他用户建立的文件</li>
</ul>
<h5 id="设置粘着位"><a href="#设置粘着位" class="headerlink" title="设置粘着位"></a>设置粘着位</h5><ol>
<li>chmod 1755 目录名</li>
<li>chmod o+t 目录名</li>
</ol>
<h5 id="取消粘着位"><a href="#取消粘着位" class="headerlink" title="取消粘着位"></a>取消粘着位</h5><ol>
<li>chmod 755 目录名</li>
<li>chmod o-t 目录名</li>
</ol>
<h3 id="文件系统属性chattr权限"><a href="#文件系统属性chattr权限" class="headerlink" title="文件系统属性chattr权限"></a>文件系统属性chattr权限</h3><h4 id="chattr命令"><a href="#chattr命令" class="headerlink" title="chattr命令"></a>chattr命令</h4><p>chattr [+-=][选项] 文件或目录名   #对root用户也生效</p>
<ul>
<li>+        增加权限</li>
<li>-         删除权限</li>
<li>\=         赋予权限</li>
</ul>
<p>选项:</p>
<ul>
<li>i:如果对文件设置i属性,那么不允许对文件进行删除、改名,也不能添加和修改数据;如果对目录设置i属性,那么只能修改目录下文件的数据,但不允许建立和删除文件</li>
<li>a:如果对文件设置a属性,那么只能在文件中增加数据,但是不能删除也不能修改已有数据;如果对目录设置a属性,那么只允许在目录中建立和修改文件,但是不允许删除</li>
</ul>
<h4 id="查看文件系统属性"><a href="#查看文件系统属性" class="headerlink" title="查看文件系统属性"></a>查看文件系统属性</h4><p>lsattr 选项 文件名</p>
<p>选项:<br>    -a    显示所有文件和目录<br>    -d    若目标是目录,仅列出目录本身的属性,而不是子文件的</p>
<h3 id="系统命令sudo权限"><a href="#系统命令sudo权限" class="headerlink" title="系统命令sudo权限"></a>系统命令sudo权限</h3><h4 id="sudo权限"><a href="#sudo权限" class="headerlink" title="sudo权限"></a>sudo权限</h4><ul>
<li>root把本来只能超级用户执行的命令赋普通用户执行</li>
<li>sudo的操作对象是系统命令</li>
</ul>
<h4 id="sudo使用"><a href="#sudo使用" class="headerlink" title="sudo使用"></a>sudo使用</h4><h5 id="sudo赋予命令"><a href="#sudo赋予命令" class="headerlink" title="sudo赋予命令"></a>sudo赋予命令</h5><p>sudo的配置文档是/etc/sudoers ,我们能够用他的专用编辑工具visudo对其进行编辑 ,此工具的好处是在添加规则有误时,保存退出会提示给我们错误信息</p>
<p>[root@localhost ~ ]# visudo</p>
<h1 id="实际修改的是-etc-sudoers文件"><a href="#实际修改的是-etc-sudoers文件" class="headerlink" title="实际修改的是/etc/sudoers文件"></a>实际修改的是/etc/sudoers文件</h1><p>root    ALL=(ALL)   ALL </p>
<h1 id="用户名-被管理主机的地址-本机IP或ALL-可使用的身份-授权命令-绝对路径"><a href="#用户名-被管理主机的地址-本机IP或ALL-可使用的身份-授权命令-绝对路径" class="headerlink" title="用户名  被管理主机的地址(本机IP或ALL)=(可使用的身份)     授权命令    (绝对路径)"></a>用户名  被管理主机的地址(本机IP或ALL)=(可使用的身份)     授权命令    (绝对路径)</h1><h1 id="wheel-ALL-ALL-ALL"><a href="#wheel-ALL-ALL-ALL" class="headerlink" title="%wheel     ALL=(ALL)        ALL"></a>%wheel     ALL=(ALL)        ALL</h1><h1 id="组名-被管理主机的地址-可使用的身份-授权命令-绝对路径"><a href="#组名-被管理主机的地址-可使用的身份-授权命令-绝对路径" class="headerlink" title="%组名     被管理主机的地址= (可使用的身份)    授权命令   (绝对路径)"></a>%组名     被管理主机的地址= (可使用的身份)    授权命令   (绝对路径)</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~ ]#visudo      修改&#x2F;etc&#x2F;sudoers文件</span><br><span class="line">user ALL&#x3D;&#x2F;sbin&#x2F;shutdown -r now  授权user用户可以重启服务器</span><br></pre></td></tr></table></figure>
<h5 id="普通用户执行sudo赋予的命令"><a href="#普通用户执行sudo赋予的命令" class="headerlink" title="普通用户执行sudo赋予的命令"></a>普通用户执行sudo赋予的命令</h5><p>sudo -l         #查看可用的sudo命令</p>
<p>sudo /sbin/shutdown -r now         #sudo执行重启</p>
<h2 id="文件系统管理"><a href="#文件系统管理" class="headerlink" title="文件系统管理"></a>文件系统管理</h2><h3 id="分区与文件系统"><a href="#分区与文件系统" class="headerlink" title="分区与文件系统"></a>分区与文件系统</h3><h4 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h4><ul>
<li>主分区:总共最多只能分四个</li>
<li>扩展分区:只能有一个,也算作主分区的一种,也就是说主分区加扩展分区最多有四个.但是扩展分区不能存储数据和格式化,必须再划分成逻辑分区才能使用</li>
<li>逻辑分区:逻辑分区是在扩展分区中划分的,如果是IDE硬盘(hd),Linux最多持59个逻辑分区,如果是SCSI硬盘(sd)Linux最多支持11个逻辑分区</li>
</ul>
<h5 id="分区方法一"><a href="#分区方法一" class="headerlink" title="分区方法一"></a>分区方法一</h5><p><img src="https://i.loli.net/2021/02/02/3UKiabOH2JSjokI.png" alt=""></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>分区</th>
<th>设备文件名</th>
</tr>
</thead>
<tbody>
<tr>
<td>主分区1</td>
<td>/dev/sda1(a代表第一块硬盘)</td>
</tr>
<tr>
<td>主分区2</td>
<td>/dev/sda2</td>
</tr>
<tr>
<td>主分区3</td>
<td>/dev/sda3</td>
</tr>
<tr>
<td>拓展分区</td>
<td>/dev/sda4</td>
</tr>
<tr>
<td>逻辑分区1</td>
<td>/dev/sda5</td>
</tr>
<tr>
<td>逻辑分区2</td>
<td>/dev/sda6</td>
</tr>
<tr>
<td>逻辑分区3</td>
<td>/dev/sda7</td>
</tr>
</tbody>
</table>
</div>
<h5 id="分区方法二"><a href="#分区方法二" class="headerlink" title="分区方法二"></a>分区方法二</h5><p><img src="https://i.loli.net/2021/02/02/RMuzJQ6ODpsiecN.png" alt=""></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>分区</th>
<th>设备文件名</th>
</tr>
</thead>
<tbody>
<tr>
<td>主分区1</td>
<td>/dev/sda1</td>
</tr>
<tr>
<td>拓展分区</td>
<td>/dev/sda2</td>
</tr>
<tr>
<td>逻辑分区1</td>
<td>/dev/sda5</td>
</tr>
<tr>
<td>逻辑分区2</td>
<td>/dev/sda6</td>
</tr>
<tr>
<td>逻辑分区3</td>
<td>/dev/sda7</td>
</tr>
</tbody>
</table>
</div>
<h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><ul>
<li>ext2: 是ext文件系统的升级版本,Red Hat Linux7.2版本以前的系统默认都是ext2文件系统.最大支持16TB的分区和最大2TB的文件</li>
<li>ext3 : ext3文件系统是ext2文件系统的升级版本,最大的区别就是带日志功能,以便在系统突然停止时提高文件系统的可靠性.支持最大16TB的分区和最大2TB的文件</li>
<li>ext4: 它是ext3文件系统的升级版.ext4在性能、伸缩性和可靠性方面进行了大量改进.ext4的变化可以说是翻天覆地的,比如向下兼容ext3、最大1EB文件系统和16TB文件、无限数量子目录、Extents连续数据块概念、多块分配、延迟分配、持久预分配、快速FSCK、日志校验、无日志模式、在线碎片整理、inode增强、默认启用barrier等.是CentOS 6.3的默认文件系统.<br>(1EB=1024PB=1 024*1024TB )</li>
</ul>
<h3 id="文件系统常见命令"><a href="#文件系统常见命令" class="headerlink" title="文件系统常见命令"></a>文件系统常见命令</h3><h4 id="文件系统查看命令-df"><a href="#文件系统查看命令-df" class="headerlink" title="文件系统查看命令(df)"></a>文件系统查看命令(df)</h4><p>df [选项] [挂载点]</p>
<p>选项:<br>    -a    显示所有的文件系统信息,包括特殊文件系统,如/proc、/sysfs<br>    -h    使用习惯单位显示容量,如KB,MB或GB等<br>    -T    显示文件系统类型<br>    -m   以MB为单位显示容量<br>    -k    以KB为单位显示容量,默认就是以KB为单位</p>
<h4 id="统计目录或文件大小-du"><a href="#统计目录或文件大小-du" class="headerlink" title="统计目录或文件大小(du)"></a>统计目录或文件大小(du)</h4><p>du [选项] [目录或文件名]</p>
<p>选项:<br>    -a  显示每个子文件的磁盘占用量,默认只统计子目录的磁盘占用量<br>    -h  使用习惯单位显示磁盘占用量,如KB,MB或GB等<br>    -s   统计总占用量,而不列出子目录和子文件的占用量</p>
<p>统计文件大小一般用ls;统计目录大小用du命令,不要用ls命令</p>
<h4 id="df命令与du命令的区别"><a href="#df命令与du命令的区别" class="headerlink" title="df命令与du命令的区别"></a>df命令与du命令的区别</h4><ul>
<li>df命令是从文件系统考虑的,不光要考虑文件占用的空间,还要统计被命令或程序占用的空间(最常见的就是文件已经删除但是程序并没有释放空间)(df看到的一般比du大)(df更准确)</li>
<li>du命令是面向文件的,只会计算文件或目录占用的空间</li>
</ul>
<h4 id="文件系统修复命令-fsck"><a href="#文件系统修复命令-fsck" class="headerlink" title="文件系统修复命令(fsck)"></a>文件系统修复命令(fsck)</h4><p>fsck [选项] 分区设备文件名</p>
<p>选项:<br>    -a  不用显示用户提示,自动修复文件系统<br>    -y  自动修复,和-a作用一致,不过有些文件系统只支持-y</p>
<p>一般不需要手工执行</p>
<h4 id="显示磁盘状态命令-dump2fs"><a href="#显示磁盘状态命令-dump2fs" class="headerlink" title="显示磁盘状态命令(dump2fs)"></a>显示磁盘状态命令(dump2fs)</h4><p>dump2fs 分区设备名</p>
<p>可以查看硬盘的UUID</p>
<h4 id="挂载命令-mount"><a href="#挂载命令-mount" class="headerlink" title="挂载命令(mount)"></a>挂载命令(mount)</h4><h5 id="查询与自动挂载"><a href="#查询与自动挂载" class="headerlink" title="查询与自动挂载"></a>查询与自动挂载</h5><p>mount [-l]         #查询系统中已经挂载的设备,-l会显示卷标名称</p>
<p>mount -a          #依据配置文件/etc/fstab的内容,自动挂载</p>
<h5 id="挂载命令格式"><a href="#挂载命令格式" class="headerlink" title="挂载命令格式"></a>挂载命令格式</h5><p>mount [-t 文件系统] [-L 卷标名] [-o 特殊选项] 设备文件名 挂载点</p>
<p>选项:<br>    -t 文件系统   加入文件系统类型来指定挂载的类型,可以是ext3、ext4、iso9660等文件系统<br>    -L 卷标名       挂载指定卷标的分区,而不是安装设备文件名挂载<br>    -o 特殊选项   可以指定挂载的额外选项</p>
<p>特殊选项汇总:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>atime/noatime</td>
<td>更新访问时间/不更新访问时间.访问分区文件时,是否更新文件的访问时间,默认为更新</td>
</tr>
<tr>
<td>async/sync</td>
<td>异步/同步,默认为异步</td>
</tr>
<tr>
<td>auto/noauto</td>
<td>自动/手动,mount -a命令执行时,是否会自动安装/etc/fstab文件内容挂载,默认为自动</td>
</tr>
<tr>
<td>defaults</td>
<td>定义默认值,相当于rw,suid,dev,exec,auto,nouser,async这七个选项</td>
</tr>
<tr>
<td>exec/noexec</td>
<td>执行/不执行,设定是否允许在文件系统中执行可执行文件,默认是exec允许(如果不允许,则里面文件无法执行)</td>
</tr>
<tr>
<td>remount</td>
<td>重新挂载已经挂载的文件系统,一般用于指定修改特殊权限</td>
</tr>
<tr>
<td>rw/ro</td>
<td>读写/只读,文件系统挂载时,是否具有读写权限,默认是rw</td>
</tr>
<tr>
<td>suid/nosuid</td>
<td>具有/不具有SUID权限,设定文件系统是否具有SUID和SGID的权限,默认是具有</td>
</tr>
<tr>
<td>user/nouser</td>
<td>允许/不允许普通用户挂载,设定文件系统是否允许普通用户挂载,默认是不允许,只有root可以挂载分区</td>
</tr>
<tr>
<td>usrquota</td>
<td>写入代表文件系统支持用户磁盘配额,默认不支持</td>
</tr>
<tr>
<td>grpquota</td>
<td>写入代表文件系统支持组磁盘配额,默认不支持</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount -o remount,noexec &#x2F;home</span><br></pre></td></tr></table></figure>
<h5 id="挂载光盘和U盘"><a href="#挂载光盘和U盘" class="headerlink" title="挂载光盘和U盘"></a>挂载光盘和U盘</h5><h6 id="挂载光盘"><a href="#挂载光盘" class="headerlink" title="挂载光盘"></a>挂载光盘</h6><ol>
<li>mkdir /mnt/cdrom    #建立挂载点</li>
<li>mount -t iso9660 /dev/cdrom /mnt/cdrom     #挂载光盘</li>
<li>mount /dev/sr0 /mnt/cdrom   #2,3均可以挂载光盘</li>
<li>去挂载点访问光盘</li>
<li>umount 设备文件名或挂载点     #卸载光盘,注意不能在光盘中执行此命令</li>
</ol>
<p>光盘设备名:</p>
<ul>
<li>/dev/cdrom  </li>
<li>/dev/sr0</li>
</ul>
<h6 id="挂载U盘"><a href="#挂载U盘" class="headerlink" title="挂载U盘"></a>挂载U盘</h6><p>U盘设备文件名是自动分配的</p>
<ol>
<li>fdisk -l      #查看U盘设备文件名</li>
<li>mount -t vfat /dev/sdb1 /mnt/usb   #挂载U盘</li>
<li>umount 设备文件名或挂载点     </li>
</ol>
<p>注意:Linux把fat16识别为fat,把fat32识别为vfat;Linux默认是不支持NTFS文件系统的</p>
<h5 id="支持NTFS文件系统"><a href="#支持NTFS文件系统" class="headerlink" title="支持NTFS文件系统"></a>支持NTFS文件系统</h5><p>可通过内核编译(复杂且使用较少)或使用NTFS插件使Linux支持NTFS文件系统,详细过程点击<a href="https://www.codenong.com/cs105317766/">链接</a>查看</p>
<h3 id="fdisk分区"><a href="#fdisk分区" class="headerlink" title="fdisk分区"></a>fdisk分区</h3><h4 id="fdisk命令分区过程"><a href="#fdisk命令分区过程" class="headerlink" title="fdisk命令分区过程"></a>fdisk命令分区过程</h4><ol>
<li>添加新硬盘</li>
<li>fdisk -l    #查看新硬盘</li>
<li>fdisk /dev/sdb     #使用fdisk命令分区(Ctrl+退格删除)</li>
<li>partprobe或重启         #重新读取分区表信息(如果分区表被占用)</li>
<li>mkfs -t ext4 /dev/sdb1     #格式化分区</li>
<li>mkdir /disk1    #建立挂载点</li>
<li>mount /dev/sdb1 /disk1/    #挂载</li>
</ol>
<p><img src="https://i.loli.net/2021/02/02/dipW8GsbrjTZNJ5.png" alt=""></p>
<p>Linux通过id识别Linux分区到底是什么,Linux标准分区id是83,swap分区id是82;详细过程点击<a href="https://blog.csdn.net/keith6785753/article/details/107324335/">链接</a>查看</p>
<h4 id="分区自动挂载与fstab文件修复"><a href="#分区自动挂载与fstab文件修复" class="headerlink" title="分区自动挂载与fstab文件修复"></a>分区自动挂载与fstab文件修复</h4><h5 id="etc-fstab文件"><a href="#etc-fstab文件" class="headerlink" title="/etc/fstab文件"></a>/etc/fstab文件</h5><ul>
<li>第一字段: 分区设备文件名或UUID(硬盘通用唯一识别码)</li>
<li>第二字段: 挂载点</li>
<li>第三字段: 文件系统名称</li>
<li>第四字段: 挂载参数</li>
<li>第五字段: 指定分区是否被dump备份,0代表不备份,1代表每天备份,2代表不定期备份</li>
<li>第六字段: 指定分区是否被fsck检测,0代表不检测,其他数字代表检测的优先级,那么当然1的优先级比2高</li>
</ul>
<h5 id="分区自动挂载"><a href="#分区自动挂载" class="headerlink" title="分区自动挂载"></a>分区自动挂载</h5><p>方法1:手工修改/etc/fstab(写错会系统崩溃)</p>
<ol>
<li>vi /etc/fstab</li>
<li>/dev/sdb1      /disk1       ext4       defaults     1   2    #安装格式填入挂载内容</li>
</ol>
<p>方法2:使用mount命令</p>
<ol>
<li>mount -a           #依据配置文件/etc/fstab的内容,自动挂载</li>
</ol>
<h5 id="etc-fstab文件修复"><a href="#etc-fstab文件修复" class="headerlink" title="/etc/fstab文件修复"></a>/etc/fstab文件修复</h5><p>系统崩溃后,修改/etc/fstab文件时无法写入,使用下面命令</p>
<ol>
<li>mount -o remount,rw /     #这种修复方式不是万能的</li>
</ol>
<h3 id="分配swap分区"><a href="#分配swap分区" class="headerlink" title="分配swap分区"></a>分配swap分区</h3><h4 id="free命令"><a href="#free命令" class="headerlink" title="free命令"></a>free命令</h4><p>[root@localhost ~]# free -m         #查看内存与swap分区使用状况,m不是按照MB查看</p>
<ul>
<li>cached(缓存): 是指把读取出来的数据保存在内存当中,当再次读取时,不用读取硬盘而直接从内存当中读取,加速了数据的读取过程</li>
<li>buffer(缓冲): 是指在写入数据时,先把分散的写入操作保存到内存当中,当达到一定程度再集中写入硬盘,减少了磁盘碎片和硬盘的反复寻道,加速了数据的写入过程</li>
</ul>
<h4 id="新建swap分区"><a href="#新建swap分区" class="headerlink" title="新建swap分区"></a>新建swap分区</h4><p>[root@localhost ~]# fdisk /dev/sdb   #注意要把swap分区id改为82</p>
<h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><p>[root@localhost ~]# mkswap /dev/sdb6</p>
<h4 id="加入swap分区"><a href="#加入swap分区" class="headerlink" title="加入swap分区"></a>加入swap分区</h4><p>[root@localhost ~]# swapon /dev/sdb6        #加入swap分区</p>
<p>[root@localhost ~]# swapoff /dev/sdb6       #取消swap分区</p>
<h4 id="swap分区开机自动挂载"><a href="#swap分区开机自动挂载" class="headerlink" title="swap分区开机自动挂载"></a>swap分区开机自动挂载</h4><p>[root@localhost ~]# vi /etc/fstab<br>/dev/sdb6    swap       swap     defaults     0    0</p>
<h2 id="shell基础"><a href="#shell基础" class="headerlink" title="shell基础"></a>shell基础</h2><h3 id="Shell概述"><a href="#Shell概述" class="headerlink" title="Shell概述"></a>Shell概述</h3><h4 id="Shell简介"><a href="#Shell简介" class="headerlink" title="Shell简介"></a>Shell简介</h4><ul>
<li>Shell是一个命令行解释器,它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序,用户可以用Shell来启动、挂起、停止甚至是编写一些程序</li>
<li>Shell还是一个功能相当强大的编程语言,易编写,易调试,灵活性较强.Shell是解释执行的脚本语言,在Shell中可以直接调用Linux系统命令</li>
</ul>
<h4 id="Shell的分类"><a href="#Shell的分类" class="headerlink" title="Shell的分类"></a>Shell的分类</h4><ul>
<li>Bourne Shell: 从1979起Unix就开始使用Bourne Shell,Bourne Shell的主文件名为sh</li>
<li>C Shell: C Shell主要在BSD版的Unix系统中使用,其语法和C语言相类似而得名</li>
<li>Shell的两种主要语法类型有Bourne和C,这两种语法彼此不兼容.Bourne家族主要包括sh、ksh、Bash、psh、zsh; C家族主要包括: csh、tcsh</li>
<li>Bash: Bash与sh兼容,现在使用的Linux就是使用Bash作为用户的基本Shell</li>
</ul>
<h4 id="Linux支持的Shell"><a href="#Linux支持的Shell" class="headerlink" title="Linux支持的Shell"></a>Linux支持的Shell</h4><p>打开/etc/shells文件查看Linux支持的Shell</p>
<h3 id="Shell脚本的执行方式"><a href="#Shell脚本的执行方式" class="headerlink" title="Shell脚本的执行方式"></a>Shell脚本的执行方式</h3><h4 id="echo输出命令"><a href="#echo输出命令" class="headerlink" title="echo输出命令"></a>echo输出命令</h4><p>[root@localhost ~]# echo [选项] [输出内容]<br>选项:<br>    -e      支持反斜线控制的字符转换</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>控制字符</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>\\\\</td>
<td>输出\本身</td>
</tr>
<tr>
<td>\\a</td>
<td>输出警告音</td>
</tr>
<tr>
<td>\\b</td>
<td>退格键,也就是向左删除键</td>
</tr>
<tr>
<td>\\c</td>
<td>取消输出行末的换行符,和“-n”选项一致</td>
</tr>
<tr>
<td>\\e</td>
<td>ESCAPE键</td>
</tr>
<tr>
<td>\\f</td>
<td>换页符</td>
</tr>
<tr>
<td>\\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\\r</td>
<td>回车键</td>
</tr>
<tr>
<td>\\t</td>
<td>制表符,也就是Tab键</td>
</tr>
<tr>
<td>\\v</td>
<td>垂直制表符</td>
</tr>
<tr>
<td>\\0nnn</td>
<td>按照八进制ASCII码表输出字符,其中0为数字零,nnn是三位八进制数</td>
</tr>
<tr>
<td>\\xhh</td>
<td>按照十六进制ASCII码表输出字符,其中hh是两位十六进制数</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo -e &quot;\e[1;31mabcd\e[0m&quot;    #输出颜色</span><br><span class="line">#30m&#x3D;黑色，31m&#x3D;红色，32m&#x3D;绿色，33m&#x3D;黄色</span><br><span class="line">#34m&#x3D;蓝色，35m&#x3D;洋红，36m&#x3D;青色，37m&#x3D;白色</span><br></pre></td></tr></table></figure>
<h4 id="脚本执行"><a href="#脚本执行" class="headerlink" title="脚本执行"></a>脚本执行</h4><ol>
<li>赋予执行权限,直接运行<ul>
<li>chmod 755 hello.sh </li>
<li>./hello.sh</li>
</ul>
</li>
<li>通过Bash调用执行脚本<ul>
<li>bash hello.sh </li>
</ul>
</li>
</ol>
<p>在Linux中回车符识别为$,windows回车符识别为^M$,所以Linux无法识别在windows编写的脚本,将在windows编写的脚本转换为Linux可识别的脚本,可使用dos2unix命令</p>
<p>格式: dos2unix 文件名</p>
<h3 id="Bash的基本功能"><a href="#Bash的基本功能" class="headerlink" title="Bash的基本功能"></a>Bash的基本功能</h3><h4 id="历史命令与命令补全"><a href="#历史命令与命令补全" class="headerlink" title="历史命令与命令补全"></a>历史命令与命令补全</h4><h5 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h5><p>[root@localhost~]#  history [选项] [历史命令保存文件]<br>选项:<br>    -c      清空历史命令<br>    -w    把缓存中的历史命令写入历史命令保存文件~/.bash_history</p>
<p>历史命令默认会保存1000条,可以在环境变量配置文件/etc/profile中进行修改,超过1000条会删除前面的,保留后面的.</p>
<ul>
<li>使用上、下箭头调用以前的历史命令</li>
<li>使用”!n”重新执行第n条历史命令</li>
<li>使用”!!”重新执行上一条命令</li>
<li>使用”!字串”重新执行最后一条以该字串开头的命令</li>
</ul>
<h5 id="命令补全"><a href="#命令补全" class="headerlink" title="命令补全"></a>命令补全</h5><p>在Bash中,命令与文件补全是非常方便与常用的功能,我们只要在输入命令或文件<br>时,按”Tab”键就会自动进行补全,如果有很多条可能不会显示,再按一下即可</p>
<h4 id="命令别名与常用快捷键"><a href="#命令别名与常用快捷键" class="headerlink" title="命令别名与常用快捷键"></a>命令别名与常用快捷键</h4><h5 id="命令别名"><a href="#命令别名" class="headerlink" title="命令别名"></a>命令别名</h5><p>[root@localhost ~]# alias 别名=’原命令’</p>
<h1 id="设定命令别名"><a href="#设定命令别名" class="headerlink" title="设定命令别名"></a>设定命令别名</h1><p>[root@localhost ~]# alias</p>
<h1 id="查询命令别名"><a href="#查询命令别名" class="headerlink" title="查询命令别名"></a>查询命令别名</h1><p>使用命令行设定别名只会临时生效;使用别名时要注意命令执行顺序</p>
<h6 id="命令执行顺序"><a href="#命令执行顺序" class="headerlink" title="命令执行顺序"></a>命令执行顺序</h6><ol>
<li>第一顺位执行用绝对路径或相对路径执行的命令</li>
<li>第二顺位执行别名</li>
<li>第三顺位执行Bash的内部命令</li>
<li>第四顺位执行按照$PATH环境变量定义的目录查找顺序找到的第一个命令</li>
</ol>
<h6 id="让别名永久生效"><a href="#让别名永久生效" class="headerlink" title="让别名永久生效"></a>让别名永久生效</h6><p>[root@localhost ~]# vi /用户名/.bashrc    #修改其中相关内容</p>
<h5 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h5><div class="table-container">
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctr1+a</td>
<td>把光标移动到命令行开头</td>
</tr>
<tr>
<td>Ctrl+e</td>
<td>把光标移动到命令行结尾</td>
</tr>
<tr>
<td>Ctrl+c</td>
<td>强制终止当前的命令</td>
</tr>
<tr>
<td>Ctrl+l</td>
<td>清屏,相当于clear命令</td>
</tr>
<tr>
<td>Ctrl+u</td>
<td>删除或剪切光标之前的命令</td>
</tr>
<tr>
<td>Ctrl+k</td>
<td>删除或剪切光标之后的内容</td>
</tr>
<tr>
<td>Ctrl+y</td>
<td>粘贴Ctrl+u或Ctrl+k剪切的内容</td>
</tr>
<tr>
<td>Ctrl+r</td>
<td>在历史命令中搜索,按下Ctrl+r之后,就会出现搜索界面,只要输入搜索内容,就会从历史命令中搜索</td>
</tr>
<tr>
<td>Ctrl+d</td>
<td>退出当前终端</td>
</tr>
<tr>
<td>Ctrl+z</td>
<td>暂停,并放入后台.这个快捷键与工作管理有关</td>
</tr>
<tr>
<td>Ctrl+s</td>
<td>暂停屏幕输出</td>
</tr>
<tr>
<td>Ctrl+q</td>
<td>恢复屏幕输出</td>
</tr>
</tbody>
</table>
</div>
<h4 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h4><h5 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h5><div class="table-container">
<table>
<thead>
<tr>
<th>设备</th>
<th>设备文件名</th>
<th>文件描述符</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>键盘</td>
<td>/dev/stdin</td>
<td>0</td>
<td>标准输入</td>
</tr>
<tr>
<td>显示器</td>
<td>/dev/stdout</td>
<td>1</td>
<td>标准输出</td>
</tr>
<tr>
<td>显示器</td>
<td>/dev/stderr</td>
<td>2</td>
<td>标准错误输出</td>
</tr>
</tbody>
</table>
</div>
<h5 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h5><table>
    <tr>
        <th>类型</th>
        <th>符号</th>
        <th>作用</th>
    </tr>
    <tr>
        <td rowspan="2">标准输出重定向</td>
        <td>命令 > 文件</td>
        <td>以覆盖的方式,把命令的正确输出输出到指定的文件或设备当中</td>
    </tr>
    <tr>
        <td>命令 >> 文件</td>
        <td>以追加的方式,把命令的正确输出输出到指定的文件或设备当中</td>
    </tr>
    <tr>
        <td rowspan="2">标准错误输出重定向</td>
        <td>错误命令 2> 文件</td>
        <td>以覆盖的方式,把命令的错误输出输出到指定的文件或设备当中</td>
    </tr>
    <tr>
        <td>错误命令 2>> 文件</td>
        <td>以追加的方式,把命令的错误输出输出到指定的文件或设备当中</td>
    </tr>
    <tr>
        <td rowspan="5">正确输出和错误输出同时保存</td>
        <td>命令 > 文件 2>&1</td>
        <td>以覆盖的方式,把正确输出和错误输出都保存到同一个文件当中</td>
    </tr>
    <tr>
        <td>命令 >> 文件 2>&1</td>
        <td>以追加的方式,把正确输出和错误输出都保存到同一个文件当中</td>
    </tr>
    <tr>
        <td>命令 &> 文件</td>
        <td>以覆盖的方式,把正确输出和错误输出都保存到同一个文件当中</td>
    </tr>
    <tr>
        <td>命令 &>> 文件</td>
        <td>以追加的方式,把正确输出和错误输出都保存到同一个文件当中</td>
    </tr>
    <tr>
        <td>命令 >> 文件1 2>>文件2</td>
        <td>把正确的输出追加到文件1中,把错误的输出追加到文件2中</td>
    </tr>
</table>



<ul>
<li>注意2与大于号(&gt;)之间不能有空格,命令与大于号之间,文件与大于号之间最好也有空格</li>
<li>2&gt;&amp;1表示把错误输出保存到正确输出中</li>
<li>ls &amp;&gt; /dev/null     #把ls结果丢进垃圾箱</li>
</ul>
<h5 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h5><p>[root@localhost~] # wc [选项] [文件名]<br>选项:<br>    -c  统计字节数<br>    -w  统计单词数<br>    -l  统计行数</p>
<p>Ctrl+d结束输入(wc会统计回车符)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wc &lt; 文件名   #统计该文件行数等信息</span><br><span class="line">wc &lt;&lt; test   #当第一次遇到test时停止,统计test之前的内容</span><br></pre></td></tr></table></figure>
<h4 id="多命令顺序执行与管道符"><a href="#多命令顺序执行与管道符" class="headerlink" title="多命令顺序执行与管道符"></a>多命令顺序执行与管道符</h4><h5 id="多命令顺序执行"><a href="#多命令顺序执行" class="headerlink" title="多命令顺序执行"></a>多命令顺序执行</h5><div class="table-container">
<table>
<thead>
<tr>
<th>多命令执行符</th>
<th>格式</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>;</td>
<td>命令1 ; 命令2</td>
<td>多个命令顺序执行,命令之间没有任何逻辑联系</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>命令1 &amp;&amp; 命令2</td>
<td>逻辑与<br>当命令1正确执行,则命令2才会执行 <br>当命令1执行不正确,则命令2不会执行</td>
</tr>
<tr>
<td>\</td>
<td>\</td>
<td></td>
<td>命令1 \</td>
<td>\</td>
<td>命令2</td>
<td>逻辑或<br/>当命令1执行不正确,则命令2才会执行<br>当命令1正确执行,则命令2不会执行</td>
</tr>
</tbody>
</table>
</div>
<h5 id="dd命令"><a href="#dd命令" class="headerlink" title="dd命令"></a>dd命令</h5><p>用于磁盘复制</p>
<p>[root@localhost ~]# dd if=输入文件 of=输出文件 bs=字节数 count=个数<br>选项:<br>    if=输入文件       指定源文件或源设备<br>    of=输出文件      指定目标文件或目标设备<br>    bs=字节数          指定一次输入/输出多少字节,即把这些字节看做一个数据块<br>    count=个数        指定输入/输出多少个数据块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">date ; dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;root&#x2F;test bs&#x3D;1k count&#x3D;102400 ; date     #记录&#x2F;dev&#x2F;zero向&#x2F;root&#x2F;test复制100MB</span><br><span class="line">命令 &amp;&amp; echo yes || echo no   #如果命令正确执行则输出yes,否则输出no</span><br></pre></td></tr></table></figure>
<h5 id="管道符"><a href="#管道符" class="headerlink" title="管道符"></a>管道符</h5><p>[root@localhost ~]# 命令1|命令2</p>
<h1 id="命令1的正确输出作为命令2的操作对象"><a href="#命令1的正确输出作为命令2的操作对象" class="headerlink" title="命令1的正确输出作为命令2的操作对象"></a>命令1的正确输出作为命令2的操作对象</h1><h4 id="通配符与其他特殊符号"><a href="#通配符与其他特殊符号" class="headerlink" title="通配符与其他特殊符号"></a>通配符与其他特殊符号</h4><h5 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h5><div class="table-container">
<table>
<thead>
<tr>
<th>通配符</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>?</td>
<td>匹配一个任意字符</td>
</tr>
<tr>
<td>*</td>
<td>匹配0个或任意多个任意字符,也就是可以匹配任何内容</td>
</tr>
<tr>
<td>[]</td>
<td>匹配中括号中任意一个字符.例如:[abc]代表一定匹配一个字符,或者是a,或者是b,或者是c</td>
</tr>
<tr>
<td>[-]</td>
<td>匹配中括号中任意一个字符,代表一个范围.例如: [a-z]代表匹配一个小写字母</td>
</tr>
<tr>
<td><sup><a href="#fn_" id="reffn_"></a></sup></td>
<td>逻辑非,表示匹配不是中括号内的一个字符.例如: [\^0-9]代表匹配一个不是数字的字符</td>
</tr>
</tbody>
</table>
</div>
<h5 id="其他特殊符号"><a href="#其他特殊符号" class="headerlink" title="其他特殊符号"></a>其他特殊符号</h5><div class="table-container">
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>‘’</td>
<td>单引号.在单引号中所有的特殊符号,如”$“和”`”(反引号)都没有特殊含义</td>
</tr>
<tr>
<td>“”</td>
<td>双引号.在双引号中特殊符号都没有特殊含义,但是”$“、”`”和”\\”是例外,拥有”调用变量的值”、”引用命令”和”转义符”的特殊含义</td>
</tr>
<tr>
<td>`</td>
<td>反引号.反引号括起来的内容是系统命令,在bash中会先执行它.和$()作用一样,不过推荐使用​$(),因为反引号非常容易看错</td>
</tr>
<tr>
<td>$()</td>
<td>和反引号作用一样,用来引用系统命令</td>
</tr>
<tr>
<td>#</td>
<td>在Shell脚本中,#开头的行代表注释</td>
</tr>
<tr>
<td>$</td>
<td>用于调用变量的值,如需要调用变量name的值时,需要用$name的方式得到变量的值</td>
</tr>
<tr>
<td>\\</td>
<td>转义符.跟在\\之后的特殊符号将失去特殊含义,变为普通字符.如$将输出”$“符号,而不当做是变量引用</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Bash的变量"><a href="#Bash的变量" class="headerlink" title="Bash的变量"></a>Bash的变量</h3><p>shell中默认变量类型为字符型</p>
<h4 id="变量分类"><a href="#变量分类" class="headerlink" title="变量分类"></a>变量分类</h4><ul>
<li>用户自定义变量(本地变量)</li>
<li>环境变量: 这种变量中主要保存的是和系统操作环境相关的数据</li>
<li>位置参数变量: 这种变量主要是用来向脚本当中传递参数或数据的,变量名不能自定义,变量作用是固定的</li>
<li>预定义变量: 是Bash中已经定义好的变量,变量名不能自定义,变量作用也是固定的</li>
</ul>
<h4 id="用户自定义变量"><a href="#用户自定义变量" class="headerlink" title="用户自定义变量"></a>用户自定义变量</h4><p>或者叫本地变量</p>
<h5 id="变量设置规则"><a href="#变量设置规则" class="headerlink" title="变量设置规则"></a>变量设置规则</h5><ul>
<li>变量名称可以由字母、数字和下划线组成,但是不能以数字开头</li>
<li>在Bash中,变量的默认类型都是字符串型,如果要进行数值运算,则必需指定变量类型为数值型</li>
<li>变量用等号连接值,等号左右两侧不能有空格</li>
<li>变量的值如果有空格,需要使用单引号或双引号括起来</li>
<li>在变量的值中,可以使用”\\”转义符</li>
<li>如果需要增加变量的值,那么可以进行变量值的叠加.不过变量需要用双引号包含”$变量名”或用${变量名}包含</li>
<li>如果是把命令的结果作为变量值赋予变量,则需要使用反引号或$()包含命令</li>
<li>环境变量名建议大写,便于区分</li>
</ul>
<h5 id="变量叠加"><a href="#变量叠加" class="headerlink" title="变量叠加"></a>变量叠加</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abc&#x3D;123           #abc值为123</span><br><span class="line">abc&#x3D;&quot;$abc&quot;456     #给abc的值追加456</span><br><span class="line">abc&#x3D;$&#123;abc&#125;789     #给abc的值追加789</span><br></pre></td></tr></table></figure>
<h5 id="变量调用"><a href="#变量调用" class="headerlink" title="变量调用"></a>变量调用</h5><p>echo $变量名</p>
<h5 id="变量查看"><a href="#变量查看" class="headerlink" title="变量查看"></a>变量查看</h5><p>set</p>
<blockquote>
<p>查看系统所有变量</p>
</blockquote>
<h5 id="变量删除"><a href="#变量删除" class="headerlink" title="变量删除"></a>变量删除</h5><p>unset 变量名</p>
<h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><h5 id="环境变量特点"><a href="#环境变量特点" class="headerlink" title="环境变量特点"></a>环境变量特点</h5><ul>
<li>用户自定义变量只在当前的Shell中生效,而环境变量会在当前Shell和这个Shell的所有子Shell当中生效.如果把环境变量写入相应的配置文件,那么这个环境变量就会在所有的Shell中生效</li>
</ul>
<h5 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h5><p>export 变量名[=变量值]        #声明变量(export表示把变量声明为全局变量)</p>
<h5 id="查询环境变量"><a href="#查询环境变量" class="headerlink" title="查询环境变量"></a>查询环境变量</h5><p>env</p>
<blockquote>
<p>专门用于查询环境变量(删除变量依旧是unset+变量名)</p>
</blockquote>
<h5 id="系统常见环境变量"><a href="#系统常见环境变量" class="headerlink" title="系统常见环境变量"></a>系统常见环境变量</h5><h6 id="PATH"><a href="#PATH" class="headerlink" title="PATH"></a>PATH</h6><blockquote>
<p>系统查找命令的路径</p>
</blockquote>
<p>如果想令自己的脚本在任何路径都能直接运行,可以将其加入PATH</p>
<p>方法一:</p>
<blockquote>
<p>直接将脚本拷贝到PATH所指向的路径</p>
</blockquote>
<p>方法二:</p>
<blockquote>
<p>通过变量叠加,为PATH增加新的路径(临时生效,必须写入指定文件)</p>
<p>例如:PATH=”$PATH”:/root   #将root目录加入环境变量</p>
</blockquote>
<h6 id="PS1"><a href="#PS1" class="headerlink" title="PS1"></a>PS1</h6><blockquote>
<p>定义系统提示符的变量</p>
<p>严格来说PS1不是环境变量(env查询不到,set可以查询到),PS1是系统预留的专门用来定义系统操作环境的变量</p>
</blockquote>
<p>\d: 显示日期,格式为“星期 月 日”<br>\h: 显示简写主机名.如默认主机名“localhost”<br>\t: 显示24小时制时间,格式为“HH:MM:SS”<br>\T: 显示12小时制时间,格式为“HH:MM:SS”<br>\A: 显示24小时制时间,格式为“HH:MM”<br>\u: 显示当前用户名<br>\w: 显示当前所在目录的完整名称<br>\W: 显示当前所在目录的最后一个目录<br>\#: 执行的第几个命令<br>\\$: 提示符.如果是root用户会显示提示符为“#”,如果是普通用户会显示提示符为“$”</p>
<h4 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h4><div class="table-container">
<table>
<thead>
<tr>
<th>位置参数变量</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>$n</td>
<td>n为数字,$0代表命令本身,$1-$9代表第一到第九个参数,十以上的参数需要用大括号包含,如${10}</td>
</tr>
<tr>
<td>$*</td>
<td>这个变量代表命令行中所有的参数,$*把所有的参数看成一个整体</td>
</tr>
<tr>
<td>$@</td>
<td>这个变量也代表命令行中所有的参数,$@把每个参数区分对待</td>
</tr>
<tr>
<td>$#</td>
<td>这个变量代表命令行中所有参数的个数</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for x in &quot;$*&quot;</span><br><span class="line">	do</span><br><span class="line">		echo $x</span><br><span class="line">	done</span><br><span class="line">for y in &quot;$@&quot;</span><br><span class="line">	do</span><br><span class="line">		echo $y</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/02/21/VM2n9QGFRwhLBdJ.png" alt=""></p>
<h4 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h4><div class="table-container">
<table>
<thead>
<tr>
<th>预定义变量</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>$?</td>
<td>最后一次执行的命令的返回状态.如果这个变量的值为0,证明<br/>上一个命令正确执行;如果这个变量的值为非0(具体是哪个<br/>数,由命令自己来决定),则证明上一个命令执行不正确</td>
</tr>
<tr>
<td>$$</td>
<td>当前进程的进程号(PID)</td>
</tr>
<tr>
<td>$!</td>
<td>后台运行的最后一个进程的进程号(PID)</td>
</tr>
</tbody>
</table>
</div>
<h5 id="接收键盘输入"><a href="#接收键盘输入" class="headerlink" title="接收键盘输入"></a>接收键盘输入</h5><p>[root@localhost ~]# read [选项] [变量名]<br>选项:<br>    -p “提示信息”      在等待read输入时,输出提示信息<br>    -t 秒数                  read命令会一直等待用户输入,使用此选项可以指定等待时间<br>    -n 字符数             read命令只接受指定的字符数,就会执行<br>    -s                           隐藏输入的数据,适用于机密信息的输入</p>
<h3 id="Bash的运算符"><a href="#Bash的运算符" class="headerlink" title="Bash的运算符"></a>Bash的运算符</h3><h4 id="数值运算与运算符"><a href="#数值运算与运算符" class="headerlink" title="数值运算与运算符"></a>数值运算与运算符</h4><p><img src="https://i.loli.net/2021/02/22/mbBqaXHsEU9RGSe.png" alt=""></p>
<p>变量直接相加无法达到预计的效果.</p>
<h5 id="declare声明变量类型"><a href="#declare声明变量类型" class="headerlink" title="declare声明变量类型"></a>declare声明变量类型</h5><p>[root@localhost ~]# declare [+/-] [选项] 变量名<br>选项:<br>    -      给变量设定类型属性<br>    +      取消变量的类型属性<br>    -i     将变量声明为整数型(integer)<br>    -x    将变量声明为环境变量<br>    -p    显示指定变量的被声明的类型</p>
<p>使用export声明环境变量其实就是赋予变量declare -x属性</p>
<h5 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h5><h6 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h6><p>使用declare将变量声明为整数型</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">x=11</span><br><span class="line">y=22</span><br><span class="line">declare -i z=$x+$y</span><br><span class="line">echo $z</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/02/22/6TuSNE4ylFZiJ7V.png" alt=""></p>
<h6 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h6><p>使用expr或let数值运算工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">x=11</span><br><span class="line">y=22</span><br><span class="line">z=$(expr $x + $y)    注意“+”号左右两侧必须有空格</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/02/22/avOuV1fIxPZcUrn.png" alt=""></p>
<h6 id="方法3-推荐"><a href="#方法3-推荐" class="headerlink" title="方法3(推荐)"></a>方法3(推荐)</h6><p>“$((运算式))”或”$[运算式]”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">x=11</span><br><span class="line">y=22</span><br><span class="line">m=$(($x+$y))</span><br><span class="line">n=$[$y-$x]</span><br><span class="line">echo $m</span><br><span class="line">echo $n</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/02/22/5x7IA1mcwFVn6pj.png" alt=""></p>
<h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><p><img src="https://i.loli.net/2021/02/22/RsryJHD18EGS9jf.png" alt=""></p>
<h4 id="变量测试与内容替换"><a href="#变量测试与内容替换" class="headerlink" title="变量测试与内容替换"></a>变量测试与内容替换</h4><p><img src="https://i.loli.net/2021/02/22/GhwCUnPTuS7QJol.png" alt=""></p>
<h3 id="环境变量配置文件"><a href="#环境变量配置文件" class="headerlink" title="环境变量配置文件"></a>环境变量配置文件</h3><h4 id="环境变量配置文件简介"><a href="#环境变量配置文件简介" class="headerlink" title="环境变量配置文件简介"></a>环境变量配置文件简介</h4><h5 id="source命令"><a href="#source命令" class="headerlink" title="source命令"></a>source命令</h5><p>[root@localhost~]# source 配置文件<br>或<br>[root@localhost~]# . 配置文件</p>
<p>让配置文件直接生效而不用注销或重新登录</p>
<h5 id="环境变量配置文件简介-1"><a href="#环境变量配置文件简介-1" class="headerlink" title="环境变量配置文件简介"></a>环境变量配置文件简介</h5><ul>
<li>环境变量配置文件中主要是定义对系统的操作环境生效的系统默认环境变量,比如PATH、HISTSIZE、PS1、HOSTNAME等默认环境变量</li>
<li>/etc/profile</li>
<li>/etc/profile.d/*.sh</li>
<li>~/.bash_profile</li>
<li>~/.bashrc</li>
<li>/etc/bashrc</li>
<li>位于/etc目录下的环境变量配置文件对全局(任何用户)起作用</li>
</ul>
<h4 id="环境变量配置文件作用"><a href="#环境变量配置文件作用" class="headerlink" title="环境变量配置文件作用"></a>环境变量配置文件作用</h4><p>越往后文件优先级越高</p>
<p><img src="https://i.loli.net/2021/02/23/1CZxXnVHYudBjvf.png" alt=""></p>
<h5 id="etc-profile的作用"><a href="#etc-profile的作用" class="headerlink" title="/etc/profile的作用"></a>/etc/profile的作用</h5><ul>
<li>USER变量</li>
<li>LOGNAME变量</li>
<li>MAIL变量</li>
<li>PATH变量</li>
<li>HOSTNAME变量</li>
<li>HISTSIZE变量</li>
<li>umask</li>
<li>调用/etc/profile.d/* .sh文件</li>
</ul>
<h5 id="bash-profile的作用"><a href="#bash-profile的作用" class="headerlink" title="~/.bash_profile的作用"></a>~/.bash_profile的作用</h5><ul>
<li>调用了~/.bashrc文件</li>
<li>在PATH变量后面加入了”:$HOME/bin”这个目录</li>
</ul>
<h5 id="etc-bashrc的作用"><a href="#etc-bashrc的作用" class="headerlink" title="/etc/bashrc的作用"></a>/etc/bashrc的作用</h5><ul>
<li>定义登录提示符</li>
</ul>
<h4 id="其他配置文件和登录信息"><a href="#其他配置文件和登录信息" class="headerlink" title="其他配置文件和登录信息"></a>其他配置文件和登录信息</h4><h5 id="注销时生效的环境变量配置文件"><a href="#注销时生效的环境变量配置文件" class="headerlink" title="注销时生效的环境变量配置文件"></a>注销时生效的环境变量配置文件</h5><ul>
<li>~/.bash_logout</li>
<li>默认为空</li>
</ul>
<h5 id="其他配置文件"><a href="#其他配置文件" class="headerlink" title="其他配置文件"></a>其他配置文件</h5><ul>
<li>~/bash_history</li>
</ul>
<h5 id="shell登录信息"><a href="#shell登录信息" class="headerlink" title="shell登录信息"></a>shell登录信息</h5><ul>
<li>本地终端欢迎信息(登录前):/etc/issue</li>
</ul>
<p><img src="https://i.loli.net/2021/02/23/gZB7KiHf9kWltDx.png" alt=""></p>
<ul>
<li>远程终端欢迎信息(登录前):/etc/issue.net<ul>
<li>转义符在/etc/issue.net文件中不能使用</li>
<li>是否显示此欢迎信息,由ssh的配置文件/etc/ssh/sshd_config决定,加入“Banner /etc/issue.net”行才能显示(记得重启SSH服务:service sshd restart)</li>
</ul>
</li>
<li>登录后欢迎信息:/etc/motd<ul>
<li>不管是本地登录,还是远程登录,都可以显示此欢迎信息,只不过是登录后显示欢迎信息</li>
</ul>
</li>
</ul>
<h2 id="shell编程"><a href="#shell编程" class="headerlink" title="shell编程"></a>shell编程</h2><h3 id="基础正则表达式"><a href="#基础正则表达式" class="headerlink" title="基础正则表达式"></a>基础正则表达式</h3><h4 id="正则表达式与通配符"><a href="#正则表达式与通配符" class="headerlink" title="正则表达式与通配符"></a>正则表达式与通配符</h4><ul>
<li>正则表达式用来在文件中匹配符合条件的字符串,正则是包含匹配. grep、awk、sed等命令可以支持正则表达式</li>
<li>通配符用来在系统中匹配符合条件的文件名,通配符是完全匹配. ls、find、cp这些命令不支持正则表达式,所以只能使用shell自己的通配符来进行匹配了</li>
</ul>
<h4 id="基础正则表达式-1"><a href="#基础正则表达式-1" class="headerlink" title="基础正则表达式"></a>基础正则表达式</h4><div class="table-container">
<table>
<thead>
<tr>
<th>元字符</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>前一个字符匹配0次或任意多次</td>
</tr>
<tr>
<td>.</td>
<td>匹配除了换行符外任意一个字符</td>
</tr>
<tr>
<td>\^</td>
<td>匹配行首.例如:^hello会匹配以hello开头的行</td>
</tr>
<tr>
<td>$</td>
<td>匹配行尾.例如:hello$会匹配以hello结尾的行</td>
</tr>
<tr>
<td>[]</td>
<td>匹配中括号中指定的任意一个字符,只匹配一个字符.<br/>例如:[aoeiu]匹配任意一个元音字母,[0-9]匹配任意一位数字,<br/>[a-z] [0-9]匹配小写字母和一位数字构成的两位字符</td>
</tr>
<tr>
<td><sup><a href="#fn_" id="reffn_"></a></sup></td>
<td>匹配除中括号中的字符以外的任意一个字符.<br/>例如: [\^0-9]表示匹配任意一位非数字的字符,<br/>[\^a-z] 表示匹配任意一位非小写字母的字符</td>
</tr>
<tr>
<td>\</td>
<td>转义符.将特殊字符进行转义,忽略其特殊意义</td>
</tr>
<tr>
<td>\ {n\\}</td>
<td>表示其前面的字符恰好出现n次.<br/>例如: [0-9]\\{4\\}匹配4位数字,[1] [3-8] [0-9]\\{9\\} 匹配手机号码</td>
</tr>
<tr>
<td>\\ {n,\\}</td>
<td>表示其前面的字符出现不小于n次.<br/>例如: [0-9]\\{2,\\} 表示两位及以上的数字</td>
</tr>
<tr>
<td>\\ {n,m\\}</td>
<td>表示其前面的字符至少出现n次,最多出现m次.<br/>例如:[a-z]\\{6,8\\}匹配6到8位的小写字母</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="string">&quot;*&quot;</span> 前一个字符匹配0次或任意多次</span></span><br><span class="line">grep &quot;a*&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配所有内容，包括空白行</span></span><br><span class="line">grep &quot;aa*&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配至少包含有一个a的行</span></span><br><span class="line">grep &quot;aaa*&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配最少包含两个连续a的字符串</span></span><br><span class="line">grep &quot;aaaaa*&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配最少包含四个连续a的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">&quot;.&quot;</span> 匹配除了换行符外任意一个字符</span></span><br><span class="line">grep &quot;s..d&quot; test.txt </span><br><span class="line"><span class="meta">#</span><span class="bash">“s..d”会匹配在s和d这两个字母之间一定有两个字符的单词</span></span><br><span class="line">grep &quot;s.*d&quot; test.txt </span><br><span class="line"><span class="meta">#</span><span class="bash">匹配在s和d字母之间有任意字符(任意个)</span></span><br><span class="line">grep &quot;.*&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配所有内容</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">&quot;^&quot;</span> 匹配行首,<span class="string">&quot;$&quot;</span> 匹配行尾</span></span><br><span class="line">grep &quot;^M&quot; test.txt </span><br><span class="line"><span class="meta">#</span><span class="bash">匹配以大写“M”开头的行</span></span><br><span class="line">grep &quot;n$&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配以小写“n”结尾的行</span></span><br><span class="line">grep -n &quot;^$&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配空白行</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">&quot;[]&quot;</span>匹配中括号里面指定的任意一个字符,只匹配一个字符</span></span><br><span class="line">grep &quot;s[ao]id&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配s和i字母之间,要不是a、要不是o</span></span><br><span class="line">grep &quot;[0-9]&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配任意0到9中一个数字</span></span><br><span class="line">grep&quot;^[a-z]&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配用小写字母开头的行</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">&quot;[^]&quot;</span>匹配除中括号里面字符以外的任意一个字符</span></span><br><span class="line">grep &quot;^[^a-z]&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配不用小写字母开头的行</span></span><br><span class="line">grep &quot;^[^a-zA-Z]&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配不用字母开头的行</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">&quot;\&quot; 转义符</span></span></span><br><span class="line">grep &quot;\.$&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配使用“.”结尾的行</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">“\&#123;n\&#125;”表示其前面的字符恰好出现n次</span></span><br><span class="line">grep &quot;a\&#123;3\&#125;&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配a字母连续出现三次的字符串</span></span><br><span class="line">grep &quot;[0-9]\&#123;3\&#125;&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配包含连续的三个数字的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">“\&#123;n,\&#125;”表示其前面的字符出现不小于n次</span></span><br><span class="line">grep &quot;^[0-9]\&#123;3,\&#125;&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配最少用连续三个数字开头的行</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">“\&#123;n,m)&#125;”匹配其前面的字符至少出现n次,最多出现m次</span></span><br><span class="line">grep &quot;sa\&#123;1,3\&#125;i&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配在字母s和字母i之间有最少一个a,最多三个a</span></span><br></pre></td></tr></table></figure>
<p><a href="https://man.linuxde.net/docs/shell_regex.html">拓展</a></p>
<h3 id="字符截取命令"><a href="#字符截取命令" class="headerlink" title="字符截取命令"></a>字符截取命令</h3><h4 id="cut命令"><a href="#cut命令" class="headerlink" title="cut命令"></a>cut命令</h4><p>cut命令要和grep命令结合使用</p>
<p>[root@localhost ~]# cut [选项] 文件名<br>选项:<br>    -f 列号        提取第几列(列与列之间是制表符(Tab键),不能是空格)<br>    -d 分隔符   按照指定分隔符分割列(默认为制表符)</p>
<p>下面以test.txt为例说明</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210226172810850.png" alt=""></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cut -f 2 test.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210226172721757.png" alt=""></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cut -f 2,3 test.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210226172849456.png" alt=""></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cut -d &quot;:&quot; -f 1,3 /etc/passwd</span><br><span class="line"><span class="meta">#</span><span class="bash">/etc/passwd以冒号分隔</span></span><br></pre></td></tr></table></figure>
<h5 id="使用cut截取用户名"><a href="#使用cut截取用户名" class="headerlink" title="使用cut截取用户名"></a>使用cut截取用户名</h5><p>使用cut截取登录shell为/bin/bash的用户(root除外)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd | grep /bin/bash | grep -v root | cut -d &quot;:&quot; -f 1</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<ul>
<li>cat /etc/passwd   查看/etc/passwd文件</li>
<li>grep /bin/bash     查找/etc/passwd中含有/bin/bash的行(root也在内)</li>
<li>grep -v root           排除含有/bin/bash的行中的root</li>
<li>cut -d “:” -f 1          以”:”为分隔符截取第一列的用户名</li>
</ul>
<h5 id="cut命令的局限"><a href="#cut命令的局限" class="headerlink" title="cut命令的局限"></a>cut命令的局限</h5><p>根据下面例子感受cut命令的局限</p>
<p>使用df -h查看系统占用情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210226193910604.png" alt=""></p>
<p>我们想要达到这样的效果,当根目录的Use%(使用率,上图中为14%)达到70%会警告用户,因此我们需要截取根目录的Use%部分</p>
<p>首先查找根目录所在行,可以看到根目录在/dev/vad1,使用grep查找其中含有vad1字段的行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -h | grep &quot;vda1&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210226193536662.png" alt=""></p>
<p>接下来截取图中的14%,我们使用cut截取,可以看到14%在第5列</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -h | grep &quot;vda1&quot; | cut -f 5 </span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210226194606942.png" alt=""></p>
<p>可以看出并没有截取到14%,这是因为列与列的间隙不是制表符,而是空格,那么我们使用下面这个命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -h | grep &quot;vda1&quot; | cut -d &quot; &quot; -f 5 </span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210226194901137.png" alt=""></p>
<p>可见提取出的是空白,这是因为我们选择的分隔符为一个空格,所以提取到空白列</p>
<p>想要实现该功能需要借助awk命令,cut命令无法做到</p>
<h4 id="awk命令"><a href="#awk命令" class="headerlink" title="awk命令"></a>awk命令</h4><p>在awk命令的输出中支持print和printf命令</p>
<ul>
<li>print命令:print会在每个输出之后自动加入一个换行符(Linux 默认没有print命令)</li>
<li>printf命令:printf是标准格式输出命令,并不会自动加入换行符,如果需要换行,需要手工加入换行符</li>
</ul>
<h5 id="printf命令"><a href="#printf命令" class="headerlink" title="printf命令"></a>printf命令</h5><p>printf命令后不能直接跟文件名,cat命令运行的结果也不能通过管道符使用printf输出</p>
<p>格式化输出命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">printf &#x27;输出类型输出格式&#x27; 输出内容</span><br></pre></td></tr></table></figure>
<h6 id="输出类型"><a href="#输出类型" class="headerlink" title="输出类型"></a>输出类型</h6><p>%ns        输出字符串,n是数字指代输出几个字符<br>%ni        输出整数,n是数字指代输出几个数字<br>%m.nf   输出浮点数,m和n是数字,指代输出的数字位数和小数位数.如%8.2f代表共输出8位数,其中2位是小数,6位是整数</p>
<h6 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h6><p>\a          输出警告声音<br>\b          输出退格键,也就是Backspace键<br>\f           清除屏幕<br>\n          换行<br>\r           回车,也就是Enter键<br>\t           水平输出退格键,也就是Tab键<br>\v          垂直输出退格键,也就是Tab键</p>
<p>例子</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">printf %s 1 2 3 4 5 6</span><br><span class="line"><span class="meta">#</span><span class="bash">没有加引号,把后面的数字当成整体输出</span></span><br><span class="line">printf %s %s %s 1 2 3 4 5 6</span><br><span class="line"><span class="meta">#</span><span class="bash">只有第一个%s起了作用,后面其他的被当成普通字符串输出</span></span><br><span class="line">printf &#x27;%s %s %s&#x27; 1 2 3 4 5 6</span><br><span class="line"><span class="meta">#</span><span class="bash">三个%s均起作用,分别输出1,2,3,(空格输出空格)然后直接输出4 5 6,因为最后一个%s后面没有空格,使用3和4之间没有空格</span> </span><br><span class="line">printf &#x27;%s %s %s\n&#x27; 1 2 3 4 5 6</span><br><span class="line"><span class="meta">#</span><span class="bash">三个%s均起作用,分别输出1,2,3,然后\n换行,再输出4 5 6</span></span><br><span class="line">printf &#x27;%s %s %s &#x27; 1 2 3 4 5 6</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210227164005664.png" alt=""></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用cat查看test.txt</span></span><br><span class="line">cat test.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210227164805994.png" alt=""></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">将cat test.txt的结果作为<span class="built_in">printf</span>的输入</span></span><br><span class="line">printf &#x27;%s&#x27; $(cat test.txt)</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">printf</span>命令后不能直接跟文件名</span></span><br><span class="line">printf &#x27;%s&#x27; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">cat命令运行的结果也不能通过管道符使用<span class="built_in">printf</span>输出</span></span><br><span class="line">cat test.txt | printf &#x27;%s&#x27;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210227165459937.png" alt=""></p>
<h5 id="awk命令格式"><a href="#awk命令格式" class="headerlink" title="awk命令格式"></a>awk命令格式</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;条件1&#123;动作1&#125; 条件2&#123;动作2&#125;...&#x27; 文件名</span><br></pre></td></tr></table></figure>
<p>条件:</p>
<ul>
<li>关系表达式,例如: x&gt;10,x&lt;=10</li>
<li>BEGIN (在读取数据之前执行其后的动作)</li>
<li>END (在所有动作执行完,再执行其后动作)</li>
</ul>
<p>动作:</p>
<ul>
<li>格式化输出</li>
<li>流程控制语句</li>
</ul>
<p>下面以test.txt为例说明:</p>
<blockquote>
<p>查看test.txt    cat test.txt</p>
</blockquote>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228185800661.png" alt=""></p>
<blockquote>
<p>使用awk截取其中的第2,4列</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;&#123;printf $2 &quot;\t&quot; $4&quot;\n&quot;&#125;&#x27; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="variable">$2</span>表示第2列,<span class="variable">$4</span>表示第4列</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228190025765.png" alt=""></p>
<p>关于cut命令的局限,awk命令则不存在,下面举例说明</p>
<blockquote>
<p>使用df -h查看系统相关信息</p>
</blockquote>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228190527438.png" alt=""></p>
<blockquote>
<p>使用awk截取/dev/vda1行中的14%</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -h | grep vda1 | awk &#x27;&#123;print $5&#125;&#x27; | cut -d &quot;%&quot; -f 1</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228190815576.png" alt=""></p>
<h5 id="关系表达式"><a href="#关系表达式" class="headerlink" title="关系表达式"></a>关系表达式</h5><blockquote>
<p>使用cat test.txt查看test.txt</p>
</blockquote>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228194934658.png" alt=""></p>
<blockquote>
<p>提取其中Mark小于80的姓名</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat test.txt | grep -v Name | awk &#x27;$4&lt;=80&#123;print $2&quot;\n&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228194925571.png" alt="image-20210228194925571"></p>
<h5 id="BEGIN"><a href="#BEGIN" class="headerlink" title="BEGIN"></a>BEGIN</h5><p>在读取数据之前执行其后的动作</p>
<blockquote>
<p>在截取test.txt第2,4列之前先执行BEGIN后的命令</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;print &quot;hello world!&quot;&#125; &#123;print $2 &quot;\t&quot; $4&quot;\n&quot;&#125;&#x27; test.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228191408806.png" alt=""></p>
<blockquote>
<p>截取/etc/passwd的第1,3列</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;&#123;FS=&quot;:&quot;&#125; &#123;print $1 &quot;\t&quot; $3&#125;&#x27; /etc/passwd</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由下图可见,/etc/passwd中的第一行并没有处理</p>
<p>awk会先读入第一行数据,再执行命令</p>
</blockquote>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228193119168.png" alt=""></p>
<blockquote>
<p>加上BEGIN,会在读入第一行数据之前,先执行命令</p>
</blockquote>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228193512426.png" alt=""></p>
<h5 id="END"><a href="#END" class="headerlink" title="END"></a>END</h5><p>在所有命令执行完毕,再执行其后的命令</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228194138995.png" alt="太长了,拼的图"></p>
<h5 id="FS内置变量"><a href="#FS内置变量" class="headerlink" title="FS内置变量"></a>FS内置变量</h5><p>用于指定分隔符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;&#123;print $1 &quot;\t&quot; $3&#125;&#x27; /etc/passwd</span><br></pre></td></tr></table></figure>
<blockquote>
<p>并没有起到提取第1列和第3列的效果</p>
</blockquote>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228192029233.png" alt=""></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;&#123;FS=&quot;:&quot;&#125; &#123;print $1 &quot;\t&quot; $3&#125;&#x27; /etc/passwd</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228192406633.png" alt=""></p>
<h4 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h4><p>sed是一种几乎包括在所有UNIX平台(包括Linux)的轻量级流编辑器.sed主要是用来将数据进行选取、替换、删除、新增的命令</p>
<h3 id="字符处理命令"><a href="#字符处理命令" class="headerlink" title="字符处理命令"></a>字符处理命令</h3><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows10下搭建汇编语言开发环境</title>
    <url>/article/11317.html</url>
    <content><![CDATA[<h1 id="Windows10下搭建汇编语言开发环境"><a href="#Windows10下搭建汇编语言开发环境" class="headerlink" title="Windows10下搭建汇编语言开发环境"></a>Windows10下搭建汇编语言开发环境</h1><a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本学期学校安排有汇编语言这门课,需要自己搭建汇编语言开发环境,特此写下本文记录搭建过程.</p>
<p>关于搭建汇编语言开发环境的教程,我也找了许多,可看下来却依旧一头雾水,经过本人摸索,同时结合网上教程,欲写下这篇易懂的文章.</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="1-下载DOSBox"><a href="#1-下载DOSBox" class="headerlink" title="1.下载DOSBox"></a>1.下载DOSBox</h3><p>工具介绍:DOSBox是一个DOS模拟程序,由于它采用的是SDL库,所以可以很方便的移植到其他的平台.目前,DOSBox已经支持在Windows、Linux、Mac OS X、BeOS 、palmOS、Android 、webOS、os/2等系统中运行.不少DOS下的游戏都可以直接在该平台上运行.</p>
<p>工具官网:</p>
<p><a href="http://www.dosbox.com/" class="LinkCard" target="_blank">工具官网</a></p>
<p>项目主页：</p>
<p><a href="http://sourceforge.net/projects/dosbox" class="LinkCard" target="_blank">项目主页</a></p>
<p>下载链接1(32位):</p>
<p><a href="http://sourceforge.net/projects/dosbox/files/dosbox/0.74/DOSBox0.74-win32-installer.exe/download/" class="LinkCard" target="_blank">下载链接1</a></p>
<p>下载链接2(这个是我下载好的,可能会快一点):</p>
<p><a href="https://idefun.lanzoux.com/i91Xpm4qzyb" class="LinkCard">下载链接2</a></p>
<h3 id="2-下载汇编工具包"><a href="#2-下载汇编工具包" class="headerlink" title="2.下载汇编工具包"></a>2.下载汇编工具包</h3><p>下载链接:</p>
<p><a href="https://idefun.lanzoux.com/i4TQgm4zjkf/" class="LinkCard" target="_blank">下载链接</a></p>
<p>汇编工具截图</p>
<p><img src="https://i.loli.net/2021/02/25/vmXynkcD7V3bwEe.png" alt=""></p>
<h2 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h2><h3 id="1-安装DOSBox"><a href="#1-安装DOSBox" class="headerlink" title="1.安装DOSBox"></a>1.安装DOSBox</h3><p>双击运行DOSBox安装程序</p>
<p><img src="https://i.loli.net/2021/02/25/X7F4cripOvBg1ex.png" alt=""></p>
<p>点击next</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/QXCsuzLV2YNwFBJ.png" alt=""></p>
<p>点击next</p>
<p><img src="https://i.loli.net/2021/02/25/Tr6jgH7u5XQElVD.png" alt=""></p>
<p>选择安装位置(我选择都是D:\DOSBox)然后点击install