<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux C编程</title>
    <url>/blog/2021/01/11/Linux-C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Linux-C编程"><a href="#Linux-C编程" class="headerlink" title="Linux C编程"></a>Linux C编程</h1><p>C语言的源代码文件是一个普通的文本文件,但扩展名是c.而且源代码文件是不能直接执行的,需要编译,编译后的可执行文件只能在指定操作系统下运行.</p>
<p>Linux编译后的可执行程序只能在linux运行,windows编译后的程序只能在windows下运行</p>
<p>64位的linux编译后的程序只能在64位linux下运行,32位linux编译后的程序只能在32位的linux运行.</p>
<p>64位的windows编译后的程序只能在64位windows下运行,32位windows编译后的程序可以在64位的windows运行.</p>
<h2 id="头文件包含"><a href="#头文件包含" class="headerlink" title="头文件包含"></a>头文件包含</h2><p>include有两种写法</p>
<p>#include &lt;文件名&gt;,如果文件在系统目录下,那么需要用&lt;&gt;</p>
<p>#include “文件名”,如果文件在当前目录下，那么用””</p>
<h2 id="System系统调用"><a href="#System系统调用" class="headerlink" title="System系统调用"></a>System系统调用</h2><p>在使用system之前需要包含stdlib.h这个头文件,system主要的功能是通过程序执行另外一个程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">system(<span class="string">&quot;命令&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>如果在命令行执行一个程序，那么这个程序的调用者就是操作系统，如果在代码中通过system执行一个程序，那么这个程序的调用者就是自己写的代码本身.</p>
<p>C语言所有的库函数调用，只能保证语法是一致的，但不能保证执行结果是一致的，同样的库函数在不同的操作系统下执行结果可能是一样的，也可能是不一样的。</p>
<h2 id="POSIX标准"><a href="#POSIX标准" class="headerlink" title="POSIX标准"></a>POSIX标准</h2><p>POSIX是一个标准，只要符合这个标准的函数，在不同的系统下执行的结果就可以一致。</p>
<p>Unix和Linux很多库函数都是支持POSIX的，但windows支持的比较差。</p>
<p>如果将unix代码移植到linux一般代价很小，如果把windows代码移植到unix或者linux就比较麻烦.</p>
<h2 id="C语言处理过程"><a href="#C语言处理过程" class="headerlink" title="C语言处理过程"></a>C语言处理过程</h2><p>C代码编译成可执行程序经过4步:<br>1)预处理:宏定义展开、头文件展开、条件编译等，同时将代码中的注释删除，这里并不会检查语法<br>2)编译:检查语法，将预处理后文件编译生成汇编文件<br>3)汇编:将汇编文件生成目标文件(二进制文件)<br>4)链接: C语言写的程序是需要依赖各种库的，所以编译之后还需要把库链接到最终的可执行程序中去</p>
<p>预处理:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure>
<p>编译:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure>
<p>汇编:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure>
<p>链接:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc hello.o -o hello</span><br></pre></td></tr></table></figure>
<p>查看程序所需动态库:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ldd hello   //linux</span><br></pre></td></tr></table></figure>
<p>交换文件说明:</p>
<ol>
<li>vi写文件，没有保存就关闭，自动生成一个后缀为. swp交换文件， 保存了之前写的内容</li>
<li>先恢复，再删除.swp交换文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi -r &#123;your file name&#125; //恢复</span><br><span class="line">rm &#123;your file name&#125;.swp   //删除</span><br></pre></td></tr></table></figure>
<h2 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h2><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p><strong>C的关键字共有32个</strong></p>
<ul>
<li><p>数据类型关键字(12个)</p>
<p>char, short, int, long, float, double,unsigned, signed, struct, union, enum, void</p>
</li>
<li><p>控制语句关键字(12个)</p>
<p>if, else, switch, case, default,for , do, while, break, continue, goto, return</p>
</li>
<li><p>存储类关键字(5个)</p>
<p>auto,extern,register, static,const</p>
</li>
<li><p>其他关键字(3个)</p>
<p>sizeof, typedef, volatile</p>
</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>数据类型的作用:编译器预算对象(变量)分配的内存空间大小</p>
<p><img src="https://i.loli.net/2021/01/11/JgoTpVBjXIPWQLD.png" alt="image-20210111193755278"></p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul>
<li>在程序运行过程中，其值不能被改变的量</li>
<li>常量一般出现在表达式或赋值语句中</li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul>
<li>在程序运行过程中，其值可以改变</li>
<li>变量在使用前必须先定义，定义变量前必须有相应的数据类型</li>
</ul>
<p>标识符命名规则:</p>
<ul>
<li><p>标识符不能是关键字</p>
</li>
<li><p>标识符只能由字母、数字、下划线组成</p>
</li>
<li><p>第一个字符必须为字母或下划线</p>
</li>
<li><p>标识符中字母区分大小写</p>
</li>
</ul>
<p>变量特点:</p>
<ul>
<li>变量在编译时为其分配相应的内存空间</li>
<li>可以通过其名字和地址访问相应内存</li>
</ul>
<p>声明和定义区别:</p>
<ul>
<li>声明变量不需要建立存储空间，如: extern int a;(a不能赋值)</li>
<li>定义变量需要建立存储空间，如: int b;</li>
<li>-般的情况下，把建立存储空间的声明称之为“定义”，而把不需要建立存储空间的声明称之为”声明”.</li>
</ul>
<h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h3><h4 id="C语言如何表示相应的进制数"><a href="#C语言如何表示相应的进制数" class="headerlink" title="C语言如何表示相应的进制数"></a>C语言如何表示相应的进制数</h4><table>
<thead>
<tr>
<th>十进制</th>
<th>以正常数字1-9开头,如123</th>
</tr>
</thead>
<tbody><tr>
<td>八进制</td>
<td>以0(零)开头,如0123</td>
</tr>
<tr>
<td>十六进制</td>
<td>以0x开头,如0x123</td>
</tr>
<tr>
<td>二进制</td>
<td>C语言不能直接书写二进制数</td>
</tr>
</tbody></table>
<h3 id="计算机内存数值存储方式"><a href="#计算机内存数值存储方式" class="headerlink" title="计算机内存数值存储方式"></a>计算机内存数值存储方式</h3><p>在计算机系统中，数值一律用补码来存储。</p>
<h4 id="原码"><a href="#原码" class="headerlink" title="原码:"></a>原码:</h4><p>最高位为符号位:0代表正数,1代表负数​</p>
<p>原码存储导致2个问题:</p>
<ol>
<li> 0有两种存储方式</li>
<li> 正数和负数相加结果不正确</li>
</ol>
<h4 id="反码"><a href="#反码" class="headerlink" title="反码:"></a>反码:</h4><p>反码是为了算补码.正数的原码和反码是一样的,负数的反码在原码基础上,符号位不变,其它位取反(0为1,1变0 ).</p>
<p>反码存储导致1个问题:</p>
<ol>
<li> 0有两种存储方式</li>
</ol>
<h4 id="补码"><a href="#补码" class="headerlink" title="补码:"></a>补码:</h4><p>正数的原码,反码,补码都一样</p>
<p>负数的补码为其反码加1</p>
<p>十进制数,站在用户角度看,<strong>原码</strong>;二进制,八进制,十六进制,要站在计算机角度看,<strong>补码</strong>.</p>
<p>原码求补码:</p>
<ol>
<li>正数原,反,补码均相同</li>
<li>负数原码最高位不变,其他位取反得反码</li>
<li>反码加1得补码</li>
</ol>
<p>补码求原码(同上面类似):</p>
<ol>
<li>正数原,反,补码均相同</li>
<li>负数补码最高位不变,其他位取反得反码</li>
<li>反码加1得原码</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> a=<span class="number">0x81</span>;<span class="comment">//a是值为十六进制数的字符,在计算机看来是补码</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);<span class="comment">//%d为输出十进制数,在用户看来是原码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序运行结果如下:</p>
<p><img src="https://i.loli.net/2021/01/12/l23jvtQaPwTHyWG.png"></p>
<p>按照十六进制转十进制,0x81等于129而不是-127</p>
<p>分析:</p>
<ol>
<li>0x81在计算机角度看来应为补码存储,其二进制形式为10000001</li>
<li>输出%d即输出十进制数,十进制数在用户角度为原码</li>
<li>由(1)(2)知,该程序即将0x81的补码转换为原码</li>
<li>其原码为11111111,即-127</li>
</ol>
<p>有符号和无符号的区别:</p>
<ul>
<li>%d,默认以有符号的方式打印</li>
<li>%u,默认以无符号的方式打印</li>
<li>有符号，最高位是符号位，如果是1代表为负数，如果为0代表为正数</li>
<li>无符号，最高位不是符号位，是数的一部分，无符号不可能是负数</li>
</ul>
<p>数据类型范围:</p>
<p>char    1个字节</p>
<img src="https://i.loli.net/2021/01/12/UNxsfOjRD2cu9eY.png" alt="image-20210112214358475" style="zoom:80%;" />

<p>数值越界:</p>
<p>通过以下代码解释</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">//情况1 有符号</span></span><br><span class="line">        <span class="comment">//char 范围 -128~127</span></span><br><span class="line">        <span class="keyword">char</span> a=<span class="number">127</span>+<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/* a=129,转换二进制为1000 0001,</span></span><br><span class="line"><span class="comment">          二进制(1000 0001)以补码形式存储,</span></span><br><span class="line"><span class="comment">          输出为%d,要求得原码(11111111),</span></span><br><span class="line"><span class="comment">          即-127</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);<span class="comment">//输出-127</span></span><br><span class="line">        <span class="comment">//情况2 无符号</span></span><br><span class="line">        <span class="comment">//无符号 范围 0~255</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> b=<span class="number">255</span>+<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/* b=257,转换二进制为1 0000 0001,</span></span><br><span class="line"><span class="comment">           舍弃最高位为0000 0001,</span></span><br><span class="line"><span class="comment">           二进制(0000 0001)以补码形式存储,</span></span><br><span class="line"><span class="comment">           转为原码(0000 0001),</span></span><br><span class="line"><span class="comment">           即1</span></span><br><span class="line"><span class="comment">           注意编译时会警告,之后./文件名运行即可</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>,b);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下:</p>
<p><img src="https://i.loli.net/2021/01/13/GL8cpTQzUtFu7n1.png" alt="image-20210113191321188"></p>
<h4 id="sizeof关键字"><a href="#sizeof关键字" class="headerlink" title="sizeof关键字"></a>sizeof关键字</h4><ul>
<li>sizeof不是函数，所以不需要包含任何头文件，它的功能是计算一个数据类型的大小，单位为字节</li>
<li>sizeof的返回值为size_ t</li>
<li>size_t 类型在32位操作系统下是unsigned int,是一个无符号的整数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*数据类型的作用:告诉编译器,</span></span><br><span class="line"><span class="comment">    定义此类型变量需要分配多大空间*/</span>					<span class="built_in">printf</span>(<span class="string">&quot;sizeof(char)=%lu\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">   	<span class="built_in">printf</span>(<span class="string">&quot;sizeof(a)=%lu\n&quot;</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下:</p>
<img src="https://i.loli.net/2021/01/13/3VmSN7iDcPkwLsY.png" style="zoom:150%;" />

<p>%d,%o,%x,%u等均以四个字节形式打印.</p>
<p>short占两个字节,short a;与short int a;等价.</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>占用空间</th>
</tr>
</thead>
<tbody><tr>
<td>short (短整型)</td>
<td>2字节</td>
</tr>
<tr>
<td>int (整型)</td>
<td>4字节</td>
</tr>
<tr>
<td>1ong(长整形)</td>
<td>Windows为4字节，Linux为 4字节(32位)，8字节(64位)</td>
</tr>
<tr>
<td>long long (长长整形)</td>
<td>8字节</td>
</tr>
</tbody></table>
<h3 id="字符型变量"><a href="#字符型变量" class="headerlink" title="字符型变量"></a>字符型变量</h3><p>字符型变量用于存储一个单一字符，在C语言中用char 表示，其中每个字符变量都会占用1个字节。在给字符型变量赋值时，需要用一对英文半角格式的单引号(‘ ‘)把字符括起来。<br>字符变量实际上并不是把该字符本身放到变量的内存单元中去，而是将该字符对应的ASCII 编码放到变量的存储单元中。char 的本质就是一个1 字节大小的整型。</p>
<p>使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man ascii</span><br></pre></td></tr></table></figure>
<p>查看ASCII码</p>
<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>字符在单引号内,原则上’ ‘内部只有一个字符,转义字符除外,不能char a=’abc’</p>
<p>转义字符由反斜杠\组成的多个字符</p>
<p>例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> a=<span class="string">&#x27;\r&#x27;</span>;<span class="comment">//光标移到句首</span></span><br><span class="line">        <span class="keyword">char</span> b=<span class="string">&#x27;\b&#x27;</span>;<span class="comment">//退格</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;12345%c6789\n&quot;</span>,a);<span class="comment">//先打印12345,之后光标移到句首再依次打印6789,其中1234被覆盖,留下5,结果为67895</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;abcde%cfghi\n&quot;</span>,b);<span class="comment">//先打印abcde之后打印\b,退一格,e就没了,结果为abcdfghi</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/22/wYUVzd2mpNqX3LQ.png"></p>
<h3 id="浮点型-实型"><a href="#浮点型-实型" class="headerlink" title="浮点型(实型)"></a>浮点型(实型)</h3><p>实型变量也可以称为浮点型变量，浮点型变量是用来存储小数数值的。在C语言中，浮点型变量分为两种:单精度浮点数(float)、双精度浮点数(double)，但是double型变量所表示的浮点数比float 型变量更精确。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>占用空间</th>
<th>有效数字范围</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>4字节</td>
<td>7位有效数字</td>
</tr>
<tr>
<td>double</td>
<td>8字节</td>
<td>15~ 16位有效数字</td>
</tr>
</tbody></table>
<p>float存储不准确</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">float</span> a=<span class="number">100.9</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,a);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/22/pT1JRNYS97IyjM4.png"></p>
<h3 id="类型限定符"><a href="#类型限定符" class="headerlink" title="类型限定符"></a>类型限定符</h3><table>
<thead>
<tr>
<th>限定符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>extern</td>
<td>声明一个变量，extexn 声明的变量没有建立存储空间。extern int a;</td>
</tr>
<tr>
<td>const</td>
<td>定义一个常量，常量的值不能修改。const int a 10;</td>
</tr>
<tr>
<td>vo1atile</td>
<td>防止编译器优化代码</td>
</tr>
<tr>
<td>register</td>
<td>定义寄存器变量，提高效率。 register是建议型的指令，而不是命令型的指令，如果CPU有空闲寄存器，那么register就生效， 如果没有空闲寄存器，那么register无效。</td>
</tr>
</tbody></table>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>字符串常量与字符常量的不同:<br>‘a’为字符常量，”a”为字符串常量</p>
<p><img src="https://i.loli.net/2021/01/22/hAXpsqiEMktCuyn.png" alt="image-20210113191321188"></p>
<p>每个字符串的结尾，编译器会自动的添加一一个结束标志位’\0’,即”a” 包含<br>两个字符’a’和’\0’。</p>
<p>%%在屏幕输出一个%，后面的d也会输出</p>
<p>%5d,以5个字符输出,没有的字符以空字符填充,默认是右对齐</p>
<p>%05d,以5个字符输出,没有的字符以0填充,默认是右对齐</p>
<p>%-5d,以5个字符输出,没有的字符以空字符填充,-代表指定为左对齐</p>
<p>0和-不能同时使用</p>
<p><img src="https://i.loli.net/2021/01/22/ts6idzBZGxWJveY.png"></p>
<h3 id="puts"><a href="#puts" class="headerlink" title="puts()"></a>puts()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[]=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">puts</span>(buf);<span class="comment">//把buf内容输出到屏幕,自动在屏幕加换行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);<span class="comment">//没有加换行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/29/u4frlgbByp9IMoT.png"></p>
<h3 id="fputs"><a href="#fputs" class="headerlink" title="fputs()"></a>fputs()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[]=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="comment">//向stdout(代表屏幕,标准输出)输出buf的内容</span></span><br><span class="line">    <span class="built_in">fputs</span>(buf,<span class="built_in">stdout</span>);<span class="comment">//没有加换行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/29/r64eO1HkSZt9JXd.png" alt="image-20210129141616052"></p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><h3 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h3><p>scanf()的缺陷，不做越界检查,不允许有空格</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入字符串:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%s\n&quot;</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/29/foM25d9lpc8aQUR.png"></p>
<h3 id="gets"><a href="#gets" class="headerlink" title="gets()"></a>gets()</h3><p>gets()从键盘读取字符串，放在指定的数组<br>gets()允许有空格，不做越界检查，此函数不安全</p>
<h3 id="fgets"><a href="#fgets" class="headerlink" title="fgets()"></a>fgets()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">//从stdin(代表标准输入,键盘)读取内容</span></span><br><span class="line">        <span class="comment">/*如果输入内容大于sizeof(buf)-1,只取	</span></span><br><span class="line"><span class="comment">        sizeof(buf)-1,放在buf所在数组;</span></span><br><span class="line"><span class="comment">        当不足sizeof(buf)-1,会把换行符读进去*/</span></span><br><span class="line">        fgets(buf,<span class="keyword">sizeof</span>(buf),<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buf=%s\n&quot;</span>,buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/29/qgh4QbsSC7MvWfd.png"></p>
<p>fgets()允许有空格</p>
<p><img src="https://i.loli.net/2021/01/29/6vIXpuY7SQeEKUM.png"></p>
<p>当不足sizeof(buf)-1,会把换行符读进去</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    fgets(buf,<span class="keyword">sizeof</span>(buf),<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf=#%s#\n&quot;</span>,buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/29/3gJLWmkOlP8fQKI.png"></p>
<h3 id="输入字符"><a href="#输入字符" class="headerlink" title="输入字符"></a>输入字符</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入字符:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;a);<span class="comment">//假设输入c</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a=&#x27;%c&#x27;\n&quot;</span>,a);</span><br><span class="line">        <span class="keyword">char</span> b;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入字符:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;b);<span class="comment">//假设输入d</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;b=&#x27;%c&#x27;\n&quot;</span>,b);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个程序看似简单,结果为a=c,b=d,其实不然,结果如下:</p>
<p><img src="https://i.loli.net/2021/01/22/itzxmayI15d6uqO.png"></p>
<p>无需输入d直接出结果</p>
<p>原因:</p>
<p>当用户输入字符时,编译器默认把输入的内容先放在一块内存中(缓冲区) , scanf()自动在缓冲区读内容(只读一个字符).第一次输入时输入了c\n(回车),scanf取走了c,留下\n还在缓存区,第2次scanf ,由于缓冲区还有内容,所以直接取内容,无需再输入</p>
<p>所以,上面的程序可以这样写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入字符:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;a);<span class="comment">//假设输入c</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a=&#x27;%c&#x27;\n&quot;</span>,a);</span><br><span class="line">        <span class="comment">//吃掉上一步的\n,不做处理</span></span><br><span class="line">        <span class="keyword">char</span> b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;b);</span><br><span class="line">        <span class="keyword">char</span> t;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入字符:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;t);<span class="comment">//假设输入d</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;t=&#x27;%c&#x27;\n&quot;</span>,t);</span><br><span class="line">    	<span class="comment">//或者都在一个scanf中写</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输入字符串"><a href="#输入字符串" class="headerlink" title="输入字符串"></a>输入字符串</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入字符串a:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);<span class="comment">//假设输入hello world</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%s\n&quot;</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入字符串b:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b=%s\n&quot;</span>,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下:</p>
<p><img src="https://i.loli.net/2021/01/29/OUtFhK74fAaNsj5.png"></p>
<p>原因:</p>
<p>当输入hello world时,第一个scanf取走第一个空格前的字符串,即hello;第二个scanf取第一个空格后第二个空格前的内容,\n不取</p>
<p>switch语句</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">        <span class="comment">//1、switch是关键字， switch() 后面没有分号</span></span><br><span class="line">        <span class="comment">//2、switch()中() 里只能放整型变量或字符型变量</span></span><br><span class="line">        <span class="keyword">switch</span>(num)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;1楼\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;2楼\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;3楼\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;其他楼层\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>goto语句</p>
<p>goto(只能跳转到同一作用域)任意地方都能使用,无条件跳转,不能滥用,代码会很乱</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">goto</span> hello;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1111111111\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2222222222\n&quot;</span>);</span><br><span class="line">        hello:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;3333333333\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://i.loli.net/2021/01/28/fNUX46T5h1YqSc9.png" alt="image-20210122205440917" style="zoom:150%;" />

<p>类型转换:</p>
<p>1.隐式转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> a;</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//编译器自动转换，把b转 换为double类型后， 再给a赋值(隐式转换)</span></span><br><span class="line">a= b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>，b) ;</span><br></pre></td></tr></table></figure>
<p>2.强制类型转换  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="comment">//a只有在此语句执行时，才强制转换为double类型，其它地址还是为int类型</span></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%lf\n&quot;</span>，(<span class="keyword">double</span>)a) ;<span class="comment">//(类型)变量名</span></span><br></pre></td></tr></table></figure>
<p>转换原则:占用内存字节数少(值域小)的类型，向占用内存字节数多(值域大)的类型转换，以保证精度不降低。</p>
<p>3.浮点型和整型打印问题<br>a)不要直接通过%d，打印一个浮点型变量，得不到想要的结果，要想得到结果，强制类型转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> a = <span class="number">11.11</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(<span class="keyword">int</span>)a) ;</span><br></pre></td></tr></table></figure>
<p>b)不要直接通过%f或%lf，打印一个整型变量，得不到想要的结果，要想得到结果，强制类型转换</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol>
<li>数组内部的变量或数组,不初始化,它的值为随机数</li>
<li>部分初始化，其它自动初始化为0<br>0~2(前3个元素)分别为1，2， 3， 其 它初始化为0<br>int a1[10] = {1, 2, 3};</li>
<li>数组全部元素初始化为0<br>int a2[10] = {0} ;</li>
<li>如果定义时同时初始化，第1个[]内部可以不写内容<br>编译器会根据用户初始化的元素来确定数组的大小<br>int a3[]={1,2,3,4,5,6,7,8,9,10};</li>
<li>如果第1个[]内容不写，必须初始化，否则语法错误</li>
</ol>
<h3 id="数组名"><a href="#数组名" class="headerlink" title="数组名"></a>数组名</h3><ul>
<li>数组名是常量,不能修改</li>
<li>数组名是数组首元素地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a=%p,&amp;a[0]=%p\n&quot;</span>,a,&amp;a[<span class="number">0</span>]);<span class="comment">//%p输出地址</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sizeof(a)=%lu\n&quot;</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/23/EFTYRgCKmLP263d.png"></p>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>内存中没有多维,只有一维,多维数组是特殊的一维数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果定义时，同时初始化，第1个[]可以不写内容</span></span><br><span class="line"><span class="keyword">int</span> a1[][<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;<span class="comment">//正确</span></span><br><span class="line"><span class="comment">//如果第1个[]不写，必须初始化</span></span><br><span class="line"><span class="keyword">int</span> a3[][<span class="number">4</span>]; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3><ol>
<li>C语言没有字符串类型,用字符数组模拟</li>
<li>字符串一定是字符数组,字符数组就不一定是字符串</li>
<li>如果字符数组以字符’\0’ (‘\0’等级于数字0)结尾,那么这个字符数组就是字符串</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、C语言没有字符串类型，用字符数组模拟</span></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//2、字符串一定是字符数组，字符数组就不一定是字符串</span></span><br><span class="line"><span class="comment">//3、如果字符数组以字符&#x27;\0&#x27;(&#x27;\0&#x27;等级于数字0)结尾，那么这个字符数组就是字符串</span></span><br><span class="line"><span class="keyword">char</span> b[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;; <span class="comment">//字符数组,方括号中不能填数字,否则会自动补零,就变成字符串</span></span><br><span class="line"><span class="keyword">char</span> c[<span class="number">10</span>] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;; <span class="comment">//字符串</span></span><br><span class="line"><span class="keyword">char</span> d[<span class="number">10</span>] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="number">0</span>&#125;; <span class="comment">//字符串</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[]=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%s\n&quot;</span>,a);<span class="comment">//会乱码,没有结束符</span></span><br><span class="line">    <span class="keyword">char</span> b[]=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b=%s\n&quot;</span>,b);<span class="comment">//输出abc,遇到\0就停止</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/27/Re83qQAwDB7K42Y.png"></p>
<p>字符数组初始化(常用)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>]=<span class="string">&quot;abcde&quot;</span>;<span class="comment">//最多写9个字符,留一个放结束符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%s\n&quot;</span>,a);</span><br><span class="line"><span class="keyword">char</span> b[]=<span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b=%s\n&quot;</span>,b);<span class="comment">//sizeof()测数据类型大小，不会因为结束符提前结束</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(b)=%lu\n&quot;</span>,<span class="keyword">sizeof</span>(b));<span class="comment">//输出6,b这个数组有5个字符,会自动补加结束符(隐藏)</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/27/iDy86UJt1X2r3ZK.png"></p>
<p>\0后面最好不要跟数字,有可能组成转义字符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[]=<span class="string">&quot;\0abc&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%s\n&quot;</span>,a);<span class="comment">//输出为空,含有结束符\0</span></span><br><span class="line">    <span class="keyword">char</span> b[]=<span class="string">&quot;\0417abcde&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b=%s\n&quot;</span>,b);<span class="comment">//输出非空,\0与其后数字组成转义字符\041,通过man ascii命令查到\041对应!(感叹号)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/27/VJXSilNmnR6wyhB.png"></p>
<p>函数的调用:产生随机数</p>
<p>当调用函数时，需要关心5要素:</p>
<ul>
<li>头文件:包含指定的头文件</li>
<li>函数名字:函数名字必须和头文件声明的名字一样</li>
<li>功能:需要知道此函数功能后再调用</li>
<li>参数:参数类型要匹配</li>
<li>返回值:根据需要接收返回值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;//产生随机数的函数包含在此</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;//获取当前系统时间的函数包含在此</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">//先设置种子,种子设置一次即可</span></span><br><span class="line">        <span class="comment">//srand(10);</span></span><br><span class="line">        <span class="comment">/*如果srand()参数一样,则每次产生的随机数一样,</span></span><br><span class="line"><span class="comment">        每次启动计算机以后，种子就是定值了，</span></span><br><span class="line"><span class="comment">        所以根据公式推算出来的结果</span></span><br><span class="line"><span class="comment">        （也就是生成的随机数）就是固定的*/</span></span><br><span class="line">        <span class="comment">/*time(NULL)用来获取系统当前时间,</span></span><br><span class="line"><span class="comment">        由于时间会变,srand()也会改变*/</span></span><br><span class="line">        srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">                num=rand();<span class="comment">//rand()产生随机数</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;num=%d\n&quot;</span>,num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/27/lTzVDuG41P6RUr7.png"></p>
]]></content>
      <categories>
        <category>C&amp;C++</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Web学习</title>
    <url>/blog/2021/01/10/Web%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Web学习"><a href="#Web学习" class="headerlink" title="Web学习"></a>Web学习</h1><a id="more"></a>

<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><h4 id="input控件"><a href="#input控件" class="headerlink" title="input控件"></a>input控件</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;属性值&quot;</span> <span class="attr">value</span>=<span class="string">&quot;你好&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<table>
    <tr>
        <th>属性</th>
        <th>属性值</th>
        <th>描述</th>  
    </tr >
    <tr >
        <td rowspan="16">type</td>
        <td>text</td>
        <td>单行文本输入框</td>
    </tr>
    <tr>
        <td>password</td>
        <td>密码输入框</td>
    </tr>
    <tr>
        <td>radio</td>
        <td>单选按钮</td>
    </tr>
    <tr>
        <td>CheckBox</td>
        <td>复选按钮</td>
    </tr>
    <tr><td>button</td>
        <td>普通按钮</td>
    </tr>
    <tr>
        <td>submit</td>
        <td>提交按钮</td>
    </tr>
    <tr>
        <td>reset</td>
        <td>重置按钮</td>
    </tr>
    <tr>
        <td>image</td>
        <td>图像形式的提交按钮</td>
    </tr>
    <tr>
        <td >file</td>
        <td>文件域</td>
    </tr>
    <tr>
        <td>number</td>
        <td>数字框,只能输入数字,右侧多出加减符号</td>
    </tr>
    <tr>
        <td>url</td>
        <td>网址输入框</td>
    </tr>
    <tr>
        <td>email</td>
        <td>邮箱输入框</td>
    </tr>
    <tr>
        <td>date</td>
        <td>日期</td>
    </tr>
    <tr>
        <td>color</td>
        <td>颜色选择表单</td>
    </tr>
    <tr>
        <td>tel</td>
        <td>手机号码</td>
    </tr>
    <tr>
        <td>search</td>
        <td>搜索框</td>
    </tr>
    <tr>
        <td >name</td>
        <td>用户自定义</td>
        <td>控件名称</td>
    </tr>
    <tr>
        <td >value</td>
        <td >用户自定义</td>
        <td >默认文本值</td>
    </tr>
    <tr>
        <td >size</td>
        <td >正整数</td>
        <td >控件在页面中的显示宽度</td>
    </tr>
    <tr>
        <td >checked</td>
        <td >checked</td>
        <td >定义选择控件默认被选中项</td>
    </tr>
    <tr>
        <td >maxlength</td>
        <td >正整数</td>
        <td >控件允许输入的最多字符</td>
    </tr>
    <tr>
        <td >placeholder</td>
        <td >自定义</td>
        <td >占位符</td>
    </tr>
    <tr>
        <td >required</td>
        <td >required</td>
        <td >内容不能为空,必填</td>
    </tr>
    <tr>
        <td >autofocus</td>
        <td >autofocus</td>
        <td >自动聚焦属性,页面加载完成自动聚焦到指定表单</td>
    </tr>
    <tr>
        <td >multiple</td>
        <td >multiple</td>
        <td >可以多选文件提交</td>
    </tr>
    <tr>
        <td >autocomplete</td>
        <td >on/off(默认为on[开启])</td>
        <td >当用户在字段开始键入时,浏览器基于之前键入过的值,显示出在字段中填写过的选项。使用要求:1.需要放在表单内同时加上name属性2.同时成功提交(off用得多)
</td>
    </tr>
</table>

<h4 id="label标签"><a href="#label标签" class="headerlink" title="label标签"></a>label标签</h4><p>label标签不会向用户呈现任何特殊效果，它的作用是为鼠标用户改进了可用性。如果你在 label 标签内点击文本，就会触发此控件。就是说，当用户单击选中该label标签时，浏览器就会自动将焦点转到和标签相关的表单控件上（就自动选中和该label标签相关连的表单控件上）。</p>
<p>语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;控件id名称&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：标签的 for 属性中的值应当与相关控件的 id 属性值一定要相同。</p>
<p>例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;email&quot;</span>&gt;</span>输入你的邮箱地址<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">id</span>=<span class="string">&quot;email&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter email&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="textarea控件-文本域"><a href="#textarea控件-文本域" class="headerlink" title="textarea控件(文本域)"></a>textarea控件(文本域)</h4><p>当用户需要在表单中输入大段文字时，需要用到文本输入域。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">&quot;行数&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;列数&quot;</span>&gt;</span>文本<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>1、<strong>cols ：</strong>多行输入域的<strong>列数</strong>。</p>
<p>2、<strong>rows ：</strong>多行输入域的<strong>行数</strong>。</p>
<p><strong>举例：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;save.php&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">label</span>&gt;</span>联系我们<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">cols</span>=<span class="string">&quot;50&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span> &gt;</span>在这里输入内容...<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="select下拉列表"><a href="#select下拉列表" class="headerlink" title="select下拉列表"></a>select下拉列表</h4><p>下拉列表:</p>
<p>下拉列表在网页中也常会用到，它可以有效的节省网页空间。既可以单选、又可以多选。如下代码：</p>
<p><img src="https://i.loli.net/2021/01/10/1cExMyhR3dkTeKi.png" alt="img"></p>
<p><strong>讲解：</strong></p>
<p>1、select和option标签都是双标签，它总是成对出现的，需要首标签和尾标签。</p>
<p>2、select标签里面只能放option标签，表示下拉列表的选项。</p>
<p>3、option标签放选项内容，不放置其他标签。</p>
<p>4、value：</p>
<p><img src="https://i.loli.net/2021/01/10/VAhEQFzT7dNoMO8.png" alt="img"></p>
<p>5、selected=”selected”：</p>
<p>设置selected=”selected”属性，则该选项就被默认选中。</p>
<p>在浏览器中显示的结果：</p>
<p><img src="https://i.loli.net/2021/01/10/p8nCDEVleONLkjg.png" alt="img"></p>
<h4 id="form表单域"><a href="#form表单域" class="headerlink" title="form表单域"></a>form表单域</h4><p>网站怎样与用户进行交互？答案是使用HTML表单(form)。表单是可以把浏览者输入的数据传送到服务器端，这样服务器端程序就可以处理表单传过来的数据。</p>
<p>语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;服务器文件/url地址&quot;</span> <span class="attr">method</span>=<span class="string">&quot;传送方式&quot;</span> <span class="attr">name</span>=<span class="string">&quot;表单名称&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>讲解：</strong></p>
<p>1.<strong>action</strong> <strong>：</strong>浏览者输入的数据被传送到的地方,比如一个PHP页面(save.php)。</p>
<p>2.<strong>method</strong> <strong>：</strong> 数据传送的方式（get/post）。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>  <span class="attr">action</span>=<span class="string">&quot;save.php&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>用户名:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;pass&quot;</span>&gt;</span>密码:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pass&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<p><strong>1、所有表单控件（文本框、文本域、按钮、单选框、复选框等）都必须放在 form 标签之间（否则用户输入的信息可提交不到服务器上哦！）。</strong></p>
<p><strong>2、method : post/get 的区别这一部分内容属于后端程序员考虑的问题。</strong></p>
<h3 id="html5语义化标签"><a href="#html5语义化标签" class="headerlink" title="html5语义化标签"></a>html5语义化标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span> :头部标签</span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span> :导航标签</span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span> :内容标签</span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span> : 块级标签</span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span> :侧边栏标签</span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span> :尾部标签</span><br></pre></td></tr></table></figure>
<ul>
<li>这种语义化标准主要针对搜索引擎的</li>
<li>这些标签页面中可以使用多次</li>
<li>在IE9中,需要把这些元素转换为块级元素</li>
<li>移动端更喜欢使用这些标签</li>
</ul>
<h3 id="多媒体标签"><a href="#多媒体标签" class="headerlink" title="多媒体标签"></a>多媒体标签</h3><p>谷歌浏览器把音频和规频自动播放禁止了</p>
<h4 id="音频标签"><a href="#音频标签" class="headerlink" title="音频标签"></a>音频标签</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;文件地址&quot;</span> <span class="attr">controls</span>=<span class="string">&quot;controls&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>=<span class="string">&quot;controls&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;mp3格式视频&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/mpeg&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;ogg格式视频&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/ogg&quot;</span>&gt;</span></span><br><span class="line">	您的浏览器暂不支持audio标签播放音频.</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h5><p>Internet Explorer 9+, Firefox, Opera, Chrome, 和 Safari 都支持 <audio> 元素.</p>
<p><strong>注意:</strong> Internet Explorer 8 及更早IE版本不支持 &lt;audio&gt; 元素.</p>
<h5 id="音频格式及浏览器支持"><a href="#音频格式及浏览器支持" class="headerlink" title="音频格式及浏览器支持"></a>音频格式及浏览器支持</h5><p>目前, &lt;audio&gt;元素支持三种音频格式文件: MP3, Wav和Ogg:</p>
<table>
<thead>
<tr>
<th align="left">浏览器</th>
<th align="left">MP3</th>
<th align="left">Wav</th>
<th align="left">Ogg</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Internet Explorer 9+</td>
<td align="left">YES</td>
<td align="left">NO</td>
<td align="left">NO</td>
</tr>
<tr>
<td align="left">Chrome 6+</td>
<td align="left">YES</td>
<td align="left">YES</td>
<td align="left">YES</td>
</tr>
<tr>
<td align="left">Firefox 3.6+</td>
<td align="left">YES</td>
<td align="left">YES</td>
<td align="left">YES</td>
</tr>
<tr>
<td align="left">Safari 5+</td>
<td align="left">YES</td>
<td align="left">YES</td>
<td align="left">NO</td>
</tr>
<tr>
<td align="left">Opera 10+</td>
<td align="left">YES</td>
<td align="left">YES</td>
<td align="left">YES</td>
</tr>
</tbody></table>
<p>因为不同浏览器支持不同格式，采取的解决方案是为这个音频准备多个格式</p>
<h5 id="音频标签常见属性"><a href="#音频标签常见属性" class="headerlink" title="音频标签常见属性"></a>音频标签常见属性</h5><table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>autoplay</td>
<td>autoplay</td>
<td>如果出现该属性，则音频在就绪后马上播放。</td>
</tr>
<tr>
<td>controls</td>
<td>controls</td>
<td>如果出现该属性，则向用户显示控件，比如播放按钮。</td>
</tr>
<tr>
<td>loop</td>
<td>loop</td>
<td>如果出现该属性，则每当音频结束时重新开始播放。</td>
</tr>
<tr>
<td>src</td>
<td>url</td>
<td>要播放的音频的URL。</td>
</tr>
</tbody></table>
<h4 id="视频标签"><a href="#视频标签" class="headerlink" title="视频标签"></a>视频标签</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;文件地址&quot;</span> <span class="attr">controls</span>=<span class="string">&quot;controls&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;mp4文件&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;ogg文件&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/ogg&quot;</span>&gt;</span></span><br><span class="line">    您的浏览器暂不支持video标签播放视频.</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="浏览器支持-1"><a href="#浏览器支持-1" class="headerlink" title="浏览器支持"></a>浏览器支持</h5><p>Internet Explorer 9+, Firefox, Opera, Chrome, 和 Safari 支持 &lt;video&gt; 元素.</p>
<p><strong>注意:</strong> Internet Explorer 8 或者更早的IE版本不支持 &lt;video&gt; 元素。</p>
<p>当前， &lt;video&gt; 元素支持三种视频格式： MP4, WebM和 Ogg:</p>
<table>
<thead>
<tr>
<th align="left">浏览器</th>
<th align="left">MP4</th>
<th align="left">WebM</th>
<th align="left">Ogg</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Internet Explorer</td>
<td align="left">YES</td>
<td align="left">NO</td>
<td align="left">NO</td>
</tr>
<tr>
<td align="left">Chrome</td>
<td align="left">YES</td>
<td align="left">YES</td>
<td align="left">YES</td>
</tr>
<tr>
<td align="left">Firefox</td>
<td align="left">YES</td>
<td align="left">YES</td>
<td align="left">YES</td>
</tr>
<tr>
<td align="left">Safari</td>
<td align="left">YES</td>
<td align="left">NO</td>
<td align="left">NO</td>
</tr>
<tr>
<td align="left">Opera</td>
<td align="left">YES (从 Opera 25 起)</td>
<td align="left">YES</td>
<td align="left">YES</td>
</tr>
</tbody></table>
<ul>
<li>MP4 = 带有 H.264 视频编码和 AAC 音频编码的 MPEG 4 文件</li>
<li>WebM = 带有 VP8 视频编码和 Vorbis 音频编码的 WebM 文件</li>
<li>Ogg = 带有 Theora 视频编码和 Vorbis 音频编码的 Ogg 文件</li>
</ul>
<h5 id="视频标签常见属性"><a href="#视频标签常见属性" class="headerlink" title="视频标签常见属性"></a>视频标签常见属性</h5><table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>autoplay</td>
<td>autoplay</td>
<td>视频就绪自动播放(谷歌浏览器需要添加muted来解决自动播放问题)</td>
</tr>
<tr>
<td>controls</td>
<td>controls</td>
<td>向用户显示播放控件</td>
</tr>
<tr>
<td>width</td>
<td>pixels(像素)</td>
<td>设置播放器宽度</td>
</tr>
<tr>
<td>height</td>
<td>pixels(像素)</td>
<td>设置播放器高度</td>
</tr>
<tr>
<td>loop</td>
<td>loop</td>
<td>播放完是否继续播放该视频，循环播放</td>
</tr>
<tr>
<td>preload</td>
<td>auto<br/>metadata<br/>none</td>
<td>如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。</td>
</tr>
<tr>
<td>src</td>
<td>url</td>
<td>视频url地址</td>
</tr>
<tr>
<td>poster</td>
<td>url</td>
<td>加载等待的画面图片地址</td>
</tr>
<tr>
<td>muted</td>
<td>muted</td>
<td>静音播放</td>
</tr>
</tbody></table>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="CSS的三种引用方式"><a href="#CSS的三种引用方式" class="headerlink" title="CSS的三种引用方式"></a>CSS的三种引用方式</h3><ol>
<li>内联样式(行内式)</li>
<li>嵌入样式(内部式)</li>
<li>外部样式(外链式)</li>
</ol>
<table>
<thead>
<tr>
<th>样式表</th>
<th>优点</th>
<th>缺点</th>
<th>使用情况</th>
<th>控制范围</th>
</tr>
</thead>
<tbody><tr>
<td>行内样式表</td>
<td>书写方便,权重高</td>
<td>没有实现结构和样式相分离</td>
<td>较少</td>
<td>控制一个标签</td>
</tr>
<tr>
<td>内部样式表</td>
<td>部分结构和样式相分离</td>
<td>没有彻底分离</td>
<td>较多</td>
<td>控制一个页面</td>
</tr>
<tr>
<td>外部样式表</td>
<td>完全实现结构和样式相分离</td>
<td>需要引入</td>
<td>最多</td>
<td>控制多个站点</td>
</tr>
</tbody></table>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><h4 id="font-family"><a href="#font-family" class="headerlink" title="font-family"></a>font-family</h4><p>可同时指定多个字体,中间以逗号隔开,表示如果浏览器不支持第一个字体,则会尝试下一个,直到找到合适的字体</p>
<h4 id="CSS-Unicode字体"><a href="#CSS-Unicode字体" class="headerlink" title="CSS Unicode字体"></a>CSS Unicode字体</h4><ul>
<li><p>为什么使用Unicode字休</p>
<ul>
<li>在CSS中设置字体名称，直接写中文是可以的。但是在文件编码(GB2312、 UTF 8等)不匹配时会产生乱码的错误。</li>
<li>xp系统不支持类似微软雅黑的中文。</li>
</ul>
</li>
<li><p>解决:</p>
<ul>
<li>方案一:你可以使用英文来替代。比如font-family: “Microsoft Yahei”。</li>
<li>方案二:在CSS直接使用Unicode编码来写字体名称可以避免这些错误。使用Unicode写中文字体名称，浏览器是可以正确的解析的。</li>
</ul>
</li>
</ul>
<h4 id="font-weight"><a href="#font-weight" class="headerlink" title="font-weight"></a>font-weight</h4><ul>
<li>在html中将字体加粗我们可以用标签来实现<ul>
<li>使用b和strong标签进行文本加粗。</li>
</ul>
</li>
<li>可以使用CSS来实现，但是CSS 是没有语义的。I</li>
</ul>
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>normal</td>
<td>默认值(不加粗的)</td>
</tr>
<tr>
<td>bold</td>
<td>定义粗体(加粗的)</td>
</tr>
<tr>
<td>100~900</td>
<td>400等同于normal,而700等同于bold</td>
</tr>
</tbody></table>
<p>提倡:<br>    我们平时更喜欢用数字来表示加粗和不加粗。 </p>
<h4 id="font-style"><a href="#font-style" class="headerlink" title="font-style"></a>font-style</h4><ul>
<li><p>在html中将字体倾斜我们可以用标签来实现，</p>
<ul>
<li>字体倾斜可以用i和em标签。</li>
</ul>
</li>
<li><p>可以使用CSS来实现，但是CSS是没有语义的</p>
</li>
</ul>
<p>font-style属性用于定义字体风格，如设置斜体、倾斜或正常字体，其可用属性值如下:</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>normal</td>
<td>默认值，浏览器会显示标准的字体样式(常用)</td>
</tr>
<tr>
<td>italic</td>
<td>浏览箭会显示斜体的字体样式。</td>
</tr>
</tbody></table>
<p>小技巧:<br>平时我们很少给文字加斜体，反而喜欢给斜体标签(em, i)改为普通模式。   </p>
<h4 id="font综合写法"><a href="#font综合写法" class="headerlink" title="font综合写法"></a>font综合写法</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器&#123;<span class="attribute">font</span>:font-style font-weight font-size/line-height font-family&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用font属性时，必须按上面语法格式中的顺序书写，不能更换顺序，各个属性以空格隔开。</p>
</li>
<li><p>其中不需要设置的属性可以省略(取默认值)，但必须保留font-size和font-amily属性， 否则font属性将不起作用。</p>
</li>
</ul>
<h4 id="CSS外观属性总结"><a href="#CSS外观属性总结" class="headerlink" title="CSS外观属性总结"></a>CSS外观属性总结</h4><table>
<thead>
<tr>
<th>属性</th>
<th>表示</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>color</td>
<td>颜色</td>
<td>我们通常用十六进制比如而且是简写形式#fff</td>
</tr>
<tr>
<td>line-height</td>
<td>行高</td>
<td>控制行与行之间的距离</td>
</tr>
<tr>
<td>text-align</td>
<td>水平对齐</td>
<td>可以设定文字水平的对齐方式</td>
</tr>
<tr>
<td>text-indent</td>
<td>首行缩进</td>
<td>通常我们用于段落首行缩进2个字的距离 text-indent: 2em;</td>
</tr>
<tr>
<td>text-decoration</td>
<td>文本修饰</td>
<td>记住添加下划线underline 取消下划线none</td>
</tr>
</tbody></table>
<h3 id="快捷操作"><a href="#快捷操作" class="headerlink" title="快捷操作"></a>快捷操作</h3><p>1.如果想要生成多个相同标签加上*就可以了比如  div*3 就可以快速生成3个div<br>2.如果有父子级关系的标签，可以用&gt;比如ul&gt;li就可以了<br>4.如果有兄弟关系的标签，用+就可以了比如div+p<br>5.如果生成带有类名或者id名字的，直接写.demo 或者#two  tab键就可以了<br>6.如果生成的div类名是有顺序的，可以用自增符号$.</p>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><h4 id="子元素选择器"><a href="#子元素选择器" class="headerlink" title="子元素选择器"></a>子元素选择器</h4><ul>
<li>子元素选择器只能选择作为某元素子元素(亲儿子)的元素。</li>
<li>其写法就是把父级标签写在前面，子级标签写在后面，中间跟一个&gt;进行连接</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.class</span>&gt;<span class="selector-tag">h3</span>&#123;<span class="attribute">color</span>:red; <span class="attribute">font-size</span>:<span class="number">14px</span>;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="交集选择器"><a href="#交集选择器" class="headerlink" title="交集选择器"></a>交集选择器</h4><ul>
<li>交集选择器由两个选择器构成，找到的标签必须满足:既有标签1的特点， 也有标签2的特点。(不常用)</li>
</ul>
<p><img src="https://i.loli.net/2021/01/12/YI8MDdCfHBEUa9O.png" alt="image-20210112132645395"></p>
<h4 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h4><ul>
<li><p>如果某些选择器定义的相同样式，就可以利用并集选择器，可以让代码更简清。</p>
</li>
<li><p>各个标签用逗号分开,通常用于集体声明</p>
</li>
</ul>
<h4 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h4><ul>
<li><p>伪类选择器（简称：伪类）通过冒号来定义，它定义了元素的状态，如点击按下，点击完成等，通过伪类可以为元素的状态修改样式。</p>
</li>
<li><p>伪类的功能和一般的DOM中的元素样式相似，但和一般的DOM中的元素样式不一样，它并不改变任何DOM内容。只是插入了一些修饰类的元素，这些元素对于用户来说是可见的，但是对于DOM来说不可见。伪类的效果可以通过添加一个实际的类来达到。</p>
</li>
<li><p>类选择器是一个点,比如.demo{},而我们的伪类用2个点就是冒号,比如:link{}</p>
</li>
<li><p>用于向某些选挥器添加特殊的效果。比如给链接添加特殊效果，比如可以选挥第1个，第n个元素。</p>
</li>
</ul>
<h5 id="链接伪类选择器"><a href="#链接伪类选择器" class="headerlink" title="链接伪类选择器"></a>链接伪类选择器</h5><ul>
<li>a:link   /*未访问的链接*/</li>
<li>a:visited   /*已访问的链接*/</li>
<li>a:hover    /*鼠标移动到链接上*/</li>
<li>a:active    /*选定的链接*/</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li><p>写的时候，他们的顺序尽量不要颠倒,按照lvha的顺序,否则可能引起错误。</p>
</li>
<li><p>记忆法</p>
<ul>
<li><strong>l</strong>o<strong>v</strong>e <strong>ha</strong>te  爱上了讨厌</li>
<li><strong>lv</strong>包包   非常<strong>ha</strong>o</li>
</ul>
</li>
<li><p>因为a链接浏览器具有默认样式，所以我们实际工作中需要给链接单独指定样式。</p>
</li>
</ul>
<h3 id="标签显示模式"><a href="#标签显示模式" class="headerlink" title="标签显示模式"></a>标签显示模式</h3><h4 id="块级元素-block-level"><a href="#块级元素-block-level" class="headerlink" title="块级元素(block-level)"></a>块级元素(block-level)</h4><ul>
<li><p>常见的块元素有&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、 &lt;div&gt;、 &lt;ul&gt;、 &lt;ol&gt;、 &lt;li&gt;等，其中&lt;div&gt;标签是最典型的块元素。</p>
</li>
<li><p>块级元素的特点:</p>
<ol>
<li>比较霸道，自己独占一行</li>
<li>高度，宽度、外边距以及内边距都可以控制。</li>
<li>宽度默认是容器(父级宽度)的100%</li>
<li>是一个容器及盒子，里面可以放行内或者块级元素。</li>
</ol>
</li>
<li><p>注意:</p>
<ul>
<li>只有文字才能组成段落,因此p里面不能放块级元素，特别是p不能放div。</li>
<li>同理还有这些标签h1,h2,h3,h4,h5,h6,dt， 他们都是文字类块级标签，里面不能放其他块级元素。</li>
</ul>
</li>
</ul>
<h4 id="行内元素-inline-level"><a href="#行内元素-inline-level" class="headerlink" title="行内元素(inline-level)"></a>行内元素(inline-level)</h4><p>常见的行内元素有&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、 &lt;span&gt;等， 其中&lt;span&gt;标签是最典型的行内元素。有的地方也称内联元素。</p>
<ul>
<li><p>行内元素的特点:</p>
<ol>
<li>相邻行内元素在一行上，一行可以显示多个。</li>
<li>高、宽直接设置是无效的。</li>
<li>默认宽度就是它本身内容的宽度。</li>
<li>行内元素只能容纳文本或者其他行内元素。</li>
</ol>
</li>
<li><p>注意:</p>
<ol>
<li>链接里面不能再放链接。</li>
<li>特殊情况a里面可以放块级元素，但是给a转换一下块级模式最安全。</li>
</ol>
</li>
</ul>
<h4 id="行内块元素-inline-block"><a href="#行内块元素-inline-block" class="headerlink" title="行内块元素(inline-block)"></a>行内块元素(inline-block)</h4><p>在行内元素中有几个特殊的标签&lt;img /&gt;、&lt;input /&gt;、&lt;td&gt;， 可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块元素。</p>
<ul>
<li>行内块元素的特点:<ol>
<li>和相邻行内元素(行内块)在一行上,但是之间会有空白缝隙,一行可以显示多个。</li>
<li>默认宽度就是它本身内容的宽度。</li>
<li>高度、行高、外边距以及内边距都可以控制。</li>
</ol>
</li>
</ul>
<h4 id="三种模式总结"><a href="#三种模式总结" class="headerlink" title="三种模式总结"></a>三种模式总结</h4><p><img src="https://i.loli.net/2021/01/12/KbigExyl5cmav6B.png" alt="image-20210112151920674"></p>
<h4 id="标签显示模式转换-display"><a href="#标签显示模式转换-display" class="headerlink" title="标签显示模式转换 display"></a>标签显示模式转换 display</h4><ul>
<li>块转行内: display: inline;</li>
<li>行内转块: display: block;</li>
<li>块、行内元素转换为行内块: display: inline-block;</li>
</ul>
<h3 id="单行文本垂直居中"><a href="#单行文本垂直居中" class="headerlink" title="单行文本垂直居中"></a>单行文本垂直居中</h3><p>行高(基线与基线的距离)我们利用最多的一个地方是:可以让单行文本在盒子中垂直居中对齐。<br><strong>文字的行高等于盒子的高度</strong>即可实现垂直对齐,可近似看作:<strong>行高=上距离+内容高度+下距离</strong></p>
<p>行高和高度的三种关系:</p>
<ul>
<li>如果行高等高度文字会重直居中</li>
<li>如果行高大于高度文字会偏下</li>
<li>如果行高小于高度文字会偏上</li>
</ul>
<h3 id="CSS背景"><a href="#CSS背景" class="headerlink" title="CSS背景"></a>CSS背景</h3><h4 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h4><p>语法:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background-color</span>: 颜色值; //默认的值是 <span class="selector-tag">transparent</span> 透明的</span><br></pre></td></tr></table></figure>
<h4 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h4><p>语法:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">background-image: none | url(url);</span><br></pre></td></tr></table></figure>
<h4 id="背景平铺"><a href="#背景平铺" class="headerlink" title="背景平铺"></a>背景平铺</h4><p>语法:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">background-repeat: repeat(默认) | no-repeat | repeat-x | repeat-y;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>repeat</td>
<td>平铺</td>
</tr>
<tr>
<td>no-repeat</td>
<td>不平铺</td>
</tr>
<tr>
<td>repeat-x</td>
<td>横向平铺</td>
</tr>
<tr>
<td>repeat-y</td>
<td>纵向平铺</td>
</tr>
</tbody></table>
<h4 id="背景位置"><a href="#背景位置" class="headerlink" title="背景位置"></a>背景位置</h4><p>语法:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">background-position: length || length;</span><br><span class="line">background-position: position || position;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>length</td>
<td>百分数|由浮点数字和单位标识符组成的长度值</td>
</tr>
<tr>
<td>position</td>
<td>center | top | bottom | left | right 方位名词</td>
</tr>
</tbody></table>
<p>注意:</p>
<ul>
<li>必须先指定background-image属性</li>
<li>position后面是x坐标和y坐标，可以使用方位名词或者精确单位。</li>
<li>如果只指定了一个方位名词，另一个值默认居中，为50%。</li>
<li>如果只指定一个数值,那该数值用于x坐标，另一个默认是y坐标，默认居中</li>
<li>如果指定两个值，两个值都是方位名字，则两个值前后顺序无关，比如left top和top left效果一致</li>
<li>如果指定两个值，精确单位和方位名字混合使用，则第一个值是x坐标，第二个值是y坐标</li>
</ul>
<h4 id="背景附着"><a href="#背景附着" class="headerlink" title="背景附着"></a>背景附着</h4><p>背景附着就是背景是滚动还是固定的</p>
<p>语法:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">background-attachment: scroll | fixed;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>scroll</td>
<td>背景图像随对象内容滚动</td>
</tr>
<tr>
<td>fixed</td>
<td>背景图像固定</td>
</tr>
</tbody></table>
<h4 id="背景简写"><a href="#背景简写" class="headerlink" title="背景简写"></a>背景简写</h4><p>背景简写和字体简写不同的是背景简写没有强制要求,建议按下面方式写 </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>:背景颜色 背景图片地址 背景平铺 背景滚动 背景位置;</span><br></pre></td></tr></table></figure>
<h4 id="背景透明"><a href="#背景透明" class="headerlink" title="背景透明"></a>背景透明</h4><p>语法:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">rgba</span>(0, 0，0，0.3);</span><br></pre></td></tr></table></figure>
<ul>
<li>最后一个参数是alpha透明度取值范围0~1之间</li>
<li>我们习惯把0.3的0省略掉这样写background: rgba(0, 0, 0, .3);</li>
<li>注意:背景半透明是指盒子背景半透明，盒子里面的内容不受影响</li>
<li>因为是CSS3,所以低于ie9的版本是不支持的。</li>
</ul>
<h3 id="CSS三大特性"><a href="#CSS三大特性" class="headerlink" title="CSS三大特性"></a>CSS三大特性</h3><h4 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h4><p>概念:</p>
<ul>
<li>所谓层叠性是指多种CSS样式的叠加。是浏览器处理冲突的一个能力，如果一个属性通过两个相同选择器设置到同一个元素上,那么这个时候一个属性就会将另一 个属性层叠掉</li>
</ul>
<p>原则: </p>
<ul>
<li>样式冲突,遵循的原则是就近原则.那个样式离结构近,就执行那个样式</li>
<li>样式不冲突,不会层叠</li>
</ul>
<h4 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h4><p>概念:</p>
<ul>
<li>子标签会继承父标签的某些样式，如文本颜色和字号。</li>
<li>想要设置一个可继承的属性，只需将它应用于父元素即可。</li>
</ul>
<p>注意:</p>
<ul>
<li>恰当地使用继承可以简化代码，降低CSS样式的复杂性。比如有很多子级孩子都需要某个样式，可以给父级指定一个，这些孩子继承过来就好了</li>
<li>子元素可以继承父元素的样式(text-, font-, line-这些元素开头的可以继承，以及color属性)</li>
</ul>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>定义CSS样式时，经常出现两个或更多规则成用在同一元素上，此时，</p>
<ul>
<li>选择器相同，则执行层叠性</li>
<li>选择器不同，就会出现优先级的问题。</li>
</ul>
<p>权重计算公式:</p>
<table>
<thead>
<tr>
<th>标签选择器</th>
<th>权重</th>
</tr>
</thead>
<tbody><tr>
<td>继承或 *</td>
<td>0,0,0,0</td>
</tr>
<tr>
<td>元素(标签选择器)</td>
<td>0,0,0,1</td>
</tr>
<tr>
<td>类,伪类</td>
<td>0,0,1,0</td>
</tr>
<tr>
<td>ID</td>
<td>0,1,0,0</td>
</tr>
<tr>
<td>行内样式 style=””</td>
<td>1,0,0,0</td>
</tr>
<tr>
<td>!important</td>
<td>∞ 无穷大</td>
</tr>
</tbody></table>
<p><strong>继承的权重为0</strong></p>
<p>我们修改样式，一 定要看该标签有没有被选中。</p>
<ol>
<li>如果选中了,那么以上面的公式来计权重.</li>
<li>如果没有选中,那么权重是0,因为继承的权重为0.</li>
</ol>
<h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p>盒子模型由内容、边框(border) 、内边距(padding) 、和外边距(margin) 组成。</p>
<h4 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h4><p>语法:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">border: border-width(宽度) | border-style(样式) | border-color(颜色)</span><br></pre></td></tr></table></figure>
<p>边框样式:</p>
<ul>
<li><strong>none :</strong> 　无边框。 </li>
<li><strong>dotted :</strong>  点线 </li>
<li><strong>dashed :</strong>  虚线</li>
<li><strong>solid :</strong> 实线</li>
</ul>
<p>边框简写:</p>
<p>无顺序,一般按宽度,样式,颜色顺序写.各边可分别指定样式.</p>
<p>表格的细线边框:</p>
<ul>
<li><p>通过表格的cellspacing=”0”,将单元格与单元格之间的距离设置为0，</p>
</li>
<li><p>但是两个单元格之间的边框会出现重叠，从而使边框变粗</p>
</li>
<li><p>通过css属性:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">table</span>&#123; <span class="attribute">border-collapse</span>:collapse; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>collapse 单词是合并的意思.</li>
<li>border-collapse:collapse;表示相邻边框合并在一起.</li>
</ul>
</li>
</ul>
<p><strong>盒子实际大小=内容的宽度(高度)+内边距+边框</strong></p>
<p>内边距不影响盒子大小的情况:</p>
<p>如果盒子没有宽度(高度),则padding不会撑开盒子.</p>
<h4 id="文字居中和盒子居中的区别"><a href="#文字居中和盒子居中的区别" class="headerlink" title="文字居中和盒子居中的区别"></a>文字居中和盒子居中的区别</h4><ol>
<li>文字水平居中是text-align: center,而且还可以让行内元素和行内块居中对齐</li>
<li>块级盒子水平居中,左右margin改为auto</li>
</ol>
<h4 id="插入图片和背景图片的区别"><a href="#插入图片和背景图片的区别" class="headerlink" title="插入图片和背景图片的区别"></a>插入图片和背景图片的区别</h4><ol>
<li>插入图片我们用的最多比如产品展示类移动位置只能靠盒模型padding margin</li>
<li>背票图片我们一 般用于小图标背景或者超大背景图片背景图片只能通过background-position</li>
</ol>
<h4 id="清除元素默认的内外边距"><a href="#清除元素默认的内外边距" class="headerlink" title="清除元素默认的内外边距"></a>清除元素默认的内外边距</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123;<span class="attribute">padding</span>:<span class="number">0</span>;<span class="attribute">margin</span>:<span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>注意:</p>
<ul>
<li>行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下内外边距。</li>
</ul>
<h4 id="外边距的合并"><a href="#外边距的合并" class="headerlink" title="外边距的合并"></a>外边距的合并</h4><p>使用margin定义块元素的垂直外边距时，可能会出现外边距的合并。<br>(1).相邻块元素垂直外边距的合并</p>
<ul>
<li>当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom</li>
<li>下面的元素有上外边距margin-top,则他们之间的垂直间距不是margin-bottom与margin-top之和</li>
<li>取两个值中的较大者这种现象被称为相邻块元素垂直外边距的合并(也称外边距塌陷)。</li>
</ul>
<p>(2).嵌套块元素垂直外边距的合并(塌陷)</p>
<ul>
<li>对于两个嵌套关系的块元素，如果父元素没有上内边距及边框</li>
<li>父元素的上外边距会与子元素的上外边距发生合并</li>
<li>合并后的外边距为两者中的较大者</li>
</ul>
<p>解决方案:<br>1.可以为父元素定义上边框<br>2.可以为父元索定义上内边距<br>3.可以为父元素添加overflow:hidden</p>
<h4 id="盒子模型布局稳定性"><a href="#盒子模型布局稳定性" class="headerlink" title="盒子模型布局稳定性"></a>盒子模型布局稳定性</h4><p>问题:什么情况下用内边距，什么情况下用外边距?<br>大部分情况下是可以混用的。 就是说，你用内边距也可以，用外边距也可以。<br>我们根据稳定性来分，建议如下:<br>按照优先便用宽度(width) ,其次使用内边距(padding),再次外边距(margin)。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">width</span> &gt; <span class="selector-tag">padding</span> &gt; <span class="selector-tag">margin</span></span><br></pre></td></tr></table></figure>
<p>原因:</p>
<ul>
<li>margin 会有外边距合并还有IE6下面margin加倍的bug ,所以最后使用</li>
<li>padding 会影响盒子大小，需要进行加减计算,其次使用</li>
<li>width 我们经常使用宽度剩余法,高度剩余法来做</li>
</ul>
<h3 id="CSS书写规范"><a href="#CSS书写规范" class="headerlink" title="CSS书写规范"></a>CSS书写规范</h3><h4 id="空格规范"><a href="#空格规范" class="headerlink" title="空格规范"></a>空格规范</h4><ol>
<li>选择器与{之间必须包含空格</li>
<li>属性名与之后的:之间不允许包含空格，:与属性值之间必须包含空格</li>
</ol>
<h4 id="选择器规范"><a href="#选择器规范" class="headerlink" title="选择器规范"></a>选择器规范</h4><ul>
<li><p>并集选择器，每个选择器声明独占一行</p>
</li>
<li><p>一般情况下，选择器的嵌套层级应不大于3级，位置靠后的限定条件应尽可能精确</p>
</li>
</ul>
<h4 id="属性规范"><a href="#属性规范" class="headerlink" title="属性规范"></a>属性规范</h4><ul>
<li>属性定义必须另起行</li>
<li>属性定义后必须以分号结尾</li>
</ul>
<h3 id="CSS布局的三种机制"><a href="#CSS布局的三种机制" class="headerlink" title="CSS布局的三种机制"></a>CSS布局的三种机制</h3><p>CSS提供了3种机制来设置盒子的摆放位置，分别是普通流(标准流)、浮动和定位，其中:<br>1.普通流(标准流)</p>
<ul>
<li><p>块级元素会独占一行，从上向下顺序排列;</p>
<ul>
<li>常用元素: div、hr、p、h1-h6、ul、ol、dl、form、table</li>
</ul>
</li>
<li><p>行内元索会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行;</p>
<ul>
<li>常用元素: span、a、i、em等</li>
</ul>
</li>
</ul>
<p>2.浮动</p>
<ul>
<li>让盒子从普通流中浮起来,主要作用让多个块级盒子一行显示。</li>
</ul>
<p>3.定位</p>
<ul>
<li>将盒子定在浏览器的某一个位置，CSS离不开定位，特别是后面的js特效。</li>
</ul>
<h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><p>问题:如何将多个盒子(div)水平排列成一行?如何实现盒子靠左靠右对齐?</p>
<p>如果将div转为inline-block可以达到将多个盒子(div)水平排列成一行,但是盒子之间有空隙,且非常难去掉,即使能去掉兼容性极差.无法靠左靠右对齐.</p>
<p>概念:元素的浮动是指设置了浮动属性的元素会</p>
<ol>
<li>脱离标准普通流的控制</li>
<li>移动到指定位置。</li>
</ol>
<p>作用:</p>
<ol>
<li>让多个盒子(div)水平排列成一行，使得浮动成为布局的重要手段。</li>
<li>可以实现盒子的左右对齐等等…</li>
<li>浮动最早是用来控制图片，实现文字环绕图片的效果。</li>
</ol>
<h4 id="清除浮动的本质"><a href="#清除浮动的本质" class="headerlink" title="清除浮动的本质:"></a>清除浮动的本质:</h4><p>清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0的问题。清除浮动之后，父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了。</p>
<h4 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法:"></a>清除浮动的方法:</h4><p>在CSS中，clear属性用于清除浮动，<br>语法:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器&#123;<span class="attribute">clear</span>:属性值;&#125; <span class="selector-tag">clear</span> 清除</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>left</td>
<td>不允许左侧有浮动元素(清除左侧浮动的影响)</td>
</tr>
<tr>
<td>right</td>
<td>不允许右侧有浮动元素(清除右侧浮动的影响)</td>
</tr>
<tr>
<td>both</td>
<td>同时清除左右两侧浮动的影响</td>
</tr>
</tbody></table>
<p>实际工作几乎只用clear:both;</p>
<h5 id="1-额外标签法-隔墙法"><a href="#1-额外标签法-隔墙法" class="headerlink" title="1.额外标签法(隔墙法)"></a>1.额外标签法(隔墙法)</h5><p>在浮动元表末尾添加一个空的标签例如&lt;div style:”clear:both”&gt;&lt;/d1v&gt;, 或者其他标签br等</p>
<ul>
<li>优点:通俗易懂，书写方便</li>
<li>缺点:添加许多无意义的标签,结构化较差</li>
</ul>
<h5 id="2-父级添加overflow属性方法"><a href="#2-父级添加overflow属性方法" class="headerlink" title="2.父级添加overflow属性方法"></a>2.父级添加overflow属性方法</h5><figure class="highlight"><table><tr><td class="code"><pre><span class="line">overflow:hidden | auto |scroll(均可清除浮动)</span><br></pre></td></tr></table></figure>
<ul>
<li>优点:代码简洁</li>
<li>缺点:内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素(溢出隐藏)</li>
</ul>
<h5 id="3-使用after伪元素清除浮动"><a href="#3-使用after伪元素清除浮动" class="headerlink" title="3.使用after伪元素清除浮动"></a>3.使用after伪元素清除浮动</h5><p>:after方式为空元素额外标签法的升级版,好处是不用单独加标签了<br>使用方法:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123; </span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block; </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>; </span><br><span class="line">    <span class="attribute">clear</span>: both; </span><br><span class="line">    <span class="attribute">visibility</span>: hidden; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">    <span class="attribute">*zoom</span>: <span class="number">1</span>;</span><br><span class="line">&#125; <span class="comment">/* IE6、7专门清除浮动*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>优点:符合闭合浮动思想结构语义化正确</li>
<li>缺点:由于IE6-7不支持:after, 使用*zoom:1触发hasLayout</li>
<li>代表网站:百度、沟宝网、网易等</li>
</ul>
<h5 id="4-使用双伪元素清除浮动"><a href="#4-使用双伪元素清除浮动" class="headerlink" title="4.使用双伪元素清除浮动"></a>4.使用双伪元素清除浮动</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:before</span>,<span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">	<span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="attribute">display</span>:table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">	<span class="attribute">clear</span>:both;</span><br><span class="line">]</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">	<span class="attribute">*zoom</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>优点:代码更简洁</li>
<li>缺点:由于IE6-7不支持:after, 使用zoom:1触发hasLayout</li>
<li>代表网站:小米，腾讯等</li>
</ul>
<h3 id="PS知识"><a href="#PS知识" class="headerlink" title="PS知识"></a>PS知识</h3><p>常见图片格式:</p>
<ol>
<li>jpg图像格式:<br>JPEG (.JPG) 对色彩的信息保留较好，高清，颜色较多，我们产品类的图片经常用jpg格式的</li>
<li>gif图像格式:<br>GIF格式最多只能储存256色，所以通常用来显示简单图形及字体，但是可以保存透明背景和动画效果</li>
<li>png图像格式<br>是一种新兴的网络图形格式，结合了GIF和JPEG的优点，具有存储形式丰富的特点，能够保持透明背景</li>
<li>PSD图像格式<br>PSD格式是Photoshop的专用格式，里面可以存放图层、通道、遮罩等多种设计草稿</li>
</ol>
<h3 id="CSS属性书写顺序"><a href="#CSS属性书写顺序" class="headerlink" title="CSS属性书写顺序"></a>CSS属性书写顺序</h3><p>建议遵循以下顺序:</p>
<ol>
<li>布局定位属性: display/position/ float/clear /visbility/overflow (建议display第一个写,毕竟关系到模式)</li>
<li>自身属性: width/height/ margin/padding/border/background</li>
<li>文本属性: color/font/text-decoration/tex-align/vertial-align/white- space/break-word</li>
<li>其他属性(CSS3) : content/cursor/border-radius/box-shadow/text-shadow/ background:linear-gradient</li>
</ol>
<h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>定位=定位模式+边偏移</p>
<h4 id="定位模式"><a href="#定位模式" class="headerlink" title="定位模式"></a>定位模式</h4><table>
<thead>
<tr>
<th>值</th>
<th>语义</th>
</tr>
</thead>
<tbody><tr>
<td>static</td>
<td>静态定位</td>
</tr>
<tr>
<td>relative</td>
<td>相对定位(不脱标)</td>
</tr>
<tr>
<td>absolute</td>
<td>绝对定位(脱标)</td>
</tr>
<tr>
<td>flxed</td>
<td>固定定位(脱标)</td>
</tr>
</tbody></table>
<h4 id="绝对定位的居中对齐"><a href="#绝对定位的居中对齐" class="headerlink" title="绝对定位的居中对齐"></a>绝对定位的居中对齐</h4><p>绝对定位或者固定定位的盒子不能通过设置margin: auto设置水平居中。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">left</span>: 50%;</span><br><span class="line"><span class="selector-tag">margin-left</span>: <span class="selector-tag">-</span>(自己宽度一半);</span><br></pre></td></tr></table></figure>
<h4 id="堆叠顺序"><a href="#堆叠顺序" class="headerlink" title="堆叠顺序"></a>堆叠顺序</h4><p>在使用定位布局时，可能会出现<strong>盒子重叠</strong>的情况.加了定位的盒子，默认<strong>后来者居上</strong>，后面的盒子会压住前面的盒子。应用z-index层叠等级属性可以调整盒子的堆叠顺序。</p>
<p>z-index的特性:</p>
<p>1.属性值:正整数、负整数或0,默认值是0,数值越大,盒子越靠上<br>2.如果属性值相同,则按照书写顺序,后来居上<br>3.数宇后面不能加单位<br>注意: z-index只能应用于相对定位、绝对定位和固定定位的元素，其他标准流、浮动和静态定位无效。</p>
<h4 id="定位改变display属性"><a href="#定位改变display属性" class="headerlink" title="定位改变display属性"></a>定位改变display属性</h4><p>display 是显示模式，可以改变显示模式有以下方式</p>
<ul>
<li>可以用inline-block 转换为行内块</li>
<li>可以用浮动float默认转换为行内块(类似，并不完全一样，因为浮动是脱标的)</li>
<li>绝对定位和固定定位也和浮动类似， 默认转换的特性转换为行内块</li>
</ul>
<p>所以说，一个行内的盒子，如果加了浮动、固定定位和绝对定位，不用转换，就可以给这个盒子直接设置宽度和高度等。<br>同时注意:<br>浮动元素、绝对定位元素的都不会触发外边距合并的问题。(我们以前是用padding border overflow解决的)<br>也就是说，我们给盒子改为了浮动或者定位，就不会有垂直外边距合并的问题了。</p>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="JavaScript概述"><a href="#JavaScript概述" class="headerlink" title="JavaScript概述"></a>JavaScript概述</h3><ul>
<li>JavaScript是世界上最流行的语言之一, 是一种运行在<strong>客户端</strong>的脚本语言( Script是脚本的意思)</li>
<li>脚本语言:不需要编译,运行过程中由js解释器(js引擎)逐行来进行解释并执行</li>
<li>现在也可以基于Node.js技术进行服务器端编程</li>
</ul>
<h3 id="JavaScript作用"><a href="#JavaScript作用" class="headerlink" title="JavaScript作用"></a>JavaScript作用</h3><ul>
<li>表单动态校验(密码强度检测) ( JS 产生最初的目的)</li>
<li>网页特效</li>
<li>服务端开发(Node.js)</li>
<li>桌面程序(Electron)</li>
<li>App(Cordova)</li>
<li>控制硬件-物联网(Ruff)</li>
<li>游戏开发(cocos2d-js)</li>
</ul>
<h3 id="HTML-CSS-JS的关系"><a href="#HTML-CSS-JS的关系" class="headerlink" title="HTML/CSS/JS的关系"></a>HTML/CSS/JS的关系</h3><p><strong>HTML/CSS标记语言–描述类语言</strong></p>
<ul>
<li>HTML决定网页结构和内容(决定看到什么) ,相当于人的身体</li>
<li>CSS 决定网页呈现给用户的模样(决定好不好看)，相当于给人穿衣服、化妆</li>
</ul>
<p><strong>JS脚本语言–编程类语言</strong></p>
<ul>
<li>实现业务逻辑和页面控制(决定功能) ,相当于人的各种动作</li>
</ul>
<h3 id="浏览器执行JS简介"><a href="#浏览器执行JS简介" class="headerlink" title="浏览器执行JS简介"></a>浏览器执行JS简介</h3><p>浏览器分成两部分:渲染引擎和JS引擎</p>
<ul>
<li>渲染引擎:用来解析HTML与CSS ,俗称内核，比如chrome浏览器的blink ,老版本的webkit</li>
<li>JS引擎:也称为JS解释器。 用来读取网页中的JavaScript代码,对其处理后运行,比如chrome浏览器的V8</li>
</ul>
<p>浏览器本身并不会执行JS代码,而是通过内置JavaScript引擎(解释器)来执行JS代码。JS 引擎执行代码时逐行解释每一句源码(转换为机器语言) , 然后由计算机去执行,所以JavaScript语言归为脚本语言,会逐行解释执行。</p>
<h3 id="JS的组成"><a href="#JS的组成" class="headerlink" title="JS的组成"></a>JS的组成</h3><p><img src="https://i.loli.net/2021/01/22/U6JwymbY3egkIWt.png"></p>
<p>1.ECMAScript<br>ECMAScript是由ECMA国际(原欧洲计算机制造商协会)进行标准化的一门编程语言,这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript ,但实际上后两者是ECMAScript语言的实现和扩展。ECMAScript规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的-套JS语法工业标准。</p>
<p><img src="https://i.loli.net/2021/01/22/AaJXE4x537D2oHP.png"></p>
<p>2.DOM–文档对象模型<br>文档对象模型( Document Object Model ,简称DOM) , 是W3C组织推荐的处理可展标记语言的标准编程接口。通过DOM提供的接口可以对页面上的各种元素进行操作(大小、位置、颜色等) .</p>
<p>3.BOM–浏览器对象模型<br>BOM (Browser Object Model ,简称BOM)是指浏览器对象模型,它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口,比如弹出框、控制浏览器跳转、获取分辨率等。</p>
<h3 id="JS书写位置"><a href="#JS书写位置" class="headerlink" title="JS书写位置"></a>JS书写位置</h3><p>JS有3种书写位置,分别为行内、内嵌和外部.</p>
<h4 id="1-行内式JS"><a href="#1-行内式JS" class="headerlink" title="1.行内式JS"></a>1.行内式JS</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>= <span class="string">&quot;button&quot;</span> <span class="attr">value</span>= <span class="string">&quot;点我试试”&quot;</span> <span class="attr">onclick</span>= <span class="string">&quot;alert(&#x27;Hello world&#x27;)&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以将单行或少量JS代码写在HTML标签的事件属性中(以on开头的属性) ,如: onclick</li>
<li>注意单双引号的使用:在HTML中我们推荐使用双引号, JS中我们推荐使用单引号</li>
<li>可读性差，在html中编写JS大量代码时,不方便阅读;</li>
<li>引号易错，引号多层嵌套匹配时,非常容易弄混; </li>
<li>特殊情况下使用</li>
</ul>
<h4 id="2-内嵌JS"><a href="#2-内嵌JS" class="headerlink" title="2.内嵌JS"></a>2.内嵌JS</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">	alert(<span class="string">&#x27;Hello wiorld~!&#x27;</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以将多行JS代码写到&lt;script&gt;标签中</li>
<li>内嵌JS是学习时常用的方式</li>
</ul>
<h4 id="3-外部JS文件"><a href="#3-外部JS文件" class="headerlink" title="3.外部JS文件"></a>3.外部JS文件</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;my.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>利于HTML页面代码结构化,把大段JS代码独立到HTML页面之外,既美观,也方便文件级别的复用</li>
<li>引用外部JS文件的script标签中间不可以写代码</li>
<li>适合于JS代码量比较大的情况</li>
</ul>
<h3 id="JS注释"><a href="#JS注释" class="headerlink" title="JS注释"></a>JS注释</h3><p>1.单行注释</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单行注释</span></span><br></pre></td></tr></table></figure>
<p>2.多行注释</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多行</span></span><br><span class="line"><span class="comment">注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="JS输入输出语句"><a href="#JS输入输出语句" class="headerlink" title="JS输入输出语句"></a>JS输入输出语句</h3><p>为了方便信息的输入输出, JS中提供了一些输入输出语句 ，其常用的语句如下:</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>归属</th>
</tr>
</thead>
<tbody><tr>
<td>alert(msg)</td>
<td>浏览器弹出警示框</td>
<td>浏览器</td>
</tr>
<tr>
<td>console.log(msg)</td>
<td>浏览器控制台打印输出信息</td>
<td>浏览器</td>
</tr>
<tr>
<td>prompt(info)</td>
<td>浏览器弹出输入框,用户可以输入,取过来的值是字符型的</td>
<td>浏览器</td>
</tr>
</tbody></table>
<h3 id="JS变量"><a href="#JS变量" class="headerlink" title="JS变量"></a>JS变量</h3><p>本质:变量是程序在内存中申请的一块用来存放数据的空间。</p>
<p>1.声明变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明变量</span></span><br><span class="line"><span class="keyword">var</span> age;<span class="comment">//声明一个名称为age的变量</span></span><br></pre></td></tr></table></figure>
<ul>
<li>name在浏览器中有含义,最好不用name作为变量名</li>
<li>变量名以字母和下划线开头(也可以以$开头)</li>
</ul>
<p>2.赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">age = <span class="number">10</span>; <span class="comment">//给age这个变量赋值为10</span></span><br></pre></td></tr></table></figure>
<ul>
<li>= 用来把右边的值赋给左边的变量空间中此处代表赋值的意思</li>
<li>变量值是程序员保存到变量空间里的值</li>
</ul>
<p>3.同时声明多个变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">18</span>,</span><br><span class="line">	address = <span class="string">&#x27;北京&#x27;</span>,</span><br><span class="line">	name = <span class="string">&#x27;Tom&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>同时声明多个变量时,只需要写一个var,多个变量名之间使用英文逗号隔开.</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>变量是用来存储值的所在处,它们有名字和数据类型.变量的数据类型决定了如何将代表这些值的位存储到计算机的内存中.**JavaScript 是一种弱类型或者说动态语言.**这意味着不用提前声明变量的类型,在程序运行过程中,类型会被自动确定。</p>
<p>JS把数据类型分为两类:</p>
<ul>
<li>简单数据类型( Number, string, Boolean, Undefined, Null )</li>
<li>复杂数据类型( object)</li>
</ul>
<table>
<thead>
<tr>
<th>简单数据类型</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>Number</td>
<td>数字型，包含整型值和浮点型值，如21、0.21</td>
<td>0</td>
</tr>
<tr>
<td>Boolean</td>
<td>布尔值类型，如true、false, 等价于1和0</td>
<td>false</td>
</tr>
<tr>
<td>String</td>
<td>字符串类型，如“张三”，字符串都带引号</td>
<td>‘’</td>
</tr>
<tr>
<td>Undefined</td>
<td>var a;声明了变量a但是没有给值，此时a = undefined</td>
<td>undefined</td>
</tr>
<tr>
<td>Null</td>
<td>var a= null;声明了变量a为空值</td>
<td>null</td>
</tr>
</tbody></table>
<h4 id="数字型Number"><a href="#数字型Number" class="headerlink" title="数字型Number"></a>数字型Number</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(<span class="literal">Infinity</span>); <span class="comment">// Infinity</span></span><br><span class="line">alert(-<span class="literal">Infinity</span>); <span class="comment">// -Infinity</span></span><br><span class="line">alert(<span class="literal">NaN</span>) ;<span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Infinity ,代表无穷大,大于任何数值</li>
<li>-Infinity ,代表无穷小,小于任何数值</li>
<li>NaN , Not a number,代表一个非数值</li>
</ul>
<p>isNaN()方法:</p>
<p>isNaN()这个方法用来判断非数字并且返回一个值,如果是数字返回的是false,如果不是数字返回的是true</p>
<h4 id="字符串型String"><a href="#字符串型String" class="headerlink" title="字符串型String"></a>字符串型String</h4><p>字符串型可以是引号中的任意文本,其语法为<strong>双引号””**和</strong>单引号’’**,推荐使用单引号</p>
<h5 id="字符串转义符"><a href="#字符串转义符" class="headerlink" title="字符串转义符"></a>字符串转义符</h5><p>类似HTML里面的特殊字符,字符串中也有特殊字符,我们称之为转义符。转义符都是\开头的,常用的转义符及其说明如下:</p>
<table>
<thead>
<tr>
<th>转义符</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>\n</td>
<td>换行符，n是newline的意思</td>
</tr>
<tr>
<td>\\</td>
<td>斜杠\</td>
</tr>
<tr>
<td>\‘</td>
<td>单引号</td>
</tr>
<tr>
<td>\“</td>
<td>双引号</td>
</tr>
<tr>
<td>\t</td>
<td>tab缩进</td>
</tr>
<tr>
<td>\b</td>
<td>空格,b是blank的意思</td>
</tr>
</tbody></table>
<h5 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h5><p>字符串是由若干字符组成的,这些字符的数量就是字符串的长度.通过字符串的<strong>length</strong>属性可以获取整个字符串的长度.</p>
<h5 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h5><ul>
<li>多个字符串之间可以使用+进行拼接,其拼接方式为<strong>字符串+任何类型=拼接之后的新字符串</strong></li>
<li>拼接前会把与字符串相加的任何类型转成字符串,再拼接成一个新的字符串</li>
</ul>
<h4 id="布尔型Boolean"><a href="#布尔型Boolean" class="headerlink" title="布尔型Boolean"></a>布尔型Boolean</h4><p>布尔类型有两个值: true和false,其中true表示真(对),而false表示假(错).<br>布尔型和数字型相加的时候,true的值为1, false的值为0.</p>
<h4 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">undefined</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a + <span class="string">&#x27;abc&#x27;</span>); <span class="comment">// undefinedabc</span></span><br><span class="line"><span class="built_in">console</span>.log(a + <span class="number">1</span>); <span class="comment">// NaN undefined和数字相加最后的结果是NaN</span></span><br></pre></td></tr></table></figure>
<h4 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a + <span class="string">&#x27;abc&#x27;</span>); <span class="comment">// nullabc</span></span><br><span class="line"><span class="built_in">console</span>.log(a + <span class="number">1</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h4 id="检测变量数据类型"><a href="#检测变量数据类型" class="headerlink" title="检测变量数据类型"></a>检测变量数据类型</h4><p>使用typeof检测变量的数据类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">// number</span></span><br><span class="line"><span class="keyword">var</span> b=<span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b); <span class="comment">// string</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> c); <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="literal">undefined</span> ;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> d); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> e = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> e); <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
<h4 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h4><p>使用表单、prompt 获取过来的数据默认是字符串类型的,此时就不能直接简单的进行加法运算,而需要转换变量的数据类型.通俗来说,就是<strong>把一种数据类型的变量转换成另外一种数据类型</strong>.</p>
<h5 id="转换为字符串类型"><a href="#转换为字符串类型" class="headerlink" title="转换为字符串类型"></a>转换为字符串类型</h5><table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
<th>案例</th>
</tr>
</thead>
<tbody><tr>
<td>toString()</td>
<td>转成字符串</td>
<td>var num= 1; alert(num.toString());</td>
</tr>
<tr>
<td>String()强制转换</td>
<td>转成字符串</td>
<td>var num = 1; alert(String(num));</td>
</tr>
<tr>
<td>加号拼接字符串(隐式转换)</td>
<td>和字符串拼接的结果都是字符串</td>
<td>var num = 1; alert(num+“字符串”);</td>
</tr>
</tbody></table>
<h5 id="转换为数字型"><a href="#转换为数字型" class="headerlink" title="转换为数字型"></a>转换为数字型</h5><table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
<th>案例</th>
</tr>
</thead>
<tbody><tr>
<td>parseInt(string)函数</td>
<td>将string类型转成整数数值型(将小数点后数值直接删除,同时会去掉单位)</td>
<td>parseInt(‘78’)</td>
</tr>
<tr>
<td>parseFloat(string)函数</td>
<td>将string类型转成浮点数数值型</td>
<td>parseFloat(‘78.21’)</td>
</tr>
<tr>
<td>Number()强制转换函数</td>
<td>将string类型转换为数值型</td>
<td>Number(‘12’)</td>
</tr>
<tr>
<td>js隐式转换(- * /)</td>
<td>利用算术运算隐式转换为数值型</td>
<td>‘12’-0</td>
</tr>
</tbody></table>
<h5 id="转换为布尔型"><a href="#转换为布尔型" class="headerlink" title="转换为布尔型"></a>转换为布尔型</h5><table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
<th>案例</th>
</tr>
</thead>
<tbody><tr>
<td>Boolean()函数</td>
<td>其他类型转成布尔值</td>
<td>Boolean(‘true’);</td>
</tr>
</tbody></table>
<ul>
<li>代表空、否定的值会被转换为false，如’’、0、NaN、null、undefined</li>
<li>其余值都会被转换为true</li>
</ul>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span>); <span class="comment">// 0.30000000000000004</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0.07</span>*<span class="number">100</span>); <span class="comment">// 7.000000000000001</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="number">0.1</span>+<span class="number">0.2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a==<span class="number">0.3</span>)<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>浮点数值的最高精度是17位小数,但在进行算术计算时其精确度远远不如整数</li>
<li>我们不能直接拿着浮点数来进行相比较是否相等</li>
</ul>
<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>概念:比较运算符(关系运算符)是两个数据进行比较时所使用的运算符,比较运算后,会返回一个布尔值( true / false )作为比较运算的结果。</p>
<table>
<thead>
<tr>
<th>运算符名称</th>
<th>说明</th>
<th>案例</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;</td>
<td>小于号</td>
<td>1 &lt;2</td>
<td>true</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于号</td>
<td>1&gt;2</td>
<td>false</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于号(大于或者等于)</td>
<td>2&gt;=2</td>
<td>true</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于号(小于或者等于)</td>
<td>3&lt;=2</td>
<td>false</td>
</tr>
<tr>
<td>==</td>
<td>判等号(会转型)</td>
<td>37==37</td>
<td>true</td>
</tr>
<tr>
<td>!=</td>
<td>不等号</td>
<td>37!= 37</td>
<td>false</td>
</tr>
<tr>
<td>===    !==</td>
<td>全等要求值和数据类型都一致</td>
<td>37 === ‘37’</td>
<td>false</td>
</tr>
</tbody></table>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>概念:逻辑运算符是用来进行布尔值运算的运算符,其返回值也是布尔值.</p>
<table>
<thead>
<tr>
<th>逻辑运算符</th>
<th>说明</th>
<th>案例</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>“逻辑与”，简称”与”and</td>
<td>true &amp;&amp; false</td>
</tr>
<tr>
<td>||</td>
<td>“逻辑或”，简称”或”or</td>
<td>true || false</td>
</tr>
<tr>
<td>!</td>
<td>“逻辑非”，简称”非”not</td>
<td>! true</td>
</tr>
</tbody></table>
<h4 id="短路运算-逻辑中断"><a href="#短路运算-逻辑中断" class="headerlink" title="短路运算(逻辑中断)"></a>短路运算(逻辑中断)</h4><p>短路运算的原理:当有多个表达式(值)时,左边的表达式值可以确定结果时就不再继续运算右边的表达式的值</p>
<p>1.逻辑与</p>
<ul>
<li>语法:表达式1&amp;&amp;表达式2</li>
<li>如果第一个表达式的值为真,则返回表达式2</li>
<li>如果第一个表达式的值为假,则返回表达式1</li>
</ul>
<p>2.逻辑或</p>
<ul>
<li>语法:表达式1||表达式2</li>
<li>如果第一个表达式的值为真,则返回表达式1</li>
<li>如果第一个表达式的值为假,则返回表达式2</li>
</ul>
<h4 id="switch语句和if-else-if语句的区别"><a href="#switch语句和if-else-if语句的区别" class="headerlink" title="switch语句和if else if语句的区别"></a>switch语句和if else if语句的区别</h4><ol>
<li>一般情况下 ,它们两个语句可以相互替换.</li>
<li>switch…case语句通常处理case为比较确定值的情况,而if…else…语句更加灵活,常用于范围判断(大于、等于某个范国).</li>
<li>switch语句进行条件判断后直接执行到程序的条件语句,效率更高.而if…else 语句有几种条件,就得判断多少次.</li>
<li>当分支比较少时，if…else语句的执行效率比switch语句高.</li>
<li>当分支比较多时, switch语句的执行效率比较高,而且结构更清晰.</li>
</ol>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>与C语言类似</p>
<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>双for循环打印九九乘法表</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">        str=str+j+<span class="string">&#x27;×&#x27;</span>+i+<span class="string">&#x27;=&#x27;</span>+i*j+<span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    str=str+<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br></pre></td></tr></table></figure>
<p>结果如下:</p>
<p><img src="https://i.loli.net/2021/01/27/Wdv2AhMRQTE1K5m.png"></p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是指一组数据的集合,其中的每个数据被称作元素,在数组中可以存放任意类型的元素。数组是一种将一组数据存储在单个变量名下的优雅方式。</p>
<h4 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h4><p>JS中创建数组有两种方式:</p>
<ul>
<li>利用new创建数组</li>
<li>利用数组字面量创建数组(常用)</li>
</ul>
<h5 id="利用new创建数组"><a href="#利用new创建数组" class="headerlink" title="利用new创建数组"></a>利用new创建数组</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组名 = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();<span class="comment">//创建一个空数组</span></span><br></pre></td></tr></table></figure>
<h5 id="利用数组字面量创建数组"><a href="#利用数组字面量创建数组" class="headerlink" title="利用数组字面量创建数组"></a>利用数组字面量创建数组</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.使用数组字面量(方括号)方式创建空的数组</span></span><br><span class="line"><span class="keyword">var</span> 数组名 = [] ;</span><br><span class="line"><span class="comment">//2.使用数组字面量方式创建带初始值的数组</span></span><br><span class="line"><span class="keyword">var</span> 数组名 = [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>] ;</span><br></pre></td></tr></table></figure>
<h4 id="数组元素的类型"><a href="#数组元素的类型" class="headerlink" title="数组元素的类型"></a>数组元素的类型</h4><p>数组中可以存放任意类型的数据,例如字符串,数字,布尔值等.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;小白&#x27;</span>,<span class="number">123</span>,<span class="literal">true</span>,<span class="number">2.5</span>] ;</span><br></pre></td></tr></table></figure>
<h4 id="数组中新增元素"><a href="#数组中新增元素" class="headerlink" title="数组中新增元素"></a>数组中新增元素</h4><p>可以通过修改length长度以及索引号增加数组元素</p>
<h5 id="通过修改length长度新增数组元素"><a href="#通过修改length长度新增数组元素" class="headerlink" title="通过修改length长度新增数组元素"></a>通过修改length长度新增数组元素</h5><ul>
<li>可以通过修改 length长度来实现数组扩容的目的</li>
<li>length属性是可读写的</li>
<li>新增元素没有给值,默认为undefined</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>,<span class="string">&#x27;green&#x27;</span>] ;</span><br><span class="line"><span class="built_in">console</span>.log(arr.length);</span><br><span class="line">arr.length=<span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">3</span>]);<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">4</span>]);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/27/T8VcRdq5ZsKwOvU.png"></p>
<h5 id="通过修改数组索引号新增数组元素"><a href="#通过修改数组索引号新增数组元素" class="headerlink" title="通过修改数组索引号新增数组元素"></a>通过修改数组索引号新增数组元素</h5><ul>
<li>可以通过修改数组索引的方式追加数组元素</li>
<li>不能直接给数组名赋值,否则会覆盖掉以前的数据</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>,<span class="string">&#x27;green&#x27;</span>] ;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line">arr[<span class="number">3</span>]=<span class="string">&#x27;pink&#x27;</span>;<span class="comment">//新增索引号为3的元素</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line">arr[<span class="number">1</span>]=<span class="string">&#x27;yellow&#x27;</span>;<span class="comment">//修改索引号为1的元素值,由blue改为yellow</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line">arr=<span class="string">&#x27;skyblue&#x27;</span>;<span class="comment">//直接给数组名赋值,覆盖掉以前的数据</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//skyblue</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/27/lGt1pmcWziJkL6x.png"></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>在JS里面,可能会定义非常多的相同代码或者功能相似的代码,这些代码可能需要大量重复使用.虽然for循环语句也能实现一些简单的重复操作,但是比较具有局限性,此时我们就可以使用JS中的函数.</p>
<p>函数就是封装了一段可被重复调用执行的代码块.通过此代码块可以实现大量代码的重复使用.</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>自建网盘搜索引擎</title>
    <url>/blog/2021/01/07/%E8%87%AA%E5%BB%BA%E7%BD%91%E7%9B%98%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<h1 id="教你如何自建网盘资源搜索引擎"><a href="#教你如何自建网盘资源搜索引擎" class="headerlink" title="教你如何自建网盘资源搜索引擎"></a>教你如何自建网盘资源搜索引擎</h1><a id="more"></a>


<h3 id="1-利用Google-要能科学上网"><a href="#1-利用Google-要能科学上网" class="headerlink" title="1.利用Google(要能科学上网)"></a>1.利用Google(要能科学上网)</h3><p><a href="https://cse.google.com/cse/" class="LinkCard">点击这里直达</a></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7559cf809c4cf41e9f0c6c79d7db4885.png" alt="image-20201114100907681"></p>
<h3 id="2-点击开始吧"><a href="#2-点击开始吧" class="headerlink" title="2.点击开始吧"></a>2.点击开始吧</h3><p>进入如下界面</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/1ae2e326d170098cd6399ebb6914aaa8.png" alt="image-20201114100937412"></p>
<h3 id="3-点击新建搜索引擎"><a href="#3-点击新建搜索引擎" class="headerlink" title="3.点击新建搜索引擎"></a>3.点击新建搜索引擎</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/56e6799e4eb5d859ce4c14e988318eda.png" alt="image-20201114101047442"></p>
<h3 id="4-依次进行配置"><a href="#4-依次进行配置" class="headerlink" title="4.依次进行配置"></a>4.依次进行配置</h3><p>注意第一个是要搜索的网站</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c2c6d2ec8573ddbe46875698e95678b9.png" alt="image-20201114101417580"></p>
<h3 id="5-创建完毕后-点击修改搜索引擎-选择刚才创建的-找到搜索引擎ID-也可以点击获取代码-插入代码即可"><a href="#5-创建完毕后-点击修改搜索引擎-选择刚才创建的-找到搜索引擎ID-也可以点击获取代码-插入代码即可" class="headerlink" title="5.创建完毕后,点击修改搜索引擎,选择刚才创建的,找到搜索引擎ID(也可以点击获取代码,插入代码即可)"></a>5.创建完毕后,点击修改搜索引擎,选择刚才创建的,找到搜索引擎ID(也可以点击获取代码,插入代码即可)</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/46d801c5e960346b65910892afbf9cc7.png" alt="image-20201114103410456"></p>
<p>外观不满意的话可以自行修改,最后附上代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#main</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">width</span><span class="selector-pseudo">:750px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">margin</span><span class="selector-pseudo">:20px</span> <span class="selector-tag">auto</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-id">#main</span> <span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">text-align</span><span class="selector-pseudo">:center</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">font-size</span><span class="selector-pseudo">:25px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">font-weight</span><span class="selector-pseudo">:bold</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">margin-button</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">百度网盘资源搜索器</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> cx = <span class="string">&#x27;你的搜索引擎ID&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> gcse = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    gcse.type = <span class="string">&#x27;text/javascript&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    gcse.async = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">    gcse.src = <span class="string">&#x27;https://cse.google.com/cse.js?cx=&#x27;</span> + cx;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> s = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;script&#x27;</span>)[<span class="number">0</span>];</span></span><br><span class="line">    s.parentNode.insertBefore(gcse, s);</span><br><span class="line">  &#125;)();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">gcse:search</span>&gt;</span><span class="tag">&lt;/<span class="name">gcse:search</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>无处安放</category>
      </categories>
      <tags>
        <tag>搜索引擎</tag>
        <tag>网盘</tag>
      </tags>
  </entry>
  <entry>
    <title>解决谷歌浏览器卸载后无法重新安装的问题</title>
    <url>/blog/2021/01/06/%E8%A7%A3%E5%86%B3%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8D%B8%E8%BD%BD%E5%90%8E%E6%97%A0%E6%B3%95%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="解决谷歌浏览器卸载后无法重新安装的问题"><a href="#解决谷歌浏览器卸载后无法重新安装的问题" class="headerlink" title="解决谷歌浏览器卸载后无法重新安装的问题"></a>解决谷歌浏览器卸载后无法重新安装的问题</h1><a id="more"></a>

<p>你是否在卸载Google后重装的路上焦头烂额？下载一遍又一遍却无法安装？（这可真是一时卸载一时爽，卸载容易重装难啊）</p>
<p>Google下载后无论怎么弄都安装不上，你焦急的求助度娘，百度出来一堆教程，却不知那个有效，只好一个个尝试搞不懂的操作（嘿嘿，不要急着否认，曾经的我就是这样）。</p>
<p>这些方法也有道理，**<em>Google出现安装不上的情况，一般是由于电脑之前安装过谷歌浏览器，使谷歌浏览器的注册表仍然残留在系统中，导致重新安装失败。**</em></p>
<p>照着网上给出的教程，我是一顿操作猛如虎（管它是什么，一顿乱删），再来安装Google，还是安装不上（当时我试了一遍又一遍，都不管用，快要崩溃），有一种想砸键盘的冲动（再也不用Google了，让你欺负我）。</p>
<p>不过说实话，Google确实好用，不舍得抛弃，我鼓捣来鼓捣去，最终找到解决方法。在这里，我把我的尝试也给列出来了。</p>
<p>解决办法如下：</p>
<h2 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a><strong>方法一：</strong></h2><p>1、打开电脑“运行”（快捷键windows+R，也可以鼠标右键点击电脑左下角“开始”键再点击“运行”）。然后输入“regedit”点击“确定”（会出来一个注册表编辑器的东西，点击“是”即可）</p>
<p>2、依次进入“计算机\HKEY_CURRENT_USER\Software\Google”文件夹并将其删除</p>
<p>3、如果无法查看到谷歌文件，可以尝试在注册列表中按住快捷键Ctrl+F，就可以进行查找看，然后再将谷歌浏览器的相关项目删除，这样就能将谷歌注册表清理干净了，有关谷歌浏览器的残留文件删除完后，您就可以尝试再次谷歌浏览器安装操作了</p>
<h2 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a><strong><em>方法二：</em></strong></h2><p>1.打开360安全卫士，选择电脑清理</p>
<p>2.点击单项清理，选择“清理注册表”</p>
<p>3.点击“一键清理”，再安装Google（如果还报错，尝试重启电脑）</p>
<h2 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h2><p>1.新建一个文本文件（不建议使用记事本，我用的是notepad++,直接在桌面建了一个）</p>
<p>2.将以下代码复制粘贴在该文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">;WARNING, this file will remove Google Chrome registry entries  </span><br><span class="line"></span><br><span class="line">;from your Windows Registry. Consider backing up your registry before</span><br><span class="line"></span><br><span class="line">; using this file: http://support.microsoft.com/kb/322756</span><br><span class="line"></span><br><span class="line">; To run this file, save it as <span class="string">&#x27;remove.reg&#x27;</span> on your desktop and double-click it.</span><br><span class="line"></span><br><span class="line">[-HKEY_LOCAL_MACHINE\SOFTWARE\Classes\ChromeHTML] </span><br><span class="line"></span><br><span class="line">[-HKEY_LOCAL_MACHINE\SOFTWARE\Clients\StartMenuInternet\chrome.exe] </span><br><span class="line"></span><br><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\RegisteredApplications]</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Chrome&quot;</span>=-</span><br><span class="line"></span><br><span class="line">[-HKEY_CURRENT_USER\SOFTWARE\Classes\ChromeHTML] </span><br><span class="line"></span><br><span class="line">[-HKEY_CURRENT_USER\SOFTWARE\Clients\StartMenuInternet\chrome.exe] </span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\SOFTWARE\RegisteredApplications]</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Chrome&quot;</span>=-</span><br><span class="line"></span><br><span class="line">[-HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Uninstall\Chrome]</span><br><span class="line"></span><br><span class="line">[-HKEY_CURRENT_USER\Software\Google\Update\Clients\&#123;8A69D345-D564-463c-AFF1-A69D9E530F96&#125;]</span><br><span class="line"></span><br><span class="line">[-HKEY_CURRENT_USER\Software\Google\Update\ClientState\&#123;8A69D345-D564-463c-AFF1-A69D9E530F96&#125;]</span><br><span class="line"></span><br><span class="line">[-HKEY_CURRENT_USER\Software\Google\Update\Clients\&#123;00058422-BABE-4310-9B8B-B8DEB5D0B68A&#125;]</span><br><span class="line"></span><br><span class="line">[-HKEY_CURRENT_USER\Software\Google\Update\ClientState\&#123;00058422-BABE-4310-9B8B-B8DEB5D0B68A&#125;]</span><br><span class="line"></span><br><span class="line">[-HKEY_LOCAL_MACHINE\SOFTWARE\Google\Update\ClientStateMedium\&#123;8A69D345-D564-463c-AFF1-A69D9E530F96&#125;]</span><br><span class="line"></span><br><span class="line">[-HKEY_LOCAL_MACHINE\SOFTWARE\Google\Update\Clients\&#123;8A69D345-D564-463c-AFF1-A69D9E530F96&#125;]</span><br><span class="line"></span><br><span class="line">[-HKEY_LOCAL_MACHINE\SOFTWARE\Google\Update\ClientState\&#123;8A69D345-D564-463c-AFF1-A69D9E530F96&#125;]</span><br><span class="line"></span><br><span class="line">[-HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Google\Update\Clients\&#123;8A69D345-D564-463c-AFF1-A69D9E530F96&#125;]</span><br></pre></td></tr></table></figure>
<p>3.将该文件命名为rm.reg</p>
<p>4.双击运行（可能会出来一些选项，我默认了），再重装Google即可</p>
<h2 id="方法四"><a href="#方法四" class="headerlink" title="方法四:"></a>方法四:</h2><p>听闻geek卸载软件可以删除注册表，所以可以用它卸载Google，且重装不会有问题。（可能对大部分人，此方法意义不大）<br>给出链接<br> 链接:<a href="https://pan.baidu.com/s/1qaDZ05A9yD1jhOcUeQppuA">https://pan.baidu.com/s/1qaDZ05A9yD1jhOcUeQppuA</a><br> 提取码:386a</p>
<h2 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h2><p>该文仅为记载我在重装Google的艰辛历程，以上方法均为网络收集，如果和我有相同问题的朋友可以尝试一下，节约你百度的时间。如果对于第三种方法不懂这里有现成的文件，下面给出链接：<a href="https://download.csdn.net/download/moshangduanchang/12354433">点这里呀</a></p>
]]></content>
      <categories>
        <category>无处安放</category>
      </categories>
      <tags>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法总结</title>
    <url>/blog/2021/01/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="一-绪论"><a href="#一-绪论" class="headerlink" title="一.绪论"></a>一.绪论</h2><p>算法是为了解决实际问题而设计的.数据结构是算法需要处理的问题载体.</p>
<h3 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语:"></a>基本概念和术语:</h3><ul>
<li><p>数据:数据是指能输入到计算机中并能够被计算机处理的一切对象.</p>
</li>
<li><p>数据元素:数据元素是数据的基本单位.</p>
</li>
<li><p>数据项:一个数据元素可由若干数据项组成.</p>
</li>
<li><p>数据对象:数据对象是具有相同性质的数据元素的集合.</p>
</li>
</ul>
<ul>
<li>数据结构:数据结构是指互相之间存在着一种或多种关系的数据元素的集合.</li>
</ul>
<hr>
<h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构:"></a>逻辑结构:</h3><p>1.集合结构:数据元素同属一个集合，单个数据元素之间没有任何关系</p>
<p><img src="https://i.loli.net/2021/01/11/qoiHNkTzsJxjBGD.png" alt="image-20201118213034722"></p>
<p>​    2.线性结构:类似于线性关系,数据元素之间是一对一的关系</p>
<p><img src="https://i.loli.net/2021/01/11/a3LdovfMAlmkNxE.png" alt="image-20201118213251428"></p>
<p>​    3.树形结构:树形结构中的数据元素之间存在一对多的关系</p>
<p><img src="https://i.loli.net/2021/01/11/c7e6tdFC3w1NAlo.png" alt="image-20201118213518986"></p>
<p>​    4.图形结构:数据元素之间是多对多的关系</p>
<p><img src="https://i.loli.net/2021/01/11/nGcsUypoHmbizL9.png" alt="image-20201118213729837"></p>
<hr>
<h3 id="存储结构-物理结构"><a href="#存储结构-物理结构" class="headerlink" title="存储结构(物理结构):"></a>存储结构(物理结构):</h3><p>(数据结构种类很多， 甚至你也可以发明自己的数据结构， 但是底层存储无非数组或者链表 ,那些多样化的数据结构， 究其源头， 都是在链表或者数组上的特殊操作 )</p>
<p>1.顺序存储:一段连续的内存空间</p>
<ul>
<li>优点：随机访问</li>
</ul>
<ul>
<li>缺点：插入删除效率低，大小固定</li>
</ul>
<p>2.链式存储:不连续的内存空间</p>
<ul>
<li>优点：大小动态扩展，插入删除效率高</li>
</ul>
<ul>
<li>缺点：不能随机访问</li>
</ul>
<p>3.索引:为了方便查找，整体无序，但索引块之间有序，需要额外空间存储索引表</p>
<ul>
<li><p>优点：对顺序查找的一种改进，查找效率高</p>
</li>
<li><p>缺点：需额外空间存储索引</p>
</li>
</ul>
<p>4.散列:选取某个函数，数据元素根据函数计算存储位置,可能存在多个数据元素存储在同一位置，引起地址冲突</p>
<ul>
<li>优点：查找基于数据本身即可找到，查找效率高，存取效率高</li>
</ul>
<ul>
<li>缺点：存取随机，不便于顺序查找</li>
</ul>
<p>队列,栈这两种数据结构既可以使⽤链表也可以使用数组实现.用数组实现,就要处理扩容缩容的问题; 用链表实现,则没有这个问题,但需要更多的内存空间存储节点指针</p>
<p>图的两种表示方法,邻接表就是链表,邻接矩阵就是二维数组.邻接矩阵判断连通性迅速,并可以进行矩阵运算解决⼀些问题,但是如果图⽐较稀疏的话很耗费空间.邻接表⽐较节省空间,但是很多操作的效率上肯定⽐不过邻接矩阵。</p>
<p>散列表就是通过散列函数把键映射到⼀个大数组里。 ⽽且对于解决散列冲突的方法， 拉链法需要链表特性， 操作简单， 但需要额外的空间存储指针； 线性探查法就需要数组特性， 以便连续寻址， 不需要指针的存储空间，但操作稍微复些。    </p>
<hr>
<h3 id="影响算法运行时间的因素"><a href="#影响算法运行时间的因素" class="headerlink" title="影响算法运行时间的因素:"></a>影响算法运行时间的因素:</h3><p>1.运行程序的计算机的机器指令的品质与速度</p>
<p>2.书写程序的语言(一般实现语言级别越高,其执行效率越低)</p>
<p>3.编译程序所生成目标代码的质量</p>
<p>4.问题的规模</p>
<hr>
<h3 id="大O表示法-用来表示时间复杂度函数的增长率的上界"><a href="#大O表示法-用来表示时间复杂度函数的增长率的上界" class="headerlink" title="大O表示法:用来表示时间复杂度函数的增长率的上界"></a>大O表示法:用来表示时间复杂度函数的增长率的上界</h3><p>时间复杂度:嵌套(求积),并列(求和),只关注最高次项</p>
<p>空间复杂度:算法运行所需存储空间:</p>
<p>1.程序本身占用的空间</p>
<p>2.算法的输入,输出占用的空间</p>
<p>3.算法运行中占用的空间</p>
<p>评价一个算法的空间复杂度一般只考虑算法运行中所占用的临时空间.</p>
<p>对于一个算法,其时间复杂度和空间复杂度往往是相互影响的.</p>
<h2 id="二-线性表"><a href="#二-线性表" class="headerlink" title="二.线性表"></a>二.线性表</h2><p>线性结构的特点是在数据元素的非空有限集合中,存在唯一的首元素和唯一的尾元素,首元素无直接前驱,尾元素无直接后继,集合中其他数据元素都有唯一的直接前驱和唯一的直接后继.线性表是最简单,最基本,也是最常用的一种线性结构.</p>
<hr>
<p>线性表是具有相同数据类型的n(n&gt;=0)个数据元素的有限序列.</p>
<h3 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构:"></a>线性表的顺序存储结构:</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20  <span class="comment">//存储空间初始分配量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType; <span class="comment">//ElemType类型根据实际情况而定,这里假设为int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data[MAXSIZE]; <span class="comment">//数组存储数据元素,最大值为MAXSIZE</span></span><br><span class="line">    <span class="keyword">int</span> length;  <span class="comment">//线性表当前长度</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>
<p>线性表顺序存储结构需要三个属性:</p>
<ul>
<li>存储空间的起始位置</li>
<li>线性表的最大存储容量(数组的长度)</li>
<li>线性表的当前长度(小于等于数组长度)</li>
</ul>
<p>顺序表的初始化:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SqList *<span class="title">init_SqList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqList *L;</span><br><span class="line">    L=(SqList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SqList)); <span class="comment">//动态分配内存空间</span></span><br><span class="line">    <span class="keyword">if</span>(!L) <span class="built_in">exit</span>(<span class="number">1</span>);  <span class="comment">//如果存储分配失败,运行exit()函数终止程序运行</span></span><br><span class="line">    L-&gt;length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺序表的插入运算:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SqList *<span class="title">Insert_SqList</span><span class="params">(SqList *L,<span class="keyword">int</span> i,ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在顺序表L第i个位置插入值为x的元素</span></span><br><span class="line">    <span class="keyword">if</span>(L-&gt;length&gt;=MAXSIZE<span class="number">-1</span>)<span class="comment">//判断表是否满</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;顺序表已满!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;L-&gt;length+<span class="number">1</span>)<span class="comment">//判断插入位置是否合理</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入位置i不合理!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> m=L-&gt;length<span class="number">-1</span>;m&gt;=i<span class="number">-1</span>;m--)</span><br><span class="line">    &#123;</span><br><span class="line">        L-&gt;data[m+<span class="number">1</span>]=L-&gt;data[m];<span class="comment">//节点后移</span></span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;data[i<span class="number">-1</span>]=x;<span class="comment">//新元素插入</span></span><br><span class="line">    L-&gt;length++;<span class="comment">//表长加1</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺序表的删除运算:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SqList *<span class="title">Delete_SqList</span><span class="params">(SqList *L,<span class="keyword">int</span> i,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//删除顺序表L中第i个元素,删除元素的值保存在e中</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;L-&gt;length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入位置i不合理!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    e=L-&gt;data[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i;i&lt;=L-&gt;length<span class="number">-1</span>;++i)</span><br><span class="line">        L-&gt;data[i<span class="number">-1</span>]=L-&gt;data[i];</span><br><span class="line">    L-&gt;length--;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺序表按值查找运算:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem_Sq</span><span class="params">(SqList *L,ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在顺序表中查找值为x的元素,查找成功返回元素存储位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L-&gt;data[i]==x)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺序表合并算法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SqList *<span class="title">Merge_SqList</span><span class="params">(SqList *A,SqList *B)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//将两个非递减次序排列的顺序表A和B合并为一个新的有序顺序表C</span></span><br><span class="line">    SqList *C;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    i=<span class="number">0</span>;j=<span class="number">0</span>;k=<span class="number">0</span>;</span><br><span class="line">    C=(SqList *)<span class="built_in">malloc</span>(<span class="number">2</span>*MAXSIZE*<span class="keyword">sizeof</span>(SqList));</span><br><span class="line">    <span class="keyword">if</span>(!C) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    C-&gt;length=A-&gt;length+B-&gt;length;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=A-&gt;length<span class="number">-1</span>&amp;&amp;j&lt;=B-&gt;length)</span><br><span class="line">        <span class="keyword">if</span>(A-&gt;data[i]&lt;B-&gt;data[j])</span><br><span class="line">        &#123;</span><br><span class="line">            C-&gt;data[k]=A-&gt;data[i];k++;i++;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            C-&gt;data[k]=B-&gt;data[j];k++;j++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//前面部分是先将A,B中较短的填入C,后面再填入另一个</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=A-&gt;length<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        C-&gt;data[k]=A-&gt;data[i];k++;i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;B-&gt;length<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        C-&gt;data[k]=B-&gt;data[j];k++;j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<h3 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构:"></a>线性表的链式存储结构:</h3><h4 id="1-单链表-动态链表"><a href="#1-单链表-动态链表" class="headerlink" title="1.单链表(动态链表)"></a>1.单链表(动态链表)</h4><p>静态链表是用类似于数组方法实现的，是顺序的存储结构，在物理地址上是连续的，而且需要预先分配地址空间大小。所以静态链表的初始长度一般是固定的，在做插入和删除操作时不需要移动元素，仅需修改指针</p>
<p>单链表节点数据类型:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">LinkList</span>;</span></span><br></pre></td></tr></table></figure>
<p>头插入法建立单链表:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">CreatList_L1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList L;</span><br><span class="line">    LinkList P;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    L=(LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p=(LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        p-&gt;data=x;</span><br><span class="line">        p-&gt;next=L-&gt;next;</span><br><span class="line">        L-&gt;next=p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尾插入法建立单链表:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">CreatList_L2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList L,p,r;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    r=L=(LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p=(LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        p-&gt;data=x;</span><br><span class="line">        p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        r-&gt;next=p;</span><br><span class="line">        r=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求链表长度的算法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Listlength</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找操作:</p>
<p>​            1.按序号查找</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">Get_LinkList</span><span class="params">(LinkList L,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在链表L中查找第i个元素,找到返回其指针,否则返回空</span></span><br><span class="line">    LinkList p;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j==i)<span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​            2.按值查找</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">Locate_LinkList</span><span class="params">(LinkList L,ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>&amp;&amp;p-&gt;data!=x)</span><br><span class="line">       p=p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入运算:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">ListInsert</span><span class="params">(LinkList L,<span class="keyword">int</span> i,ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在单链表第i个节点前插入新元素x</span></span><br><span class="line">    LinkList p,s;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>&amp;&amp;j&lt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||j&gt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;<span class="built_in">printf</span>(<span class="string">&quot;参数i错误!&quot;</span>);<span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line">    s=(LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除运算:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">ListDelete</span><span class="params">(LinkList L,<span class="keyword">int</span> i,ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//删除单链表L中第i个元素</span></span><br><span class="line">    LinkList p,q;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>&amp;&amp;j&lt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next=<span class="literal">NULL</span>||j&gt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;参数i错误!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    q=p-&gt;next;</span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    *e=q-&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有序链表归并算法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">Merge_LinkList</span><span class="params">(LinkList A,LinkList B)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//A,B均为带头节点的单链表</span></span><br><span class="line">    LinkList C,p,q,s;</span><br><span class="line">    p=A-&gt;next;</span><br><span class="line">    q=B-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">    C=A;</span><br><span class="line">    C-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data&lt;q-&gt;data)&#123;s=p;p=p-&gt;next;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;s=q;q=q-&gt;next;&#125;</span><br><span class="line">        s-&gt;next=C-&gt;next;</span><br><span class="line">        C-&gt;next=s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)p=q;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        s=p;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        s-&gt;next=C-&gt;next;</span><br><span class="line">        C-&gt;next=s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-循环链表"><a href="#2-循环链表" class="headerlink" title="2.循环链表"></a>2.循环链表</h4><p>1.单向循环链表</p>
<p>单链表尾节点的指针域是空指针.而单向循环链表的最后一个节点的指针指向链表头节点.</p>
<p>对于单链表,从一已知节点只能访问该节点及其后继节点,无法访问该节点之前的节点;而对于单向循环链表,只要知道表中任一节点的地址,就可搜寻到所有其他节点的地址,遍历整个链表.</p>
<p>单向循环链表的数据类型定义与单链表相同.在单循环链表上的操作也与单链表基本相同,二者主要区别在于:判断是否达到表尾的条件不同.在单链表中,用指针域是否为NULL作为判断表尾节点的条件;而在循环链表中,则以节点指针域是否等于表头节点(头指针)作为判断到达表尾的条件.</p>
<p>2.双向链表</p>
<p>双向链表的结构:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLnode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span></span><br><span class="line">&#125;DuLnode;</span><br><span class="line"><span class="keyword">typedef</span> DuLnode *DuLinkList;</span><br></pre></td></tr></table></figure>
<p>双向链表的插入运算:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DuLinkList <span class="title">ListInsert_Dul</span><span class="params">(DuLinkList L,<span class="keyword">int</span> i,ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在双向链表的第i个节点前插入一个新元素x</span></span><br><span class="line">	DuLinkList p,s;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    p=L;</span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)</span><br><span class="line">    &#123;p=p-&gt;next;j++&#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||j&lt;i)</span><br><span class="line">    &#123;<span class="built_in">printf</span>(<span class="string">&quot;参数i错误!&quot;</span>);<span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line">    <span class="keyword">if</span>(!(s=(DuLinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DuLnode))))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;prior=p-&gt;prior;p-&gt;prior-&gt;next=s;</span><br><span class="line">    s-&gt;next=p;p-&gt;prior=s;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双向链表的删除运算:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DuLinkList <span class="title">ListDelete_Dul</span><span class="params">(DuLinkList L,<span class="keyword">int</span> i,ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//删除双向链表中第i数据元素</span></span><br><span class="line">    DuLinkList p;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    p=L;</span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)</span><br><span class="line">    &#123;p=p-&gt;next;j++;&#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||j&gt;i)</span><br><span class="line">    &#123;<span class="built_in">printf</span>(<span class="string">&quot;参数i错误!&quot;</span>);<span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        e=p-&gt;data;</span><br><span class="line">        p-&gt;prior-&gt;next=p-&gt;next;</span><br><span class="line">        p-&gt;next-&gt;prior=p-&gt;prior;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三-栈与队列"><a href="#三-栈与队列" class="headerlink" title="三.栈与队列"></a>三.栈与队列</h2><p>栈和队列是在程序设计中被广泛使用的两种数据结构.由于从数据结构角度看,栈和队列是两种特殊的线性表.它们的逻辑结构和线性表相同,只是其运算规则较线性表有更多的限制,因此,也可以将栈和队列称为操作受限的线性表.</p>
<p>栈是限定仅在表尾进行插入和删除操作的线性表.队列是只允许在一端进行插入操作,而在另一端进行删除操作的线性表.</p>
<h3 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h3><ul>
<li>栈是一种特殊的线性表,是一种只允许在表的一端进行插入或删除操作的线性表.把栈中允许进行插入,删除操作的一端称为栈顶,栈的另一端称为栈底.</li>
<li>当栈中没有数据元素时,称之为空栈.栈顶是动态的,对栈顶位置的标记称为栈顶指针.栈的插入操作通常称为进栈(入栈或压栈),栈的删除操作通常称为退栈或出栈.</li>
<li>根据栈的定义,每次进栈的数据元素都放在当前栈顶元素之前而成为新的栈顶元素,每次退栈的数据元素都是当前栈顶元素.这样,最后进入栈的数据元素总是最先退出栈,因此,栈具有”后进先出”的特性,所以栈又称为后进先出的线性表,简称LIFO表.</li>
</ul>
<h3 id="栈的存储结构"><a href="#栈的存储结构" class="headerlink" title="栈的存储结构"></a>栈的存储结构</h3><p>栈有两种存储表示方法,即顺序存储和链式存储.顺序存储的栈称为顺序栈,链式存储的栈称为链式栈.</p>
<h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><p>顺序栈的存储结构:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> StackInitSize 100;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> StackElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    StackElementType data[StackInitSize];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125;SeqStack;</span><br></pre></td></tr></table></figure>
<p>顺序栈的初始化:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SeqStack *<span class="title">InitStack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SeqStack *s;</span><br><span class="line">    s=(SeqStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SeqStack));</span><br><span class="line">    <span class="keyword">if</span>(s!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;s-&gt;top=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> s;&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;没有足够的内存空间,申请失败,程序运行终止!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断栈空的函数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(SeqStack *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(s-&gt;top==<span class="number">-1</span>)?<span class="number">1</span>:<span class="number">0</span>;<span class="comment">//栈空返回1,否则返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>销毁栈的函数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestoryStack</span><span class="params">(SeqStack *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈已销毁!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进栈操作:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(SeqStack *s,StackElementType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;top==StackInitSize)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈满!栈发生上溢,程序停止运行!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        s-&gt;top++;</span><br><span class="line">        s-&gt;data[s-&gt;top]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>退栈操作:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">StackElementType <span class="title">Pop</span><span class="params">(SeqStack *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StackElementType temp;</span><br><span class="line">    <span class="keyword">if</span>(IsElpty(s))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈空!栈发生下溢,程序停止运行!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        temp=s-&gt;data[s-&gt;top];</span><br><span class="line">        s-&gt;top--;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取栈顶元素:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">StackElementType <span class="title">GetTop</span><span class="params">(SeqStack *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;空栈,程序停止运行!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> s-&gt;data[s-&gt;top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>栈浮动技术:</p>
<p>当一个程序中同时使用多个顺序栈时,为了防止上溢错误,需要为每个栈分配较大的存储空间.在多栈使用过程中通常会出现:在某一栈发生上溢的同时,其余栈尚有大量未用空间存在,这样不利于内存空间的共享,会降低内存空间的使用效率.如果将多个栈安排在同一个连续的存储空间中,这样多个栈共享存储空间,并使它们根据实际情况互相调节余缺.如此既节省了存储空间的开销,又降低了上溢现象发生的概率.这种多栈共享空间的技术,通常称为栈浮动技术.</p>
<p>当程序中同时使用两个栈时,两个栈可以共享同一存储空间.此时,将两个栈的栈底分别设在同一存储空间的两端,让两个栈各自向中间延伸.这样只有当整个共享空间被两个栈占满(两个栈的栈顶相遇)时,才会发生上溢.</p>
<p>两栈共享空间的结构:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    StackElementType data[StackInitSize];</span><br><span class="line">    <span class="keyword">int</span> top1;<span class="comment">//栈1栈顶指针</span></span><br><span class="line">    <span class="keyword">int</span> top2;<span class="comment">//栈2栈顶指针</span></span><br><span class="line">&#125;SqDoubleStack;</span><br></pre></td></tr></table></figure>
<p>对于两栈共享空间的进栈方法,我们除了要插入元素值参数外,还需要有一个判断是栈1还是栈2的栈号参数stackNumber</p>
<h4 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h4><p>链式栈的存储结构:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> StackElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    StackElementType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkStack;</span><br></pre></td></tr></table></figure>
<p>链式栈的进栈操作:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkStack *<span class="title">Push</span><span class="params">(LinkStack *top,StackElementType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkStack *p;</span><br><span class="line">    p=(LinkStack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkStack));</span><br><span class="line">    <span class="keyword">if</span>(p)&#123;p-&gt;data=x;</span><br><span class="line">         p-&gt;next=top;</span><br><span class="line">         top=p;</span><br><span class="line">         <span class="keyword">return</span> top;&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;内存不足,程序运行停止!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链式栈的退栈操作:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkStack *<span class="title">Pop</span><span class="params">(LinkStack *top,StackElementType *elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkStack *temp;</span><br><span class="line">    <span class="keyword">if</span>(top)</span><br><span class="line">    &#123;</span><br><span class="line">        temp=top;</span><br><span class="line">        *elem=top-&gt;data;</span><br><span class="line">        top=top-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链式栈读取栈顶元素:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">StackElementType <span class="title">GetTop</span><span class="params">(LinkStack *top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> top?top-&gt;data:<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h3><ul>
<li>队列(Queue)是一种只允许在一端进行插入,另一端进行删除的运算受限的线性表,允许删除的一端叫队头(front),允许插入的一端叫队尾(rear).</li>
<li>队列的插入操作通常称为入队,删除操作通常称为出队,当队列中没有元素时称为空队列.</li>
<li>队列具有”先进先出”(FIFO)特性,简称为FIFO表.</li>
</ul>
<h4 id="队列的存储结构"><a href="#队列的存储结构" class="headerlink" title="队列的存储结构"></a>队列的存储结构</h4><h5 id="循环队列-顺序队列"><a href="#循环队列-顺序队列" class="headerlink" title="循环队列(顺序队列)"></a>循环队列(顺序队列)</h5><p>在顺序队列中,进行入队和出队操作时可能产生溢出现象:</p>
<p>1.”下溢”现象</p>
<p>当队列为空时,进行出队运算产生的溢出现象,称为”下溢”.可通过判断队列是否为空来控制</p>
<p>2.”真上溢”现象</p>
<p>当队列满时,进行入队运算时产生空间溢出的现象,称为”真上溢”.可通过判断队列是否满来控制</p>
<p>3.”假上溢”现象</p>
<p>由于在入队和出队操作中,队头指针与队尾指针只增加不减小,致使被删元素的空间永远无法重新利用.当队列中实际的元素个数远远小于存储空间的规模时,也可能由于队尾指针已超越队列空间的上界而不能做入队操作.这种现象称为”假下溢”.</p>
<p>为防止假溢出现象发生,充分利用存储空间,最巧妙的解决方法就是把队列存储空间看作首尾相连的环,而这种队列的循环顺序存储结构称为循环队列.</p>
<p>循环队列存储结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QueueElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    QueueElementType *base;<span class="comment">//base指向队列存储区首地址</span></span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">&#125;SeqQueue;</span><br></pre></td></tr></table></figure>
<p>循环队列的特点</p>
<ul>
<li>队头,队尾指针加1时从MaxSize-1直接进到0,这种变化可用C语言的取模(余数)运算实现</li>
<li>队空与队满时头尾指针均相等,无法通过front==rear来判断队列的”空”和”满”,解决此问题有两种方法:<ol>
<li>另设一个状态标志位来区别”队空”和”队满”</li>
<li>少用一个存储空间,约定以队头指针在队尾指针的下一位置上作为队列满的标志</li>
</ol>
</li>
</ul>
<p>采用第二种处理方法:</p>
<p>循环队列空的标志:front==rear</p>
<p>循环队列满的标志:(rear+1)%MaxSize==front</p>
<p>循环队列初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SeqQueue <span class="title">InitQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SeqQueue Q;</span><br><span class="line">    Q.base=(QueueElementType*)<span class="built_in">malloc</span>(MaxSize*<span class="keyword">sizeof</span>(QueueElementType));</span><br><span class="line">    <span class="keyword">if</span>(!Q.base)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;申请存储空间失败,程序运行终止!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Q.front=<span class="number">0</span>;</span><br><span class="line">    Q.rear=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断循环队列为空</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueEmpty</span><span class="params">(SeqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front==Q.rear)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断循环队列为满</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueFull</span><span class="params">(SeqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front==(Q.rear+<span class="number">1</span>)%MaxSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入队操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SeqQueue <span class="title">EnQUeue</span><span class="params">(SeqQueue Q,QueueElementType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(QueueFull(Q)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;队满!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        *(Q.base+Q.rear)=x;</span><br><span class="line">        Q.rear=(Q.rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出队操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SeqQueue <span class="title">DeQueue</span><span class="params">(SeqQueue Q,QueueElementType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(QueueEmpty(Q))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队空!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        *e=*(Q.base+Q.front);</span><br><span class="line">        Q.front=(Q.front+<span class="number">1</span>)%MaxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取队头元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">QueueElementType <span class="title">GetHead</span><span class="params">(SeqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(QueueEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队空!读取失败!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> *(Q.base+Q.front);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>销毁队列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestoryQueue</span><span class="params">(SeqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(Q.base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队列已被销毁!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>队列遍历操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueueDisplay</span><span class="params">(SeqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(QueueEmpty(Q))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队空!队列遍历完成!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列遍历(队头-&gt;队尾):\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=Q.front;i!=Q.rear;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>,*(Q.base+i));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\b\b \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h5><p>一个链式队列由一个头指针和一个尾指针唯一地确定.</p>
<p>链式队列节点类型定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QueueElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    QueueElementType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QueueNode;</span><br></pre></td></tr></table></figure>
<p>链式队列数据类型定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    QueueNode *front;</span><br><span class="line">    QueueNode *rear;</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>
<p>链式队列的初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkQueue <span class="title">InitQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    QueueNode *p;</span><br><span class="line">    p=(QueueNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">    <span class="keyword">if</span>(p)&#123;</span><br><span class="line">        Q.front=Q.rear=p;</span><br><span class="line">        Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> Q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;初始化失败!程序运行终止!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断链式队列是否为空</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueEmpty</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front=Q.rear)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入队操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkQueue <span class="title">EnQueue</span><span class="params">(LinkQueue Q,QueueElementType x)</span></span>&#123;</span><br><span class="line">    QueueNode *p;</span><br><span class="line">    p=(QueueNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">    <span class="keyword">if</span>(!p)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;申请空间失败!程序运行终止!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        p-&gt;data=x;</span><br><span class="line">        p-&gt;next=<span class="literal">NULL</span>;<span class="comment">//尾节点的next置空</span></span><br><span class="line">        Q.rear-&gt;next=p;</span><br><span class="line">        Q.rear=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出队操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkQueue <span class="title">DeQueue</span><span class="params">(LinkQueue Q,QueueELementType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QueueNode *p;</span><br><span class="line">    <span class="keyword">if</span>(QueueEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空!出队失败!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        p=Q.front-&gt;next;</span><br><span class="line">        *e=p-&gt;data;</span><br><span class="line">        Q.front-&gt;next=p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(Q.rear==p)</span><br><span class="line">            Q.rear=Q.front;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取队头操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">QueueElementType <span class="title">GetHead</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(QueueEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;队列为空!读取队头失败!\n&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (Q.front-&gt;next.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四-矩阵的压缩存储"><a href="#四-矩阵的压缩存储" class="headerlink" title="四.矩阵的压缩存储"></a>四.矩阵的压缩存储</h2><h2 id="五-递归"><a href="#五-递归" class="headerlink" title="五.递归"></a>五.递归</h2><h2 id="六-树与二叉树"><a href="#六-树与二叉树" class="headerlink" title="六.树与二叉树"></a>六.树与二叉树</h2><h2 id="七-图"><a href="#七-图" class="headerlink" title="七.图"></a>七.图</h2><p>图形结构是一种比树形结构更复杂的非线性结构.在树形结构中,节点间具有分支层次关系,每一层上的节点只能和上一层中的至多一个节点相关,但可能和下一层的多个节点相关.而在图形结构中,任意两个节点之间都可能相关,即节点之间的邻接关系可以是任意的.</p>
<h3 id="图及其相关概念"><a href="#图及其相关概念" class="headerlink" title="图及其相关概念"></a>图及其相关概念</h3><ul>
<li>图是由顶点(vertex)集合及顶点间的关系组成的一种数据结构.</li>
<li>图分为无向图和有向图.具有n个顶点,n(n-1)/2条边的无向图,称为完全无向图.具有n个顶点,n(n-1)条弧的有向图称为完全有向图.完全无向图和完全有向图统称为完全图.</li>
<li>当一个图接近完全图时,称它为稠密图.相反称为稀疏图.</li>
<li>与边有关的数据信息称为权.带权图又称为网络.如果边是有方向的带权图,则是一个有向网络.</li>
<li>在无向图中,一个顶点依附的边的数目称为该顶点的度.在有向图中,指向顶点的弧的数目称为该顶点的入度(这种弧也称为入弧).从顶点发出的弧的数目称为该顶点的出度.有向图的某个顶点的入度和出度之和称为该顶点的度.</li>
<li>除第一个顶点与最后一个顶点之外,其它顶点不重复出现的回路称为简单回路(简单环).</li>
<li>若G中任意两个顶点都是连通的,则称G为连通图,否则称为非连通图.</li>
</ul>
<h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><h4 id="邻接矩阵表示法"><a href="#邻接矩阵表示法" class="headerlink" title="邻接矩阵表示法"></a>邻接矩阵表示法</h4><p>在图的邻接矩阵表示中,除用一个一维数组存放顶点本身的信息外,还用一个n×n的矩阵表示各个顶点之间的邻接关系.即若(i,j)或&lt;i,j&gt;属于边集E,则矩阵中第i行,第j列元素值为1,否则为0.</p>
<p>从无向图的邻接矩阵存储方法可以看出:</p>
<ol>
<li>无向图的邻接矩阵一定是一个对称矩阵</li>
<li>第i行或第i列中1的个数是顶点i的度</li>
<li>矩阵中1的个数的一半为图中边的数目</li>
</ol>
<p>从有向图的邻接矩阵存储方法可以看出:</p>
<ol>
<li>有向图的邻接矩阵不一定是一个对称矩阵</li>
<li>第i行中1的个数为顶点i的出度</li>
<li>第i列中1的个数为顶点i的入度</li>
<li>矩阵中1的个数为图中弧的数目</li>
</ol>
<p>从无向网络的邻接矩阵存储方法可以看出:</p>
<ol>
<li>无向网络的邻接矩阵一定是一个对称矩阵</li>
<li>第i行或第i列中非∞元素的个数为顶点i的度</li>
<li>矩阵中非∞元素的个数的一半为网络中边的数目</li>
</ol>
<p>从有向网络的邻接矩阵存储方法可以看出:</p>
<ol>
<li>有向网络的邻接矩阵不一定是一个对称矩阵</li>
<li>第i行中非∞元素的个数为顶点i的出度</li>
<li>第i列中非∞元素的个数为顶点i的入度</li>
<li>矩阵中非∞元素的个数为网络中弧的数目</li>
</ol>
<p>邻接矩阵的存储结构:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITY 65535 <span class="comment">//用65535表示∞</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVEX 100 <span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;<span class="comment">//顶点类型由用户定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType;<span class="comment">//边上的权值类型由用户定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    VertexType vexs[MAXVEX];<span class="comment">//顶点表</span></span><br><span class="line">    EdgeType arc[MAXVEX][MAXVEX];<span class="comment">//邻接矩阵,可看作边表</span></span><br><span class="line">    <span class="keyword">int</span> numVertexs,numEdges;<span class="comment">//图中当前的顶点和边数</span></span><br><span class="line">&#125;Mgraph;</span><br></pre></td></tr></table></figure>
<p>无向网图的邻接矩阵表示:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatMGraph</span><span class="params">(MGraph *G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k,w;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入顶点数和边数:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;G-&gt;numVertexs,&amp;G-&gt;numEdges);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;numVertexs;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(&amp;G-&gt;vexs[i]);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;numVertexs;i++)</span><br><span class="line">        <span class="keyword">for</span>(j<span class="number">-0</span>;j&lt;G-&gt;numVertexs;j++)</span><br><span class="line">            G-&gt;arc[i][j]=INFINITY;<span class="comment">//邻接矩阵初始化</span></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G-&gt;numEdges;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入边(vi,vj)上的下标i,下标j和权w:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d,%d&quot;</span>,&amp;i,&amp;j,&amp;w);</span><br><span class="line">        G-&gt;arc[i][j]=w;</span><br><span class="line">        G-&gt;arc[j][i]=G-&gt;arc[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="邻接表表示法"><a href="#邻接表表示法" class="headerlink" title="邻接表表示法"></a>邻接表表示法</h4><h2 id="八-查找"><a href="#八-查找" class="headerlink" title="八.查找"></a>八.查找</h2><h2 id="九-排序"><a href="#九-排序" class="headerlink" title="九.排序"></a>九.排序</h2><h3 id="排序的概念"><a href="#排序的概念" class="headerlink" title="排序的概念"></a>排序的概念</h3><p>排序(Sorting)就是按照某种规则,将一组数据对象(记录)排列次序,其主要目的是提高数据检索的效率.</p>
<h3 id="排序的分类"><a href="#排序的分类" class="headerlink" title="排序的分类"></a>排序的分类</h3><p>按照排序过程中所使用存储器情况,可将排序方法分为两大类:</p>
<p>1.内部排序</p>
<p>在排序过程中,整个待排序列都是存放于内存中进行处理,无内外存储器之间的数据交换问题.内部排序速度快,适合少量数据的排序处理.</p>
<p>2.外部排序</p>
<p>在排序过程中,由于待排序记录数据量相当大,不可能也不允许全部驻留在内存中,而必须存放在外部存储器上,然后根据排序过程中的要求,不断在内外存之间进行数据交换来完成排序工作.外部排序速度慢,适合大量数据的排序问处理.</p>
<p>内部排序的方法较多,按照实现策略的不同,可以将内部排序分五大类.</p>
<ol>
<li>插入排序.直接插入排序,希尔排序.</li>
<li>交换排序.冒泡排序,快速排序.</li>
<li>选择排序.直接选择排序,堆排序.</li>
<li>归并排序.</li>
<li>基数排序.</li>
</ol>
<p>假设待排序序列中记录的数据类型定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    ElementType otherinfo;<span class="comment">//排序记录中的其他所有数据项</span></span><br><span class="line">&#125;RecordType;</span><br><span class="line"><span class="keyword">typedef</span> RecordType SeqList[MaxSize+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>数组的第0个元素既可以用来作暂存空间使用,也可以作”监测哨兵”使用,但不用其存放待排序记录.在本章均要求排成递增序.</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p>思想:</p>
<p>1.将待排序序列分为有序区和无序区,初始时,有序区为[R1],无序区为[R2…Rn],令i指向无序区第一个元素,初值i=2</p>
<p>2.当i&lt;=n时,重复执行:将当前无序区第一个记录插入到有序区合适位置</p>
<p>3.当i&gt;n时,排序结束</p>
<p>算法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(SeqList R,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//length为待排序列长度</span></span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(R[i].key&lt;R[i<span class="number">-1</span>].key)</span><br><span class="line">        &#123;</span><br><span class="line">            R[<span class="number">0</span>]=R[i];</span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;R[<span class="number">0</span>].key&lt;R[j].key;j--)</span><br><span class="line">                R[j+<span class="number">1</span>]=R[j];<span class="comment">//记录后移</span></span><br><span class="line">            R[j+<span class="number">1</span>]=R[<span class="number">0</span>];</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哨兵的作用:</p>
<p>1.进入查找(插入位置)循环之前,它保存了R[i]的副本,使不至于记录后移而丢失R[i]的内容.</p>
<p>2.在查找循环中”监视”下标j是否越界.</p>
<p>直接插入排序的时间复杂度为O(n^2),空间复杂度为O(1),直接插入排序是稳定的</p>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>希尔排序也叫缩小增量排序,是插入排序的一种,在时间复杂度上比直接插入排序好.</p>
<p>思想:</p>
<p>1.先将整个待排序列以d1(d1&lt;n)为步长分成若干子序列,把所有相隔为d1的记录放在同一组</p>
<p>2.在每个分组内进行直接插入排序</p>
<p>3.再将整个待排序记录以d2(d2&lt;d1&lt;n)为步长重新分组,并在每组内进行直接插入排序</p>
<p>4.重复上步,直至dt=1,即所有记录放进一个组中进行直接插入排序,其最终结果为有序序列</p>
<p>算法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellPass</span><span class="params">(SeqList R,<span class="keyword">int</span> length,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//希尔排序的一次排序,length为待排序列长度,d为当前增量</span></span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=d+<span class="number">1</span>;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(R[i].key&lt;R[i-d].key)&#123;</span><br><span class="line">            R[<span class="number">0</span>]=R[i];</span><br><span class="line">            j=i-d;</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                R[j+d]=R[j];</span><br><span class="line">                j=j-d;</span><br><span class="line">            &#125;<span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;R[<span class="number">0</span>].key&lt;R[j].key)</span><br><span class="line">                R[j+d]=R[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(SeqList R,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//对序列R进行希尔排序,length为待排序长度</span></span><br><span class="line">    <span class="keyword">int</span> increment=length;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        increment=(increment+<span class="number">1</span>)/<span class="number">3</span>;</span><br><span class="line">        ShellPass(R,length,increment);</span><br><span class="line">    &#125;<span class="keyword">while</span>(increment&gt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>希尔排序时间复杂度可达到O(n^1.25),空间复杂度为O(1),希尔排序不稳定</p>
<h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><p>交换排序的基本思想是两两比较待排序记录的关键字,如果发现两个关键字逆序,则将两个记录位置互换,重复此过程,直到该系列所有关键字都有序为止.</p>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>思想:</p>
<p>1.将第一个记录的关键字与第二个记录的关键字比较,若二者为逆序(R[1].key&gt;R[2].key),则交换两记录位置,然后比较第二个记录与第三个记录,若两关键字为逆序,同样交换位置</p>
<p>2.依次类推,直至第n-1个记录与第n个记录比较完为止.上述过程称为第一趟冒泡排序,其结果使n个记录中关键字最大的记录被移动到最后一个位置</p>
<p>3.然后进行第二次冒泡排序,即对前n-1个记录重复与第一趟冒泡排序类似的过程,结果使关键字次大的记录被移到第n-1个记录位置</p>
<p>4.重复上述过程,直到”在一趟排序过程中没有进行交换记录的操作”为止</p>
<p>算法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(SeqList R,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,exchange=<span class="number">1</span>;<span class="comment">//exchange为发生交换的标志</span></span><br><span class="line">    <span class="keyword">for</span>(i=length;i&gt;<span class="number">1</span>&amp;&amp;exchange;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        exchange=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(R[j].key&lt;R[j+<span class="number">1</span>].key)</span><br><span class="line">            &#123;</span><br><span class="line">                R[<span class="number">0</span>]=R[j];</span><br><span class="line">                R[j]=R[j+<span class="number">1</span>];</span><br><span class="line">                R[j+<span class="number">1</span>]=R[<span class="number">0</span>];</span><br><span class="line">                exchange=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冒泡排序时间复杂度为O(n²),空间复杂度为O(1),且冒泡排序是稳定的</p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>快速排序采用一种分治的策略,通常称为分治法.分治的基本思想是:将原问题分解为若干规模更小但将结构与原问题相似的子问题,采用递归方法求解这些子问题,然后将这些子问题的解组合成原问题的解.</p>
<p>思想:</p>
<p>1.从待排序列中任取一个记录(例如)的关键字作为枢轴(pivot),按照枢轴,将整个待排序列划分为左右两个子序列,其中左子序列中所有关键字都小于等于枢轴,而右子序列中所有的关键字都大于枢轴,枢轴记录则排在这两个子序列中间(这也是该记录的最终位置).此过程称为一趟快速排序(或一次划分).</p>
<p>2.对左右两个子序列分别重复实施上述方法,直到所有的记录都排在相应的位置上为止(每个子序列只含一个记录)</p>
<p>算法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuickPass</span><span class="params">(SeqList R,<span class="keyword">int</span> b,<span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//对R[b],...R[e]作一趟划分,并返回枢轴记录的位置</span></span><br><span class="line">    <span class="keyword">int</span> i=b,j=e;</span><br><span class="line">    R[<span class="number">0</span>]=R[i];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">while</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>python笔记</title>
    <url>/blog/2021/01/28/python%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="python笔记"><a href="#python笔记" class="headerlink" title="python笔记"></a>python笔记</h1><a id="more"></a>









]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>BurpSuite的设置及使用</title>
    <url>/blog/2021/01/24/BurpSuite%E7%9A%84%E8%AE%BE%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="BurpSuite的设置及使用"><a href="#BurpSuite的设置及使用" class="headerlink" title="BurpSuite的设置及使用"></a>BurpSuite的设置及使用</h1><h2 id="1-BurpSuite安装与配置"><a href="#1-BurpSuite安装与配置" class="headerlink" title="1.BurpSuite安装与配置"></a>1.BurpSuite安装与配置</h2><h3 id="BurpSuite功能介绍"><a href="#BurpSuite功能介绍" class="headerlink" title="BurpSuite功能介绍"></a>BurpSuite功能介绍</h3><p>BurpSuite是用于攻击web应用程序的集成平台，包含了许多工具。BurpSuite为这些工具设计了许多接口，以加快攻击应用程序的过程。所有工具都共享-一个请求， 并能处理对应的HTTP消息、持久性、认证、代理、日志、警报。</p>
<p>Burpsuite是由JAVA语言编写,所以Burpsuite是-款跨平台的软件。 但是在测试过程中Buripsuite不像其他自动化测试工具不需要输入任何内容即可完成测试，而需要手动的配置某些参数触发对应的行为才会完成测试。</p>
<h2 id="2-BurpSuite-Proxy模块"><a href="#2-BurpSuite-Proxy模块" class="headerlink" title="2.BurpSuite Proxy模块"></a>2.BurpSuite Proxy模块</h2><p>Burp Proxy 是Burp Suite以用户驱动测试流程功能的核心，通过代理模式，可以让我们拦截、查看、修改所有在客户端和服务端之间传输的数据。</p>
<h3 id="1-Intercept"><a href="#1-Intercept" class="headerlink" title="1.Intercept"></a>1.Intercept</h3><p>Forward表示将截断的HTTP或HTTPS请求发送到服务器。<br>Drop表示将截断的HTTP或HTTPS请求丢弃。<br>Intercept is on和Intercept is off表示开启或关闭代理截断功能。<br>Action表示将代理截断的HT TP或HT TPS请求发送到其他模块或做其他处理。<br>对Intercept进行Raw Hex Params Header切换查看不同的数据格式。</p>
<h3 id="2-HTTP-history"><a href="#2-HTTP-history" class="headerlink" title="2.HTTP history"></a>2.HTTP history</h3><p>HTTP history用来查看提交过的HTTP请求。<br>Fiter可以过滤显示某些HTTP请求。点击Filter就可以打开。对于指定URL可以选中右键点击,执行其他操作。WebSockets history与HTTP history功能类似。</p>
<h3 id="3-options"><a href="#3-options" class="headerlink" title="3.options"></a>3.options</h3><p>Options具有的功能:代理监听设置、戳断客户端请求、截断服务器响应、截断WebSocket通信、服务端响应修改(绕过JS验证文件上传)、匹配与替换HTTP消息中的内容、通过SSL连接Web服务器配置、其他配置选项。</p>
<h3 id="4-设置proxy-listener"><a href="#4-设置proxy-listener" class="headerlink" title="4.设置proxy listener"></a>4.设置proxy listener</h3><p>通过设置Proxy Listeners来截断数据流量。比如设置监听端口等。BurpSuite默认监听8080端口.</p>
<p>修改端口:</p>
<p>1.关闭截断</p>
<p>2.options-&gt;edit</p>
<p>3.修改端口,点击running</p>
<p>4.修改浏览器端口</p>
<p>5.Internet选项-&gt;连接-&gt;局域网设置</p>
<p>6.修改端口</p>
<h3 id="5-设置intercept-client-requests"><a href="#5-设置intercept-client-requests" class="headerlink" title="5.设置intercept client requests"></a>5.设置intercept client requests</h3><p>通过设置Intercept Client Requests来截断符合条件的HTTP请求。</p>
<h3 id="6-设置Intercept-Server-Response"><a href="#6-设置Intercept-Server-Response" class="headerlink" title="6.设置Intercept Server Response"></a>6.设置Intercept Server Response</h3><p>通过设置Intercept Server Response来筛选出符合条件的HTTP响应。</p>
<h3 id="7-设置截断Websocket通信以及修改Response的内容"><a href="#7-设置截断Websocket通信以及修改Response的内容" class="headerlink" title="7.设置截断Websocket通信以及修改Response的内容"></a>7.设置截断Websocket通信以及修改Response的内容</h3><h3 id="8-匹配以及修改HTTP消息"><a href="#8-匹配以及修改HTTP消息" class="headerlink" title="8.匹配以及修改HTTP消息"></a>8.匹配以及修改HTTP消息</h3><p>可以修改HTTP请求和HTTP响应中的内容。</p>
<h2 id="3-Burpsuite抓取手机APP流量"><a href="#3-Burpsuite抓取手机APP流量" class="headerlink" title="3.Burpsuite抓取手机APP流量"></a>3.Burpsuite抓取手机APP流量</h2><p>目前WebApp(手机App)的通信任然使用HTTP协议进行对应的通信.可以通过Burp设置代理,然后手机设置网络代理,通过Burp截断手机APP流量.</p>
<p>1.Burpsuite设置截断所有网卡的流量，那么局城网中所有的主机都可以通过该代理进行网络访问。</p>
<p><img src="https://i.loli.net/2021/01/24/n1owBAfCMJXqvhW.png"></p>
<p><img src="https://i.loli.net/2021/01/24/Cu6NGxn2SI57hBs.png"></p>
<p>2.查看电脑ip</p>
<p>3.在手机网络设置中，填写对应的代理。</p>
<p><img src="https://i.loli.net/2021/01/24/gcYyFBzhjZEKOev.png"></p>
<p><img src="https://i.loli.net/2021/01/24/US7BIW1oNuXlHhJ.png"></p>
<p><img src="https://i.loli.net/2021/01/24/o8hED3xYzjUlvC9.png"></p>
<p>4.Burpsuite开启截断</p>
<p><img src="https://i.loli.net/2021/01/24/nU8QWAlJGESgP96.png"></p>
<h2 id="4-Burpsuite剔除JS脚本-绕过JS文件上传验证"><a href="#4-Burpsuite剔除JS脚本-绕过JS文件上传验证" class="headerlink" title="4.Burpsuite剔除JS脚本(绕过JS文件上传验证)"></a>4.Burpsuite剔除JS脚本(绕过JS文件上传验证)</h2><p>JavaScript—种直译式脚本语言，是一种动态类型、 弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML (标准通用标记语言下的一个应用)网页上使用，用来给HTML网页增加动态功能。例如:对于上传文件进行JS验证。</p>
<p><img src="https://i.loli.net/2021/01/25/P1A6G4zFDUpbRs3.png"></p>
<p>也可以使用浏览器审计工具直接删除JS</p>
<h2 id="5-Burpsuite-Target介绍"><a href="#5-Burpsuite-Target介绍" class="headerlink" title="5.Burpsuite Target介绍"></a>5.Burpsuite Target介绍</h2><p>Burp Target组件主要包含站点地图、目标域、Target 工具三部分组成，他们帮助渗透测试人员更好地了解目标应用的整体状况、当前的工作涉及哪些目标域、分析可能存在的攻击面等信息</p>
<p>Target Scope中作用域的定义比较宽泛，通常来说，当我们对某个产品进行渗透测试时，可以通过域名或者主机名去限制拦截内容，这里域名或主机名就是我们说的作用域;如果我们想限制得更为细粒度化，比如，你只想拦截login目录下的所有请求，这时我们也可以在此设置，此时，作用域就是目录。</p>
]]></content>
      <categories>
        <category>Hack</category>
      </categories>
      <tags>
        <tag>BurpSuite</tag>
      </tags>
  </entry>
  <entry>
    <title>Kail Linux虚拟机安装配置Nessus漏洞扫描器</title>
    <url>/blog/2021/01/25/Kail-Linux%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AENessus%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F%E5%99%A8/</url>
    <content><![CDATA[<h1 id="Kail-Linux虚拟机安装配置Nessus漏洞扫描器"><a href="#Kail-Linux虚拟机安装配置Nessus漏洞扫描器" class="headerlink" title="Kail Linux虚拟机安装配置Nessus漏洞扫描器"></a>Kail Linux虚拟机安装配置Nessus漏洞扫描器</h1><a id="more"></a>

<h2 id="1-获取激活码"><a href="#1-获取激活码" class="headerlink" title="1.获取激活码"></a>1.获取激活码</h2><p>前往<a href="https://www.tenable.com/products/nessus/nessus-essentials">官网</a>进行注册</p>
<p><img src="https://i.loli.net/2021/01/26/HVptOeBDnJZlF6w.png"></p>
<h2 id="2-下载nessus"><a href="#2-下载nessus" class="headerlink" title="2.下载nessus"></a>2.下载nessus</h2><p>注册完毕后前往下载页面</p>
<p><img src="https://i.loli.net/2021/01/26/SaI7x2nDEHRfMOu.png"></p>
<p>选择deb结尾的(我选择的64位)</p>
<p><img src="https://i.loli.net/2021/01/26/hPzGvds7T2bXirE.png"></p>
<p>官网下载较慢,这里我准备了一份,<a href="https://idefun.lanzous.com/iQnR4kvm5oh">点击下载</a></p>
<h2 id="3-安装nessus"><a href="#3-安装nessus" class="headerlink" title="3.安装nessus"></a>3.安装nessus</h2><p>将nessus拖入kail linux虚拟机</p>
<p><img src="https://i.loli.net/2021/01/26/Mca54FXCQuY6x7p.png"></p>
<p>打开终端,切换至桌面</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd 桌面</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/26/ekf7ri8R54ZuwDW.png"></p>
<p>安装nessus(需要密码)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i Nessus-8.13.1-debian6_amd64.deb</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/26/hYk1gFqJplIuQw9.png"></p>
<p>安装完成</p>
<p><img src="https://i.loli.net/2021/01/26/KWfAuHosZB7vJ1F.png"></p>
<h2 id="4-启动nessus"><a href="#4-启动nessus" class="headerlink" title="4.启动nessus"></a>4.启动nessus</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/bin/systemctl start nessusd.service</span><br></pre></td></tr></table></figure>
<p>同样需要密码</p>
<img src="https://i.loli.net/2021/01/26/1Wjf7rMiImHSk4A.png"  />

<p>在浏览器中访问</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">https://kali:8834/</span><br></pre></td></tr></table></figure>
<p>选择Managed Scanner</p>
<p><img src="https://i.loli.net/2021/01/26/Y9wajpE7ye1JhVv.png"></p>
<p>选择Tenable.sc</p>
<p><img src="https://i.loli.net/2021/01/26/ONiI4T2EJeylcZ5.png"></p>
<p>创建账号</p>
<p><img src="https://i.loli.net/2021/01/26/1KLS8misZR7DVCI.png"></p>
]]></content>
      <categories>
        <category>Hack</category>
      </categories>
      <tags>
        <tag>Nessus</tag>
        <tag>Kail</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode刷题记录</title>
    <url>/blog/2021/01/27/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="Leetcode刷题记录"><a href="#Leetcode刷题记录" class="headerlink" title="Leetcode刷题记录"></a>Leetcode刷题记录</h1><a id="more"></a>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习笔记</title>
    <url>/blog/2021/01/27/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Linux学习笔记"><a href="#Linux学习笔记" class="headerlink" title="Linux学习笔记"></a>Linux学习笔记</h1><a id="more"></a>

<h2 id="Linux注意事项"><a href="#Linux注意事项" class="headerlink" title="Linux注意事项"></a>Linux注意事项</h2><p>Ctrl+a  快速回到行首</p>
<p>Ctrl+e  快速回到行末</p>
<p>Linux严格区分大小写.</p>
<p>Linux中所有内容以文件形式保存，包括硬件</p>
<ul>
<li>硬盘文件是/dev/sd[a-p]</li>
<li>光盘文件是/dev/sr0</li>
</ul>
<p>Linux不靠扩展名区分文件类型(扩展名便于用户使用),靠文件权限</p>
<ul>
<li>压缩包: “*.gz”、”*.bz2”、”*.tar.bz2”、”*.tgz”等</li>
<li>二进制软件包: “*.rpm”</li>
<li>网页文件: “*.html”、”*.php”</li>
<li>脚本文件: “*.sh”</li>
<li>配置文件: “*.conf”</li>
</ul>
<p>Linux所有的存储设备都必须挂载,之后用户才能使用,包括硬盘、U盘和光盘</p>
<p>Windows下的程序不能直接在Iinux中安装和运行</p>
<h2 id="服务器管理和维护"><a href="#服务器管理和维护" class="headerlink" title="服务器管理和维护"></a>服务器管理和维护</h2><h3 id="目录及作用"><a href="#目录及作用" class="headerlink" title="目录及作用"></a>目录及作用</h3><table>
<thead>
<tr>
<th>目录名</th>
<th>目录作用</th>
</tr>
</thead>
<tbody><tr>
<td>/bin/</td>
<td>存放系统命令的目录，普通用户和超级用户都可以执行。不过放在/bin下的命令在单用户模式下也可以执行</td>
</tr>
<tr>
<td>/sbin/</td>
<td>保存和系统环境设置相关的命令，只有超级用户可以使用这些命令进行系统环境设置，但是有些命令可以允许普通用户查看</td>
</tr>
<tr>
<td>/usr/bin/</td>
<td>存放系统命令的目录，普通用户和超级用户都可以执行。这些命令和系统启动无关，在单用户模式下不能执行</td>
</tr>
<tr>
<td>/usr/sbin/</td>
<td>存放根文件系统不必要的系统管理命令，例如多数服务程序。只有超级用户可以使用。大家其实可以注意到Linux的系统，在所有“sbin” 目录中保存的命令只有超级用户可以使用，“bin”目录中保存的命令所有用户都可以使用</td>
</tr>
<tr>
<td>/boot/</td>
<td>系统启动目录，保存系统启动相关的文件，如内核文件和启动引导程序( grub)文件等</td>
</tr>
<tr>
<td>/dev/</td>
<td>设备文件保存位置。我们已经说过Linux中所有内容以文件形式保存，包括硬件。那么这个目录就是用来保存所有硬件设备文件的</td>
</tr>
<tr>
<td>/etc/</td>
<td>配置文件保存位置。系统内所有采用默认安装方式(rpm安装)的服务的配置文件全部都保存在这个目录当中，如用户账户和密码，服务的启动脚本，常用服务的配置文件等</td>
</tr>
<tr>
<td>/home/</td>
<td>普通用户的家目录。建立每个用户时，每个用户要有一个默认登录位置，这个位置就是这个用户的家目录，所有普通用户的家目录就是在/home下建立一个和用户名相同的目录。如用户user1 的家目录就是home/user1</td>
</tr>
<tr>
<td>/lib/</td>
<td>系统调用的函数库保存位置</td>
</tr>
<tr>
<td>/lost+found/</td>
<td>当系统意外崩溃或机器意外关机，而产生一些文件碎片放在这里。当系统启动的过程中fsck工具会检查这里，并修复已经损坏的文件系统。这个目录只在每个分区中出现，例如/lost+found就是根分区的备份恢复目录，/boot/lost+ found就是/boot分区的备份恢复目录</td>
</tr>
<tr>
<td>/media/</td>
<td>挂载目录。系统建议是用来挂载媒体设备的，例如软盘和光盘</td>
</tr>
<tr>
<td>/mnt/</td>
<td>挂载目录，早期Linux中只有这一个挂载目录，并没有细分。现在这个目录系统建议挂载额外设备，如U盘，移动硬盘和其他操作系统的分区</td>
</tr>
<tr>
<td>/misc/</td>
<td>挂载目录。系统建议用来挂载NFS服务的共享目录。只要是一个已经建立的空目录就可以作为挂载点。那么系统虽然准备了三个默认挂载目录/media、/mnt、 /misc, 但是到底在哪个目录中挂载什么设备都可以由管理员自己决定。例如在/mnt下建立不同目录挂载不同设备。如/mnt/cdrom挂载光盘，/mnt/usb挂载U盘</td>
</tr>
<tr>
<td>/opt/</td>
<td>第三方安装的软件保存位置。这个目录就是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录当中。/usr/local目录也可以用来安装软件(更为常用)</td>
</tr>
<tr>
<td>/proc/</td>
<td>虚拟文件系统，该目录中的数据并不保存到硬盘当中，而是保存到内存当中。主要保存系统的内核，进程，外部设备状态和网络状态灯。如/proc/cpuinfo是保存CPU信息的，/proc/devices是保存设备驱动的列表的，/proc/filesystems是保存文件系统列表的，/proc/net/是保存网络协议信息的</td>
</tr>
<tr>
<td>/sys/</td>
<td>虚拟文件系统。和/proc 目录相似，都是保存在内存当中的，主要是保存于内核相关信息的</td>
</tr>
<tr>
<td>/root/</td>
<td>超级用户的家目录。普通用户家目录在“home”下，超级用户家目录直接在“/”下</td>
</tr>
<tr>
<td>/srv/</td>
<td>服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据</td>
</tr>
<tr>
<td>/tmp/</td>
<td>临时目录。系统存放临时文件的目录，该目录下所有用户都可以访问和写入。建议此目录中不能保存重要数据，最好每次开机都把该目录清空</td>
</tr>
<tr>
<td>/usr/</td>
<td>系统软件资源目录。注意usr不是user的缩写，而是“Unix Softwre Resource”的缩写，所以不是存放用户数据，而是存放系统软件资源的目录。系统中安装的软件大多数保存在这里</td>
</tr>
<tr>
<td>/var/</td>
<td>动态数据保存位置。主要保存缓存、日志以及软件运行所产生的文件</td>
</tr>
</tbody></table>
<h3 id="服务器注意事项"><a href="#服务器注意事项" class="headerlink" title="服务器注意事项"></a>服务器注意事项</h3><ul>
<li>远程服务器不允许关机，只能重启</li>
<li>重启时应该正确关闭服务</li>
<li>不要在服务器访问高峰运行高负载命令</li>
<li>远程配置防火墙时不要把自己踢出服务器</li>
<li>指定合理的密码规范并定期更新</li>
<li>合理分配权限</li>
<li>定期备份重要数据和日志</li>
</ul>
<h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><h3 id="文件处理命令"><a href="#文件处理命令" class="headerlink" title="文件处理命令"></a>文件处理命令</h3><h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>命令格式:命令 [-选项] [参数]<br>例:ls -la /etc<br>说明:</p>
<ol>
<li>个别命令使用不遵循此格式</li>
<li>当有多个选项时，可以写在一起,绝大多数顺序也可以改变</li>
<li>简化选项与完整选项<br>-a等于--all</li>
</ol>
<h4 id="目录处理命令"><a href="#目录处理命令" class="headerlink" title="目录处理命令"></a>目录处理命令</h4><h5 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h5><p>命令名称: ls<br>命令英文原意:list<br>命令所在路径: /bin/ls<br>执行权限:所有用户<br>功能描述:显示目录文件<br>语法: ls 选项[-ald] [文件或目录]<br>    -a  显示所有文件，包括隐藏文件<br>    -1  详细信息显示<br>    -d  查看目录属性</p>
<p>-rw-r--r--</p>
<ul>
<li>- 文件类型(-二进制文件 d目录 l软链接文件)</li>
<li>rw- r-- r--<br>u     g    o<br>u所有者 g所属组 o其他人<br>r读 w写 x执行</li>
</ul>
<h5 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h5><p>命令名称: mkdir<br>命令英文原意: make directories<br>命令所在路径: /bin/mkdir<br>执行权限: 所有用户<br>语法: mkdir -p [目录名]<br>功能描述:创建新目录<br>      -p  递归创建(不加-p只能在已有目录创建一个新目录,而不能创建一个带有子目录的目录)</p>
<p>mkdir可同时创建多个目录  </p>
<h5 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h5><p>命令名称: cd<br>命令英文原意: change directory<br>命令所在路径: shell内置命令<br>执行权限: 所有用户<br>语法: cd [目录]<br>功能描述: 切换目录</p>
<h5 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h5><p>命令名称: pwd<br>命令英文原意: print working directory<br>命令所在路径: /bin/pwd<br>执行权限: 所有用户<br>语法: pwd<br>功能描述: 显示当前目录</p>
<h5 id="rmdir命令"><a href="#rmdir命令" class="headerlink" title="rmdir命令"></a>rmdir命令</h5><p>命令名称: rmdir<br>命令英文原意: remove empty directories<br>命令所在路径: /bin/rmdir<br>执行权限: 所有用户<br>语法: rmdir [目录名]<br>功能描述: 只能删除空目录</p>
<h5 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h5><p>命令名称: cp<br>命令英文原意: copy<br>命令所在路径: /bin/cp<br>执行权限: 所有用户<br>语法: cp -rp [原文件或目录] [目标目录]<br>    -r  复制目录<br>    -p  保留文件属性(不加-p时会改变文件的修改时间)<br>功能描述: 复制文件或目录到另一个文件(改名)或目录</p>
<p>cp命令可以同时复制多个目录或文件,可以复制并同时改名</p>
<h5 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h5><p>命令名称: mv<br>命令英文原意: move<br>命令所在路径: /bin/mv<br>执行权限: 所有用户<br>语法: mv [原文件或目录] [目标目录]<br>功能描述: 剪切文件、改名</p>
<h5 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h5><p>命令名称: rm<br>命令英文原意: remove<br>命令所在路径: /bin/rm<br>执行权限: 所有用户<br>语法: rm -rf [文件或目录]<br>    -r  删除目录<br>    -f  强制执行<br>功能描述: 删除文件</p>
<p>Linux没有回收站概念,删除文件要谨慎.删除文件前要备份,一旦发现误删除情况,尽量不要对硬盘做过多的读写或查找操作.</p>
<h4 id="文件处理命令-1"><a href="#文件处理命令-1" class="headerlink" title="文件处理命令"></a>文件处理命令</h4><h4 id="链接命令"><a href="#链接命令" class="headerlink" title="链接命令"></a>链接命令</h4><h3 id="权限管理命令"><a href="#权限管理命令" class="headerlink" title="权限管理命令"></a>权限管理命令</h3><h3 id="文件搜索命令"><a href="#文件搜索命令" class="headerlink" title="文件搜索命令"></a>文件搜索命令</h3><h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><h3 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h3><h3 id="压缩解压命令"><a href="#压缩解压命令" class="headerlink" title="压缩解压命令"></a>压缩解压命令</h3><h3 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h3><h3 id="关机重启命令"><a href="#关机重启命令" class="headerlink" title="关机重启命令"></a>关机重启命令</h3>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>教你如何获取腾讯视频源地址链接</title>
    <url>/blog/2021/01/28/%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E8%85%BE%E8%AE%AF%E8%A7%86%E9%A2%91%E6%BA%90%E5%9C%B0%E5%9D%80%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<h1 id="教你如何获取腾讯视频源地址链接"><a href="#教你如何获取腾讯视频源地址链接" class="headerlink" title="教你如何获取腾讯视频源地址链接"></a>教你如何获取腾讯视频源地址链接</h1><a id="more"></a>

<p>下面以<a href="https://v.qq.com/x/cover/umpnsyqfu7f60se/n003547u6to.html">星骸骑士第5集</a>为例获取其视频源链接</p>
<h2 id="1-获取视频vid"><a href="#1-获取视频vid" class="headerlink" title="1.获取视频vid"></a>1.获取视频vid</h2><p><img src="https://i.loli.net/2021/01/28/qaZ7UP3RvO2p9wn.png" alt="image-20210128094307061"></p>
<p>本视频的vid为:<strong>n003547u6to</strong></p>
<h2 id="2-获取视频相关信息"><a href="#2-获取视频相关信息" class="headerlink" title="2.获取视频相关信息"></a>2.获取视频相关信息</h2><p>将获取的vid替换到以下接口地址中的vid</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">http://vv.video.qq.com/getinfo?vids=n003547u6to&amp;platform=101001&amp;charge=0&amp;otype=json</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/28/bKydUeomPDJ26pv.png" alt="image-20210128094934650"></p>
<p>替换后直接访问<a href="https://vv.video.qq.com/getinfo?vids=n003547u6to&platform=101001&charge=0&otype=json">此接口地址</a>,得到视频相关信息</p>
<p><img src="https://i.loli.net/2021/01/28/6WDMa4ZYCpmK9c7.png" alt="image-20210128095135162"></p>
<h2 id="3-记录fn值-fvkey值-url值"><a href="#3-记录fn值-fvkey值-url值" class="headerlink" title="3.记录fn值,fvkey值,url值"></a>3.记录fn值,fvkey值,url值</h2><img src="https://i.loli.net/2021/01/28/ClqnVZ8i17ymrbQ.png" alt="image-20210128095804655" style="zoom:150%;" />

<p>fn值:n003547u6to.mp4</p>
<p>fvkey值:C6BC3B0988CA19AA2F174E5D78E2B423980D558135C5C2D121533A22C4296B58AC52A0CCA5E0D1F2999B20CF4B4A9DCE560088AA238AFA2DD377158F603EEF853EF7FE56F25027CCEE6856BC6C53C831D055DF618F89D9405DE9A84A9B3D3F183F50B8B26BD49B564C9B733F27791429</p>
<p>url值:<a href="http://101.206.186.29/vlive.qqvideo.tc.qq.com/A8q7f567bhHzdteBgaLoRWLtIt01ZxK4F-vSY8TLLzUo/uwMROfz2r5zAoaQXGdGlC2dfDmYqGCmd2Ymfgp6_SfoyIMNz/">http://101.206.186.29/vlive.qqvideo.tc.qq.com/A8q7f567bhHzdteBgaLoRWLtIt01ZxK4F-vSY8TLLzUo/uwMROfz2r5zAoaQXGdGlC2dfDmYqGCmd2Ymfgp6_SfoyIMNz/</a></p>
<h2 id="4-通过公式组合成源视频链接"><a href="#4-通过公式组合成源视频链接" class="headerlink" title="4.通过公式组合成源视频链接"></a>4.通过公式组合成源视频链接</h2><p>组合公式为：url值 + fn值? + vkey值 + fvkey值(注意fn值后面要加个问号)</p>
<p><img src="https://i.loli.net/2021/01/28/AeaLG8kNQ5Y9Cc7.png" alt="image-20210128100914780"></p>
<p>源视频链接为:<a href="http://101.206.186.29/vlive.qqvideo.tc.qq.com/A8q7f567bhHzdteBgaLoRWLtIt01ZxK4F-vSY8TLLzUo/uwMROfz2r5zAoaQXGdGlC2dfDmYqGCmd2Ymfgp6_SfoyIMNz/n003547u6to.mp4?C6BC3B0988CA19AA2F174E5D78E2B423980D558135C5C2D121533A22C4296B58AC52A0CCA5E0D1F2999B20CF4B4A9DCE560088AA238AFA2DD377158F603EEF853EF7FE56F25027CCEE6856BC6C53C831D055DF618F89D9405DE9A84A9B3D3F183F50B8B26BD49B564C9B733F27791429">http://101.206.186.29/vlive.qqvideo.tc.qq.com/A8q7f567bhHzdteBgaLoRWLtIt01ZxK4F-vSY8TLLzUo/uwMROfz2r5zAoaQXGdGlC2dfDmYqGCmd2Ymfgp6_SfoyIMNz/n003547u6to.mp4?C6BC3B0988CA19AA2F174E5D78E2B423980D558135C5C2D121533A22C4296B58AC52A0CCA5E0D1F2999B20CF4B4A9DCE560088AA238AFA2DD377158F603EEF853EF7FE56F25027CCEE6856BC6C53C831D055DF618F89D9405DE9A84A9B3D3F183F50B8B26BD49B564C9B733F27791429</a></p>
]]></content>
      <categories>
        <category>无处安放</category>
      </categories>
      <tags>
        <tag>视频解析</tag>
      </tags>
  </entry>
</search>
