<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux C编程</title>
    <url>/blog/2021/01/11/Linux-C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Linux-C编程"><a href="#Linux-C编程" class="headerlink" title="Linux C编程"></a>Linux C编程</h1><h2 id="vim简介"><a href="#vim简介" class="headerlink" title="vim简介"></a>vim简介</h2><p>Vim 采⽤模式编辑的理念，即它提供了多种模式，按键在不同的模式下作⽤不同。 你可以在普通模式 下浏览⽂件，在插⼊模式下插⼊⽂本， 在可视模式下选择⾏，在命令模式下执⾏命令等等。起初这听起来可能很复杂， 但是这有⼀个很⼤的优点：不需要通过同时按住多个键来完成操作， ⼤多数时候你只需要依次按下这些按键即可。越常⽤的操作，所需要的按键数量越少。<br>和模式编辑紧密相连的概念是 操作符 和 动作。 操作符 指的是开始某个⾏为， 例如：修改、删除或者选择⽂本，之后你要⽤⼀个 动作 来指定需要操作的⽂本域。 ⽐如，要改变括号内的⽂本，需要执⾏ ci( （读做 change inner parentheses ）； 删除整个段落的内容，需要执⾏ dap （读做： delete around paragraph ）。  </p>
<p>:q! &lt;回车&gt;       退出编辑器并丢弃改动</p>
<p>:wq &lt;回车&gt;       保存改动并退出</p>
<p>vimtutor &lt;回车&gt;     进入vim学习教程</p>
<p><ESC>         返回normal模式</p>
<p>(normal模式下)</p>
<p>x    删除光标所在位置的字符（一个字符）</p>
<p>i    插入文本</p>
<p>A   添加文本</p>
<p>删除命令：</p>
<p>   d motion</p>
<p> 其中：</p>
<p>​     d      -删除操作符</p>
<p>​     motion  -操作符的操作对象</p>
<p>dw   从光标处删除至下一个单词的起始处（不包括它的第一个字符）</p>
<p>de   从当前光标处删除至下一个单词末尾（包括最后一个字符）</p>
<p>d$   从当前光标删除至行末</p>
<p>dd   删除光标所在位置的整行</p>
<p><x>dd  删除光标所在位置及接下来的x行</p>
<p>使用计数删除：</p>
<p>​    d number(数字) motion</p>
<p>计数命令：  </p>
<p><x>w 使光标向前（向右）移动到第x个单词首</p>
<p><x>e  使光标向前（向右）移动到第x个单词尾</p>
<p>撤销类命令：</p>
<p>U   撤销对整行的修改</p>
<p>u   撤销以前的操作</p>
<p>Ctrl+r 撤销以前的撤销命令</p>
<p>置入类命令：</p>
<p>p  将最后一次删除的内容置入光标之后（准备置入的位置的上方）</p>
<p>替换类命令：</p>
<p>r&lt;字符&gt;  替换光标所在位置的字符</p>
<p>更改类命令：</p>
<p>ce  删除光标处至一个单词结束并添加字符</p>
<p>更改类操作符的工作方式跟删除类是一致的。操作格式是：</p>
<p>c [number] motion</p>
<p>动作参数(motion)也是一样的，比如 w 代表单词，$代表行末等等</p>
<p>交换文件说明:</p>
<ol>
<li>vi写文件，没有保存就关闭，自动生成一个后缀为. swp交换文件， 保存了之前写的内容</li>
<li>先恢复，再删除.swp交换文件</li>
</ol>
<h2 id="C语言处理过程"><a href="#C语言处理过程" class="headerlink" title="C语言处理过程"></a>C语言处理过程</h2><p>C代码编译成可执行程序经过4步:<br>1)预处理:宏定义展开、头文件展开、条件编译等，同时将代码中的注释删除，这里并不会检查语法<br>2)编译:检查语法，将预处理后文件编译生成汇编文件<br>3)汇编:将汇编文件生成目标文件(二进制文件)<br>4)链接: C语言写的程序是需要依赖各种库的，所以编译之后还需要把库链接到最终的可执行程序中去</p>
<p>预处理:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure>
<p>编译:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure>
<p>汇编:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure>
<p>链接:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc hello.o -o hello</span><br></pre></td></tr></table></figure>
<p>查看程序所需动态库:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ldd hello   //linux</span><br></pre></td></tr></table></figure>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h3><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p><strong>C的关键字共有32个</strong></p>
<ul>
<li><p>数据类型关键字(12个)</p>
<p>char, short, int, long, float, double,unsigned, signed, struct, union, enum, void</p>
</li>
<li><p>控制语句关键字(12个)</p>
<p>if, else, switch, case, default,for , do, while, break, continue, goto, return</p>
</li>
<li><p>存储类关键字(5个)</p>
<p>auto,extern,register, static,const</p>
</li>
<li><p>其他关键字(3个)</p>
<p>sizeof, typedef, volatile</p>
</li>
</ul>
<h4 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h4><p>数据类型的作用:编译器预算对象(变量)分配的内存空间大小</p>
<p><img src="https://i.loli.net/2021/01/11/JgoTpVBjXIPWQLD.png" alt="image-20210111193755278"></p>
<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><ul>
<li>在程序运行过程中，其值不能被改变的量</li>
<li>常量一般出现在表达式或赋值语句中</li>
</ul>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul>
<li>在程序运行过程中，其值可以改变</li>
<li>变量在使用前必须先定义，定义变量前必须有相应的数据类型</li>
</ul>
<p>标识符命名规则:</p>
<ul>
<li><p>标识符不能是关键字</p>
</li>
<li><p>标识符只能由字母、数字、下划线组成</p>
</li>
<li><p>第一个字符必须为字母或下划线</p>
</li>
<li><p>标识符中字母区分大小写</p>
</li>
</ul>
<p>变量特点:</p>
<ul>
<li>变量在编译时为其分配相应的内存空间</li>
<li>可以通过其名字和地址访问相应内存</li>
</ul>
<p>声明和定义区别:</p>
<ul>
<li>声明变量不需要建立存储空间，如: extern int a;(a不能赋值)</li>
<li>定义变量需要建立存储空间，如: int b;</li>
<li>-般的情况下，把建立存储空间的声明称之为“定义”，而把不需要建立存储空间的声明称之为”声明”.</li>
</ul>
<h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h3><h4 id="C语言如何表示相应的进制数"><a href="#C语言如何表示相应的进制数" class="headerlink" title="C语言如何表示相应的进制数"></a>C语言如何表示相应的进制数</h4><table>
<thead>
<tr>
<th>十进制</th>
<th>以正常数字1-9开头,如123</th>
</tr>
</thead>
<tbody><tr>
<td>八进制</td>
<td>以0(零)开头,如0123</td>
</tr>
<tr>
<td>十六进制</td>
<td>以0x开头,如0x123</td>
</tr>
<tr>
<td>二进制</td>
<td>C语言不能直接书写二进制数</td>
</tr>
</tbody></table>
<h3 id="计算机内存数值存储方式"><a href="#计算机内存数值存储方式" class="headerlink" title="计算机内存数值存储方式"></a>计算机内存数值存储方式</h3><p>在计算机系统中，数值一律用补码来存储。</p>
<h4 id="原码"><a href="#原码" class="headerlink" title="原码:"></a>原码:</h4><p>最高位为符号位:0代表正数,1代表负数​</p>
<p>原码存储导致2个问题:</p>
<ol>
<li> 0有两种存储方式</li>
<li> 正数和负数相加结果不正确</li>
</ol>
<h4 id="反码"><a href="#反码" class="headerlink" title="反码:"></a>反码:</h4><p>反码是为了算补码.正数的原码和反码是一样的,负数的反码在原码基础上,符号位不变,其它位取反(0为1,1变0 ).</p>
<p>反码存储导致1个问题:</p>
<ol>
<li> 0有两种存储方式</li>
</ol>
<h4 id="补码"><a href="#补码" class="headerlink" title="补码:"></a>补码:</h4><p>正数的原码,反码,补码都一样</p>
<p>负数的补码为其反码加1</p>
<p>十进制数,站在用户角度看,<strong>原码</strong>;二进制,八进制,十六进制,要站在计算机角度看,<strong>补码</strong>.</p>
<p>原码求补码:</p>
<ol>
<li>正数原,反,补码均相同</li>
<li>负数原码最高位不变,其他位取反得反码</li>
<li>反码加1得补码</li>
</ol>
<p>补码求原码(同上面类似):</p>
<ol>
<li>正数原,反,补码均相同</li>
<li>负数补码最高位不变,其他位取反得反码</li>
<li>反码加1得原码</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> a=<span class="number">0x81</span>;<span class="comment">//a是值为十六进制数的字符,在计算机看来是补码</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);<span class="comment">//%d为输出十进制数,在用户看来是原码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序运行结果如下:</p>
<p><img src="https://i.loli.net/2021/01/12/l23jvtQaPwTHyWG.png"></p>
<p>按照十六进制转十进制,0x81等于129而不是-127</p>
<p>分析:</p>
<ol>
<li>0x81在计算机角度看来应为补码存储,其二进制形式为10000001</li>
<li>输出%d即输出十进制数,十进制数在用户角度为原码</li>
<li>由(1)(2)知,该程序即将0x81的补码转换为原码</li>
<li>其原码为11111111,即-127</li>
</ol>
<p>有符号和无符号的区别:</p>
<ul>
<li>%d,默认以有符号的方式打印</li>
<li>%u,默认以无符号的方式打印</li>
<li>有符号，最高位是符号位，如果是1代表为负数，如果为0代表为正数</li>
<li>无符号，最高位不是符号位，是数的一部分，无符号不可能是负数</li>
</ul>
<p>数据类型范围:</p>
<p>char    1个字节</p>
<img src="https://i.loli.net/2021/01/12/UNxsfOjRD2cu9eY.png" alt="image-20210112214358475" style="zoom:80%;" />

<p>数值越界:</p>
<p>通过以下代码解释</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">//情况1 有符号</span></span><br><span class="line">        <span class="comment">//char 范围 -128~127</span></span><br><span class="line">        <span class="keyword">char</span> a=<span class="number">127</span>+<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/* a=129,转换二进制为1000 0001,</span></span><br><span class="line"><span class="comment">          二进制(1000 0001)以补码形式存储,</span></span><br><span class="line"><span class="comment">          输出为%d,要求得原码(11111111),</span></span><br><span class="line"><span class="comment">          即-127</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);<span class="comment">//输出-127</span></span><br><span class="line">        <span class="comment">//情况2 无符号</span></span><br><span class="line">        <span class="comment">//无符号 范围 0~255</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> b=<span class="number">255</span>+<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/* b=257,转换二进制为1 0000 0001,</span></span><br><span class="line"><span class="comment">           舍弃最高位为0000 0001,</span></span><br><span class="line"><span class="comment">           二进制(0000 0001)以补码形式存储,</span></span><br><span class="line"><span class="comment">           转为原码(0000 0001),</span></span><br><span class="line"><span class="comment">           即1</span></span><br><span class="line"><span class="comment">           注意编译时会警告,之后./文件名运行即可</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>,b);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下:</p>
<p><img src="https://i.loli.net/2021/01/13/GL8cpTQzUtFu7n1.png" alt="image-20210113191321188"></p>
<h4 id="sizeof关键字"><a href="#sizeof关键字" class="headerlink" title="sizeof关键字"></a>sizeof关键字</h4><ul>
<li>sizeof不是函数，所以不需要包含任何头文件，它的功能是计算一个数据类型的大小，单位为字节</li>
<li>sizeof的返回值为size_ t</li>
<li>size_t 类型在32位操作系统下是unsigned int,是一个无符号的整数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*数据类型的作用:告诉编译器,</span></span><br><span class="line"><span class="comment">    定义此类型变量需要分配多大空间*/</span>					<span class="built_in">printf</span>(<span class="string">&quot;sizeof(char)=%lu\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">   	<span class="built_in">printf</span>(<span class="string">&quot;sizeof(a)=%lu\n&quot;</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下:</p>
<img src="https://i.loli.net/2021/01/13/3VmSN7iDcPkwLsY.png" style="zoom:150%;" />

<p>%d,%o,%x,%u等均以四个字节形式打印.</p>
<p>short占两个字节,short a;与short int a;等价.</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>占用空间</th>
</tr>
</thead>
<tbody><tr>
<td>short (短整型)</td>
<td>2字节</td>
</tr>
<tr>
<td>int (整型)</td>
<td>4字节</td>
</tr>
<tr>
<td>1ong(长整形)</td>
<td>Windows为4字节，Linux为 4字节(32位)，8字节(64位)</td>
</tr>
<tr>
<td>long long (长长整形)</td>
<td>8字节</td>
</tr>
</tbody></table>
<h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><p>字符型变量用于存储一个单一字符，在C语言中用char 表示，其中每个字符变量都会占用1个字节。在给字符型变量赋值时，需要用一对英文半角格式的单引号(‘ ‘)把字符括起来。<br>字符变量实际上并不是把该字符本身放到变量的内存单元中去，而是将该字符对应的ASCII 编码放到变量的存储单元中。char 的本质就是一个1 字节大小的整型。</p>
<p>使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man ascii</span><br></pre></td></tr></table></figure>
<p>查看ASCII码</p>
<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>字符在单引号内,原则上’ ‘内部只有一个字符,转义字符除外,不能char a=’abc’</p>
<p>转义字符由反斜杠\组成的多个字符</p>
<p>例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> a=<span class="string">&#x27;\r&#x27;</span>;<span class="comment">//光标移到句首</span></span><br><span class="line">        <span class="keyword">char</span> b=<span class="string">&#x27;\b&#x27;</span>;<span class="comment">//退格</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;12345%c6789\n&quot;</span>,a);<span class="comment">//先打印12345,之后光标移到句首再依次打印6789,其中1234被覆盖,留下5,结果为67895</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;abcde%cfghi\n&quot;</span>,b);<span class="comment">//先打印abcde之后打印\b,退一格,e就没了,结果为abcdfghi</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/22/wYUVzd2mpNqX3LQ.png"></p>
<h3 id="浮点型-实型"><a href="#浮点型-实型" class="headerlink" title="浮点型(实型)"></a>浮点型(实型)</h3><p>实型变量也可以称为浮点型变量，浮点型变量是用来存储小数数值的。在C语言中，浮点型变量分为两种:单精度浮点数(float)、双精度浮点数(double)，但是double型变量所表示的浮点数比float 型变量更精确。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>占用空间</th>
<th>有效数字范围</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>4字节</td>
<td>7位有效数字</td>
</tr>
<tr>
<td>double</td>
<td>8字节</td>
<td>15~ 16位有效数字</td>
</tr>
</tbody></table>
<p>float存储不准确</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">float</span> a=<span class="number">100.9</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,a);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/22/pT1JRNYS97IyjM4.png"></p>
<h3 id="类型限定符"><a href="#类型限定符" class="headerlink" title="类型限定符"></a>类型限定符</h3><table>
<thead>
<tr>
<th>限定符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>extern</td>
<td>声明一个变量，extexn 声明的变量没有建立存储空间。extern int a;</td>
</tr>
<tr>
<td>const</td>
<td>定义一个常量，常量的值不能修改。const int a 10;</td>
</tr>
<tr>
<td>vo1atile</td>
<td>防止编译器优化代码</td>
</tr>
<tr>
<td>register</td>
<td>定义寄存器变量，提高效率。 register是建议型的指令，而不是命令型的指令，如果CPU有空闲寄存器，那么register就生效， 如果没有空闲寄存器，那么register无效。</td>
</tr>
</tbody></table>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>字符串常量与字符常量的不同:<br>‘a’为字符常量，”a”为字符串常量</p>
<p><img src="https://i.loli.net/2021/01/22/hAXpsqiEMktCuyn.png" alt="image-20210113191321188"></p>
<p>每个字符串的结尾，编译器会自动的添加一一个结束标志位’\0’,即”a” 包含<br>两个字符’a’和’\0’。</p>
<p>%%在屏幕输出一个%，后面的d也会输出</p>
<p>%5d,以5个字符输出,没有的字符以空字符填充,默认是右对齐</p>
<p>%05d,以5个字符输出,没有的字符以0填充,默认是右对齐</p>
<p>%-5d,以5个字符输出,没有的字符以空字符填充,-代表指定为左对齐</p>
<p>0和-不能同时使用</p>
<p><img src="https://i.loli.net/2021/01/22/ts6idzBZGxWJveY.png"></p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入字符:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;a);<span class="comment">//假设输入c</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a=&#x27;%c&#x27;\n&quot;</span>,a);</span><br><span class="line">        <span class="keyword">char</span> b;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入字符:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;b);<span class="comment">//假设输入d</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;b=&#x27;%c&#x27;\n&quot;</span>,b);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个程序看似简单,结果为a=c,b=d,其实不然,结果如下:</p>
<p><img src="https://i.loli.net/2021/01/22/itzxmayI15d6uqO.png"></p>
<p>无需输入d直接出结果</p>
<p>原因:</p>
<p>当用户输入字符时,编译器默认把输入的内容先放在一块内存中(缓冲区) , scanf()自动在缓冲区读内容(只读一个字符).第一次输入时输入了c\n(回车),scanf取走了c,留下\n还在缓存区,第2次scanf ,由于缓冲区还有内容,所以直接取内容,无需再输入</p>
<p>所以,上面的程序可以这样写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入字符:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;a);<span class="comment">//假设输入c</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a=&#x27;%c&#x27;\n&quot;</span>,a);</span><br><span class="line">        <span class="comment">//吃掉上一步的\n,不做处理</span></span><br><span class="line">        <span class="keyword">char</span> b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;b);</span><br><span class="line">        <span class="keyword">char</span> t;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入字符:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;t);<span class="comment">//假设输入d</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;t=&#x27;%c&#x27;\n&quot;</span>,t);</span><br><span class="line">    	<span class="comment">//或者都在一个scanf中写</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>switch语句</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">        <span class="comment">//1、switch是关键字， switch() 后面没有分号</span></span><br><span class="line">        <span class="comment">//2、switch()中() 里只能放整型变量或字符型变量</span></span><br><span class="line">        <span class="keyword">switch</span>(num)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;1楼\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;2楼\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;3楼\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;其他楼层\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>goto语句</p>
<p>goto(只能跳转到同一作用域)任意地方都能使用,无条件跳转,不能滥用,代码会很乱</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">goto</span> hello;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1111111111\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2222222222\n&quot;</span>);</span><br><span class="line">        hello:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;3333333333\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="C:\Users\Peng\AppData\Roaming\Typora\typora-user-images\image-20210122205440917.png" alt="image-20210122205440917" style="zoom:150%;" />

<p>类型转换:</p>
<p>1.隐式转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> a;</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//编译器自动转换，把b转 换为double类型后， 再给a赋值(隐式转换)</span></span><br><span class="line">a= b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>，b) ;</span><br></pre></td></tr></table></figure>
<p>2.强制类型转换  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="comment">//a只有在此语句执行时，才强制转换为double类型，其它地址还是为int类型</span></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%lf\n&quot;</span>，(<span class="keyword">double</span>)a) ;<span class="comment">//(类型)变量名</span></span><br></pre></td></tr></table></figure>
<p>转换原则:占用内存字节数少(值域小)的类型，向占用内存字节数多(值域大)的类型转换，以保证精度不降低。</p>
<p>3.浮点型和整型打印问题<br>a)不要直接通过%d，打印一个浮点型变量，得不到想要的结果，要想得到结果，强制类型转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> a = <span class="number">11.11</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(<span class="keyword">int</span>)a) ;</span><br></pre></td></tr></table></figure>
<p>b)不要直接通过%f或%lf，打印一个整型变量，得不到想要的结果，要想得到结果，强制类型转换</p>
]]></content>
      <categories>
        <category>C&amp;C++</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Web学习</title>
    <url>/blog/2021/01/10/Web%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Web学习"><a href="#Web学习" class="headerlink" title="Web学习"></a>Web学习</h1><a id="more"></a>

<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><h4 id="input控件"><a href="#input控件" class="headerlink" title="input控件"></a>input控件</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;属性值&quot;</span> <span class="attr">value</span>=<span class="string">&quot;你好&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<table>
    <tr>
        <th>属性</th>
        <th>属性值</th>
        <th>描述</th>  
    </tr >
    <tr >
        <td rowspan="12">type</td>
        <td>text</td>
        <td>单行文本输入框</td>
    </tr>
    <tr>
        <td>password</td>
        <td>密码输入框</td>
    </tr>
    <tr>
        <td>radio</td>
        <td>单选按钮</td>
    </tr>
    <tr>
        <td>CheckBox</td>
        <td>复选按钮</td>
    </tr>
    <tr><td>button</td>
        <td>普通按钮</td>
    </tr>
    <tr>
        <td>submit</td>
        <td>提交按钮</td>
    </tr>
    <tr>
        <td>reset</td>
        <td>重置按钮</td>
    </tr>
    <tr>
        <td>image</td>
        <td>图像形式的提交按钮</td>
    </tr>
    <tr>
        <td >file</td>
        <td>文件域</td>
    </tr>
    <tr>
        <td>number</td>
        <td>数字框,只能输入数字,右侧多出加减符号</td>
    </tr>
    <tr>
        <td>url</td>
        <td>网址输入框</td>
    </tr>
    <tr>
        <td>email</td>
        <td>邮箱输入框</td>
    </tr>
    <tr>
        <td >name</td>
        <td>用户自定义</td>
        <td>控件名称</td>
    </tr>
    <tr>
        <td >value</td>
        <td >用户自定义</td>
        <td >默认文本值</td>
    </tr>
    <tr>
        <td >size</td>
        <td >正整数</td>
        <td >控件在页面中的显示宽度</td>
    </tr>
    <tr>
        <td >checked</td>
        <td >checked</td>
        <td >定义选择控件默认被选中项</td>
    </tr>
    <tr>
        <td >maxlength</td>
        <td >正整数</td>
        <td >控件允许输入的最多字符</td>
    </tr>
    <tr>
        <td >placeholder</td>
        <td >自定义</td>
        <td >占位符</td>
    </tr>
</table>


<h4 id="label标签"><a href="#label标签" class="headerlink" title="label标签"></a>label标签</h4><p>label标签不会向用户呈现任何特殊效果，它的作用是为鼠标用户改进了可用性。如果你在 label 标签内点击文本，就会触发此控件。就是说，当用户单击选中该label标签时，浏览器就会自动将焦点转到和标签相关的表单控件上（就自动选中和该label标签相关连的表单控件上）。</p>
<p>语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;控件id名称&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：标签的 for 属性中的值应当与相关控件的 id 属性值一定要相同。</p>
<p>例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;email&quot;</span>&gt;</span>输入你的邮箱地址<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">id</span>=<span class="string">&quot;email&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter email&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="textarea控件-文本域"><a href="#textarea控件-文本域" class="headerlink" title="textarea控件(文本域)"></a>textarea控件(文本域)</h4><p>当用户需要在表单中输入大段文字时，需要用到文本输入域。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> **<span class="attr">rows</span>=<span class="string">&quot;行数&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;列数&quot;</span>**&gt;</span>文本<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>1、<strong>cols ：</strong>多行输入域的<strong>列数</strong>。</p>
<p>2、<strong>rows ：</strong>多行输入域的<strong>行数</strong>。</p>
<p><strong>举例：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;save.php&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">label</span>&gt;</span>联系我们<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">cols</span>=<span class="string">&quot;50&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span> &gt;</span>在这里输入内容...<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="select下拉列表"><a href="#select下拉列表" class="headerlink" title="select下拉列表"></a>select下拉列表</h4><p>下拉列表:</p>
<p>下拉列表在网页中也常会用到，它可以有效的节省网页空间。既可以单选、又可以多选。如下代码：</p>
<p><img src="https://i.loli.net/2021/01/10/1cExMyhR3dkTeKi.png" alt="img"></p>
<p><strong>讲解：</strong></p>
<p>1、select和option标签都是双标签，它总是成对出现的，需要首标签和尾标签。</p>
<p>2、select标签里面只能放option标签，表示下拉列表的选项。</p>
<p>3、option标签放选项内容，不放置其他标签。</p>
<p>4、value：</p>
<p><img src="https://i.loli.net/2021/01/10/VAhEQFzT7dNoMO8.png" alt="img"></p>
<p>5、selected=”selected”：</p>
<p>设置selected=”selected”属性，则该选项就被默认选中。</p>
<p>在浏览器中显示的结果：</p>
<p><img src="https://i.loli.net/2021/01/10/p8nCDEVleONLkjg.png" alt="img"></p>
<h4 id="form表单域"><a href="#form表单域" class="headerlink" title="form表单域"></a>form表单域</h4><p>网站怎样与用户进行交互？答案是使用HTML表单(form)。表单是可以把浏览者输入的数据传送到服务器端，这样服务器端程序就可以处理表单传过来的数据。</p>
<p>语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;服务器文件/url地址&quot;</span> <span class="attr">method</span>=<span class="string">&quot;传送方式&quot;</span> <span class="attr">name</span>=<span class="string">&quot;表单名称&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>讲解：</strong></p>
<p>1.<strong>action</strong> <strong>：</strong>浏览者输入的数据被传送到的地方,比如一个PHP页面(save.php)。</p>
<p>2.<strong>method</strong> <strong>：</strong> 数据传送的方式（get/post）。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>  <span class="attr">action</span>=<span class="string">&quot;save.php&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>用户名:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;pass&quot;</span>&gt;</span>密码:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pass&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<p><strong>1、所有表单控件（文本框、文本域、按钮、单选框、复选框等）都必须放在 form 标签之间（否则用户输入的信息可提交不到服务器上哦！）。</strong></p>
<p><strong>2、method : post/get 的区别这一部分内容属于后端程序员考虑的问题。</strong></p>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="CSS的三种引用方式"><a href="#CSS的三种引用方式" class="headerlink" title="CSS的三种引用方式"></a>CSS的三种引用方式</h3><ol>
<li>内联样式(行内式)</li>
<li>嵌入样式(内部式)</li>
<li>外部样式(外链式)</li>
</ol>
<table>
<thead>
<tr>
<th>样式表</th>
<th>优点</th>
<th>缺点</th>
<th>使用情况</th>
<th>控制范围</th>
</tr>
</thead>
<tbody><tr>
<td>行内样式表</td>
<td>书写方便,权重高</td>
<td>没有实现结构和样式相分离</td>
<td>较少</td>
<td>控制一个标签</td>
</tr>
<tr>
<td>内部样式表</td>
<td>部分结构和样式相分离</td>
<td>没有彻底分离</td>
<td>较多</td>
<td>控制一个页面</td>
</tr>
<tr>
<td>外部样式表</td>
<td>完全实现结构和样式相分离</td>
<td>需要引入</td>
<td>最多</td>
<td>控制多个站点</td>
</tr>
</tbody></table>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><h4 id="font-family"><a href="#font-family" class="headerlink" title="font-family"></a>font-family</h4><p>可同时指定多个字体,中间以逗号隔开,表示如果浏览器不支持第一个字体,则会尝试下一个,直到找到合适的字体</p>
<h4 id="CSS-Unicode字体"><a href="#CSS-Unicode字体" class="headerlink" title="CSS Unicode字体"></a>CSS Unicode字体</h4><ul>
<li><p>为什么使用Unicode字休</p>
<ul>
<li>在CSS中设置字体名称，直接写中文是可以的。但是在文件编码(GB2312、 UTF 8等)不匹配时会产生乱码的错误。</li>
<li>xp系统不支持类似微软雅黑的中文。</li>
</ul>
</li>
<li><p>解决:</p>
<ul>
<li>方案一:你可以使用英文来替代。比如font-family: “Microsoft Yahei”。</li>
<li>方案二:在CSS直接使用Unicode编码来写字体名称可以避免这些错误。使用Unicode写中文字体名称，浏览器是可以正确的解析的。</li>
</ul>
</li>
</ul>
<h4 id="font-weight"><a href="#font-weight" class="headerlink" title="font-weight"></a>font-weight</h4><ul>
<li>在html中将字体加粗我们可以用标签来实现<ul>
<li>使用b和strong标签进行文本加粗。</li>
</ul>
</li>
<li>可以使用CSS来实现，但是CSS 是没有语义的。I</li>
</ul>
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>normal</td>
<td>默认值(不加粗的)</td>
</tr>
<tr>
<td>bold</td>
<td>定义粗体(加粗的)</td>
</tr>
<tr>
<td>100~900</td>
<td>400等同于normal,而700等同于bold</td>
</tr>
</tbody></table>
<p>提倡:<br>    我们平时更喜欢用数字来表示加粗和不加粗。 </p>
<h4 id="font-style"><a href="#font-style" class="headerlink" title="font-style"></a>font-style</h4><ul>
<li><p>在html中将字体倾斜我们可以用标签来实现，</p>
<ul>
<li>字体倾斜可以用i和em标签。</li>
</ul>
</li>
<li><p>可以使用CSS来实现，但是CSS是没有语义的</p>
</li>
</ul>
<p>font-style属性用于定义字体风格，如设置斜体、倾斜或正常字体，其可用属性值如下:</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>normal</td>
<td>默认值，浏览器会显示标准的字体样式(常用)</td>
</tr>
<tr>
<td>italic</td>
<td>浏览箭会显示斜体的字体样式。</td>
</tr>
</tbody></table>
<p>小技巧:<br>平时我们很少给文字加斜体，反而喜欢给斜体标签(em, i)改为普通模式。   </p>
<h4 id="font综合写法"><a href="#font综合写法" class="headerlink" title="font综合写法"></a>font综合写法</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器&#123;<span class="attribute">font</span>:font-style font-weight font-size/line-height font-family&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用font属性时，必须按上面语法格式中的顺序书写，不能更换顺序，各个属性以空格隔开。</p>
</li>
<li><p>其中不需要设置的属性可以省略(取默认值)，但必须保留font-size和font-amily属性， 否则font属性将不起作用。</p>
</li>
</ul>
<h4 id="CSS外观属性总结"><a href="#CSS外观属性总结" class="headerlink" title="CSS外观属性总结"></a>CSS外观属性总结</h4><table>
<thead>
<tr>
<th>属性</th>
<th>表示</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>color</td>
<td>颜色</td>
<td>我们通常用十六进制比如而且是简写形式#fff</td>
</tr>
<tr>
<td>line-height</td>
<td>行高</td>
<td>控制行与行之间的距离</td>
</tr>
<tr>
<td>text-align</td>
<td>水平对齐</td>
<td>可以设定文字水平的对齐方式</td>
</tr>
<tr>
<td>text-indent</td>
<td>首行缩进</td>
<td>通常我们用于段落首行缩进2个字的距离 text-indent: 2em;</td>
</tr>
<tr>
<td>text-decoration</td>
<td>文本修饰</td>
<td>记住添加下划线underline 取消下划线none</td>
</tr>
</tbody></table>
<h3 id="快捷操作"><a href="#快捷操作" class="headerlink" title="快捷操作"></a>快捷操作</h3><p>1.如果想要生成多个相同标签加上*就可以了比如  div*3 就可以快速生成3个div<br>2.如果有父子级关系的标签，可以用&gt;比如ul&gt;li就可以了<br>4.如果有兄弟关系的标签，用+就可以了比如div+p<br>5.如果生成带有类名或者id名字的，直接写.demo 或者#two  tab键就可以了<br>6.如果生成的div类名是有顺序的，可以用自增符号$.</p>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><h4 id="子元素选择器"><a href="#子元素选择器" class="headerlink" title="子元素选择器"></a>子元素选择器</h4><ul>
<li>子元素选择器只能选择作为某元素子元素(亲儿子)的元素。</li>
<li>其写法就是把父级标签写在前面，子级标签写在后面，中间跟一个&gt;进行连接</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.class</span>&gt;<span class="selector-tag">h3</span>&#123;<span class="attribute">color</span>:red; <span class="attribute">font-size</span>:<span class="number">14px</span>;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="交集选择器"><a href="#交集选择器" class="headerlink" title="交集选择器"></a>交集选择器</h4><ul>
<li>交集选择器由两个选择器构成，找到的标签必须满足:既有标签1的特点， 也有标签2的特点。(不常用)</li>
</ul>
<p><img src="https://i.loli.net/2021/01/12/YI8MDdCfHBEUa9O.png" alt="image-20210112132645395"></p>
<h4 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h4><ul>
<li><p>如果某些选择器定义的相同样式，就可以利用并集选择器，可以让代码更简清。</p>
</li>
<li><p>各个标签用逗号分开,通常用于集体声明</p>
</li>
</ul>
<h4 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h4><ul>
<li><p>伪类选择器（简称：伪类）通过冒号来定义，它定义了元素的状态，如点击按下，点击完成等，通过伪类可以为元素的状态修改样式。</p>
</li>
<li><p>伪类的功能和一般的DOM中的元素样式相似，但和一般的DOM中的元素样式不一样，它并不改变任何DOM内容。只是插入了一些修饰类的元素，这些元素对于用户来说是可见的，但是对于DOM来说不可见。伪类的效果可以通过添加一个实际的类来达到。</p>
</li>
<li><p>类选择器是一个点,比如.demo{},而我们的伪类用2个点就是冒号,比如:link{}</p>
</li>
<li><p>用于向某些选挥器添加特殊的效果。比如给链接添加特殊效果，比如可以选挥第1个，第n个元素。</p>
</li>
</ul>
<h5 id="链接伪类选择器"><a href="#链接伪类选择器" class="headerlink" title="链接伪类选择器"></a>链接伪类选择器</h5><ul>
<li>a:link   /*未访问的链接*/</li>
<li>a:visited   /*已访问的链接*/</li>
<li>a:hover    /*鼠标移动到链接上*/</li>
<li>a:active    /*选定的链接*/</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li><p>写的时候，他们的顺序尽量不要颠倒,按照lvha的顺序,否则可能引起错误。</p>
</li>
<li><p>记忆法</p>
<ul>
<li><strong>l</strong>o<strong>v</strong>e <strong>ha</strong>te  爱上了讨厌</li>
<li><strong>lv</strong>包包   非常<strong>ha</strong>o</li>
</ul>
</li>
<li><p>因为a链接浏览器具有默认样式，所以我们实际工作中需要给链接单独指定样式。</p>
</li>
</ul>
<h3 id="标签显示模式"><a href="#标签显示模式" class="headerlink" title="标签显示模式"></a>标签显示模式</h3><h4 id="块级元素-block-level"><a href="#块级元素-block-level" class="headerlink" title="块级元素(block-level)"></a>块级元素(block-level)</h4><ul>
<li><p>常见的块元素有&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、 &lt;div&gt;、 &lt;ul&gt;、 &lt;ol&gt;、 &lt;li&gt;等，其中&lt;div&gt;标签是最典型的块元素。</p>
</li>
<li><p>块级元素的特点:</p>
<ol>
<li>比较霸道，自己独占一行</li>
<li>高度，宽度、外边距以及内边距都可以控制。</li>
<li>宽度默认是容器(父级宽度)的100%</li>
<li>是一个容器及盒子，里面可以放行内或者块级元素。</li>
</ol>
</li>
<li><p>注意:</p>
<ul>
<li>只有文字才能组成段落,因此p里面不能放块级元素，特别是p不能放div。</li>
<li>同理还有这些标签h1,h2,h3,h4,h5,h6,dt， 他们都是文字类块级标签，里面不能放其他块级元素。</li>
</ul>
</li>
</ul>
<h4 id="行内元素-inline-level"><a href="#行内元素-inline-level" class="headerlink" title="行内元素(inline-level)"></a>行内元素(inline-level)</h4><p>常见的行内元素有&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、 &lt;span&gt;等， 其中&lt;span&gt;标签是最典型的行内元素。有的地方也称内联元素。</p>
<ul>
<li><p>行内元素的特点:</p>
<ol>
<li>相邻行内元素在一行上，一行可以显示多个。</li>
<li>高、宽直接设置是无效的。</li>
<li>默认宽度就是它本身内容的宽度。</li>
<li>行内元素只能容纳文本或者其他行内元素。</li>
</ol>
</li>
<li><p>注意:</p>
<ol>
<li>链接里面不能再放链接。</li>
<li>特殊情况a里面可以放块级元素，但是给a转换一下块级模式最安全。</li>
</ol>
</li>
</ul>
<h4 id="行内块元素-inline-block"><a href="#行内块元素-inline-block" class="headerlink" title="行内块元素(inline-block)"></a>行内块元素(inline-block)</h4><p>在行内元素中有几个特殊的标签&lt;img /&gt;、&lt;input /&gt;、&lt;td&gt;， 可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块元素。</p>
<ul>
<li>行内块元素的特点:<ol>
<li>和相邻行内元素(行内块)在一行上,但是之间会有空白缝隙,一行可以显示多个。</li>
<li>默认宽度就是它本身内容的宽度。</li>
<li>高度、行高、外边距以及内边距都可以控制。</li>
</ol>
</li>
</ul>
<h4 id="三种模式总结"><a href="#三种模式总结" class="headerlink" title="三种模式总结"></a>三种模式总结</h4><p><img src="https://i.loli.net/2021/01/12/KbigExyl5cmav6B.png" alt="image-20210112151920674"></p>
<h4 id="标签显示模式转换-display"><a href="#标签显示模式转换-display" class="headerlink" title="标签显示模式转换 display"></a>标签显示模式转换 display</h4><ul>
<li>块转行内: display: inline;</li>
<li>行内转块: display: block;</li>
<li>块、行内元素转换为行内块: display: inline-block;</li>
</ul>
<h3 id="单行文本垂直居中"><a href="#单行文本垂直居中" class="headerlink" title="单行文本垂直居中"></a>单行文本垂直居中</h3><p>行高(基线与基线的距离)我们利用最多的一个地方是:可以让单行文本在盒子中垂直居中对齐。<br><strong>文字的行高等于盒子的高度</strong>即可实现垂直对齐,可近似看作:<strong>行高=上距离+内容高度+下距离</strong></p>
<p>行高和高度的三种关系:</p>
<ul>
<li>如果行高等高度文字会重直居中</li>
<li>如果行高大于高度文字会偏下</li>
<li>如果行高小于高度文字会偏上</li>
</ul>
<h3 id="CSS背景"><a href="#CSS背景" class="headerlink" title="CSS背景"></a>CSS背景</h3><h4 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h4><p>语法:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background-color</span>: 颜色值; //默认的值是 <span class="selector-tag">transparent</span> 透明的</span><br></pre></td></tr></table></figure>
<h4 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h4><p>语法:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">background-image: none | url(url);</span><br></pre></td></tr></table></figure>
<h4 id="背景平铺"><a href="#背景平铺" class="headerlink" title="背景平铺"></a>背景平铺</h4><p>语法:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">background-repeat: repeat(默认) | no-repeat | repeat-x | repeat-y;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>repeat</td>
<td>平铺</td>
</tr>
<tr>
<td>no-repeat</td>
<td>不平铺</td>
</tr>
<tr>
<td>repeat-x</td>
<td>横向平铺</td>
</tr>
<tr>
<td>repeat-y</td>
<td>纵向平铺</td>
</tr>
</tbody></table>
<h4 id="背景位置"><a href="#背景位置" class="headerlink" title="背景位置"></a>背景位置</h4><p>语法:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">background-position: length || length;</span><br><span class="line">background-position: position || position;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>length</td>
<td>百分数|由浮点数字和单位标识符组成的长度值</td>
</tr>
<tr>
<td>position</td>
<td>center | top | bottom | left | right 方位名词</td>
</tr>
</tbody></table>
<p>注意:</p>
<ul>
<li>必须先指定background-image属性</li>
<li>position后面是x坐标和y坐标，可以使用方位名词或者精确单位。</li>
<li>如果只指定了一个方位名词，另一个值默认居中，为50%。</li>
<li>如果只指定一个数值,那该数值用于x坐标，另一个默认是y坐标，默认居中</li>
<li>如果指定两个值，两个值都是方位名字，则两个值前后顺序无关，比如left top和top left效果一致</li>
<li>如果指定两个值，精确单位和方位名字混合使用，则第一个值是x坐标，第二个值是y坐标</li>
</ul>
<h4 id="背景附着"><a href="#背景附着" class="headerlink" title="背景附着"></a>背景附着</h4><p>背景附着就是背景是滚动还是固定的</p>
<p>语法:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">background-attachment: scroll | fixed;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>scroll</td>
<td>背景图像随对象内容滚动</td>
</tr>
<tr>
<td>fixed</td>
<td>背景图像固定</td>
</tr>
</tbody></table>
<h4 id="背景简写"><a href="#背景简写" class="headerlink" title="背景简写"></a>背景简写</h4><p>背景简写和字体简写不同的是背景简写没有强制要求,建议按下面方式写 </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>:背景颜色 背景图片地址 背景平铺 背景滚动 背景位置;</span><br></pre></td></tr></table></figure>
<h4 id="背景透明"><a href="#背景透明" class="headerlink" title="背景透明"></a>背景透明</h4><p>语法:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">rgba</span>(0, 0，0，0.3);</span><br></pre></td></tr></table></figure>
<ul>
<li>最后一个参数是alpha透明度取值范围0~1之间</li>
<li>我们习惯把0.3的0省略掉这样写background: rgba(0, 0, 0, .3);</li>
<li>注意:背景半透明是指盒子背景半透明，盒子里面的内容不受影响</li>
<li>因为是CSS3,所以低于ie9的版本是不支持的。</li>
</ul>
<h3 id="CSS三大特性"><a href="#CSS三大特性" class="headerlink" title="CSS三大特性"></a>CSS三大特性</h3><h4 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h4><p>概念:</p>
<ul>
<li>所谓层叠性是指多种CSS样式的叠加。是浏览器处理冲突的一个能力，如果一个属性通过两个相同选择器设置到同一个元素上,那么这个时候一个属性就会将另一 个属性层叠掉</li>
</ul>
<p>原则: </p>
<ul>
<li>样式冲突,遵循的原则是就近原则.那个样式离结构近,就执行那个样式</li>
<li>样式不冲突,不会层叠</li>
</ul>
<h4 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h4><p>概念:</p>
<ul>
<li>子标签会继承父标签的某些样式，如文本颜色和字号。</li>
<li>想要设置一个可继承的属性，只需将它应用于父元素即可。</li>
</ul>
<p>注意:</p>
<ul>
<li>恰当地使用继承可以简化代码，降低CSS样式的复杂性。比如有很多子级孩子都需要某个样式，可以给父级指定一个，这些孩子继承过来就好了</li>
<li>子元素可以继承父元素的样式(text-, font-, line-这些元素开头的可以继承，以及color属性)</li>
</ul>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>定义CSS样式时，经常出现两个或更多规则成用在同一元素上，此时，</p>
<ul>
<li>选择器相同，则执行层叠性</li>
<li>选择器不同，就会出现优先级的问题。</li>
</ul>
<p>权重计算公式:</p>
<table>
<thead>
<tr>
<th>标签选择器</th>
<th>权重</th>
</tr>
</thead>
<tbody><tr>
<td>继承或 *</td>
<td>0,0,0,0</td>
</tr>
<tr>
<td>元素(标签选择器)</td>
<td>0,0,0,1</td>
</tr>
<tr>
<td>类,伪类</td>
<td>0,0,1,0</td>
</tr>
<tr>
<td>ID</td>
<td>0,1,0,0</td>
</tr>
<tr>
<td>行内样式 style=””</td>
<td>1,0,0,0</td>
</tr>
<tr>
<td>!important</td>
<td>∞ 无穷大</td>
</tr>
</tbody></table>
<p><strong>继承的权重为0</strong></p>
<p>我们修改样式，一 定要看该标签有没有被选中。</p>
<ol>
<li>如果选中了,那么以上面的公式来计权重.</li>
<li>如果没有选中,那么权重是0,因为继承的权重为0.</li>
</ol>
<h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p>盒子模型由内容、边框(border) 、内边距(padding) 、和外边距(margin) 组成。</p>
<h4 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h4><p>语法:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">border: border-width(宽度) | border-style(样式) | border-color(颜色)</span><br></pre></td></tr></table></figure>
<p>边框样式:</p>
<ul>
<li><strong>none :</strong> 　无边框。 </li>
<li><strong>dotted :</strong>  点线 </li>
<li><strong>dashed :</strong>  虚线</li>
<li><strong>solid :</strong> 实线</li>
</ul>
<p>边框简写:</p>
<p>无顺序,一般按宽度,样式,颜色顺序写.各边可分别指定样式.</p>
<p>表格的细线边框:</p>
<ul>
<li><p>通过表格的cellspacing=”0”,将单元格与单元格之间的距离设置为0，</p>
</li>
<li><p>但是两个单元格之间的边框会出现重叠，从而使边框变粗</p>
</li>
<li><p>通过css属性:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">table</span>&#123; <span class="attribute">border-collapse</span>:collapse; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>collapse 单词是合并的意思.</li>
<li>border-collapse:collapse;表示相邻边框合并在一起.</li>
</ul>
</li>
</ul>
<p><strong>盒子实际大小=内容的宽度(高度)+内边距+边框</strong></p>
<p>内边距不影响盒子大小的情况:</p>
<p>如果盒子没有宽度(高度),则padding不会撑开盒子.</p>
<h4 id="文字居中和盒子居中的区别"><a href="#文字居中和盒子居中的区别" class="headerlink" title="文字居中和盒子居中的区别"></a>文字居中和盒子居中的区别</h4><ol>
<li>文字水平居中是text-align: center,而且还可以让行内元素和行内块居中对齐</li>
<li>块级盒子水平居中,左右margin改为auto</li>
</ol>
<h4 id="插入图片和背景图片的区别"><a href="#插入图片和背景图片的区别" class="headerlink" title="插入图片和背景图片的区别"></a>插入图片和背景图片的区别</h4><ol>
<li>插入图片我们用的最多比如产品展示类移动位置只能靠盒模型padding margin</li>
<li>背票图片我们一 般用于小图标背景或者超大背景图片背景图片只能通过background-position</li>
</ol>
<h4 id="清除元素默认的内外边距"><a href="#清除元素默认的内外边距" class="headerlink" title="清除元素默认的内外边距"></a>清除元素默认的内外边距</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123;<span class="attribute">padding</span>:<span class="number">0</span>;<span class="attribute">margin</span>:<span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>注意:</p>
<ul>
<li>行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下内外边距。</li>
</ul>
<h4 id="外边距的合并"><a href="#外边距的合并" class="headerlink" title="外边距的合并"></a>外边距的合并</h4><p>使用margin定义块元素的垂直外边距时，可能会出现外边距的合并。<br>(1).相邻块元素垂直外边距的合并</p>
<ul>
<li>当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom</li>
<li>下面的元素有上外边距margin-top,则他们之间的垂直间距不是margin-bottom与margin-top之和</li>
<li>取两个值中的较大者这种现象被称为相邻块元素垂直外边距的合并(也称外边距塌陷)。</li>
</ul>
<p>(2).嵌套块元素垂直外边距的合并(塌陷)</p>
<ul>
<li>对于两个嵌套关系的块元素，如果父元素没有上内边距及边框</li>
<li>父元素的上外边距会与子元素的上外边距发生合并</li>
<li>合并后的外边距为两者中的较大者</li>
</ul>
<p>解决方案:<br>1.可以为父元素定义上边框<br>2.可以为父元索定义上内边距<br>3.可以为父元素添加overflow:hidden</p>
<h4 id="盒子模型布局稳定性"><a href="#盒子模型布局稳定性" class="headerlink" title="盒子模型布局稳定性"></a>盒子模型布局稳定性</h4><p>问题:什么情况下用内边距，什么情况下用外边距?<br>大部分情况下是可以混用的。 就是说，你用内边距也可以，用外边距也可以。<br>我们根据稳定性来分，建议如下:<br>按照优先便用宽度(width) ,其次使用内边距(padding),再次外边距(margin)。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">width</span> &gt; <span class="selector-tag">padding</span> &gt; <span class="selector-tag">margin</span></span><br></pre></td></tr></table></figure>
<p>原因:</p>
<ul>
<li>margin 会有外边距合并还有IE6下面margin加倍的bug ,所以最后使用</li>
<li>padding 会影响盒子大小，需要进行加减计算,其次使用</li>
<li>width 我们经常使用宽度剩余法,高度剩余法来做</li>
</ul>
<h3 id="CSS书写规范"><a href="#CSS书写规范" class="headerlink" title="CSS书写规范"></a>CSS书写规范</h3><h4 id="空格规范"><a href="#空格规范" class="headerlink" title="空格规范"></a>空格规范</h4><ol>
<li>选择器与{之间必须包含空格</li>
<li>属性名与之后的:之间不允许包含空格，:与属性值之间必须包含空格</li>
</ol>
<h4 id="选择器规范"><a href="#选择器规范" class="headerlink" title="选择器规范"></a>选择器规范</h4><ul>
<li><p>并集选择器，每个选择器声明独占一行</p>
</li>
<li><p>一般情况下，选择器的嵌套层级应不大于3级，位置靠后的限定条件应尽可能精确</p>
</li>
</ul>
<h4 id="属性规范"><a href="#属性规范" class="headerlink" title="属性规范"></a>属性规范</h4><ul>
<li>属性定义必须另起行</li>
<li>属性定义后必须以分号结尾</li>
</ul>
<h3 id="CSS布局的三种机制"><a href="#CSS布局的三种机制" class="headerlink" title="CSS布局的三种机制"></a>CSS布局的三种机制</h3><p>CSS提供了3种机制来设置盒子的摆放位置，分别是普通流(标准流)、浮动和定位，其中:<br>1.普通流(标准流)</p>
<ul>
<li><p>块级元素会独占一行，从上向下顺序排列;</p>
<ul>
<li>常用元素: div、hr、p、h1-h6、ul、ol、dl、form、table</li>
</ul>
</li>
<li><p>行内元索会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行;</p>
<ul>
<li>常用元素: span、a、i、em等</li>
</ul>
</li>
</ul>
<p>2.浮动</p>
<ul>
<li>让盒子从普通流中浮起来,主要作用让多个块级盒子一行显示。</li>
</ul>
<p>3.定位</p>
<ul>
<li>将盒子定在浏览器的某一个位置，CSS离不开定位，特别是后面的js特效。</li>
</ul>
<h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><p>问题:如何将多个盒子(div)水平排列成一行?如何实现盒子靠左靠右对齐?</p>
<p>如果将div转为inline-block可以达到将多个盒子(div)水平排列成一行,但是盒子之间有空隙,且非常难去掉,即使能去掉兼容性极差.无法靠左靠右对齐.</p>
<p>概念:元素的浮动是指设置了浮动属性的元素会</p>
<ol>
<li>脱离标准普通流的控制</li>
<li>移动到指定位置。</li>
</ol>
<p>作用:</p>
<ol>
<li>让多个盒子(div)水平排列成一行，使得浮动成为布局的重要手段。</li>
<li>可以实现盒子的左右对齐等等…</li>
<li>浮动最早是用来控制图片，实现文字环绕图片的效果。</li>
</ol>
<h4 id="清除浮动的本质"><a href="#清除浮动的本质" class="headerlink" title="清除浮动的本质:"></a>清除浮动的本质:</h4><p>清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0的问题。清除浮动之后，父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了。</p>
<h4 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法:"></a>清除浮动的方法:</h4><p>在CSS中，clear属性用于清除浮动，<br>语法:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器&#123;<span class="attribute">clear</span>:属性值;&#125; <span class="selector-tag">clear</span> 清除</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>left</td>
<td>不允许左侧有浮动元素(清除左侧浮动的影响)</td>
</tr>
<tr>
<td>right</td>
<td>不允许右侧有浮动元素(清除右侧浮动的影响)</td>
</tr>
<tr>
<td>both</td>
<td>同时清除左右两侧浮动的影响</td>
</tr>
</tbody></table>
<p>实际工作几乎只用clear:both;</p>
<h5 id="1-额外标签法-隔墙法"><a href="#1-额外标签法-隔墙法" class="headerlink" title="1.额外标签法(隔墙法)"></a>1.额外标签法(隔墙法)</h5><p>在浮动元表末尾添加一个空的标签例如&lt;div style:”clear:both”&gt;&lt;/d1v&gt;, 或者其他标签br等</p>
<ul>
<li>优点:通俗易懂，书写方便</li>
<li>缺点:添加许多无意义的标签,结构化较差</li>
</ul>
<h5 id="2-父级添加overflow属性方法"><a href="#2-父级添加overflow属性方法" class="headerlink" title="2.父级添加overflow属性方法"></a>2.父级添加overflow属性方法</h5><figure class="highlight"><table><tr><td class="code"><pre><span class="line">overflow:hidden | auto |scroll(均可清除浮动)</span><br></pre></td></tr></table></figure>
<ul>
<li>优点:代码简洁</li>
<li>缺点:内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素(溢出隐藏)</li>
</ul>
<h5 id="3-使用after伪元素清除浮动"><a href="#3-使用after伪元素清除浮动" class="headerlink" title="3.使用after伪元素清除浮动"></a>3.使用after伪元素清除浮动</h5><p>:after方式为空元素额外标签法的升级版,好处是不用单独加标签了<br>使用方法:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123; </span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block; </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>; </span><br><span class="line">    <span class="attribute">clear</span>: both; </span><br><span class="line">    <span class="attribute">visibility</span>: hidden; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">    <span class="attribute">*zoom</span>: <span class="number">1</span>;</span><br><span class="line">&#125; <span class="comment">/* IE6、7专门清除浮动*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>优点:符合闭合浮动思想结构语义化正确</li>
<li>缺点:由于IE6-7不支持:after, 使用*zoom:1触发hasLayout</li>
<li>代表网站:百度、沟宝网、网易等</li>
</ul>
<h5 id="4-使用双伪元素清除浮动"><a href="#4-使用双伪元素清除浮动" class="headerlink" title="4.使用双伪元素清除浮动"></a>4.使用双伪元素清除浮动</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:before</span>,<span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">	<span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="attribute">display</span>:table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">	<span class="attribute">clear</span>:both;</span><br><span class="line">]</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">	<span class="attribute">*zoom</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>优点:代码更简洁</li>
<li>缺点:由于IE6-7不支持:after, 使用zoom:1触发hasLayout</li>
<li>代表网站:小米，腾讯等</li>
</ul>
<h3 id="PS知识"><a href="#PS知识" class="headerlink" title="PS知识"></a>PS知识</h3><p>常见图片格式:</p>
<ol>
<li>jpg图像格式:<br>JPEG (.JPG) 对色彩的信息保留较好，高清，颜色较多，我们产品类的图片经常用jpg格式的</li>
<li>gif图像格式:<br>GIF格式最多只能储存256色，所以通常用来显示简单图形及字体，但是可以保存透明背景和动画效果</li>
<li>png图像格式<br>是一种新兴的网络图形格式，结合了GIF和JPEG的优点，具有存储形式丰富的特点，能够保持透明背景</li>
<li>PSD图像格式<br>PSD格式是Photoshop的专用格式，里面可以存放图层、通道、遮罩等多种设计草稿</li>
</ol>
<h3 id="CSS属性书写顺序"><a href="#CSS属性书写顺序" class="headerlink" title="CSS属性书写顺序"></a>CSS属性书写顺序</h3><p>建议遵循以下顺序:</p>
<ol>
<li>布局定位属性: display/position/ float/clear /visbility/overflow (建议display第一个写,毕竟关系到模式)</li>
<li>自身属性: width/height/ margin/padding/border/background</li>
<li>文本属性: color/font/text-decoration/tex-align/vertial-align/white- space/break-word</li>
<li>其他属性(CSS3) : content/cursor/border-radius/box-shadow/text-shadow/ background:linear-gradient</li>
</ol>
<h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>定位=定位模式+边偏移</p>
<h4 id="定位模式"><a href="#定位模式" class="headerlink" title="定位模式"></a>定位模式</h4><table>
<thead>
<tr>
<th>值</th>
<th>语义</th>
</tr>
</thead>
<tbody><tr>
<td>static</td>
<td>静态定位</td>
</tr>
<tr>
<td>relative</td>
<td>相对定位(不脱标)</td>
</tr>
<tr>
<td>absolute</td>
<td>绝对定位(脱标)</td>
</tr>
<tr>
<td>flxed</td>
<td>固定定位(脱标)</td>
</tr>
</tbody></table>
<h4 id="绝对定位的居中对齐"><a href="#绝对定位的居中对齐" class="headerlink" title="绝对定位的居中对齐"></a>绝对定位的居中对齐</h4><p>绝对定位或者固定定位的盒子不能通过设置margin: auto设置水平居中。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">left</span>: 50%;</span><br><span class="line"><span class="selector-tag">margin-left</span>: <span class="selector-tag">-</span>(自己宽度一半);</span><br></pre></td></tr></table></figure>
<h4 id="堆叠顺序"><a href="#堆叠顺序" class="headerlink" title="堆叠顺序"></a>堆叠顺序</h4><p>在使用定位布局时，可能会出现<strong>盒子重叠</strong>的情况.加了定位的盒子，默认<strong>后来者居上</strong>，后面的盒子会压住前面的盒子。应用z-index层叠等级属性可以调整盒子的堆叠顺序。</p>
<p>z-index的特性:</p>
<p>1.属性值:正整数、负整数或0,默认值是0,数值越大,盒子越靠上<br>2.如果属性值相同,则按照书写顺序,后来居上<br>3.数宇后面不能加单位<br>注意: z-index只能应用于相对定位、绝对定位和固定定位的元素，其他标准流、浮动和静态定位无效。</p>
<h4 id="定位改变display属性"><a href="#定位改变display属性" class="headerlink" title="定位改变display属性"></a>定位改变display属性</h4><p>display 是显示模式，可以改变显示模式有以下方式</p>
<ul>
<li>可以用inline-block 转换为行内块</li>
<li>可以用浮动float默认转换为行内块(类似，并不完全一样，因为浮动是脱标的)</li>
<li>绝对定位和固定定位也和浮动类似， 默认转换的特性转换为行内块</li>
</ul>
<p>所以说，一个行内的盒子，如果加了浮动、固定定位和绝对定位，不用转换，就可以给这个盒子直接设置宽度和高度等。<br>同时注意:<br>浮动元素、绝对定位元素的都不会触发外边距合并的问题。(我们以前是用padding border overflow解决的)<br>也就是说，我们给盒子改为了浮动或者定位，就不会有垂直外边距合并的问题了。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>自建网盘搜索引擎</title>
    <url>/blog/2021/01/07/%E8%87%AA%E5%BB%BA%E7%BD%91%E7%9B%98%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<h1 id="教你如何自建网盘资源搜索引擎"><a href="#教你如何自建网盘资源搜索引擎" class="headerlink" title="教你如何自建网盘资源搜索引擎"></a>教你如何自建网盘资源搜索引擎</h1><a id="more"></a>


<h3 id="1-利用Google-要能科学上网"><a href="#1-利用Google-要能科学上网" class="headerlink" title="1.利用Google(要能科学上网)"></a>1.利用Google(要能科学上网)</h3><p><a href="https://cse.google.com/cse/" class="LinkCard">点击这里直达</a></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7559cf809c4cf41e9f0c6c79d7db4885.png" alt="image-20201114100907681"></p>
<h3 id="2-点击开始吧"><a href="#2-点击开始吧" class="headerlink" title="2.点击开始吧"></a>2.点击开始吧</h3><p>进入如下界面</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/1ae2e326d170098cd6399ebb6914aaa8.png" alt="image-20201114100937412"></p>
<h3 id="3-点击新建搜索引擎"><a href="#3-点击新建搜索引擎" class="headerlink" title="3.点击新建搜索引擎"></a>3.点击新建搜索引擎</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/56e6799e4eb5d859ce4c14e988318eda.png" alt="image-20201114101047442"></p>
<h3 id="4-依次进行配置"><a href="#4-依次进行配置" class="headerlink" title="4.依次进行配置"></a>4.依次进行配置</h3><p>注意第一个是要搜索的网站</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c2c6d2ec8573ddbe46875698e95678b9.png" alt="image-20201114101417580"></p>
<h3 id="5-创建完毕后-点击修改搜索引擎-选择刚才创建的-找到搜索引擎ID-也可以点击获取代码-插入代码即可"><a href="#5-创建完毕后-点击修改搜索引擎-选择刚才创建的-找到搜索引擎ID-也可以点击获取代码-插入代码即可" class="headerlink" title="5.创建完毕后,点击修改搜索引擎,选择刚才创建的,找到搜索引擎ID(也可以点击获取代码,插入代码即可)"></a>5.创建完毕后,点击修改搜索引擎,选择刚才创建的,找到搜索引擎ID(也可以点击获取代码,插入代码即可)</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/46d801c5e960346b65910892afbf9cc7.png" alt="image-20201114103410456"></p>
<p>外观不满意的话可以自行修改,最后附上代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#main</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">width</span><span class="selector-pseudo">:750px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">margin</span><span class="selector-pseudo">:20px</span> <span class="selector-tag">auto</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-id">#main</span> <span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">text-align</span><span class="selector-pseudo">:center</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">font-size</span><span class="selector-pseudo">:25px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">font-weight</span><span class="selector-pseudo">:bold</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">margin-button</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">百度网盘资源搜索器</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> cx = <span class="string">&#x27;你的搜索引擎ID&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> gcse = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    gcse.type = <span class="string">&#x27;text/javascript&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    gcse.async = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">    gcse.src = <span class="string">&#x27;https://cse.google.com/cse.js?cx=&#x27;</span> + cx;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> s = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;script&#x27;</span>)[<span class="number">0</span>];</span></span><br><span class="line">    s.parentNode.insertBefore(gcse, s);</span><br><span class="line">  &#125;)();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">gcse:search</span>&gt;</span><span class="tag">&lt;/<span class="name">gcse:search</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>搜索引擎</tag>
        <tag>网盘</tag>
      </tags>
  </entry>
  <entry>
    <title>解决谷歌浏览器卸载后无法重新安装的问题</title>
    <url>/blog/2021/01/06/%E8%A7%A3%E5%86%B3%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8D%B8%E8%BD%BD%E5%90%8E%E6%97%A0%E6%B3%95%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="解决谷歌浏览器卸载后无法重新安装的问题"><a href="#解决谷歌浏览器卸载后无法重新安装的问题" class="headerlink" title="解决谷歌浏览器卸载后无法重新安装的问题"></a>解决谷歌浏览器卸载后无法重新安装的问题</h1><a id="more"></a>

<p>你是否在卸载Google后重装的路上焦头烂额？下载一遍又一遍却无法安装？（这可真是一时卸载一时爽，卸载容易重装难啊）</p>
<p>Google下载后无论怎么弄都安装不上，你焦急的求助度娘，百度出来一堆教程，却不知那个有效，只好一个个尝试搞不懂的操作（嘿嘿，不要急着否认，曾经的我就是这样）。</p>
<p>这些方法也有道理，**<em>Google出现安装不上的情况，一般是由于电脑之前安装过谷歌浏览器，使谷歌浏览器的注册表仍然残留在系统中，导致重新安装失败。**</em></p>
<p>照着网上给出的教程，我是一顿操作猛如虎（管它是什么，一顿乱删），再来安装Google，还是安装不上（当时我试了一遍又一遍，都不管用，快要崩溃），有一种想砸键盘的冲动（再也不用Google了，让你欺负我）。</p>
<p>不过说实话，Google确实好用，不舍得抛弃，我鼓捣来鼓捣去，最终找到解决方法。在这里，我把我的尝试也给列出来了。</p>
<p>解决办法如下：</p>
<h2 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a><strong>方法一：</strong></h2><p>1、打开电脑“运行”（快捷键windows+R，也可以鼠标右键点击电脑左下角“开始”键再点击“运行”）。然后输入“regedit”点击“确定”（会出来一个注册表编辑器的东西，点击“是”即可）</p>
<p>2、依次进入“计算机\HKEY_CURRENT_USER\Software\Google”文件夹并将其删除</p>
<p>3、如果无法查看到谷歌文件，可以尝试在注册列表中按住快捷键Ctrl+F，就可以进行查找看，然后再将谷歌浏览器的相关项目删除，这样就能将谷歌注册表清理干净了，有关谷歌浏览器的残留文件删除完后，您就可以尝试再次谷歌浏览器安装操作了</p>
<h2 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a><strong><em>方法二：</em></strong></h2><p>1.打开360安全卫士，选择电脑清理</p>
<p>2.点击单项清理，选择“清理注册表”</p>
<p>3.点击“一键清理”，再安装Google（如果还报错，尝试重启电脑）</p>
<h2 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h2><p>1.新建一个文本文件（不建议使用记事本，我用的是notepad++,直接在桌面建了一个）</p>
<p>2.将以下代码复制粘贴在该文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">;WARNING, this file will remove Google Chrome registry entries  </span><br><span class="line"></span><br><span class="line">;from your Windows Registry. Consider backing up your registry before</span><br><span class="line"></span><br><span class="line">; using this file: http://support.microsoft.com/kb/322756</span><br><span class="line"></span><br><span class="line">; To run this file, save it as <span class="string">&#x27;remove.reg&#x27;</span> on your desktop and double-click it.</span><br><span class="line"></span><br><span class="line">[-HKEY_LOCAL_MACHINE\SOFTWARE\Classes\ChromeHTML] </span><br><span class="line"></span><br><span class="line">[-HKEY_LOCAL_MACHINE\SOFTWARE\Clients\StartMenuInternet\chrome.exe] </span><br><span class="line"></span><br><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\RegisteredApplications]</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Chrome&quot;</span>=-</span><br><span class="line"></span><br><span class="line">[-HKEY_CURRENT_USER\SOFTWARE\Classes\ChromeHTML] </span><br><span class="line"></span><br><span class="line">[-HKEY_CURRENT_USER\SOFTWARE\Clients\StartMenuInternet\chrome.exe] </span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\SOFTWARE\RegisteredApplications]</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Chrome&quot;</span>=-</span><br><span class="line"></span><br><span class="line">[-HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Uninstall\Chrome]</span><br><span class="line"></span><br><span class="line">[-HKEY_CURRENT_USER\Software\Google\Update\Clients\&#123;8A69D345-D564-463c-AFF1-A69D9E530F96&#125;]</span><br><span class="line"></span><br><span class="line">[-HKEY_CURRENT_USER\Software\Google\Update\ClientState\&#123;8A69D345-D564-463c-AFF1-A69D9E530F96&#125;]</span><br><span class="line"></span><br><span class="line">[-HKEY_CURRENT_USER\Software\Google\Update\Clients\&#123;00058422-BABE-4310-9B8B-B8DEB5D0B68A&#125;]</span><br><span class="line"></span><br><span class="line">[-HKEY_CURRENT_USER\Software\Google\Update\ClientState\&#123;00058422-BABE-4310-9B8B-B8DEB5D0B68A&#125;]</span><br><span class="line"></span><br><span class="line">[-HKEY_LOCAL_MACHINE\SOFTWARE\Google\Update\ClientStateMedium\&#123;8A69D345-D564-463c-AFF1-A69D9E530F96&#125;]</span><br><span class="line"></span><br><span class="line">[-HKEY_LOCAL_MACHINE\SOFTWARE\Google\Update\Clients\&#123;8A69D345-D564-463c-AFF1-A69D9E530F96&#125;]</span><br><span class="line"></span><br><span class="line">[-HKEY_LOCAL_MACHINE\SOFTWARE\Google\Update\ClientState\&#123;8A69D345-D564-463c-AFF1-A69D9E530F96&#125;]</span><br><span class="line"></span><br><span class="line">[-HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Google\Update\Clients\&#123;8A69D345-D564-463c-AFF1-A69D9E530F96&#125;]</span><br></pre></td></tr></table></figure>
<p>3.将该文件命名为rm.reg</p>
<p>4.双击运行（可能会出来一些选项，我默认了），再重装Google即可</p>
<h2 id="方法四"><a href="#方法四" class="headerlink" title="方法四:"></a>方法四:</h2><p>听闻geek卸载软件可以删除注册表，所以可以用它卸载Google，且重装不会有问题。（可能对大部分人，此方法意义不大）<br>给出链接<br> 链接:<a href="https://pan.baidu.com/s/1qaDZ05A9yD1jhOcUeQppuA">https://pan.baidu.com/s/1qaDZ05A9yD1jhOcUeQppuA</a><br> 提取码:386a</p>
<h2 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h2><p>该文仅为记载我在重装Google的艰辛历程，以上方法均为网络收集，如果和我有相同问题的朋友可以尝试一下，节约你百度的时间。如果对于第三种方法不懂这里有现成的文件，下面给出链接：<a href="https://download.csdn.net/download/moshangduanchang/12354433">点这里呀</a></p>
]]></content>
      <tags>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法总结</title>
    <url>/blog/2021/01/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="一-绪论"><a href="#一-绪论" class="headerlink" title="一.绪论"></a>一.绪论</h2><p>算法是为了解决实际问题而设计的.数据结构是算法需要处理的问题载体.</p>
<h3 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语:"></a>基本概念和术语:</h3><ul>
<li><p>数据:数据是指能输入到计算机中并能够被计算机处理的一切对象.</p>
</li>
<li><p>数据元素:数据元素是数据的基本单位.</p>
</li>
<li><p>数据项:一个数据元素可由若干数据项组成.</p>
</li>
<li><p>数据对象:数据对象是具有相同性质的数据元素的集合.</p>
</li>
</ul>
<ul>
<li>数据结构:数据结构是指互相之间存在着一种或多种关系的数据元素的集合.</li>
</ul>
<hr>
<h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构:"></a>逻辑结构:</h3><p>1.集合结构:数据元素同属一个集合，单个数据元素之间没有任何关系</p>
<p><img src="https://i.loli.net/2021/01/11/qoiHNkTzsJxjBGD.png" alt="image-20201118213034722"></p>
<p>​    2.线性结构:类似于线性关系,数据元素之间是一对一的关系</p>
<p><img src="https://i.loli.net/2021/01/11/a3LdovfMAlmkNxE.png" alt="image-20201118213251428"></p>
<p>​    3.树形结构:树形结构中的数据元素之间存在一对多的关系</p>
<p><img src="https://i.loli.net/2021/01/11/c7e6tdFC3w1NAlo.png" alt="image-20201118213518986"></p>
<p>​    4.图形结构:数据元素之间是多对多的关系</p>
<p><img src="https://i.loli.net/2021/01/11/nGcsUypoHmbizL9.png" alt="image-20201118213729837"></p>
<hr>
<h3 id="存储结构-物理结构"><a href="#存储结构-物理结构" class="headerlink" title="存储结构(物理结构):"></a>存储结构(物理结构):</h3><p>(数据结构种类很多， 甚至你也可以发明自己的数据结构， 但是底层存储无非数组或者链表 ,那些多样化的数据结构， 究其源头， 都是在链表或者数组上的特殊操作 )</p>
<p>1.顺序存储:一段连续的内存空间</p>
<ul>
<li>优点：随机访问</li>
</ul>
<ul>
<li>缺点：插入删除效率低，大小固定</li>
</ul>
<p>2.链式存储:不连续的内存空间</p>
<ul>
<li>优点：大小动态扩展，插入删除效率高</li>
</ul>
<ul>
<li>缺点：不能随机访问</li>
</ul>
<p>3.索引:为了方便查找，整体无序，但索引块之间有序，需要额外空间存储索引表</p>
<ul>
<li><p>优点：对顺序查找的一种改进，查找效率高</p>
</li>
<li><p>缺点：需额外空间存储索引</p>
</li>
</ul>
<p>4.散列:选取某个函数，数据元素根据函数计算存储位置,可能存在多个数据元素存储在同一位置，引起地址冲突</p>
<ul>
<li>优点：查找基于数据本身即可找到，查找效率高，存取效率高</li>
</ul>
<ul>
<li>缺点：存取随机，不便于顺序查找</li>
</ul>
<p>队列,栈这两种数据结构既可以使⽤链表也可以使用数组实现.用数组实现,就要处理扩容缩容的问题; 用链表实现,则没有这个问题,但需要更多的内存空间存储节点指针</p>
<p>图的两种表示方法,邻接表就是链表,邻接矩阵就是二维数组.邻接矩阵判断连通性迅速,并可以进行矩阵运算解决⼀些问题,但是如果图⽐较稀疏的话很耗费空间.邻接表⽐较节省空间,但是很多操作的效率上肯定⽐不过邻接矩阵。</p>
<p>散列表就是通过散列函数把键映射到⼀个大数组里。 ⽽且对于解决散列冲突的方法， 拉链法需要链表特性， 操作简单， 但需要额外的空间存储指针； 线性探查法就需要数组特性， 以便连续寻址， 不需要指针的存储空间，但操作稍微复些。    </p>
<hr>
<h3 id="影响算法运行时间的因素"><a href="#影响算法运行时间的因素" class="headerlink" title="影响算法运行时间的因素:"></a>影响算法运行时间的因素:</h3><p>1.运行程序的计算机的机器指令的品质与速度</p>
<p>2.书写程序的语言(一般实现语言级别越高,其执行效率越低)</p>
<p>3.编译程序所生成目标代码的质量</p>
<p>4.问题的规模</p>
<hr>
<h3 id="大O表示法-用来表示时间复杂度函数的增长率的上界"><a href="#大O表示法-用来表示时间复杂度函数的增长率的上界" class="headerlink" title="大O表示法:用来表示时间复杂度函数的增长率的上界"></a>大O表示法:用来表示时间复杂度函数的增长率的上界</h3><p>时间复杂度:嵌套(求积),并列(求和),只关注最高次项</p>
<p>空间复杂度:算法运行所需存储空间:</p>
<p>1.程序本身占用的空间</p>
<p>2.算法的输入,输出占用的空间</p>
<p>3.算法运行中占用的空间</p>
<p>评价一个算法的空间复杂度一般只考虑算法运行中所占用的临时空间.</p>
<p>对于一个算法,其时间复杂度和空间复杂度往往是相互影响的.</p>
<h2 id="二-线性表"><a href="#二-线性表" class="headerlink" title="二.线性表"></a>二.线性表</h2><p>线性结构的特点是在数据元素的非空有限集合中,存在唯一的首元素和唯一的尾元素,首元素无直接前驱,尾元素无直接后继,集合中其他数据元素都有唯一的直接前驱和唯一的直接后继.线性表是最简单,最基本,也是最常用的一种线性结构.</p>
<hr>
<p>线性表是具有相同数据类型的n(n&gt;=0)个数据元素的有限序列.</p>
<h3 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构:"></a>线性表的顺序存储结构:</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20  <span class="comment">//存储空间初始分配量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType; <span class="comment">//ElemType类型根据实际情况而定,这里假设为int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data[MAXSIZE]; <span class="comment">//数组存储数据元素,最大值为MAXSIZE</span></span><br><span class="line">    <span class="keyword">int</span> length;  <span class="comment">//线性表当前长度</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>
<p>线性表顺序存储结构需要三个属性:</p>
<ul>
<li>存储空间的起始位置</li>
<li>线性表的最大存储容量(数组的长度)</li>
<li>线性表的当前长度(小于等于数组长度)</li>
</ul>
<p>顺序表的初始化:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SqList *<span class="title">init_SqList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqList *L;</span><br><span class="line">    L=(SqList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SqList)); <span class="comment">//动态分配内存空间</span></span><br><span class="line">    <span class="keyword">if</span>(!L) <span class="built_in">exit</span>(<span class="number">1</span>);  <span class="comment">//如果存储分配失败,运行exit()函数终止程序运行</span></span><br><span class="line">    L-&gt;length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺序表的插入运算:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SqList *<span class="title">Insert_SqList</span><span class="params">(SqList *L,<span class="keyword">int</span> i,ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在顺序表L第i个位置插入值为x的元素</span></span><br><span class="line">    <span class="keyword">if</span>(L-&gt;length&gt;=MAXSIZE<span class="number">-1</span>)<span class="comment">//判断表是否满</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;顺序表已满!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;L-&gt;length+<span class="number">1</span>)<span class="comment">//判断插入位置是否合理</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入位置i不合理!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> m=L-&gt;length<span class="number">-1</span>;m&gt;=i<span class="number">-1</span>;m--)</span><br><span class="line">    &#123;</span><br><span class="line">        L-&gt;data[m+<span class="number">1</span>]=L-&gt;data[m];<span class="comment">//节点后移</span></span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;data[i<span class="number">-1</span>]=x;<span class="comment">//新元素插入</span></span><br><span class="line">    L-&gt;length++;<span class="comment">//表长加1</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺序表的删除运算:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SqList *<span class="title">Delete_SqList</span><span class="params">(SqList *L,<span class="keyword">int</span> i,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//删除顺序表L中第i个元素,删除元素的值保存在e中</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;L-&gt;length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入位置i不合理!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    e=L-&gt;data[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i;i&lt;=L-&gt;length<span class="number">-1</span>;++i)</span><br><span class="line">        L-&gt;data[i<span class="number">-1</span>]=L-&gt;data[i];</span><br><span class="line">    L-&gt;length--;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺序表按值查找运算:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem_Sq</span><span class="params">(SqList *L,ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在顺序表中查找值为x的元素,查找成功返回元素存储位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L-&gt;data[i]==x)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺序表合并算法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SqList *<span class="title">Merge_SqList</span><span class="params">(SqList *A,SqList *B)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//将两个非递减次序排列的顺序表A和B合并为一个新的有序顺序表C</span></span><br><span class="line">    SqList *C;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    i=<span class="number">0</span>;j=<span class="number">0</span>;k=<span class="number">0</span>;</span><br><span class="line">    C=(SqList *)<span class="built_in">malloc</span>(<span class="number">2</span>*MAXSIZE*<span class="keyword">sizeof</span>(SqList));</span><br><span class="line">    <span class="keyword">if</span>(!C) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    C-&gt;length=A-&gt;length+B-&gt;length;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=A-&gt;length<span class="number">-1</span>&amp;&amp;j&lt;=B-&gt;length)</span><br><span class="line">        <span class="keyword">if</span>(A-&gt;data[i]&lt;B-&gt;data[j])</span><br><span class="line">        &#123;</span><br><span class="line">            C-&gt;data[k]=A-&gt;data[i];k++;i++;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            C-&gt;data[k]=B-&gt;data[j];k++;j++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//前面部分是先将A,B中较短的填入C,后面再填入另一个</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=A-&gt;length<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        C-&gt;data[k]=A-&gt;data[i];k++;i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;B-&gt;length<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        C-&gt;data[k]=B-&gt;data[j];k++;j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<h3 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构:"></a>线性表的链式存储结构:</h3><h4 id="1-单链表-动态链表"><a href="#1-单链表-动态链表" class="headerlink" title="1.单链表(动态链表)"></a>1.单链表(动态链表)</h4><p>静态链表是用类似于数组方法实现的，是顺序的存储结构，在物理地址上是连续的，而且需要预先分配地址空间大小。所以静态链表的初始长度一般是固定的，在做插入和删除操作时不需要移动元素，仅需修改指针</p>
<p>单链表节点数据类型:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">LinkList</span>;</span></span><br></pre></td></tr></table></figure>
<p>头插入法建立单链表:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">CreatList_L1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList L;</span><br><span class="line">    LinkList P;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    L=(LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p=(LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        p-&gt;data=x;</span><br><span class="line">        p-&gt;next=L-&gt;next;</span><br><span class="line">        L-&gt;next=p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尾插入法建立单链表:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">CreatList_L2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList L,p,r;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    r=L=(LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p=(LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        p-&gt;data=x;</span><br><span class="line">        p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        r-&gt;next=p;</span><br><span class="line">        r=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求链表长度的算法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Listlength</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找操作:</p>
<p>​            1.按序号查找</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">Get_LinkList</span><span class="params">(LinkList L,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在链表L中查找第i个元素,找到返回其指针,否则返回空</span></span><br><span class="line">    LinkList p;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j==i)<span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​            2.按值查找</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">Locate_LinkList</span><span class="params">(LinkList L,ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>&amp;&amp;p-&gt;data!=x)</span><br><span class="line">       p=p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入运算:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">ListInsert</span><span class="params">(LinkList L,<span class="keyword">int</span> i,ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在单链表第i个节点前插入新元素x</span></span><br><span class="line">    LinkList p,s;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>&amp;&amp;j&lt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||j&gt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;<span class="built_in">printf</span>(<span class="string">&quot;参数i错误!&quot;</span>);<span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line">    s=(LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除运算:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">ListDelete</span><span class="params">(LinkList L,<span class="keyword">int</span> i,ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//删除单链表L中第i个元素</span></span><br><span class="line">    LinkList p,q;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>&amp;&amp;j&lt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next=<span class="literal">NULL</span>||j&gt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;参数i错误!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    q=p-&gt;next;</span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    *e=q-&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有序链表归并算法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">Merge_LinkList</span><span class="params">(LinkList A,LinkList B)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//A,B均为带头节点的单链表</span></span><br><span class="line">    LinkList C,p,q,s;</span><br><span class="line">    p=A-&gt;next;</span><br><span class="line">    q=B-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">    C=A;</span><br><span class="line">    C-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data&lt;q-&gt;data)&#123;s=p;p=p-&gt;next;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;s=q;q=q-&gt;next;&#125;</span><br><span class="line">        s-&gt;next=C-&gt;next;</span><br><span class="line">        C-&gt;next=s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)p=q;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        s=p;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        s-&gt;next=C-&gt;next;</span><br><span class="line">        C-&gt;next=s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-循环链表"><a href="#2-循环链表" class="headerlink" title="2.循环链表"></a>2.循环链表</h4><p>1.单向循环链表</p>
<p>单链表尾节点的指针域是空指针.而单向循环链表的最后一个节点的指针指向链表头节点.</p>
<p>对于单链表,从一已知节点只能访问该节点及其后继节点,无法访问该节点之前的节点;而对于单向循环链表,只要知道表中任一节点的地址,就可搜寻到所有其他节点的地址,遍历整个链表.</p>
<p>单向循环链表的数据类型定义与单链表相同.在单循环链表上的操作也与单链表基本相同,二者主要区别在于:判断是否达到表尾的条件不同.在单链表中,用指针域是否为NULL作为判断表尾节点的条件;而在循环链表中,则以节点指针域是否等于表头节点(头指针)作为判断到达表尾的条件.</p>
<p>2.双向链表</p>
<p>双向链表的结构:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLnode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span></span><br><span class="line">&#125;DuLnode;</span><br><span class="line"><span class="keyword">typedef</span> DuLnode *DuLinkList;</span><br></pre></td></tr></table></figure>
<p>双向链表的插入运算:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DuLinkList <span class="title">ListInsert_Dul</span><span class="params">(DuLinkList L,<span class="keyword">int</span> i,ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在双向链表的第i个节点前插入一个新元素x</span></span><br><span class="line">	DuLinkList p,s;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    p=L;</span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)</span><br><span class="line">    &#123;p=p-&gt;next;j++&#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||j&lt;i)</span><br><span class="line">    &#123;<span class="built_in">printf</span>(<span class="string">&quot;参数i错误!&quot;</span>);<span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line">    <span class="keyword">if</span>(!(s=(DuLinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DuLnode))))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;prior=p-&gt;prior;p-&gt;prior-&gt;next=s;</span><br><span class="line">    s-&gt;next=p;p-&gt;prior=s;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双向链表的删除运算:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DuLinkList <span class="title">ListDelete_Dul</span><span class="params">(DuLinkList L,<span class="keyword">int</span> i,ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//删除双向链表中第i数据元素</span></span><br><span class="line">    DuLinkList p;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    p=L;</span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)</span><br><span class="line">    &#123;p=p-&gt;next;j++;&#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||j&gt;i)</span><br><span class="line">    &#123;<span class="built_in">printf</span>(<span class="string">&quot;参数i错误!&quot;</span>);<span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        e=p-&gt;data;</span><br><span class="line">        p-&gt;prior-&gt;next=p-&gt;next;</span><br><span class="line">        p-&gt;next-&gt;prior=p-&gt;prior;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三-栈与队列"><a href="#三-栈与队列" class="headerlink" title="三.栈与队列"></a>三.栈与队列</h2><p>栈和队列是在程序设计中被广泛使用的两种数据结构.由于从数据结构角度看,栈和队列是两种特殊的线性表.它们的逻辑结构和线性表相同,只是其运算规则较线性表有更多的限制,因此,也可以将栈和队列称为操作受限的线性表.</p>
<p>栈是限定仅在表尾进行插入和删除操作的线性表.队列是只允许在一端进行插入操作,而在另一端进行删除操作的线性表.</p>
<h3 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h3><ul>
<li>栈是一种特殊的线性表,是一种只允许在表的一端进行插入或删除操作的线性表.把栈中允许进行插入,删除操作的一端称为栈顶,栈的另一端称为栈底.</li>
<li>当栈中没有数据元素时,称之为空栈.栈顶是动态的,对栈顶位置的标记称为栈顶指针.栈的插入操作通常称为进栈(入栈或压栈),栈的删除操作通常称为退栈或出栈.</li>
<li>根据栈的定义,每次进栈的数据元素都放在当前栈顶元素之前而成为新的栈顶元素,每次退栈的数据元素都是当前栈顶元素.这样,最后进入栈的数据元素总是最先退出栈,因此,栈具有”后进先出”的特性,所以栈又称为后进先出的线性表,简称LIFO表.</li>
</ul>
<h3 id="栈的存储结构"><a href="#栈的存储结构" class="headerlink" title="栈的存储结构"></a>栈的存储结构</h3><p>栈有两种存储表示方法,即顺序存储和链式存储.顺序存储的栈称为顺序栈,链式存储的栈称为链式栈.</p>
<h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><p>顺序栈的存储结构:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> StackInitSize 100;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> StackElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    StackElementType data[StackInitSize];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125;SeqStack;</span><br></pre></td></tr></table></figure>
<p>顺序栈的初始化:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SeqStack *<span class="title">InitStack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SeqStack *s;</span><br><span class="line">    s=(SeqStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SeqStack));</span><br><span class="line">    <span class="keyword">if</span>(s!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;s-&gt;top=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> s;&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;没有足够的内存空间,申请失败,程序运行终止!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断栈空的函数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(SeqStack *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(s-&gt;top==<span class="number">-1</span>)?<span class="number">1</span>:<span class="number">0</span>;<span class="comment">//栈空返回1,否则返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>销毁栈的函数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestoryStack</span><span class="params">(SeqStack *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈已销毁!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进栈操作:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(SeqStack *s,StackElementType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;top==StackInitSize)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈满!栈发生上溢,程序停止运行!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        s-&gt;top++;</span><br><span class="line">        s-&gt;data[s-&gt;top]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>退栈操作:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">StackElementType <span class="title">Pop</span><span class="params">(SeqStack *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StackElementType temp;</span><br><span class="line">    <span class="keyword">if</span>(IsElpty(s))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈空!栈发生下溢,程序停止运行!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        temp=s-&gt;data[s-&gt;top];</span><br><span class="line">        s-&gt;top--;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取栈顶元素:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">StackElementType <span class="title">GetTop</span><span class="params">(SeqStack *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;空栈,程序停止运行!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> s-&gt;data[s-&gt;top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>栈浮动技术:</p>
<p>当一个程序中同时使用多个顺序栈时,为了防止上溢错误,需要为每个栈分配较大的存储空间.在多栈使用过程中通常会出现:在某一栈发生上溢的同时,其余栈尚有大量未用空间存在,这样不利于内存空间的共享,会降低内存空间的使用效率.如果将多个栈安排在同一个连续的存储空间中,这样多个栈共享存储空间,并使它们根据实际情况互相调节余缺.如此既节省了存储空间的开销,又降低了上溢现象发生的概率.这种多栈共享空间的技术,通常称为栈浮动技术.</p>
<p>当程序中同时使用两个栈时,两个栈可以共享同一存储空间.此时,将两个栈的栈底分别设在同一存储空间的两端,让两个栈各自向中间延伸.这样只有当整个共享空间被两个栈占满(两个栈的栈顶相遇)时,才会发生上溢.</p>
<p>两栈共享空间的结构:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    StackElementType data[StackInitSize];</span><br><span class="line">    <span class="keyword">int</span> top1;<span class="comment">//栈1栈顶指针</span></span><br><span class="line">    <span class="keyword">int</span> top2;<span class="comment">//栈2栈顶指针</span></span><br><span class="line">&#125;SqDoubleStack;</span><br></pre></td></tr></table></figure>
<p>对于两栈共享空间的进栈方法,我们除了要插入元素值参数外,还需要有一个判断是栈1还是栈2的栈号参数stackNumber</p>
<h4 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h4><p>链式栈的存储结构:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> StackElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    StackElementType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkStack;</span><br></pre></td></tr></table></figure>
<p>链式栈的进栈操作:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkStack *<span class="title">Push</span><span class="params">(LinkStack *top,StackElementType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkStack *p;</span><br><span class="line">    p=(LinkStack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkStack));</span><br><span class="line">    <span class="keyword">if</span>(p)&#123;p-&gt;data=x;</span><br><span class="line">         p-&gt;next=top;</span><br><span class="line">         top=p;</span><br><span class="line">         <span class="keyword">return</span> top;&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;内存不足,程序运行停止!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链式栈的退栈操作:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkStack *<span class="title">Pop</span><span class="params">(LinkStack *top,StackElementType *elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkStack *temp;</span><br><span class="line">    <span class="keyword">if</span>(top)</span><br><span class="line">    &#123;</span><br><span class="line">        temp=top;</span><br><span class="line">        *elem=top-&gt;data;</span><br><span class="line">        top=top-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链式栈读取栈顶元素:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">StackElementType <span class="title">GetTop</span><span class="params">(LinkStack *top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> top?top-&gt;data:<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h3><ul>
<li>队列(Queue)是一种只允许在一端进行插入,另一端进行删除的运算受限的线性表,允许删除的一端叫队头(front),允许插入的一端叫队尾(rear).</li>
<li>队列的插入操作通常称为入队,删除操作通常称为出队,当队列中没有元素时称为空队列.</li>
<li>队列具有”先进先出”(FIFO)特性,简称为FIFO表.</li>
</ul>
<h4 id="队列的存储结构"><a href="#队列的存储结构" class="headerlink" title="队列的存储结构"></a>队列的存储结构</h4><h5 id="循环队列-顺序队列"><a href="#循环队列-顺序队列" class="headerlink" title="循环队列(顺序队列)"></a>循环队列(顺序队列)</h5><p>在顺序队列中,进行入队和出队操作时可能产生溢出现象:</p>
<p>1.”下溢”现象</p>
<p>当队列为空时,进行出队运算产生的溢出现象,称为”下溢”.可通过判断队列是否为空来控制</p>
<p>2.”真上溢”现象</p>
<p>当队列满时,进行入队运算时产生空间溢出的现象,称为”真上溢”.可通过判断队列是否满来控制</p>
<p>3.”假上溢”现象</p>
<p>由于在入队和出队操作中,队头指针与队尾指针只增加不减小,致使被删元素的空间永远无法重新利用.当队列中实际的元素个数远远小于存储空间的规模时,也可能由于队尾指针已超越队列空间的上界而不能做入队操作.这种现象称为”假下溢”.</p>
<p>为防止假溢出现象发生,充分利用存储空间,最巧妙的解决方法就是把队列存储空间看作首尾相连的环,而这种队列的循环顺序存储结构称为循环队列.</p>
<p>循环队列存储结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QueueElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    QueueElementType *base;<span class="comment">//base指向队列存储区首地址</span></span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">&#125;SeqQueue;</span><br></pre></td></tr></table></figure>
<p>循环队列的特点</p>
<ul>
<li>队头,队尾指针加1时从MaxSize-1直接进到0,这种变化可用C语言的取模(余数)运算实现</li>
<li>队空与队满时头尾指针均相等,无法通过front==rear来判断队列的”空”和”满”,解决此问题有两种方法:<ol>
<li>另设一个状态标志位来区别”队空”和”队满”</li>
<li>少用一个存储空间,约定以队头指针在队尾指针的下一位置上作为队列满的标志</li>
</ol>
</li>
</ul>
<p>采用第二种处理方法:</p>
<p>循环队列空的标志:front==rear</p>
<p>循环队列满的标志:(rear+1)%MaxSize==front</p>
<p>循环队列初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SeqQueue <span class="title">InitQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SeqQueue Q;</span><br><span class="line">    Q.base=(QueueElementType*)<span class="built_in">malloc</span>(MaxSize*<span class="keyword">sizeof</span>(QueueElementType));</span><br><span class="line">    <span class="keyword">if</span>(!Q.base)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;申请存储空间失败,程序运行终止!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Q.front=<span class="number">0</span>;</span><br><span class="line">    Q.rear=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断循环队列为空</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueEmpty</span><span class="params">(SeqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front==Q.rear)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断循环队列为满</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueFull</span><span class="params">(SeqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front==(Q.rear+<span class="number">1</span>)%MaxSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入队操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SeqQueue <span class="title">EnQUeue</span><span class="params">(SeqQueue Q,QueueElementType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(QueueFull(Q)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;队满!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        *(Q.base+Q.rear)=x;</span><br><span class="line">        Q.rear=(Q.rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出队操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SeqQueue <span class="title">DeQueue</span><span class="params">(SeqQueue Q,QueueElementType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(QueueEmpty(Q))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队空!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        *e=*(Q.base+Q.front);</span><br><span class="line">        Q.front=(Q.front+<span class="number">1</span>)%MaxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取队头元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">QueueElementType <span class="title">GetHead</span><span class="params">(SeqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(QueueEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队空!读取失败!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> *(Q.base+Q.front);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>销毁队列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestoryQueue</span><span class="params">(SeqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(Q.base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队列已被销毁!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>队列遍历操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueueDisplay</span><span class="params">(SeqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(QueueEmpty(Q))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队空!队列遍历完成!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列遍历(队头-&gt;队尾):\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=Q.front;i!=Q.rear;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>,*(Q.base+i));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\b\b \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h5><p>一个链式队列由一个头指针和一个尾指针唯一地确定.</p>
<p>链式队列节点类型定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QueueElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    QueueElementType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QueueNode;</span><br></pre></td></tr></table></figure>
<p>链式队列数据类型定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    QueueNode *front;</span><br><span class="line">    QueueNode *rear;</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>
<p>链式队列的初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkQueue <span class="title">InitQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    QueueNode *p;</span><br><span class="line">    p=(QueueNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">    <span class="keyword">if</span>(p)&#123;</span><br><span class="line">        Q.front=Q.rear=p;</span><br><span class="line">        Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> Q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;初始化失败!程序运行终止!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断链式队列是否为空</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueEmpty</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front=Q.rear)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入队操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkQueue <span class="title">EnQueue</span><span class="params">(LinkQueue Q,QueueElementType x)</span></span>&#123;</span><br><span class="line">    QueueNode *p;</span><br><span class="line">    p=(QueueNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">    <span class="keyword">if</span>(!p)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;申请空间失败!程序运行终止!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        p-&gt;data=x;</span><br><span class="line">        p-&gt;next=<span class="literal">NULL</span>;<span class="comment">//尾节点的next置空</span></span><br><span class="line">        Q.rear-&gt;next=p;</span><br><span class="line">        Q.rear=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出队操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkQueue <span class="title">DeQueue</span><span class="params">(LinkQueue Q,QueueELementType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QueueNode *p;</span><br><span class="line">    <span class="keyword">if</span>(QueueEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空!出队失败!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        p=Q.front-&gt;next;</span><br><span class="line">        *e=p-&gt;data;</span><br><span class="line">        Q.front-&gt;next=p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(Q.rear==p)</span><br><span class="line">            Q.rear=Q.front;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取队头操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">QueueElementType <span class="title">GetHead</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(QueueEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;队列为空!读取队头失败!\n&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (Q.front-&gt;next.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四-矩阵的压缩存储"><a href="#四-矩阵的压缩存储" class="headerlink" title="四.矩阵的压缩存储"></a>四.矩阵的压缩存储</h2><h2 id="五-递归"><a href="#五-递归" class="headerlink" title="五.递归"></a>五.递归</h2><h2 id="六-树与二叉树"><a href="#六-树与二叉树" class="headerlink" title="六.树与二叉树"></a>六.树与二叉树</h2><h2 id="七-图"><a href="#七-图" class="headerlink" title="七.图"></a>七.图</h2><p>图形结构是一种比树形结构更复杂的非线性结构.在树形结构中,节点间具有分支层次关系,每一层上的节点只能和上一层中的至多一个节点相关,但可能和下一层的多个节点相关.而在图形结构中,任意两个节点之间都可能相关,即节点之间的邻接关系可以是任意的.</p>
<h3 id="图及其相关概念"><a href="#图及其相关概念" class="headerlink" title="图及其相关概念"></a>图及其相关概念</h3><ul>
<li>图是由顶点(vertex)集合及顶点间的关系组成的一种数据结构.</li>
<li>图分为无向图和有向图.具有n个顶点,n(n-1)/2条边的无向图,称为完全无向图.具有n个顶点,n(n-1)条弧的有向图称为完全有向图.完全无向图和完全有向图统称为完全图.</li>
<li>当一个图接近完全图时,称它为稠密图.相反称为稀疏图.</li>
<li>与边有关的数据信息称为权.带权图又称为网络.如果边是有方向的带权图,则是一个有向网络.</li>
<li>在无向图中,一个顶点依附的边的数目称为该顶点的度.在有向图中,指向顶点的弧的数目称为该顶点的入度(这种弧也称为入弧).从顶点发出的弧的数目称为该顶点的出度.有向图的某个顶点的入度和出度之和称为该顶点的度.</li>
<li>除第一个顶点与最后一个顶点之外,其它顶点不重复出现的回路称为简单回路(简单环).</li>
<li>若G中任意两个顶点都是连通的,则称G为连通图,否则称为非连通图.</li>
</ul>
<h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><h4 id="邻接矩阵表示法"><a href="#邻接矩阵表示法" class="headerlink" title="邻接矩阵表示法"></a>邻接矩阵表示法</h4><p>在图的邻接矩阵表示中,除用一个一维数组存放顶点本身的信息外,还用一个n×n的矩阵表示各个顶点之间的邻接关系.即若(i,j)或&lt;i,j&gt;属于边集E,则矩阵中第i行,第j列元素值为1,否则为0.</p>
<p>从无向图的邻接矩阵存储方法可以看出:</p>
<ol>
<li>无向图的邻接矩阵一定是一个对称矩阵</li>
<li>第i行或第i列中1的个数是顶点i的度</li>
<li>矩阵中1的个数的一半为图中边的数目</li>
</ol>
<p>从有向图的邻接矩阵存储方法可以看出:</p>
<ol>
<li>有向图的邻接矩阵不一定是一个对称矩阵</li>
<li>第i行中1的个数为顶点i的出度</li>
<li>第i列中1的个数为顶点i的入度</li>
<li>矩阵中1的个数为图中弧的数目</li>
</ol>
<p>从无向网络的邻接矩阵存储方法可以看出:</p>
<ol>
<li>无向网络的邻接矩阵一定是一个对称矩阵</li>
<li>第i行或第i列中非∞元素的个数为顶点i的度</li>
<li>矩阵中非∞元素的个数的一半为网络中边的数目</li>
</ol>
<p>从有向网络的邻接矩阵存储方法可以看出:</p>
<ol>
<li>有向网络的邻接矩阵不一定是一个对称矩阵</li>
<li>第i行中非∞元素的个数为顶点i的出度</li>
<li>第i列中非∞元素的个数为顶点i的入度</li>
<li>矩阵中非∞元素的个数为网络中弧的数目</li>
</ol>
<p>邻接矩阵的存储结构:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITY 65535 <span class="comment">//用65535表示∞</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVEX 100 <span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;<span class="comment">//顶点类型由用户定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType;<span class="comment">//边上的权值类型由用户定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    VertexType vexs[MAXVEX];<span class="comment">//顶点表</span></span><br><span class="line">    EdgeType arc[MAXVEX][MAXVEX];<span class="comment">//邻接矩阵,可看作边表</span></span><br><span class="line">    <span class="keyword">int</span> numVertexs,numEdges;<span class="comment">//图中当前的顶点和边数</span></span><br><span class="line">&#125;Mgraph;</span><br></pre></td></tr></table></figure>
<p>无向网图的邻接矩阵表示:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatMGraph</span><span class="params">(MGraph *G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k,w;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入顶点数和边数:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;G-&gt;numVertexs,&amp;G-&gt;numEdges);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;numVertexs;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(&amp;G-&gt;vexs[i]);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;numVertexs;i++)</span><br><span class="line">        <span class="keyword">for</span>(j<span class="number">-0</span>;j&lt;G-&gt;numVertexs;j++)</span><br><span class="line">            G-&gt;arc[i][j]=INFINITY;<span class="comment">//邻接矩阵初始化</span></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G-&gt;numEdges;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入边(vi,vj)上的下标i,下标j和权w:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d,%d&quot;</span>,&amp;i,&amp;j,&amp;w);</span><br><span class="line">        G-&gt;arc[i][j]=w;</span><br><span class="line">        G-&gt;arc[j][i]=G-&gt;arc[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="邻接表表示法"><a href="#邻接表表示法" class="headerlink" title="邻接表表示法"></a>邻接表表示法</h4><h2 id="八-查找"><a href="#八-查找" class="headerlink" title="八.查找"></a>八.查找</h2><h2 id="九-排序"><a href="#九-排序" class="headerlink" title="九.排序"></a>九.排序</h2><h3 id="排序的概念"><a href="#排序的概念" class="headerlink" title="排序的概念"></a>排序的概念</h3><p>排序(Sorting)就是按照某种规则,将一组数据对象(记录)排列次序,其主要目的是提高数据检索的效率.</p>
<h3 id="排序的分类"><a href="#排序的分类" class="headerlink" title="排序的分类"></a>排序的分类</h3><p>按照排序过程中所使用存储器情况,可将排序方法分为两大类:</p>
<p>1.内部排序</p>
<p>在排序过程中,整个待排序列都是存放于内存中进行处理,无内外存储器之间的数据交换问题.内部排序速度快,适合少量数据的排序处理.</p>
<p>2.外部排序</p>
<p>在排序过程中,由于待排序记录数据量相当大,不可能也不允许全部驻留在内存中,而必须存放在外部存储器上,然后根据排序过程中的要求,不断在内外存之间进行数据交换来完成排序工作.外部排序速度慢,适合大量数据的排序问处理.</p>
<p>内部排序的方法较多,按照实现策略的不同,可以将内部排序分五大类.</p>
<ol>
<li>插入排序.直接插入排序,希尔排序.</li>
<li>交换排序.冒泡排序,快速排序.</li>
<li>选择排序.直接选择排序,堆排序.</li>
<li>归并排序.</li>
<li>基数排序.</li>
</ol>
<p>假设待排序序列中记录的数据类型定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    ElementType otherinfo;<span class="comment">//排序记录中的其他所有数据项</span></span><br><span class="line">&#125;RecordType;</span><br><span class="line"><span class="keyword">typedef</span> RecordType SeqList[MaxSize+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>数组的第0个元素既可以用来作暂存空间使用,也可以作”监测哨兵”使用,但不用其存放待排序记录.在本章均要求排成递增序.</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p>思想:</p>
<p>1.将待排序序列分为有序区和无序区,初始时,有序区为[R1],无序区为[R2…Rn],令i指向无序区第一个元素,初值i=2</p>
<p>2.当i&lt;=n时,重复执行:将当前无序区第一个记录插入到有序区合适位置</p>
<p>3.当i&gt;n时,排序结束</p>
<p>算法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(SeqList R,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//length为待排序列长度</span></span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(R[i].key&lt;R[i<span class="number">-1</span>].key)</span><br><span class="line">        &#123;</span><br><span class="line">            R[<span class="number">0</span>]=R[i];</span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;R[<span class="number">0</span>].key&lt;R[j].key;j--)</span><br><span class="line">                R[j+<span class="number">1</span>]=R[j];<span class="comment">//记录后移</span></span><br><span class="line">            R[j+<span class="number">1</span>]=R[<span class="number">0</span>];</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哨兵的作用:</p>
<p>1.进入查找(插入位置)循环之前,它保存了R[i]的副本,使不至于记录后移而丢失R[i]的内容.</p>
<p>2.在查找循环中”监视”下标j是否越界.</p>
<p>直接插入排序的时间复杂度为O(n^2),空间复杂度为O(1),直接插入排序是稳定的</p>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>希尔排序也叫缩小增量排序,是插入排序的一种,在时间复杂度上比直接插入排序好.</p>
<p>思想:</p>
<p>1.先将整个待排序列以d1(d1&lt;n)为步长分成若干子序列,把所有相隔为d1的记录放在同一组</p>
<p>2.在每个分组内进行直接插入排序</p>
<p>3.再将整个待排序记录以d2(d2&lt;d1&lt;n)为步长重新分组,并在每组内进行直接插入排序</p>
<p>4.重复上步,直至dt=1,即所有记录放进一个组中进行直接插入排序,其最终结果为有序序列</p>
<p>算法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellPass</span><span class="params">(SeqList R,<span class="keyword">int</span> length,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//希尔排序的一次排序,length为待排序列长度,d为当前增量</span></span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=d+<span class="number">1</span>;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(R[i].key&lt;R[i-d].key)&#123;</span><br><span class="line">            R[<span class="number">0</span>]=R[i];</span><br><span class="line">            j=i-d;</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                R[j+d]=R[j];</span><br><span class="line">                j=j-d;</span><br><span class="line">            &#125;<span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;R[<span class="number">0</span>].key&lt;R[j].key)</span><br><span class="line">                R[j+d]=R[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(SeqList R,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//对序列R进行希尔排序,length为待排序长度</span></span><br><span class="line">    <span class="keyword">int</span> increment=length;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        increment=(increment+<span class="number">1</span>)/<span class="number">3</span>;</span><br><span class="line">        ShellPass(R,length,increment);</span><br><span class="line">    &#125;<span class="keyword">while</span>(increment&gt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>希尔排序时间复杂度可达到O(n^1.25),空间复杂度为O(1),希尔排序不稳定</p>
<h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><p>交换排序的基本思想是两两比较待排序记录的关键字,如果发现两个关键字逆序,则将两个记录位置互换,重复此过程,直到该系列所有关键字都有序为止.</p>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>思想:</p>
<p>1.将第一个记录的关键字与第二个记录的关键字比较,若二者为逆序(R[1].key&gt;R[2].key),则交换两记录位置,然后比较第二个记录与第三个记录,若两关键字为逆序,同样交换位置</p>
<p>2.依次类推,直至第n-1个记录与第n个记录比较完为止.上述过程称为第一趟冒泡排序,其结果使n个记录中关键字最大的记录被移动到最后一个位置</p>
<p>3.然后进行第二次冒泡排序,即对前n-1个记录重复与第一趟冒泡排序类似的过程,结果使关键字次大的记录被移到第n-1个记录位置</p>
<p>4.重复上述过程,直到”在一趟排序过程中没有进行交换记录的操作”为止</p>
<p>算法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(SeqList R,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,exchange=<span class="number">1</span>;<span class="comment">//exchange为发生交换的标志</span></span><br><span class="line">    <span class="keyword">for</span>(i=length;i&gt;<span class="number">1</span>&amp;&amp;exchange;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        exchange=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(R[j].key&lt;R[j+<span class="number">1</span>].key)</span><br><span class="line">            &#123;</span><br><span class="line">                R[<span class="number">0</span>]=R[j];</span><br><span class="line">                R[j]=R[j+<span class="number">1</span>];</span><br><span class="line">                R[j+<span class="number">1</span>]=R[<span class="number">0</span>];</span><br><span class="line">                exchange=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冒泡排序时间复杂度为O(n²),空间复杂度为O(1),且冒泡排序是稳定的</p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>快速排序采用一种分治的策略,通常称为分治法.分治的基本思想是:将原问题分解为若干规模更小但将结构与原问题相似的子问题,采用递归方法求解这些子问题,然后将这些子问题的解组合成原问题的解.</p>
<p>思想:</p>
<p>1.从待排序列中任取一个记录(例如)的关键字作为枢轴(pivot),按照枢轴,将整个待排序列划分为左右两个子序列,其中左子序列中所有关键字都小于等于枢轴,而右子序列中所有的关键字都大于枢轴,枢轴记录则排在这两个子序列中间(这也是该记录的最终位置).此过程称为一趟快速排序(或一次划分).</p>
<p>2.对左右两个子序列分别重复实施上述方法,直到所有的记录都排在相应的位置上为止(每个子序列只含一个记录)</p>
<p>算法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuickPass</span><span class="params">(SeqList R,<span class="keyword">int</span> b,<span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//对R[b],...R[e]作一趟划分,并返回枢轴记录的位置</span></span><br><span class="line">    <span class="keyword">int</span> i=b,j=e;</span><br><span class="line">    R[<span class="number">0</span>]=R[i];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">while</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
</search>
