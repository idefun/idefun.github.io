<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BurpSuite的设置及使用</title>
    <url>/article/13804.html</url>
    <content><![CDATA[<h1 id="BurpSuite的设置及使用"><a href="#BurpSuite的设置及使用" class="headerlink" title="BurpSuite的设置及使用"></a>BurpSuite的设置及使用</h1><h2 id="1-BurpSuite安装与配置"><a href="#1-BurpSuite安装与配置" class="headerlink" title="1.BurpSuite安装与配置"></a>1.BurpSuite安装与配置</h2><h3 id="BurpSuite功能介绍"><a href="#BurpSuite功能介绍" class="headerlink" title="BurpSuite功能介绍"></a>BurpSuite功能介绍</h3><p>BurpSuite是用于攻击web应用程序的集成平台，包含了许多工具。BurpSuite为这些工具设计了许多接口，以加快攻击应用程序的过程。所有工具都共享一个请求，并能处理对应的HTTP消息、持久性、认证、代理、日志、警报。</p>
<p>Burpsuite是由JAVA语言编写,所以Burpsuite是-款跨平台的软件。但是在测试过程中Buripsuite不像其他自动化测试工具不需要输入任何内容即可完成测试，而需要手动的配置某些参数触发对应的行为才会完成测试。</p>
<h2 id="2-BurpSuite-Proxy模块"><a href="#2-BurpSuite-Proxy模块" class="headerlink" title="2.BurpSuite Proxy模块"></a>2.BurpSuite Proxy模块</h2><p>Burp Proxy 是Burp Suite以用户驱动测试流程功能的核心，通过代理模式，可以让我们拦截、查看、修改所有在客户端和服务端之间传输的数据。</p>
<h3 id="1-Intercept"><a href="#1-Intercept" class="headerlink" title="1.Intercept"></a>1.Intercept</h3><p>Forward表示将截断的HTTP或HTTPS请求发送到服务器。<br>Drop表示将截断的HTTP或HTTPS请求丢弃。<br>Intercept is on和Intercept is off表示开启或关闭代理截断功能。<br>Action表示将代理截断的HTTP或HTTPS请求发送到其他模块或做其他处理。<br>对Intercept进行Raw Hex Params Header切换查看不同的数据格式。</p>
<h3 id="2-HTTP-history"><a href="#2-HTTP-history" class="headerlink" title="2.HTTP history"></a>2.HTTP history</h3><p>HTTP history用来查看提交过的HTTP请求。<br>Fiter可以过滤显示某些HTTP请求。点击Filter就可以打开。对于指定URL可以选中右键点击,执行其他操作。WebSockets history与HTTP history功能类似。</p>
<h3 id="3-options"><a href="#3-options" class="headerlink" title="3.options"></a>3.options</h3><p>Options具有的功能:代理监听设置、戳断客户端请求、截断服务器响应、截断WebSocket通信、服务端响应修改(绕过JS验证文件上传)、匹配与替换HTTP消息中的内容、通过SSL连接Web服务器配置、其他配置选项。</p>
<h3 id="4-设置proxy-listener"><a href="#4-设置proxy-listener" class="headerlink" title="4.设置proxy listener"></a>4.设置proxy listener</h3><p>通过设置Proxy Listeners来截断数据流量。比如设置监听端口等。BurpSuite默认监听8080端口.</p>
<p>修改端口:</p>
<p>1.关闭截断</p>
<p>2.options-&gt;edit</p>
<p>3.修改端口,点击running</p>
<p>4.修改浏览器端口</p>
<p>5.Internet选项-&gt;连接-&gt;局域网设置</p>
<p>6.修改端口</p>
<h3 id="5-设置intercept-client-requests"><a href="#5-设置intercept-client-requests" class="headerlink" title="5.设置intercept client requests"></a>5.设置intercept client requests</h3><p>通过设置Intercept Client Requests来截断符合条件的HTTP请求。</p>
<h3 id="6-设置Intercept-Server-Response"><a href="#6-设置Intercept-Server-Response" class="headerlink" title="6.设置Intercept Server Response"></a>6.设置Intercept Server Response</h3><p>通过设置Intercept Server Response来筛选出符合条件的HTTP响应。</p>
<h3 id="7-设置截断Websocket通信以及修改Response的内容"><a href="#7-设置截断Websocket通信以及修改Response的内容" class="headerlink" title="7.设置截断Websocket通信以及修改Response的内容"></a>7.设置截断Websocket通信以及修改Response的内容</h3><h3 id="8-匹配以及修改HTTP消息"><a href="#8-匹配以及修改HTTP消息" class="headerlink" title="8.匹配以及修改HTTP消息"></a>8.匹配以及修改HTTP消息</h3><p>可以修改HTTP请求和HTTP响应中的内容。</p>
<h2 id="3-Burpsuite抓取手机APP流量"><a href="#3-Burpsuite抓取手机APP流量" class="headerlink" title="3.Burpsuite抓取手机APP流量"></a>3.Burpsuite抓取手机APP流量</h2><p>目前WebApp(手机App)的通信任然使用HTTP协议进行对应的通信.可以通过Burp设置代理,然后手机设置网络代理,通过Burp截断手机APP流量.</p>
<p>1.Burpsuite设置截断所有网卡的流量，那么局城网中所有的主机都可以通过该代理进行网络访问。</p>
<p><img src="https://i.loli.net/2021/01/24/n1owBAfCMJXqvhW.png" alt=""></p>
<p><img src="https://i.loli.net/2021/01/24/Cu6NGxn2SI57hBs.png" alt=""></p>
<p>2.查看电脑ip</p>
<p>3.在手机网络设置中，填写对应的代理。</p>
<p><img src="https://i.loli.net/2021/01/24/gcYyFBzhjZEKOev.png" alt=""></p>
<p><img src="https://i.loli.net/2021/01/24/US7BIW1oNuXlHhJ.png" alt=""></p>
<p><img src="https://i.loli.net/2021/01/24/o8hED3xYzjUlvC9.png" alt=""></p>
<p>4.Burpsuite开启截断</p>
<p><img src="https://i.loli.net/2021/01/24/nU8QWAlJGESgP96.png" alt=""></p>
<h2 id="4-Burpsuite剔除JS脚本-绕过JS文件上传验证"><a href="#4-Burpsuite剔除JS脚本-绕过JS文件上传验证" class="headerlink" title="4.Burpsuite剔除JS脚本(绕过JS文件上传验证)"></a>4.Burpsuite剔除JS脚本(绕过JS文件上传验证)</h2><p>JavaScript—-种直译式脚本语言，是一种动态类型、 弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML (标准通用标记语言下的一个应用)网页上使用，用来给HTML网页增加动态功能。例如:对于上传文件进行JS验证。</p>
<p><img src="https://i.loli.net/2021/01/25/P1A6G4zFDUpbRs3.png" alt=""></p>
<p>也可以使用浏览器审计工具直接删除JS</p>
<h2 id="5-Burpsuite-Target介绍"><a href="#5-Burpsuite-Target介绍" class="headerlink" title="5.Burpsuite Target介绍"></a>5.Burpsuite Target介绍</h2><p>Burp Target组件主要包含站点地图、目标域、Target 工具三部分组成，他们帮助渗透测试人员更好地了解目标应用的整体状况、当前的工作涉及哪些目标域、分析可能存在的攻击面等信息</p>
<p>Target Scope中作用域的定义比较宽泛，通常来说，当我们对某个产品进行渗透测试时，可以通过域名或者主机名去限制拦截内容，这里域名或主机名就是我们说的作用域;如果我们想限制得更为细粒度化，比如，你只想拦截login目录下的所有请求，这时我们也可以在此设置，此时，作用域就是目录。</p>
<h3 id="Target站点地图Sitemap介绍"><a href="#Target站点地图Sitemap介绍" class="headerlink" title="Target站点地图Sitemap介绍"></a>Target站点地图Sitemap介绍</h3><p>Site Map的左边为访问的URL,按照网站的层级和深度，树形展示整个应用系统的结构和关联其他域的url情况;右边显示的是某一个url被访问的明细列表，共访问哪些url,请求和应答内容分别是什么，都有着详实的记录。基于左边的树形结构，我们可以选择某个分支，对指定的路径进行扫描和抓取</p>
<h2 id="6-Burpsuite-站点地图介绍"><a href="#6-Burpsuite-站点地图介绍" class="headerlink" title="6.Burpsuite 站点地图介绍"></a>6.Burpsuite 站点地图介绍</h2><h3 id="目标分析"><a href="#目标分析" class="headerlink" title="目标分析"></a>目标分析</h3><p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708061126089.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708061243107.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708061313124.png" alt=""></p>
<h3 id="站点地图比较"><a href="#站点地图比较" class="headerlink" title="站点地图比较"></a>站点地图比较</h3><p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708061805978.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708061858034.png" alt=""></p>
<h2 id="7-BurpSuite-爬虫介绍"><a href="#7-BurpSuite-爬虫介绍" class="headerlink" title="7.BurpSuite 爬虫介绍"></a>7.BurpSuite 爬虫介绍</h2><p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708072254485.png" alt=""></p>
<h3 id="BurpSuite-spider-control介绍"><a href="#BurpSuite-spider-control介绍" class="headerlink" title="BurpSuite spider control介绍"></a>BurpSuite spider control介绍</h3><p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708072433387.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708074243626.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708074425977.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708074440370.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708074847766.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708085028692.png" alt=""></p>
<h2 id="8-BurpSuite-漏洞扫描介绍"><a href="#8-BurpSuite-漏洞扫描介绍" class="headerlink" title="8.BurpSuite 漏洞扫描介绍"></a>8.BurpSuite 漏洞扫描介绍</h2><p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708090758906.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708091157848.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708091209413.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708091304387.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708091509730.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708092032622.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708092618118.png" alt=""></p>
<h2 id="9-BurpSuite-Intruder模块介绍"><a href="#9-BurpSuite-Intruder模块介绍" class="headerlink" title="9.BurpSuite Intruder模块介绍"></a>9.BurpSuite Intruder模块介绍</h2><p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708093712409.png" alt=""></p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708093804196.png" alt="image-20210708093804196"></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708094507606.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708153113545.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708153201596.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708154420924.png" alt=""></p>
<h2 id="10-BurpSuite-repeater介绍"><a href="#10-BurpSuite-repeater介绍" class="headerlink" title="10.BurpSuite repeater介绍"></a>10.BurpSuite repeater介绍</h2><p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20210708155215613.png" alt=""></p>
]]></content>
      <categories>
        <category>Hack</category>
      </categories>
      <tags>
        <tag>BurpSuite</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中length()、size()、sizeof()三者的区别</title>
    <url>/article/21ddb368.html</url>
    <content><![CDATA[<h1 id="C-中length-、size-、sizeof-三者的区别"><a href="#C-中length-、size-、sizeof-三者的区别" class="headerlink" title="C++中length()、size()、sizeof()三者的区别"></a>C++中length()、size()、sizeof()三者的区别</h1><a id="more"></a>
<h2 id="一、length-函数"><a href="#一、length-函数" class="headerlink" title="一、length()函数"></a>一、length()函数</h2><p>c++中，length()只是用来获取<strong>字符串</strong>的长度。</p>
<blockquote>
<p>例如：string str = “absdhffhf”,则str.length() = 9。</p>
</blockquote>
<h2 id="二、size-函数"><a href="#二、size-函数" class="headerlink" title="二、size()函数"></a>二、size()函数</h2><p>c++中，在获取字符串长度时，<strong>size()函数与length()函数作用相同</strong>。除此之外，size()函数还可以<strong>获取vector类型的长度</strong>。</p>
<blockquote>
<p>例如：vector \<int> num(15,2),则num.size() = 15。</p>
<p>例如：string str = “abcd”,则 str.size()=4。</p>
</blockquote>
<h2 id="三、sizeof-运算符"><a href="#三、sizeof-运算符" class="headerlink" title="三、sizeof()运算符"></a>三、sizeof()运算符</h2><p>sizeof()运算符用来<strong>求对象所占内存空间的大小</strong>。</p>
<blockquote>
<p>char c[] = “asdsds”;<br> char* cc = c;<br> char cn[40] = “asdsds”;<br> int a[] = {1,2,3,4,5,6};<br> int* aa = a;<br> cout &lt;&lt; sizeof(c) &lt;&lt; sizeof(cc) &lt;&lt; sizeof(<em>cc) &lt;&lt; sizeof(cn);<br> cout &lt;&lt; sizeof(a) &lt;&lt; sizeof(aa) &lt;&lt; sizeof(</em>aa);</p>
<p>结果输出：<br> sizeof(c) = 7          //c是数组，计算到’\0’位置，结果为6 * 1+1=7<br> sizeof(cc) = 8         //cc为指针类型，大小为8<br> sizeof(<em>cc) = 1        //</em>cc指向c的第一个字符，大小为1<br> sizeof(cn) = 40        //开辟40个char空间，大小为40 * 1=40<br> sizeof(a) = 24         //a是数组，但不需计算到’\0’，结果为6* 4=24<br> sizeof(aa) = 8         //aa为指针类型，大小为8<br> sizeof(<em>aa) = 4        //</em>aa指向a的第一个数字，大小为4</p>
</blockquote>
<p>需要注意的是，如果不使用Vector作为数组进行参数传递，那么在传递数组引用是需要再传递一个数组的大小，否则在函数中无法根据首地址计算出数组大小。</p>
]]></content>
      <categories>
        <category>c&amp;c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo的next主题实现双语功能</title>
    <url>/article/99e78227.html</url>
    <content><![CDATA[<h1 id="Hexo的next主题实现双语功能"><a href="#Hexo的next主题实现双语功能" class="headerlink" title="Hexo的next主题实现双语功能"></a>Hexo的next主题实现双语功能</h1><a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前不久,给博客添加了Google Analytics,通过数据显示,发现我这小破站寥寥无几的流量大部分竟然是国外朋友贡献的,心中便想着将博客国际化—-搞个英文版本.说干就干,经过我的一番折腾,终于给搞出来了,但我要说明一下文章的内容是要自己转换为英文,具体效果大家可以点击下面链接前往查看</p>
<p><a href="https://en.idefun.com/" class="LinkCard" target="_blank">英文版本</a></p>
<h2 id="诉求"><a href="#诉求" class="headerlink" title="诉求"></a>诉求</h2><p>首先说说我对英文网站的诉求:</p>
<ol>
<li>英文网站要与原网站的结构外观基本保持一致(我看到有的小伙伴直接换支持双语的主题了,我可不想让自己的心血白流)</li>
<li>我希望原网站和英文网站有个切换按钮,很容易切换</li>
</ol>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>在hexo本地目录创建英文文件夹(名字自定义),我的是en</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320154606919.png" alt=""></p>
<p>复制hexo目录的内容(node_modules除外)到en文件夹,复制后en文件夹如下</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320154912791.png" alt=""></p>
<p>安装相关插件,在en文件夹使用命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>修改en文件夹中_config.yml文件,将下图中的language改为en,可以比对着hexo本地目录的_config.yml文件将中文改为相应的英文(如下图的title,subtitle等)</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320155305119.png" alt=""></p>
<p>修改hexo目录next主题配置文件_config.yml文件,找到menu字段,增添language菜单,注意链接要换成自己的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">language: https:&#x2F;&#x2F;en.idefun.com&#x2F; || fa fa-language</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320155819757.png" alt=""></p>
<p>修改next主题文件夹下的languages中的zh-CN.yml,找到menu,添加language:English</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320160213558.png" alt=""></p>
<p>可以在hexo目录使用hexo s查看效果</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320160423212.png" alt=""></p>
<p>同理,修改en文件夹中next主题配置文件_config.yml文件,找到menu字段,增添中文菜单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">中文: https:&#x2F;&#x2F;www.idefun.com&#x2F; || fa fa-language</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320160547373.png" alt=""></p>
<p>修改en文件夹下themes中next主题文件夹下的languages中的en.yml,找到menu,添加language:中文</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320160801285.png" alt=""></p>
<p>可以在en目录使用hexo s查看效果</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320160357274.png" alt=""></p>
<h3 id="部署配置"><a href="#部署配置" class="headerlink" title="部署配置"></a>部署配置</h3><p>下面提供两种部署方法,第一种不用再创建仓库,第二种要再创建仓库,若想要给英文博客绑定域名建议选择第二种,关于创建仓库及打开github page就不多说了</p>
<h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>在en文件夹生成英文博客,并将生成的public文件夹中的内容复制到hexo目录下的public文件夹中的en文件夹,推送时只需在hexo目录下推送</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>使用下面命令即可实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; cd en &amp;&amp;  hexo clean &amp;&amp; hexo g &amp;&amp; cd ..&#x2F; &amp;&amp; cp -r en&#x2F;public&#x2F;. public&#x2F;en&#x2F; &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<p>可以写成shell脚本,我这里提供一份简单的脚本供大家参考</p>
<p><a href="https://idefun.lanzous.com/i4cz6n4ov7e" class="LinkCard">点击下载</a></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320162843893.png" alt=""></p>
<p>下载后改后缀为sh即可双击运行</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320162956255.png" alt=""></p>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p>在en文件夹生成英文博客,将生成英文博客推送到一个新的仓库,需要分别推送,可以编写相应脚本来简化操作</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><p>修改en文件夹在_config.yml文件,找到deploy字段,修改为自己的仓库即可</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320163232780.png" alt=""></p>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>为大家提供一种思路,希望有帮助</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记</title>
    <url>/article/7b8ad929.html</url>
    <content><![CDATA[<h1 id="Java学习笔记"><a href="#Java学习笔记" class="headerlink" title="Java学习笔记"></a>Java学习笔记</h1><a id="more"></a>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h3><p>单行注释使用<code>//</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 输出hello world</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><p>多行注释使用<code>/**/</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 输出hello </span></span><br><span class="line"><span class="comment">        world*/</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h3><p>Javadoc：文档注释</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span> HelloWorld</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span> idefun</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="标识符和关键字"><a href="#标识符和关键字" class="headerlink" title="标识符和关键字"></a>标识符和关键字</h2><p>关键字</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Java关键字类别</th>
<th style="text-align:left">Java关键字</th>
<th style="text-align:center">关键字含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">访问控制</td>
<td style="text-align:left">private</td>
<td style="text-align:center">一种访问控制方式：私用模式，访问控制修饰符，可以应用于类、方法或字段（在类中声明的变量）</td>
</tr>
<tr>
<td style="text-align:left">访问控制</td>
<td style="text-align:left">protected</td>
<td style="text-align:center">一种访问控制方式：保护模式，可以应用于类、方法或字段（在类中声明的变量）的访问控制修饰符</td>
</tr>
<tr>
<td style="text-align:left">访问控制</td>
<td style="text-align:left">public</td>
<td style="text-align:center">一种访问控制方式：共用模式，可以应用于类、方法或字段（在类中声明的变量）的访问控制修饰符。</td>
</tr>
<tr>
<td style="text-align:left">类、方法和变量修饰符</td>
<td style="text-align:left">abstract</td>
<td style="text-align:center">表明类或者成员方法具有抽象属性，用于修改类或方法</td>
</tr>
<tr>
<td style="text-align:left">类、方法和变量修饰符</td>
<td style="text-align:left">class</td>
<td style="text-align:center">声明一个类，用来声明新的Java类</td>
</tr>
<tr>
<td style="text-align:left">类、方法和变量修饰符</td>
<td style="text-align:left">extends</td>
<td style="text-align:center">表明一个类型是另一个类型的子类型。对于类，可以是另一个类或者抽象类；对于接口，可以是另一个接口</td>
</tr>
<tr>
<td style="text-align:left">类、方法和变量修饰符</td>
<td style="text-align:left">final</td>
<td style="text-align:center">用来说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变，用来定义常量</td>
</tr>
<tr>
<td style="text-align:left">类、方法和变量修饰符</td>
<td style="text-align:left">implements</td>
<td style="text-align:center">表明一个类实现了给定的接口</td>
</tr>
<tr>
<td style="text-align:left">类、方法和变量修饰符</td>
<td style="text-align:left">interface</td>
<td style="text-align:center">接口</td>
</tr>
<tr>
<td style="text-align:left">类、方法和变量修饰符</td>
<td style="text-align:left">native</td>
<td style="text-align:center">用来声明一个方法是由与计算机相关的语言（如C/C++/FORTRAN语言）实现的</td>
</tr>
<tr>
<td style="text-align:left">类、方法和变量修饰符</td>
<td style="text-align:left">new</td>
<td style="text-align:center">用来创建新实例对象</td>
</tr>
<tr>
<td style="text-align:left">类、方法和变量修饰符</td>
<td style="text-align:left">static</td>
<td style="text-align:center">表明具有静态属性</td>
</tr>
<tr>
<td style="text-align:left">类、方法和变量修饰符</td>
<td style="text-align:left">strictfp</td>
<td style="text-align:center">用来声明FP_strict（单精度或双精度浮点数）表达式遵循IEEE 754算术规范</td>
</tr>
<tr>
<td style="text-align:left">类、方法和变量修饰符</td>
<td style="text-align:left">synchronized</td>
<td style="text-align:center">表明一段代码需要同步执行</td>
</tr>
<tr>
<td style="text-align:left">类、方法和变量修饰符</td>
<td style="text-align:left">transient</td>
<td style="text-align:center">声明不用序列化的成员域</td>
</tr>
<tr>
<td style="text-align:left">类、方法和变量修饰符</td>
<td style="text-align:left">volatile</td>
<td style="text-align:center">表明两个或者多个变量必须同步地发生变化</td>
</tr>
<tr>
<td style="text-align:left">程序控制</td>
<td style="text-align:left">break</td>
<td style="text-align:center">提前跳出一个块</td>
</tr>
<tr>
<td style="text-align:left">程序控制</td>
<td style="text-align:left">continue</td>
<td style="text-align:center">回到一个块的开始处</td>
</tr>
<tr>
<td style="text-align:left">程序控制</td>
<td style="text-align:left">return</td>
<td style="text-align:center">从成员方法中返回数据</td>
</tr>
<tr>
<td style="text-align:left">程序控制</td>
<td style="text-align:left">do</td>
<td style="text-align:center">用在do-while循环结构中</td>
</tr>
<tr>
<td style="text-align:left">程序控制</td>
<td style="text-align:left">while</td>
<td style="text-align:center">用在循环结构中</td>
</tr>
<tr>
<td style="text-align:left">程序控制</td>
<td style="text-align:left">if</td>
<td style="text-align:center">条件语句的引导词</td>
</tr>
<tr>
<td style="text-align:left">程序控制</td>
<td style="text-align:left">else</td>
<td style="text-align:center">用在条件语句中，表明当条件不成立时的分支</td>
</tr>
<tr>
<td style="text-align:left">程序控制</td>
<td style="text-align:left">for</td>
<td style="text-align:center">一种循环结构的引导词</td>
</tr>
<tr>
<td style="text-align:left">程序控制</td>
<td style="text-align:left">instanceof</td>
<td style="text-align:center">用来测试一个对象是否是指定类型的实例对象</td>
</tr>
<tr>
<td style="text-align:left">程序控制</td>
<td style="text-align:left">switch</td>
<td style="text-align:center">分支语句结构的引导词</td>
</tr>
<tr>
<td style="text-align:left">程序控制</td>
<td style="text-align:left">case</td>
<td style="text-align:center">用在switch语句之中，表示其中的一个分支</td>
</tr>
<tr>
<td style="text-align:left">程序控制</td>
<td style="text-align:left">default</td>
<td style="text-align:center">默认，例如：用在switch语句中，表明一个默认的分支。Java8 中也作用于声明接口函数的默认实现</td>
</tr>
<tr>
<td style="text-align:left">错误处理</td>
<td style="text-align:left">try</td>
<td style="text-align:center">尝试一个可能抛出异常的程序块</td>
</tr>
<tr>
<td style="text-align:left">错误处理</td>
<td style="text-align:left">catch</td>
<td style="text-align:center">用在异常处理中，用来捕捉异常</td>
</tr>
<tr>
<td style="text-align:left">错误处理</td>
<td style="text-align:left">throw</td>
<td style="text-align:center">抛出一个异常</td>
</tr>
<tr>
<td style="text-align:left">错误处理</td>
<td style="text-align:left">throws</td>
<td style="text-align:center">声明在当前定义的成员方法中所有需要抛出的异常</td>
</tr>
<tr>
<td style="text-align:left">包相关</td>
<td style="text-align:left">import</td>
<td style="text-align:center">表明要访问指定的类或包</td>
</tr>
<tr>
<td style="text-align:left">包相关</td>
<td style="text-align:left">package</td>
<td style="text-align:center">包</td>
</tr>
<tr>
<td style="text-align:left">基本类型</td>
<td style="text-align:left">boolean</td>
<td style="text-align:center">基本数据类型之一，声明布尔类型的关键字</td>
</tr>
<tr>
<td style="text-align:left">基本类型</td>
<td style="text-align:left">byte</td>
<td style="text-align:center">基本数据类型之一，字节类型</td>
</tr>
<tr>
<td style="text-align:left">基本类型</td>
<td style="text-align:left">char</td>
<td style="text-align:center">基本数据类型之一，字符类型</td>
</tr>
<tr>
<td style="text-align:left">基本类型</td>
<td style="text-align:left">double</td>
<td style="text-align:center">基本数据类型之一，双精度浮点数类型</td>
</tr>
<tr>
<td style="text-align:left">基本类型</td>
<td style="text-align:left">float</td>
<td style="text-align:center">基本数据类型之一，单精度浮点数类型</td>
</tr>
<tr>
<td style="text-align:left">基本类型</td>
<td style="text-align:left">int</td>
<td style="text-align:center">基本数据类型之一，整数类型</td>
</tr>
<tr>
<td style="text-align:left">基本类型</td>
<td style="text-align:left">long</td>
<td style="text-align:center">基本数据类型之一，长整数类型</td>
</tr>
<tr>
<td style="text-align:left">基本类型</td>
<td style="text-align:left">short</td>
<td style="text-align:center">基本数据类型之一,短整数类型</td>
</tr>
<tr>
<td style="text-align:left">基本类型</td>
<td style="text-align:left">null</td>
<td style="text-align:center">空，表示无值，不能将null赋给原始类型（byte、short、int、long、char、float、double、boolean）变量</td>
</tr>
<tr>
<td style="text-align:left">基本类型</td>
<td style="text-align:left">true</td>
<td style="text-align:center">真，boolean变量的两个合法值中的一个</td>
</tr>
<tr>
<td style="text-align:left">基本类型</td>
<td style="text-align:left">false</td>
<td style="text-align:center">假，boolean变量的两个合法值之一</td>
</tr>
<tr>
<td style="text-align:left">变量引用</td>
<td style="text-align:left">super</td>
<td style="text-align:center">表明当前对象的父类型的引用或者父类型的构造方法</td>
</tr>
<tr>
<td style="text-align:left">变量引用</td>
<td style="text-align:left">this</td>
<td style="text-align:center">指向当前实例对象的引用，用于引用当前实例</td>
</tr>
<tr>
<td style="text-align:left">变量引用</td>
<td style="text-align:left">void</td>
<td style="text-align:center">声明当前成员方法没有返回值，void可以用作方法的返回类型，以指示该方法不返回值</td>
</tr>
<tr>
<td style="text-align:left">保留字</td>
<td style="text-align:left">goto</td>
<td style="text-align:center">保留关键字，没有具体含义</td>
</tr>
<tr>
<td style="text-align:left">保留字</td>
<td style="text-align:left">const</td>
<td style="text-align:center">保留关键字，没有具体含义，是一个类型修饰符，使用const声明的对象不能更新</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>所有标识符应该以字母<code>A-Z</code>或<code>a-z</code>、美元符<code>$</code>、或下划线<code>_</code>开始</li>
<li>首字母之后可以是字母、美元符、下划线或数字的组合</li>
<li>标识符是大小写敏感的</li>
<li>可以使用中文命名，但不建议</li>
<li>不能使用关键字作为变量名或方法名</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><blockquote>
<p>强类型语言：强制类型定义，要求变量的使用要严格符合规定，所有变量都必须先定义后才能使用</p>
<p>弱类型语言：类型可以被忽略，一个变量被定义类型，该变量可以根据环境变化自动进行转换，不需要经过显性强制转换</p>
</blockquote>
<p>java的数据类型分为两大类：</p>
<ul>
<li>基本类型</li>
<li>引用类型</li>
</ul>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/img/image-20211229173211924.png" alt="image-20211229173211924"></p>
<blockquote>
<p>注意：long型赋值时要加上L(大写)，float型要加上f或F</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//八大基本数据类型</span></span><br><span class="line">        <span class="comment">//整数</span></span><br><span class="line">        <span class="keyword">byte</span> n1=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> n2=<span class="number">20</span>;</span><br><span class="line">        <span class="keyword">short</span> n3=<span class="number">30</span>;</span><br><span class="line">        <span class="keyword">long</span> n4= <span class="number">30L</span>;</span><br><span class="line">        <span class="comment">//浮点数</span></span><br><span class="line">        <span class="keyword">float</span> n5=<span class="number">40.2F</span>;</span><br><span class="line">        <span class="keyword">double</span> n6=<span class="number">12.44</span>;</span><br><span class="line">        <span class="comment">//字符</span></span><br><span class="line">        <span class="keyword">char</span> n7=<span class="string">&#x27;好&#x27;</span>;</span><br><span class="line">        String n8=<span class="string">&quot;你好&quot;</span>;</span><br><span class="line">        <span class="comment">//布尔值</span></span><br><span class="line">        <span class="keyword">boolean</span> n9=<span class="keyword">true</span>;</span><br><span class="line">        System.out.println(n9);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：八进制要在前面加0，十六进制要加0x，二进制加0b；</p>
<p>尽量不要使用浮点数进行比较，使用BigDecimal类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//整数拓展 进制</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> i1=<span class="number">010</span>; <span class="comment">//八进制</span></span><br><span class="line">        <span class="keyword">int</span> i2=<span class="number">0x10</span>; <span class="comment">//十六进制</span></span><br><span class="line">        <span class="keyword">int</span> i3=<span class="number">0b10</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(i1);</span><br><span class="line">        System.out.println(i2);</span><br><span class="line">        System.out.println(i3);</span><br><span class="line">        <span class="comment">//浮点数拓展</span></span><br><span class="line">        <span class="keyword">float</span> i4=<span class="number">0.1F</span>;</span><br><span class="line">        <span class="keyword">double</span> i5=<span class="number">1.0</span>/<span class="number">10</span>;</span><br><span class="line">        System.out.println(i4==i5);<span class="comment">//false</span></span><br><span class="line">        <span class="keyword">float</span> i6=<span class="number">123344443342342245f</span>;</span><br><span class="line">        <span class="keyword">float</span> i7=i6+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//明显i6!=i7,但float表示的字长有限，i6超出范围，所以会输出true</span></span><br><span class="line">        <span class="comment">//尽量不使用浮点数比较，使用BigDecimal类</span></span><br><span class="line">        System.out.println(i6==i7);<span class="comment">//true</span></span><br><span class="line">        <span class="comment">//字符拓展</span></span><br><span class="line">        <span class="keyword">char</span> a1=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">char</span> a2=<span class="string">&#x27;中&#x27;</span>;</span><br><span class="line">        System.out.println(a1);</span><br><span class="line">        System.out.println((<span class="keyword">int</span>)a1);<span class="comment">//强制转换</span></span><br><span class="line">        System.out.println(a2);</span><br><span class="line">        System.out.println((<span class="keyword">int</span>)a2);<span class="comment">//强制转换</span></span><br><span class="line">        <span class="comment">//所有字符本质还是数字</span></span><br><span class="line">        <span class="comment">//编码 Unicode 2字节 0-65536</span></span><br><span class="line">        <span class="comment">//U0000 UFFFF</span></span><br><span class="line">        <span class="keyword">char</span> a3=<span class="string">&#x27;\u0061&#x27;</span>;</span><br><span class="line">        System.out.println(a3);</span><br><span class="line">        <span class="comment">//转义字符</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hello\tworld&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String sa=<span class="keyword">new</span> String(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        String sb=<span class="keyword">new</span> String(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        System.out.println(sa==sb);<span class="comment">//比较地址</span></span><br><span class="line">        String sc=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        String sd=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        System.out.println(sc==sd);<span class="comment">//比较内存</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//布尔值拓展</span></span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>由于java是强类型语言，所以进行有些计算时需要类型转换。</p>
<p>类型转换分为：</p>
<p>强制类型转换</p>
<p>自动类型转换</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode刷题:135.分发糖果</title>
    <url>/article/b47abe2.html</url>
    <content><![CDATA[<h1 id="LeetCode刷题-135-分发糖果"><a href="#LeetCode刷题-135-分发糖果" class="headerlink" title="LeetCode刷题:135.分发糖果"></a>LeetCode刷题:135.分发糖果</h1><a id="more"></a>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p>
<p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p>
<p>每个孩子至少分配到 1 个糖果。<br>评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。<br>那么这样下来，老师至少需要准备多少颗糖果呢？</p>
<p><strong>示例 1：</strong></p>
<p>输入：[1,0,2]<br>输出：5<br>解释：你可以分别给这三个孩子分发 2、1、2 颗糖果。</p>
<p><strong>示例 2：</strong></p>
<p>输入：[1,2,2]<br>输出：4<br>解释：你可以分别给这三个孩子分发 1、2、1 颗糖果。<br>第三个孩子只得到 1 颗糖果，这已满足上述两个条件。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>把所有孩子的糖果数初始化为1；先从左往右遍历一遍，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的糖果数加1；再从右往左遍历一遍，如果左边孩子的评分比右边的高，且左边孩子当前的糖果数不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加1。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = ratings.size();</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">num</span><span class="params">(size, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ratings[i] &gt; ratings[i<span class="number">-1</span>]) &#123;</span><br><span class="line">    num[i] = num[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ratings[i] &lt; ratings[i<span class="number">-1</span>]) &#123;</span><br><span class="line">    num[i<span class="number">-1</span>] = max(num[i<span class="number">-1</span>], num[i] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> accumulate(num.begin(), num.end(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Kail Linux虚拟机安装配置Nessus漏洞扫描器</title>
    <url>/article/57445.html</url>
    <content><![CDATA[<h1 id="Kail-Linux虚拟机安装配置Nessus漏洞扫描器"><a href="#Kail-Linux虚拟机安装配置Nessus漏洞扫描器" class="headerlink" title="Kail Linux虚拟机安装配置Nessus漏洞扫描器"></a>Kail Linux虚拟机安装配置Nessus漏洞扫描器</h1><a id="more"></a>
<h2 id="1-获取激活码"><a href="#1-获取激活码" class="headerlink" title="1.获取激活码"></a>1.获取激活码</h2><p>前往<a href="https://www.tenable.com/products/nessus/nessus-essentials">官网</a>进行注册</p>
<p><img src="https://i.loli.net/2021/01/26/HVptOeBDnJZlF6w.png" alt=""></p>
<h2 id="2-下载nessus"><a href="#2-下载nessus" class="headerlink" title="2.下载nessus"></a>2.下载nessus</h2><p>注册完毕后前往下载页面</p>
<p><img src="https://i.loli.net/2021/01/26/SaI7x2nDEHRfMOu.png" alt=""></p>
<p>选择deb结尾的(我选择的64位)</p>
<p><img src="https://i.loli.net/2021/01/26/hPzGvds7T2bXirE.png" alt=""></p>
<p>官网下载较慢,这里我准备了一份,<a href="https://idefun.lanzous.com/iQnR4kvm5oh">点击下载</a></p>
<h2 id="3-安装nessus"><a href="#3-安装nessus" class="headerlink" title="3.安装nessus"></a>3.安装nessus</h2><p>将nessus拖入kail linux虚拟机</p>
<p><img src="https://i.loli.net/2021/01/26/Mca54FXCQuY6x7p.png" alt=""></p>
<p>打开终端,切换至桌面</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd 桌面</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/26/ekf7ri8R54ZuwDW.png" alt=""></p>
<p>安装nessus(需要密码)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i Nessus-8.13.1-debian6_amd64.deb</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/26/hYk1gFqJplIuQw9.png" alt=""></p>
<p>安装完成</p>
<p><img src="https://i.loli.net/2021/01/26/KWfAuHosZB7vJ1F.png" alt=""></p>
<h2 id="4-启动nessus"><a href="#4-启动nessus" class="headerlink" title="4.启动nessus"></a>4.启动nessus</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/bin/systemctl start nessusd.service</span><br></pre></td></tr></table></figure>
<p>同样需要密码</p>
<p><img src="https://i.loli.net/2021/01/26/1Wjf7rMiImHSk4A.png"  /></p>
<p>在浏览器中访问</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">https://kali:8834/</span><br></pre></td></tr></table></figure>
<p>选择Managed Scanner</p>
<p><img src="https://i.loli.net/2021/01/26/Y9wajpE7ye1JhVv.png" alt=""></p>
<p>选择Tenable.sc</p>
<p><img src="https://i.loli.net/2021/01/26/ONiI4T2EJeylcZ5.png" alt=""></p>
<p>创建账号</p>
<p><img src="https://i.loli.net/2021/01/26/1KLS8misZR7DVCI.png" alt=""></p>
]]></content>
      <categories>
        <category>Hack</category>
      </categories>
      <tags>
        <tag>Nessus</tag>
        <tag>Kail</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题:455.分发饼干</title>
    <url>/article/4d94effd.html</url>
    <content><![CDATA[<h1 id="LeetCode刷题-455-分发饼干"><a href="#LeetCode刷题-455-分发饼干" class="headerlink" title="LeetCode刷题:455.分发饼干"></a>LeetCode刷题:455.分发饼干</h1><a id="more"></a>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<p><strong>示例 1:</strong></p>
<p>输入: g = [1,2,3], s = [1,1]<br>输出: 1<br>解释:<br>你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。<br>虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。<br>所以你应该输出1。<br><strong>示例 2:</strong></p>
<p>输入: g = [1,2], s = [1,2,3]<br>输出: 2<br>解释:<br>你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。<br>你拥有的饼干数量和尺寸都足以让所有孩子满足。<br>所以你应该输出2.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为饥饿度最小的孩子最容易吃饱，所以我们先考虑这个孩子。为了尽量使得剩下的饼干可以满足饥饿度更大的孩子，所以我们应该把大于等于这个孩子饥饿度的、且大小最小的饼干给这个孩子。满足了这个孩子之后，我们采取同样的策略，考虑剩下孩子里饥饿度最小的孩子，直到没有满足条件的饼干存在。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; g, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        sort(g.begin(),g.end());</span><br><span class="line">        sort(s.begin(),s.end());</span><br><span class="line">        <span class="keyword">while</span>(i&lt;g.size()&amp;&amp;j&lt;s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[i]&lt;=s[j])i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题:435.无重叠区间</title>
    <url>/article/4886200.html</url>
    <content><![CDATA[<h1 id="LeetCode刷题-435-无重叠区间"><a href="#LeetCode刷题-435-无重叠区间" class="headerlink" title="LeetCode刷题:435.无重叠区间"></a>LeetCode刷题:435.无重叠区间</h1><a id="more"></a>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>
<p>注意:</p>
<p>可以认为区间的终点总是大于它的起点。<br>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</p>
<p><strong>示例 1:</strong></p>
<p>输入: [ [1,2], [2,3], [3,4], [1,3] ]</p>
<p>输出: 1</p>
<p>解释: 移除 [1,3] 后，剩下的区间没有重叠。</p>
<p><strong>示例 2:</strong></p>
<p>输入: [ [1,2], [1,2], [1,2] ]</p>
<p>输出: 2</p>
<p>解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</p>
<p><strong>示例 3:</strong></p>
<p>输入: [ [1,2], [2,3] ]</p>
<p>输出: 0</p>
<p>解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在选择要保留区间时，区间的结尾十分重要：选择的区间结尾越小，余留给其它区间的空间就越大，就越能保留更多的区间。因此，我们采取的贪心策略为，优先保留结尾小且不相交的区间。<br>具体实现方法为，先把区间按照结尾的大小进行增序排序，每次选择结尾最小且和前一个选<br>择的区间不重叠的区间。我们这里使用C++ 的Lambda，结合std::sort() 函数进行自定义排序。</p>
<p>需要根据实际情况判断按区间开头排序还是按区间结尾排序。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        if (intervals.empty()) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n &#x3D; intervals.size();</span><br><span class="line">        sort(intervals.begin(), intervals.end(), [](vector&lt;int&gt; a, vector&lt;int&gt; b) &#123;</span><br><span class="line">        return a[1] &lt; b[1];</span><br><span class="line">        &#125;);</span><br><span class="line">        int total &#x3D; 0, prev &#x3D; intervals[0][1];</span><br><span class="line">        for (int i &#x3D; 1; i &lt; n; ++i) &#123;</span><br><span class="line">        if (intervals[i][0] &lt; prev) &#123;</span><br><span class="line">        ++total;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        prev &#x3D; intervals[i][1];</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题:605.种花问题</title>
    <url>/article/d4783519.html</url>
    <content><![CDATA[<h1 id="LeetCode刷题-605-种花问题"><a href="#LeetCode刷题-605-种花问题" class="headerlink" title="LeetCode刷题:605.种花问题"></a>LeetCode刷题:605.种花问题</h1><a id="more"></a>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p>
<p>给你一个整数数组  flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false。</p>
<p><strong>示例 1：</strong></p>
<p>输入：flowerbed = [1,0,0,0,1], n = 1<br>输出：true</p>
<p><strong>示例 2：</strong></p>
<p>输入：flowerbed = [1,0,0,0,1], n = 2<br>输出：false</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux C编程</title>
    <url>/article/34877.html</url>
    <content><![CDATA[<h1 id="Linux-C编程"><a href="#Linux-C编程" class="headerlink" title="Linux C编程"></a>Linux C编程</h1><p>C语言的源代码文件是一个普通的文本文件,但扩展名是c.而且源代码文件是不能直接执行的,需要编译,编译后的可执行文件只能在指定操作系统下运行.</p>
<p>Linux编译后的可执行程序只能在linux运行,windows编译后的程序只能在windows下运行</p>
<p>64位的linux编译后的程序只能在64位linux下运行,32位linux编译后的程序只能在32位的linux运行.</p>
<p>64位的windows编译后的程序只能在64位windows下运行,32位windows编译后的程序可以在64位的windows运行.</p>
<h2 id="头文件包含"><a href="#头文件包含" class="headerlink" title="头文件包含"></a>头文件包含</h2><p>include有两种写法</p>
<p>#include &lt;文件名&gt;,如果文件在系统目录下,那么需要用&lt;&gt;</p>
<p>#include “文件名”,如果文件在当前目录下，那么用””</p>
<h2 id="System系统调用"><a href="#System系统调用" class="headerlink" title="System系统调用"></a>System系统调用</h2><p>在使用system之前需要包含stdlib.h这个头文件,system主要的功能是通过程序执行另外一个程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">system(<span class="string">&quot;命令&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>如果在命令行执行一个程序，那么这个程序的调用者就是操作系统，如果在代码中通过system执行一个程序，那么这个程序的调用者就是自己写的代码本身.</p>
<p>C语言所有的库函数调用，只能保证语法是一致的，但不能保证执行结果是一致的，同样的库函数在不同的操作系统下执行结果可能是一样的，也可能是不一样的。</p>
<h2 id="POSIX标准"><a href="#POSIX标准" class="headerlink" title="POSIX标准"></a>POSIX标准</h2><p>POSIX是一个标准，只要符合这个标准的函数，在不同的系统下执行的结果就可以一致。</p>
<p>Unix和Linux很多库函数都是支持POSIX的，但windows支持的比较差。</p>
<p>如果将unix代码移植到linux一般代价很小，如果把windows代码移植到unix或者linux就比较麻烦.</p>
<h2 id="C语言处理过程"><a href="#C语言处理过程" class="headerlink" title="C语言处理过程"></a>C语言处理过程</h2><p>C代码编译成可执行程序经过4步:<br>1)预处理:宏定义展开、头文件展开、条件编译等，同时将代码中的注释删除，这里并不会检查语法<br>2)编译:检查语法，将预处理后文件编译生成汇编文件<br>3)汇编:将汇编文件生成目标文件(二进制文件)<br>4)链接: C语言写的程序是需要依赖各种库的，所以编译之后还需要把库链接到最终的可执行程序中去</p>
<p>预处理:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure>
<p>编译:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure>
<p>汇编:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure>
<p>链接:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc hello.o -o hello</span><br></pre></td></tr></table></figure>
<p>查看程序所需动态库:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ldd hello   //linux</span><br></pre></td></tr></table></figure>
<p>交换文件说明:<br>1) vi写文件，没有保存就关闭，自动生成一个后缀为. swp交换文件， 保存了之前写的内容<br>2)先恢复，再删除.swp交换文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi -r &#123;your file name&#125; //恢复</span><br><span class="line">rm &#123;your file name&#125;.swp   //删除</span><br></pre></td></tr></table></figure>
<h2 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h2><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p><strong>C的关键字共有32个</strong></p>
<ul>
<li><p>数据类型关键字(12个)</p>
<p>char, short, int, long, float, double,unsigned, signed, struct, union, enum, void</p>
</li>
<li><p>控制语句关键字(12个)</p>
<p>if, else, switch, case, default,for , do, while, break, continue, goto, return</p>
</li>
<li><p>存储类关键字(5个)</p>
<p>auto,extern,register, static,const</p>
</li>
<li><p>其他关键字(3个)</p>
<p>sizeof, typedef, volatile</p>
</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>数据类型的作用:编译器预算对象(变量)分配的内存空间大小</p>
<p><img src="https://i.loli.net/2021/01/11/JgoTpVBjXIPWQLD.png" alt="image-20210111193755278"></p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul>
<li>在程序运行过程中，其值不能被改变的量</li>
<li>常量一般出现在表达式或赋值语句中</li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul>
<li>在程序运行过程中，其值可以改变</li>
<li>变量在使用前必须先定义，定义变量前必须有相应的数据类型</li>
</ul>
<p>标识符命名规则:</p>
<ul>
<li><p>标识符不能是关键字</p>
</li>
<li><p>标识符只能由字母、数字、下划线组成</p>
</li>
<li>第一个字符必须为字母或下划线</li>
<li>标识符中字母区分大小写</li>
</ul>
<p>变量特点:</p>
<ul>
<li>变量在编译时为其分配相应的内存空间</li>
<li>可以通过其名字和地址访问相应内存</li>
</ul>
<p>声明和定义区别:</p>
<ul>
<li>声明变量不需要建立存储空间，如: extern int a;(a不能赋值)</li>
<li>定义变量需要建立存储空间，如: int b;</li>
<li>-般的情况下，把建立存储空间的声明称之为“定义”，而把不需要建立存储空间的声明称之为”声明”.</li>
</ul>
<h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h3><h4 id="C语言如何表示相应的进制数"><a href="#C语言如何表示相应的进制数" class="headerlink" title="C语言如何表示相应的进制数"></a>C语言如何表示相应的进制数</h4><div class="table-container">
<table>
<thead>
<tr>
<th>十进制</th>
<th>以正常数字1-9开头,如123</th>
</tr>
</thead>
<tbody>
<tr>
<td>八进制</td>
<td>以0(零)开头,如0123</td>
</tr>
<tr>
<td>十六进制</td>
<td>以0x开头,如0x123</td>
</tr>
<tr>
<td>二进制</td>
<td>C语言不能直接书写二进制数</td>
</tr>
</tbody>
</table>
</div>
<h3 id="计算机内存数值存储方式"><a href="#计算机内存数值存储方式" class="headerlink" title="计算机内存数值存储方式"></a>计算机内存数值存储方式</h3><p>在计算机系统中，数值一律用补码来存储。</p>
<h4 id="原码"><a href="#原码" class="headerlink" title="原码:"></a>原码:</h4><p>最高位为符号位:0代表正数,1代表负数​</p>
<p>原码存储导致2个问题:</p>
<ol>
<li>0有两种存储方式</li>
<li>正数和负数相加结果不正确</li>
</ol>
<h4 id="反码"><a href="#反码" class="headerlink" title="反码:"></a>反码:</h4><p>反码是为了算补码.正数的原码和反码是一样的,负数的反码在原码基础上,符号位不变,其它位取反(0为1,1变0 ).</p>
<p>反码存储导致1个问题:</p>
<ol>
<li>0有两种存储方式</li>
</ol>
<h4 id="补码"><a href="#补码" class="headerlink" title="补码:"></a>补码:</h4><p>正数的原码,反码,补码都一样</p>
<p>负数的补码为其反码加1</p>
<p>十进制数,站在用户角度看,<strong>原码</strong>;二进制,八进制,十六进制,要站在计算机角度看,<strong>补码</strong>.</p>
<p>原码求补码:</p>
<ol>
<li>正数原,反,补码均相同</li>
<li>负数原码最高位不变,其他位取反得反码</li>
<li>反码加1得补码</li>
</ol>
<p>补码求原码(同上面类似):</p>
<ol>
<li>正数原,反,补码均相同</li>
<li>负数补码最高位不变,其他位取反得反码</li>
<li>反码加1得原码</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> a=<span class="number">0x81</span>;<span class="comment">//a是值为十六进制数的字符,在计算机看来是补码</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);<span class="comment">//%d为输出十进制数,在用户看来是原码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序运行结果如下:</p>
<p><img src="https://i.loli.net/2021/01/12/l23jvtQaPwTHyWG.png" alt=""></p>
<p>按照十六进制转十进制,0x81等于129而不是-127</p>
<p>分析:</p>
<ol>
<li>0x81在计算机角度看来应为补码存储,其二进制形式为10000001</li>
<li>输出%d即输出十进制数,十进制数在用户角度为原码</li>
<li>由(1)(2)知,该程序即将0x81的补码转换为原码</li>
<li>其原码为11111111,即-127</li>
</ol>
<p>有符号和无符号的区别:</p>
<ul>
<li>%d,默认以有符号的方式打印</li>
<li>%u,默认以无符号的方式打印</li>
<li>有符号，最高位是符号位，如果是1代表为负数，如果为0代表为正数</li>
<li>无符号，最高位不是符号位，是数的一部分，无符号不可能是负数</li>
</ul>
<p>数据类型范围:</p>
<p>char    1个字节</p>
<p><img src="https://i.loli.net/2021/01/12/UNxsfOjRD2cu9eY.png" alt="image-20210112214358475" style="zoom:80%;" /></p>
<p>数值越界:</p>
<p>通过以下代码解释</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">//情况1 有符号</span></span><br><span class="line">        <span class="comment">//char 范围 -128~127</span></span><br><span class="line">        <span class="keyword">char</span> a=<span class="number">127</span>+<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/* a=129,转换二进制为1000 0001,</span></span><br><span class="line"><span class="comment">          二进制(1000 0001)以补码形式存储,</span></span><br><span class="line"><span class="comment">          输出为%d,要求得原码(11111111),</span></span><br><span class="line"><span class="comment">          即-127</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);<span class="comment">//输出-127</span></span><br><span class="line">        <span class="comment">//情况2 无符号</span></span><br><span class="line">        <span class="comment">//无符号 范围 0~255</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> b=<span class="number">255</span>+<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/* b=257,转换二进制为1 0000 0001,</span></span><br><span class="line"><span class="comment">           舍弃最高位为0000 0001,</span></span><br><span class="line"><span class="comment">           二进制(0000 0001)以补码形式存储,</span></span><br><span class="line"><span class="comment">           转为原码(0000 0001),</span></span><br><span class="line"><span class="comment">           即1</span></span><br><span class="line"><span class="comment">           注意编译时会警告,之后./文件名运行即可</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>,b);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下:</p>
<p><img src="https://i.loli.net/2021/01/13/GL8cpTQzUtFu7n1.png" alt="image-20210113191321188"></p>
<h4 id="sizeof关键字"><a href="#sizeof关键字" class="headerlink" title="sizeof关键字"></a>sizeof关键字</h4><ul>
<li>sizeof不是函数，所以不需要包含任何头文件，它的功能是计算一个数据类型的大小，单位为字节</li>
<li>sizeof的返回值为size_ t</li>
<li>size_t 类型在32位操作系统下是unsigned int,是一个无符号的整数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*数据类型的作用:告诉编译器,</span></span><br><span class="line"><span class="comment">    定义此类型变量需要分配多大空间*/</span>					<span class="built_in">printf</span>(<span class="string">&quot;sizeof(char)=%lu\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">   	<span class="built_in">printf</span>(<span class="string">&quot;sizeof(a)=%lu\n&quot;</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下:</p>
<p><img src="https://i.loli.net/2021/01/13/3VmSN7iDcPkwLsY.png" style="zoom:150%;" /></p>
<p>%d,%o,%x,%u等均以四个字节形式打印.</p>
<p>short占两个字节,short a;与short int a;等价.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据类型</th>
<th>占用空间</th>
</tr>
</thead>
<tbody>
<tr>
<td>short (短整型)</td>
<td>2字节</td>
</tr>
<tr>
<td>int (整型)</td>
<td>4字节</td>
</tr>
<tr>
<td>1ong(长整形)</td>
<td>Windows为4字节，Linux为 4字节(32位)，8字节(64位)</td>
</tr>
<tr>
<td>long long (长长整形)</td>
<td>8字节</td>
</tr>
</tbody>
</table>
</div>
<h3 id="字符型变量"><a href="#字符型变量" class="headerlink" title="字符型变量"></a>字符型变量</h3><p>字符型变量用于存储一个单一字符，在C语言中用char 表示，其中每个字符变量都会占用1个字节。在给字符型变量赋值时，需要用一对英文半角格式的单引号(‘ ‘)把字符括起来。<br>字符变量实际上并不是把该字符本身放到变量的内存单元中去，而是将该字符对应的ASCII 编码放到变量的存储单元中。char 的本质就是一个1 字节大小的整型。</p>
<p>使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man ascii</span><br></pre></td></tr></table></figure>
<p>查看ASCII码</p>
<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>字符在单引号内,原则上’ ‘内部只有一个字符,转义字符除外,不能char a=’abc’</p>
<p>转义字符由反斜杠\组成的多个字符</p>
<p>例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> a=<span class="string">&#x27;\r&#x27;</span>;<span class="comment">//光标移到句首</span></span><br><span class="line">        <span class="keyword">char</span> b=<span class="string">&#x27;\b&#x27;</span>;<span class="comment">//退格</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;12345%c6789\n&quot;</span>,a);<span class="comment">//先打印12345,之后光标移到句首再依次打印6789,其中1234被覆盖,留下5,结果为67895</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;abcde%cfghi\n&quot;</span>,b);<span class="comment">//先打印abcde之后打印\b,退一格,e就没了,结果为abcdfghi</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/22/wYUVzd2mpNqX3LQ.png" alt=""></p>
<h3 id="浮点型-实型"><a href="#浮点型-实型" class="headerlink" title="浮点型(实型)"></a>浮点型(实型)</h3><p>实型变量也可以称为浮点型变量，浮点型变量是用来存储小数数值的。在C语言中，浮点型变量分为两种:单精度浮点数(float)、双精度浮点数(double)，但是double型变量所表示的浮点数比float 型变量更精确。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据类型</th>
<th>占用空间</th>
<th>有效数字范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>float</td>
<td>4字节</td>
<td>7位有效数字</td>
</tr>
<tr>
<td>double</td>
<td>8字节</td>
<td>15~ 16位有效数字</td>
</tr>
</tbody>
</table>
</div>
<p>float存储不准确</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">float</span> a=<span class="number">100.9</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,a);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/22/pT1JRNYS97IyjM4.png" alt=""></p>
<h3 id="类型限定符"><a href="#类型限定符" class="headerlink" title="类型限定符"></a>类型限定符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>限定符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>extern</td>
<td>声明一个变量，extexn 声明的变量没有建立存储空间。extern int a;</td>
</tr>
<tr>
<td>const</td>
<td>定义一个常量，常量的值不能修改。const int a 10;</td>
</tr>
<tr>
<td>vo1atile</td>
<td>防止编译器优化代码</td>
</tr>
<tr>
<td>register</td>
<td>定义寄存器变量，提高效率。 register是建议型的指令，而不是命令型的指令，如果CPU有空闲寄存器，那么register就生效， 如果没有空闲寄存器，那么register无效。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>字符串常量与字符常量的不同:<br>‘a’为字符常量，”a”为字符串常量</p>
<p><img src="https://i.loli.net/2021/01/22/hAXpsqiEMktCuyn.png" alt="image-20210113191321188"></p>
<p>每个字符串的结尾，编译器会自动的添加一一个结束标志位’\0’,即”a” 包含<br>两个字符’a’和’\0’。</p>
<p>%%在屏幕输出一个%，后面的d也会输出</p>
<p>%5d,以5个字符输出,没有的字符以空字符填充,默认是右对齐</p>
<p>%05d,以5个字符输出,没有的字符以0填充,默认是右对齐</p>
<p>%-5d,以5个字符输出,没有的字符以空字符填充,-代表指定为左对齐</p>
<p>0和-不能同时使用</p>
<p><img src="https://i.loli.net/2021/01/22/ts6idzBZGxWJveY.png" alt=""></p>
<h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><blockquote>
<p>遇到”\0”停止</p>
</blockquote>
<h3 id="puts"><a href="#puts" class="headerlink" title="puts()"></a>puts()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[]=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">puts</span>(buf);<span class="comment">//把buf内容输出到屏幕,自动在屏幕加换行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);<span class="comment">//没有加换行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/29/u4frlgbByp9IMoT.png" alt=""></p>
<h3 id="fputs"><a href="#fputs" class="headerlink" title="fputs()"></a>fputs()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[]=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="comment">//向stdout(代表屏幕,标准输出)输出buf的内容</span></span><br><span class="line">    <span class="built_in">fputs</span>(buf,<span class="built_in">stdout</span>);<span class="comment">//没有加换行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/29/r64eO1HkSZt9JXd.png" alt="image-20210129141616052"></p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><h3 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h3><p>scanf()的缺陷，不做越界检查,不允许有空格</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入字符串:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%s\n&quot;</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/29/foM25d9lpc8aQUR.png" alt=""></p>
<h3 id="gets"><a href="#gets" class="headerlink" title="gets()"></a>gets()</h3><p>gets()从键盘读取字符串，放在指定的数组<br>gets()允许有空格，不做越界检查，此函数不安全</p>
<h3 id="fgets"><a href="#fgets" class="headerlink" title="fgets()"></a>fgets()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">//从stdin(代表标准输入,键盘)读取内容</span></span><br><span class="line">        <span class="comment">/*如果输入内容大于sizeof(buf)-1,只取	</span></span><br><span class="line"><span class="comment">        sizeof(buf)-1,放在buf所在数组;</span></span><br><span class="line"><span class="comment">        当不足sizeof(buf)-1,会把换行符读进去*/</span></span><br><span class="line">        fgets(buf,<span class="keyword">sizeof</span>(buf),<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buf=%s\n&quot;</span>,buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/29/qgh4QbsSC7MvWfd.png" alt=""></p>
<p>fgets()允许有空格</p>
<p><img src="https://i.loli.net/2021/01/29/6vIXpuY7SQeEKUM.png" alt=""></p>
<p>当不足sizeof(buf)-1,会把换行符读进去</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    fgets(buf,<span class="keyword">sizeof</span>(buf),<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf=#%s#\n&quot;</span>,buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/29/3gJLWmkOlP8fQKI.png" alt=""></p>
<h3 id="输入字符"><a href="#输入字符" class="headerlink" title="输入字符"></a>输入字符</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入字符:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;a);<span class="comment">//假设输入c</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a=&#x27;%c&#x27;\n&quot;</span>,a);</span><br><span class="line">        <span class="keyword">char</span> b;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入字符:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;b);<span class="comment">//假设输入d</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;b=&#x27;%c&#x27;\n&quot;</span>,b);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个程序看似简单,结果为a=c,b=d,其实不然,结果如下:</p>
<p><img src="https://i.loli.net/2021/01/22/itzxmayI15d6uqO.png" alt=""></p>
<p>无需输入d直接出结果</p>
<p>原因:</p>
<p>当用户输入字符时,编译器默认把输入的内容先放在一块内存中(缓冲区) , scanf()自动在缓冲区读内容(只读一个字符).第一次输入时输入了c\n(回车),scanf取走了c,留下\n还在缓存区,第2次scanf ,由于缓冲区还有内容,所以直接取内容,无需再输入</p>
<p>所以,上面的程序可以这样写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入字符:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;a);<span class="comment">//假设输入c</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a=&#x27;%c&#x27;\n&quot;</span>,a);</span><br><span class="line">        <span class="comment">//吃掉上一步的\n,不做处理</span></span><br><span class="line">        <span class="keyword">char</span> b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;b);</span><br><span class="line">        <span class="keyword">char</span> t;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入字符:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;t);<span class="comment">//假设输入d</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;t=&#x27;%c&#x27;\n&quot;</span>,t);</span><br><span class="line">    	<span class="comment">//或者都在一个scanf中写</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输入字符串"><a href="#输入字符串" class="headerlink" title="输入字符串"></a>输入字符串</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入字符串a:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);<span class="comment">//假设输入hello world</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%s\n&quot;</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入字符串b:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b=%s\n&quot;</span>,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下:</p>
<p><img src="https://i.loli.net/2021/01/29/OUtFhK74fAaNsj5.png" alt=""></p>
<p>原因:</p>
<p>当输入hello world时,第一个scanf取走第一个空格前的字符串,即hello;第二个scanf取第一个空格后第二个空格前的内容,\\n不取</p>
<p>switch语句</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">        <span class="comment">//1、switch是关键字， switch() 后面没有分号</span></span><br><span class="line">        <span class="comment">//2、switch()中() 里只能放整型变量或字符型变量</span></span><br><span class="line">        <span class="keyword">switch</span>(num)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;1楼\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;2楼\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;3楼\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;其他楼层\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>goto语句</p>
<p>goto(只能跳转到同一作用域)任意地方都能使用,无条件跳转,不能滥用,代码会很乱</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">goto</span> hello;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1111111111\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2222222222\n&quot;</span>);</span><br><span class="line">        hello:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;3333333333\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/28/fNUX46T5h1YqSc9.png" alt="image-20210122205440917" style="zoom:150%;" /></p>
<p>类型转换:</p>
<p>1.隐式转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> a;</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//编译器自动转换，把b转 换为double类型后， 再给a赋值(隐式转换)</span></span><br><span class="line">a= b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>，b) ;</span><br></pre></td></tr></table></figure>
<p>2.强制类型转换  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="comment">//a只有在此语句执行时，才强制转换为double类型，其它地址还是为int类型</span></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%lf\n&quot;</span>，(<span class="keyword">double</span>)a) ;<span class="comment">//(类型)变量名</span></span><br></pre></td></tr></table></figure>
<p>转换原则:占用内存字节数少(值域小)的类型，向占用内存字节数多(值域大)的类型转换，以保证精度不降低。</p>
<p>3.浮点型和整型打印问题<br>a)不要直接通过%d，打印一个浮点型变量，得不到想要的结果，要想得到结果，强制类型转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> a = <span class="number">11.11</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(<span class="keyword">int</span>)a) ;</span><br></pre></td></tr></table></figure>
<p>b)不要直接通过%f或%lf，打印一个整型变量，得不到想要的结果，要想得到结果，强制类型转换</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol>
<li>数组内部的变量或数组,不初始化,它的值为随机数</li>
<li>部分初始化，其它自动初始化为0<br>0~2(前3个元素)分别为1，2， 3， 其 它初始化为0<br>int a1[10] = {1, 2, 3};</li>
<li>数组全部元素初始化为0<br>int a2[10] = {0} ;</li>
<li>如果定义时同时初始化，第1个[]内部可以不写内容<br>编译器会根据用户初始化的元素来确定数组的大小<br>int a3[]={1,2,3,4,5,6,7,8,9,10};</li>
<li>如果第1个[]内容不写，必须初始化，否则语法错误</li>
</ol>
<h3 id="数组名"><a href="#数组名" class="headerlink" title="数组名"></a>数组名</h3><ul>
<li>数组名是常量,不能修改</li>
<li>数组名是数组首元素地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a=%p,&amp;a[0]=%p\n&quot;</span>,a,&amp;a[<span class="number">0</span>]);<span class="comment">//%p输出地址</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sizeof(a)=%lu\n&quot;</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/23/EFTYRgCKmLP263d.png" alt=""></p>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>内存中没有多维,只有一维,多维数组是特殊的一维数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果定义时，同时初始化，第1个[]可以不写内容</span></span><br><span class="line"><span class="keyword">int</span> a1[][<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;<span class="comment">//正确</span></span><br><span class="line"><span class="comment">//如果第1个[]不写，必须初始化</span></span><br><span class="line"><span class="keyword">int</span> a3[][<span class="number">4</span>]; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3><ol>
<li>C语言没有字符串类型,用字符数组模拟</li>
<li>字符串一定是字符数组,字符数组就不一定是字符串</li>
<li>如果字符数组以字符’\0’ (‘\0’等级于数字0)结尾,那么这个字符数组就是字符串</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、C语言没有字符串类型，用字符数组模拟</span></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//2、字符串一定是字符数组，字符数组就不一定是字符串</span></span><br><span class="line"><span class="comment">//3、如果字符数组以字符&#x27;\0&#x27;(&#x27;\0&#x27;等级于数字0)结尾，那么这个字符数组就是字符串</span></span><br><span class="line"><span class="keyword">char</span> b[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;; <span class="comment">//字符数组,方括号中不能填数字,否则会自动补零,就变成字符串</span></span><br><span class="line"><span class="keyword">char</span> c[<span class="number">10</span>] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;; <span class="comment">//字符串</span></span><br><span class="line"><span class="keyword">char</span> d[<span class="number">10</span>] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="number">0</span>&#125;; <span class="comment">//字符串</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[]=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%s\n&quot;</span>,a);<span class="comment">//会乱码,没有结束符</span></span><br><span class="line">    <span class="keyword">char</span> b[]=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b=%s\n&quot;</span>,b);<span class="comment">//输出abc,遇到\0就停止</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/27/Re83qQAwDB7K42Y.png" alt=""></p>
<p>字符数组初始化(常用)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>]=<span class="string">&quot;abcde&quot;</span>;<span class="comment">//最多写9个字符,留一个放结束符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%s\n&quot;</span>,a);</span><br><span class="line"><span class="keyword">char</span> b[]=<span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b=%s\n&quot;</span>,b);<span class="comment">//sizeof()测数据类型大小，不会因为结束符提前结束</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(b)=%lu\n&quot;</span>,<span class="keyword">sizeof</span>(b));<span class="comment">//输出6,b这个数组有5个字符,会自动补加结束符(隐藏)</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/27/iDy86UJt1X2r3ZK.png" alt=""></p>
<p>\0后面最好不要跟数字,有可能组成转义字符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[]=<span class="string">&quot;\0abc&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%s\n&quot;</span>,a);<span class="comment">//输出为空,含有结束符\0</span></span><br><span class="line">    <span class="keyword">char</span> b[]=<span class="string">&quot;\0417abcde&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b=%s\n&quot;</span>,b);<span class="comment">//输出非空,\0与其后数字组成转义字符\041,通过man ascii命令查到\041对应!(感叹号)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/27/VJXSilNmnR6wyhB.png" alt=""></p>
<p>函数的调用:产生随机数</p>
<p>当调用函数时，需要关心5要素:</p>
<ul>
<li>头文件:包含指定的头文件</li>
<li>函数名字:函数名字必须和头文件声明的名字一样</li>
<li>功能:需要知道此函数功能后再调用</li>
<li>参数:参数类型要匹配</li>
<li>返回值:根据需要接收返回值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;//产生随机数的函数包含在此</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;//获取当前系统时间的函数包含在此</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">//先设置种子,种子设置一次即可</span></span><br><span class="line">        <span class="comment">//srand(10);</span></span><br><span class="line">        <span class="comment">/*如果srand()参数一样,则每次产生的随机数一样,</span></span><br><span class="line"><span class="comment">        每次启动计算机以后，种子就是定值了，</span></span><br><span class="line"><span class="comment">        所以根据公式推算出来的结果</span></span><br><span class="line"><span class="comment">        （也就是生成的随机数）就是固定的*/</span></span><br><span class="line">        <span class="comment">/*time(NULL)用来获取系统当前时间,</span></span><br><span class="line"><span class="comment">        由于时间会变,srand()也会改变*/</span></span><br><span class="line">        srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">                num=rand();<span class="comment">//rand()产生随机数</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;num=%d\n&quot;</span>,num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/27/lTzVDuG41P6RUr7.png" alt=""></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h3><blockquote>
<p>strlen需要使用返回值,返回值就是字符串的长度,从首元素开始,到结束符为止的长度,结束符不算(遇到’\0’结束)</p>
</blockquote>
<h3 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h3><blockquote>
<p>拷贝原理:从首元素开始,到结束符(\0)为止的长度</p>
</blockquote>
<h3 id="strncpy"><a href="#strncpy" class="headerlink" title="strncpy"></a>strncpy</h3><blockquote>
<p>可以把”\0”拷贝过去,但是”\0”后面的就不能了</p>
</blockquote>
]]></content>
      <categories>
        <category>C&amp;C++</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习笔记</title>
    <url>/article/34487.html</url>
    <content><![CDATA[<h1 id="Linux学习笔记"><a href="#Linux学习笔记" class="headerlink" title="Linux学习笔记"></a>Linux学习笔记</h1><a id="more"></a>
<h2 id="Linux注意事项"><a href="#Linux注意事项" class="headerlink" title="Linux注意事项"></a>Linux注意事项</h2><p>Ctrl+a  快速回到行首</p>
<p>Ctrl+e  快速回到行末</p>
<p>Linux严格区分大小写.</p>
<p>Linux中所有内容以文件形式保存，包括硬件</p>
<ul>
<li>硬盘文件是/dev/sd[a-p]</li>
<li>光盘文件是/dev/sr0</li>
</ul>
<p>Linux不靠扩展名区分文件类型(扩展名便于用户使用),靠文件权限</p>
<ul>
<li>压缩包: “*.gz”、”*.bz2”、”*.tar.bz2”、”*.tgz”等</li>
<li>二进制软件包: “*.rpm”</li>
<li>网页文件: “*.html”、”*.php”</li>
<li>脚本文件: “*.sh”</li>
<li>配置文件: “*.conf”</li>
</ul>
<p>Linux所有的存储设备都必须挂载,之后用户才能使用,包括硬盘、U盘和光盘</p>
<p>Windows下的程序不能直接在Iinux中安装和运行</p>
<h2 id="服务器管理和维护"><a href="#服务器管理和维护" class="headerlink" title="服务器管理和维护"></a>服务器管理和维护</h2><h3 id="目录及作用"><a href="#目录及作用" class="headerlink" title="目录及作用"></a>目录及作用</h3><div class="table-container">
<table>
<thead>
<tr>
<th>目录名</th>
<th>目录作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>/bin/</td>
<td>存放系统命令的目录，普通用户和超级用户都可以执行。不过放在/bin下的命令在单用户模式下也可以执行</td>
</tr>
<tr>
<td>/sbin/</td>
<td>保存和系统环境设置相关的命令，只有超级用户可以使用这些命令进行系统环境设置，但是有些命令可以允许普通用户查看</td>
</tr>
<tr>
<td>/usr/bin/</td>
<td>存放系统命令的目录，普通用户和超级用户都可以执行。这些命令和系统启动无关，在单用户模式下不能执行</td>
</tr>
<tr>
<td>/usr/sbin/</td>
<td>存放根文件系统不必要的系统管理命令，例如多数服务程序。只有超级用户可以使用。大家其实可以注意到Linux的系统，在所有“sbin” 目录中保存的命令只有超级用户可以使用，“bin”目录中保存的命令所有用户都可以使用</td>
</tr>
<tr>
<td>/boot/</td>
<td>系统启动目录，保存系统启动相关的文件，如内核文件和启动引导程序( grub)文件等</td>
</tr>
<tr>
<td>/dev/</td>
<td>设备文件保存位置。我们已经说过Linux中所有内容以文件形式保存，包括硬件。那么这个目录就是用来保存所有硬件设备文件的</td>
</tr>
<tr>
<td>/etc/</td>
<td>配置文件保存位置。系统内所有采用默认安装方式(rpm安装)的服务的配置文件全部都保存在这个目录当中，如用户账户和密码，服务的启动脚本，常用服务的配置文件等</td>
</tr>
<tr>
<td>/home/</td>
<td>普通用户的家目录。建立每个用户时，每个用户要有一个默认登录位置，这个位置就是这个用户的家目录，所有普通用户的家目录就是在/home下建立一个和用户名相同的目录。如用户user1 的家目录就是home/user1</td>
</tr>
<tr>
<td>/lib/</td>
<td>系统调用的函数库保存位置</td>
</tr>
<tr>
<td>/lost+found/</td>
<td>当系统意外崩溃或机器意外关机，而产生一些文件碎片放在这里。当系统启动的过程中fsck工具会检查这里，并修复已经损坏的文件系统。这个目录只在每个分区中出现，例如/lost+found就是根分区的备份恢复目录，/boot/lost+ found就是/boot分区的备份恢复目录</td>
</tr>
<tr>
<td>/media/</td>
<td>挂载目录。系统建议是用来挂载媒体设备的，例如软盘和光盘</td>
</tr>
<tr>
<td>/mnt/</td>
<td>挂载目录，早期Linux中只有这一个挂载目录，并没有细分。现在这个目录系统建议挂载额外设备，如U盘，移动硬盘和其他操作系统的分区</td>
</tr>
<tr>
<td>/misc/</td>
<td>挂载目录。系统建议用来挂载NFS服务的共享目录。只要是一个已经建立的空目录就可以作为挂载点。那么系统虽然准备了三个默认挂载目录/media、/mnt、 /misc, 但是到底在哪个目录中挂载什么设备都可以由管理员自己决定。例如在/mnt下建立不同目录挂载不同设备。如/mnt/cdrom挂载光盘，/mnt/usb挂载U盘</td>
</tr>
<tr>
<td>/opt/</td>
<td>第三方安装的软件保存位置。这个目录就是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录当中。/usr/local目录也可以用来安装软件(更为常用)</td>
</tr>
<tr>
<td>/proc/</td>
<td>虚拟文件系统，该目录中的数据并不保存到硬盘当中，而是保存到内存当中。主要保存系统的内核，进程，外部设备状态和网络状态灯。如/proc/cpuinfo是保存CPU信息的，/proc/devices是保存设备驱动的列表的，/proc/filesystems是保存文件系统列表的，/proc/net/是保存网络协议信息的</td>
</tr>
<tr>
<td>/sys/</td>
<td>虚拟文件系统。和/proc 目录相似，都是保存在内存当中的，主要是保存于内核相关信息的</td>
</tr>
<tr>
<td>/root/</td>
<td>超级用户的家目录。普通用户家目录在“home”下，超级用户家目录直接在“/”下</td>
</tr>
<tr>
<td>/srv/</td>
<td>服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据</td>
</tr>
<tr>
<td>/tmp/</td>
<td>临时目录。系统存放临时文件的目录，该目录下所有用户都可以访问和写入。建议此目录中不能保存重要数据，最好每次开机都把该目录清空</td>
</tr>
<tr>
<td>/usr/</td>
<td>系统软件资源目录。注意usr不是user的缩写，而是“Unix Softwre Resource”的缩写，所以不是存放用户数据，而是存放系统软件资源的目录。系统中安装的软件大多数保存在这里</td>
</tr>
<tr>
<td>/var/</td>
<td>动态数据保存位置。主要保存缓存、日志以及软件运行所产生的文件</td>
</tr>
</tbody>
</table>
</div>
<h3 id="服务器注意事项"><a href="#服务器注意事项" class="headerlink" title="服务器注意事项"></a>服务器注意事项</h3><ul>
<li>远程服务器不允许关机，只能重启</li>
<li>重启时应该正确关闭服务</li>
<li>不要在服务器访问高峰运行高负载命令(搜索)</li>
<li>远程配置防火墙时不要把自己踢出服务器</li>
<li>指定合理的密码规范并定期更新</li>
<li>合理分配权限</li>
<li>定期备份重要数据和日志</li>
</ul>
<h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><h3 id="文件处理命令"><a href="#文件处理命令" class="headerlink" title="文件处理命令"></a>文件处理命令</h3><h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>命令格式:命令 [-选项] [参数]<br>例:ls -la /etc<br>说明:</p>
<ol>
<li>个别命令使用不遵循此格式</li>
<li>当有多个选项时，可以写在一起,绝大多数顺序也可以改变</li>
<li>简化选项与完整选项<br>-a等于--all</li>
</ol>
<h4 id="目录处理命令"><a href="#目录处理命令" class="headerlink" title="目录处理命令"></a>目录处理命令</h4><h5 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h5><p>命令名称: ls<br>命令英文原意:list<br>命令所在路径: /bin/ls<br>执行权限:所有用户<br>功能描述:显示目录文件<br>语法: ls 选项[-ald] [文件或目录]<br>    -a  显示所有文件，包括隐藏文件<br>    -1  详细信息显示<br>    -d  查看目录属性<br>    -i  查看i节点(linux中，文件查找不是通过文件名称来查找的。实际上是通过i节点来实现文件的查找定位的。)</p>
<p>-rw-r--r--</p>
<ul>
<li>- 文件类型(-二进制文件 d目录 l软链接文件)</li>
<li>rw- r-- r--<br>u     g    o<br>u所有者 g所属组 o其他人<br>r读 w写 x执行</li>
</ul>
<h5 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h5><p>命令名称: mkdir<br>命令英文原意: make directories<br>命令所在路径: /bin/mkdir<br>执行权限: 所有用户<br>语法: mkdir -p [目录名]<br>功能描述:创建新目录<br>      -p  递归创建(不加-p只能在已有目录创建一个新目录,而不能创建一个带有子目录的目录)</p>
<p>mkdir可同时创建多个目录  </p>
<h5 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h5><p>命令名称: cd<br>命令英文原意: change directory<br>命令所在路径: shell内置命令<br>执行权限: 所有用户<br>语法: cd [目录]<br>功能描述: 切换目录</p>
<h5 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h5><p>命令名称: pwd<br>命令英文原意: print working directory<br>命令所在路径: /bin/pwd<br>执行权限: 所有用户<br>语法: pwd<br>功能描述: 显示当前目录</p>
<h5 id="rmdir命令"><a href="#rmdir命令" class="headerlink" title="rmdir命令"></a>rmdir命令</h5><p>命令名称: rmdir<br>命令英文原意: remove empty directories<br>命令所在路径: /bin/rmdir<br>执行权限: 所有用户<br>语法: rmdir [目录名]<br>功能描述: 只能删除空目录</p>
<h5 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h5><p>命令名称: cp<br>命令英文原意: copy<br>命令所在路径: /bin/cp<br>执行权限: 所有用户<br>语法: cp -rp [原文件或目录] [目标目录]<br>    -r  复制目录<br>    -p  保留文件属性(不加-p时会改变文件的修改时间)<br>功能描述: 复制文件或目录到另一个文件(改名)或目录</p>
<p>cp命令可以同时复制多个目录或文件,可以复制并同时改名</p>
<h5 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h5><p>命令名称: mv<br>命令英文原意: move<br>命令所在路径: /bin/mv<br>执行权限: 所有用户<br>语法: mv [原文件或目录] [目标目录]<br>功能描述: 剪切文件、改名</p>
<h5 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h5><p>命令名称: rm<br>命令英文原意: remove<br>命令所在路径: /bin/rm<br>执行权限: 所有用户<br>语法: rm -rf [文件或目录]<br>    -r  删除目录<br>    -f  强制执行<br>    -i  询问删除<br>功能描述: 删除文件</p>
<p>Linux没有回收站概念,删除文件要谨慎.删除文件前要备份,一旦发现误删除情况,尽量不要对硬盘做过多的读写或查找操作.</p>
<h4 id="文件处理命令-1"><a href="#文件处理命令-1" class="headerlink" title="文件处理命令"></a>文件处理命令</h4><h5 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h5><p>命令名称: touch<br>命令所在路径: /bin/touch<br>执行权限: 所有用户<br>语法: touch [文件名]<br>功能描述: 创建空文件</p>
<h5 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h5><p>命令名称: cat<br>命令所在路径: /bin/cat<br>执行权限: 所有用户<br>语法: cat -n [文件名]<br>功能描述: 显示文件内容(只能用于查看内容较少的文件,否则滚动条会一直滚动,只显示最后一页,内容较多用more命令)<br>    -n  显示行号<br>    -A  查询所有文件内容,包括隐藏字符</p>
<h5 id="tac命令"><a href="#tac命令" class="headerlink" title="tac命令"></a>tac命令</h5><p>命令名称: tac<br>命令所在路径: /usr/bin/tac<br>执行权限: 所有用户<br>语法: tac [文件名]<br>功能描述: 显示文件内容(反向列示,与cat相反)</p>
<h5 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h5><p>命令名称: more<br>命令所在路径: /bin/more<br>执行权限: 所有用户<br>语法: more [文件名]<br>    (空格)或f  翻页<br>    (Enter)  换行<br>    q或Q  退出<br>功能描述: 分页显示文件内容(无法向上翻页)</p>
<h5 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h5><p>命令名称: less<br>命令所在路径: /usr/bin/less<br>执行权限: 所有用户<br>语法: less [文件名]<br>    (空格)或f  翻页<br>    (Enter)  换行<br>    q或Q  退出<br>    pgup  向上翻页<br>    pgdn  向下翻页<br>    /[关键词]  搜索<br>    n  搜索下一个<br>功能描述: 分页显示文件内容(可向上翻页),可进行搜索</p>
<h5 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a>head命令</h5><p>命令名称: head<br>命令所在路径: /usr/bin/head<br>执行权限: 所有用户<br>语法: head -n [行数] [文件名]<br>功能描述: 显示文件前面几行<br>    -n  指定行数(不加默认显示前10行)</p>
<h5 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h5><p>命令名称: tail<br>命令所在路径: /usr/bin/tail<br>执行权限: 所有用户<br>语法: tail -n [行数] [文件名]<br>功能描述: 显示文件后面几行<br>    -n  指定行数(不加默认显示后10行)<br>    -f  动态显示文件末尾内容(监控日志)</p>
<h4 id="链接命令"><a href="#链接命令" class="headerlink" title="链接命令"></a>链接命令</h4><h5 id="ln命令"><a href="#ln命令" class="headerlink" title="ln命令"></a>ln命令</h5><p>命令名称: ln<br>命令英文原意: link<br>命令所在路径: /bin/ln<br>执行权限: 所有用户<br>语法: ln -s [原文件] [目标文件]<br>    -s  创建软链接(不加创建硬链接)<br>功能描述: 生成链接文件</p>
<h5 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h5><ol>
<li>软链接全部都为lrwxrwxrwx,软链接权限不决定源文件权限,用户对软链接操作时具有什么权限由软链接对应的源文件确定</li>
<li>文件大小只是符号链接</li>
<li>软链接有箭头指向源文件</li>
<li>源文件删除,软链接失效</li>
</ol>
<h5 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h5><ol>
<li>拷贝(保留文件属性)cp -p + 同步更新</li>
<li>通过i节点识别(ls -i [文件名])(一个文件对应一个i节点,一个i节点可以对应多个文件)</li>
<li>不能跨分区(类似将windowsC盘的文件硬链接到D盘)</li>
<li>不能针对目录使用</li>
<li>源文件删除,硬链接依旧存在</li>
</ol>
<h3 id="权限管理命令"><a href="#权限管理命令" class="headerlink" title="权限管理命令"></a>权限管理命令</h3><h4 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h4><p>命令名称: chmod<br>命令英文原意: change the permissions mode of a file<br>命令所在路径: /bin/chmod<br>执行权限: 所有用户<br>语法: chmod [{ugoa} {+-=} {rwx}] [文件或目录]<br>                        [mode=421(rwx)] [文件或目录]<br>                        -R  递归修改主目录及主目录下所有目录或文件的权限<br>功能描述:改变文件或目录权限</p>
<p>如果有几个类型的用户需要同时设置权限,用逗号分隔</p>
<h4 id="文件目录权限总结"><a href="#文件目录权限总结" class="headerlink" title="文件目录权限总结"></a>文件目录权限总结</h4><div class="table-container">
<table>
<thead>
<tr>
<th>代表字符</th>
<th>权限</th>
<th>对文件的含义</th>
<th>对目录的含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>读权限</td>
<td>可以查看文件内容</td>
<td>可以列出目录中内容</td>
</tr>
<tr>
<td>w</td>
<td>写权限</td>
<td>可以修改文件内容</td>
<td>可以在目录中创建、删除文件</td>
</tr>
<tr>
<td>x</td>
<td>执行权限</td>
<td>可以执行文件</td>
<td>可以进入目录</td>
</tr>
</tbody>
</table>
</div>
<p>只有文件所有者和root可以改变文件权限</p>
<h4 id="其他权限管理命令"><a href="#其他权限管理命令" class="headerlink" title="其他权限管理命令"></a>其他权限管理命令</h4><h5 id="chown命令"><a href="#chown命令" class="headerlink" title="chown命令"></a>chown命令</h5><p>命令名称: chown<br>命令英文原意: change file ownership<br>命令所在路径: /bin/chown<br>执行权限: 所有用户<br>语法: chown [用户] [文件或目录]<br>功能描述: 改变文件或目录的所有者</p>
<p>只有root可以改变文件或目录的所有者</p>
<h5 id="chgrp命令"><a href="#chgrp命令" class="headerlink" title="chgrp命令"></a>chgrp命令</h5><p>命令名称: chgrp<br>命令英文原意: change file group ownership<br>命令所在路径: /bin/chgrp<br>执行权限: 所有用户<br>语法: chgrp [用户组] [文件或目录]<br>功能描述: 改变文件或目录的所属组</p>
<h5 id="umask命令"><a href="#umask命令" class="headerlink" title="umask命令"></a>umask命令</h5><p>命令名称: umask<br>命令英文原意: the user file-creation mask<br>命令所在路径: Shell内置命令<br>执行权限: 所有用户<br>语法: umask [-S]<br>    -S  以rwx形式显示新建文件缺省(默认)权限<br>功能描述:显示、设置文件的缺省权限(默认)</p>
<p>新建文件默认不具有可执行权限;使用umask命令会显示0022,其中,0表示特殊权限,022为权限掩码,真正的权限(缺省)为777-022=755;修改默认权限可以通过下面方式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">umask 权限掩码</span><br></pre></td></tr></table></figure>
<h3 id="文件搜索命令"><a href="#文件搜索命令" class="headerlink" title="文件搜索命令"></a>文件搜索命令</h3><p>搜索会占用大量的系统资源</p>
<h4 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h4><p>命令名称: find<br>命令所在路径: /bin/find<br>执行权限: 所有用户<br>语法: find [搜索范围] [匹配条件]<br>    -name  根据文件名搜索(严格区分大小写)<br>    -iname  根据文件名搜索(不区分大小写)<br>    -size  根据文件大小搜索<br>    -user  根据所有者搜索<br>    -group  根据所属组搜索<br>    -amin  访问时间(access)<br>    -cmin  文件属性(change)<br>    -mmin  文件内容(modify)<br>    -a  两个条件同时满足(and)<br>    -o  两个条件满足任意一个即可(or)<br>    -type  根据文件类型查找(f文件 d目录 l软链接文件)<br>    -exec/-ok 命令 {} \;  对搜索结果执行操作(花括号表示对搜索结果做替换,反斜杠表示转义符,分号表示结束;-ok和-exec最大的区别是有一个询问确认的环节)<br>    -inum  根据i节点搜索<br>功能描述: 文件搜索</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;etc -name init &#x2F;&#x2F;在etc目录搜索文件名为init的文件和目录(精准搜索)</span><br><span class="line">find &#x2F;etc -name *init*  &#x2F;&#x2F;在etc目录搜索文件名中包含init的文件和目录(模糊搜索)</span><br><span class="line">find &#x2F;etc -name init*  &#x2F;&#x2F;在etc目录搜索以init开头的文件和目录(*匹配任意字符)</span><br><span class="line">find &#x2F;etc -name init???  &#x2F;&#x2F;在etc目录搜索以init开头并且后面还有三个字母的文件或目录(问号匹配单个字符)</span><br><span class="line">find &#x2F; -size +204800  &#x2F;&#x2F;在根目录下查找大于100MB的文件和目录  </span><br><span class="line">+n 大于    -n 小于    n 等于  1数据块&#x3D;512字节&#x3D;0.5k</span><br><span class="line">find &#x2F;etc -cmin -5 &#x2F;&#x2F;在&#x2F;etc下查找5分钟内被修改过属性的文件和目录</span><br><span class="line">find &#x2F;etc -mmin +5 &#x2F;&#x2F;在&#x2F;etc下查找5分钟前被修改过内容的文件和目录</span><br><span class="line">find &#x2F;etc -size +163840 -a -size -204800  &#x2F;&#x2F;在&#x2F;etc下查找大于8OMB小于100MB的文件和目录</span><br><span class="line">find &#x2F;etc -name init* -a -type f &#x2F;&#x2F;在etc目录搜索以init开头的文件(没有目录)</span><br><span class="line">find &#x2F;etc -name inittab -exec ls -l &#123;&#125; \;  &#x2F;&#x2F;在&#x2F;etc下查找inittab文件并显示其详细信息</span><br><span class="line">find . -inum 123 -exec rm &#123;&#125; \;  &#x2F;&#x2F;在当前目录搜索i节点为123的文件和目录并删除</span><br></pre></td></tr></table></figure>
<p>不要在服务器高峰期使用find命令;搜索范围越小越好,搜索条件越精准越好</p>
<h4 id="其他搜索命令"><a href="#其他搜索命令" class="headerlink" title="其他搜索命令"></a>其他搜索命令</h4><h5 id="locate命令"><a href="#locate命令" class="headerlink" title="locate命令"></a>locate命令</h5><p>命令名称: locate<br>命令所在路径: /usr/bin/locate<br>执行权限: 所有用户<br>语法: locate 文件名<br>功能描述: 在文件资料库(自动定期更新)中查找文件(比find快)<br>    -i  不区分大小写(不加区分大小写)</p>
<p>如果一个新建立的文件没有被收录,就查找不到,可以使用updatedb更新文件资料库;/tmp存放临时文件,(存放临时文件的目录)不在locate文件资料库收录范围,无法查找/tmp中文件</p>
<h5 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h5><p>命令名称: which<br>命令所在路径: /usr/bin/which<br>执行权限: 所有用户<br>语法: which 命令名称<br>功能描述: 搜索命令所在目录及别名信息</p>
<h5 id="whereis命令"><a href="#whereis命令" class="headerlink" title="whereis命令"></a>whereis命令</h5><p>命令名称: whereis<br>命令所在路径: /usr/bin/whereis<br>执行权限: 所有用户<br>语法: whereis [命令名称]<br>功能描述: 搜索命令所在目录及帮助文档路径(配置文件)</p>
<h5 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h5><p>命令名称: grep<br>命令所在路径: /bin/grep<br>执行权限: 所有用户<br>语法: grep -iv [指定字串] [文件]<br>功能描述: 在文件中搜寻字串匹配的行并输出<br>    -i  不区分大小写<br>    -v  排除指定字串<br>    -n  输出行号<br>    --color=auto   搜索出的关键字用颜色显示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -v ^# &#x2F;etc&#x2F;inittab  &#x2F;&#x2F;搜索时去掉以#号开头的内容</span><br></pre></td></tr></table></figure>
<h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><h4 id="man命令"><a href="#man命令" class="headerlink" title="man命令"></a>man命令</h4><p>命令名称: man<br>命令英文原意: manual<br>命令所在路径: /usr/bin/man<br>执行权限: 所有用户<br>语法: man [命令或配置文件]<br>功能描述: 获得(命令或配置文件的)帮助信息</p>
<p>man命令与more和less类似;man查看配置文件的帮助信息不要加绝对路径,只要加配置文件名称即可;1表示命令的帮助,5表示配置文件的帮助</p>
<h4 id="whatis命令"><a href="#whatis命令" class="headerlink" title="whatis命令"></a>whatis命令</h4><p>命令名称: whatis<br>命令所在路径: /usr/bin/whatis<br>执行权限: 所有用户<br>语法: whatis [命令]<br>功能描述: 获得命令(相对man命令更为简短)的帮助信息</p>
<h4 id="apropos命令"><a href="#apropos命令" class="headerlink" title="apropos命令"></a>apropos命令</h4><p>命令名称: apropos<br>命令所在路径: /usr/bin/apropos<br>执行权限: 所有用户<br>语法: apropos [配置文件]<br>功能描述: 获得配置文件(相对man命令更为简短)的帮助信息</p>
<h4 id="info命令"><a href="#info命令" class="headerlink" title="info命令"></a>info命令</h4><p>命令名称: info<br>命令英文原意: information<br>命令所在路径: /usr/bin/info<br>执行权限: 所有用户<br>语法: info [命令或配置文件]<br>功能描述: 获得(命令或配置文件的)帮助信息</p>
<p>info命令与man命令类似,只是显示方式不同</p>
<h4 id="help"><a href="#help" class="headerlink" title="--help"></a>--help</h4><p>命令名称: --help<br>执行权限: 所有用户<br>语法: 命令 --help<br>功能描述: 获得命令主要选项的帮助信息(适用于外部命令)</p>
<h4 id="help命令"><a href="#help命令" class="headerlink" title="help命令"></a>help命令</h4><p>命令名称: help<br>命令所在路径: Shell内置命令<br>执行权限: 所有用户<br>语法: help 命令<br>功能描述: 获得Shell(命令解释器)内置命令(找不到路径)的帮助信息(不能使用man查看)</p>
<p>可以使用type [命令名称],来查看是外部命令还是内置命令</p>
<h3 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h3><h4 id="useradd命令"><a href="#useradd命令" class="headerlink" title="useradd命令"></a>useradd命令</h4><p>命令名称: useradd<br>命令所在路径: /usr/sbin/useradd<br>执行权限: root<br>语法: useradd 用户名<br>功能描述: 添加新用户</p>
<h4 id="passwd命令"><a href="#passwd命令" class="headerlink" title="passwd命令"></a>passwd命令</h4><p>命令名称: passwd<br>命令所在路径: /usr/bin/passwd<br>执行权限: 所有用户<br>语法: passwd 用户名<br>功能描述: 设置用户密码</p>
<p>root用户更改密码不用遵循密码复杂度要求;普通用户更改密码必须遵循密码复杂度要求.root可以更改任何人的密码,普通用户只能更改自己的密码</p>
<h4 id="who命令"><a href="#who命令" class="headerlink" title="who命令"></a>who命令</h4><p>命令名称: who<br>命令所在路径: /usr/bin/who<br>执行权限: 所有用户<br>语法: who<br>功能描述: 查看登录用户信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">登录用户名 登录终端(tty本地终端,pts远程终端) 登录时间 登录ip</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/30/FzxVm3KoPpfQLXJ.png" alt=""></p>
<h4 id="w命令"><a href="#w命令" class="headerlink" title="w命令"></a>w命令</h4><p>命令名称: w<br>命令所在路径: /usr/bin/w<br>执行权限: 所有用户<br>语法: w<br>功能描述: 查看登录用户详细信息(比who更详细)</p>
<p><img src="https://i.loli.net/2021/01/30/CF9i24xHXTBqMKs.png" alt=""></p>
<h3 id="压缩解压命令"><a href="#压缩解压命令" class="headerlink" title="压缩解压命令"></a>压缩解压命令</h3><h4 id="du命令"><a href="#du命令" class="headerlink" title="du命令"></a>du命令</h4><p>命令名称: du<br>命令英文原意: disk usage<br>命令所在路径: /usr/bin/du<br>执行权限: 所有用户<br>语法: du [文件或目录] -h<br>    -h  以K,M,G为单位,提高信息的可读性<br>    -s  仅显示每个参数的总计<br>功能描述: 显示文件或目录的大小</p>
<h4 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h4><p>命令名称: tar<br>命令所在路径: /bin/tar<br>执行权限:所有用户<br>语法: tar 选项[-cvf] 打包文件 源文件(可以有多个源文件,只打包解包不压缩)<br>    -c  创建tar包<br>    -x  解tar包<br>    -v  显示详细信息(进度)<br>    -f  备份文件(f必须放在后面)<br>    -C  解包到指定路径<br>    -z  压缩为.gz文件(将.gz文件解压)<br>    -j   压缩为.bz2文件(将.bz2文件解压)<br>功能描述: 归档管理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -cvf xxx.tar 1.c 2.c 3.c    &#x2F;&#x2F;将1.c,2.c,3.c打包至tar文件(* 全部打包)</span><br><span class="line">tar -xvf xxx.tar -C 路径    &#x2F;&#x2F;指定目录解包,不指定路径,默认在当前路径解包</span><br><span class="line">tar -czvf xxx.tar.gz 1.c 2.c   &#x2F;&#x2F;打包同时压缩为.gz文件</span><br><span class="line">tar -xzvf xxx.tar.gz      &#x2F;&#x2F;解压并解包</span><br><span class="line">tar -cjvf xxx.tar.bz2 1.c 2.c   &#x2F;&#x2F;打包同时压缩为.bz2文件</span><br><span class="line">tar -xjvf xxx.tar.bz2      &#x2F;&#x2F;解压并解包</span><br></pre></td></tr></table></figure>
<h4 id="gzip命令"><a href="#gzip命令" class="headerlink" title="gzip命令"></a>gzip命令</h4><p>命令名称: gzip<br>命令英文原意: GNU zip<br>命令所在路径: /bin/gzip<br>执行权限: 所有用户<br>语法: gzip [文件]<br>功能描述: 压缩文件(自动生成.gz文件,且不保留源文件)<br>    -d  解压文件<br>    -r  压缩所有子目录中文件(不能压缩目录)<br>压缩后文件格式: .gz</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip -r 目录(假设为test) &#x2F;&#x2F;将test目录及其子目录下所有文件压缩为.gz文件</span><br><span class="line">gzip -d -r 目录(假设为test) &#x2F;&#x2F;将test目录及其子目录下所有文件解压</span><br></pre></td></tr></table></figure>
<h4 id="gunzip命令"><a href="#gunzip命令" class="headerlink" title="gunzip命令"></a>gunzip命令</h4><p>命令名称: gunzip<br>命令英文原意: GNU unzip<br>命令所在路径: /bin/gunzip<br>执行权限: 所有用户<br>语法: gunzip [压缩文件]<br>功能描述: 解压.gz的压缩文件</p>
<h4 id="bzip2命令"><a href="#bzip2命令" class="headerlink" title="bzip2命令"></a>bzip2命令</h4><p>命令名称: bzip2<br>命令所在路径: /usr/bin/bzip2<br>执行权限: 所有用户<br>语法: bzip2 [文件]<br>功能描述: 压缩文件(自动生成.bz2文件,且不保留源文件,不能压缩目录,没有-r选项)<br>    -d  解压文件<br>    -k  产生压缩文件后保留源文件<br>压缩后文件格式: .bz2</p>
<h4 id="bunzip2命令"><a href="#bunzip2命令" class="headerlink" title="bunzip2命令"></a>bunzip2命令</h4><p>命令名称: bunzip2<br>命令所在路径: /usr/bin/bunzip2<br>执行权限: 所有用户<br>语法: bunzip2 选项[-k] [压缩文件]<br>    -k  解压后保留原文件<br>功能描述: 解压.bz2文件</p>
<h4 id="zip命令"><a href="#zip命令" class="headerlink" title="zip命令"></a>zip命令</h4><p>命令名称: zip<br>命令所在路径: /usr/bin/zip<br>执行权限: 所有用户<br>语法: zip 选项[-r] [压缩后文件名] [文件或目录]<br>    -r  压缩目录<br>功能描述: 压缩文件或目录(能保留源文件)<br>压缩后文件格式: .zip</p>
<h4 id="unzip命令"><a href="#unzip命令" class="headerlink" title="unzip命令"></a>unzip命令</h4><p>命令名称: unzip<br>命令所在路径: /usr/bin/unzip<br>执行权限: 所有用户<br>语法: unzip [压缩文件]<br>功能描述: 解压.zip的压缩文件</p>
<h3 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h3><h4 id="write命令"><a href="#write命令" class="headerlink" title="write命令"></a>write命令</h4><p>命令名称: write<br>命令所在路径: /usr/bin/write<br>执行权限: 所有用户<br>语法: write &lt;用户名&gt;<br>功能描述: 给指定在线用户发信息,以Ctrl+D保存结束</p>
<h4 id="wall命令"><a href="#wall命令" class="headerlink" title="wall命令"></a>wall命令</h4><p>命令名称: wall<br>命令英文原意: write all<br>命令所在路径: /usr/bin/yvall<br>执行权限: 所有用户<br>语法: wall [message]<br>功能描述: 发广播信息(给所有在线用户发送)</p>
<h4 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h4><p>命令名称: ping<br>命令所在路径: /bin/ping<br>执行权限: 所有用户<br>语法: ping 选项 IP地址<br>    -c  指定发送次数<br>功能描述: 测试网络连通性<br>范例: ping -c 3 ip地址  //ping三次</p>
<h4 id="ifconfig命令"><a href="#ifconfig命令" class="headerlink" title="ifconfig命令"></a>ifconfig命令</h4><p>命令名称: ifconfig<br>命令英文原意: interface configure<br>命令所在路径: /sbin/ifconfig<br>执行权限: root<br>语法: ifconfig 网卡名称 IP地址<br>功能描述:查看和设置网卡信息<br>范例: #ifconfig eth0 192.168.8.250</p>
<h4 id="mail-命令"><a href="#mail-命令" class="headerlink" title="mail 命令"></a>mail 命令</h4><p>命令名称: mail<br>命令所在路径: /bin/mail<br>执行权限: 所有用户<br>语法: mail [用户名]<br>功能描述: 查看发送电子邮件(以Ctrl+D保存结束)(查看邮件时直接使用mail,按q退出)</p>
<h4 id="last命令"><a href="#last命令" class="headerlink" title="last命令"></a>last命令</h4><p>命令名称: last<br>命令所在路径: /usr/bin/last<br>执行权限: 所有用户<br>语法: last<br>功能描述: 列出目前与过去登入系统的用户信息</p>
<h4 id="lastlog命令"><a href="#lastlog命令" class="headerlink" title="lastlog命令"></a>lastlog命令</h4><p>命令名称: lastlog<br>命令所在路径: /usr/bin/lastlog<br>执行权限: 所有用户<br>语法: lastlog<br>    -u 用户uid  查看指定用户登录<br>功能描述:检查某特定用户上次登录的时间</p>
<h4 id="traceroute命令"><a href="#traceroute命令" class="headerlink" title="traceroute命令"></a>traceroute命令</h4><p>命令名称: traceroute<br>命令所在路径: /bin/traceroute<br>执行权限: 所有用户<br>语法: traceroute<br>功能描述:显示数据包到主机间的路径</p>
<h4 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h4><p>命令名称: netstat<br>命令所在路径: /bin/netstat<br>执行权限: 所有用户<br>语法: netstat [选项]<br>    -a  全部信息<br>    -t  TCP协议<br>    -u  UDP协议<br>    -l  监听<br>    -r  路由(网关)<br>    -n  显示IP地址和端口号<br>功能描述: 显示网络相关信息<br>范例:<br>    netstat -tlun       查看本机监听的端口<br>    netstat -an          查看本机所有的网络连接<br>    netstat -rn           查看本机路由表</p>
<h4 id="setup命令-red-hat专有"><a href="#setup命令-red-hat专有" class="headerlink" title="setup命令(red hat专有)"></a>setup命令(red hat专有)</h4><p>命令名称: setup<br>命令所在路径: /usr/bin/setup<br>执行权限: root<br>语法: setup<br>功能描述:配置网络</p>
<h4 id="mount命令"><a href="#mount命令" class="headerlink" title="mount命令"></a>mount命令</h4><p>命令名称: mount<br>命令位置: /bin/mount<br>执行权限: 所有用户<br>命令语法: mount [-t 文件系统] 设备文件名 挂载点<br>功能描述: 挂载设备<br>范例: mount -t iso9660 /dev/sr0 /mnt/cdrom</p>
<h4 id="umount命令"><a href="#umount命令" class="headerlink" title="umount命令"></a>umount命令</h4><p>命令名称: umount<br>命令位置: /bin/umount<br>执行权限: 所有用户<br>命令语法: umount 设备文件名<br>功能描述: 卸载设备<br>范例: umount /dev/sr0</p>
<h3 id="关机重启命令"><a href="#关机重启命令" class="headerlink" title="关机重启命令"></a>关机重启命令</h3><h4 id="shutdown命令"><a href="#shutdown命令" class="headerlink" title="shutdown命令"></a>shutdown命令</h4><p>命令名称: shutdown<br>命令语法: shutdown [选项] 时间<br>    -c  取消前一个关机命令<br>    -h  关机<br>    -r  重启<br>功能描述: 关机重启<br>范例:<br>shutdown -h now   现在关机<br>shutdown -r 12:00   12:00重启<br>shutdown -c    取消前一个关机命令</p>
<h4 id="halt命令"><a href="#halt命令" class="headerlink" title="halt命令"></a>halt命令</h4><p>命令名称: halt<br>命令语法: halt<br>功能描述: 关机</p>
<h4 id="poweroff命令"><a href="#poweroff命令" class="headerlink" title="poweroff命令"></a>poweroff命令</h4><p>命令名称: poweroff<br>命令语法: poweroff<br>功能描述: 关机</p>
<p>相当于直接断电</p>
<h4 id="init-0命令"><a href="#init-0命令" class="headerlink" title="init 0命令"></a>init 0命令</h4><p>命令名称: init 0<br>命令语法: init 0<br>功能描述: 关机</p>
<h4 id="reboot命令"><a href="#reboot命令" class="headerlink" title="reboot命令"></a>reboot命令</h4><p>命令名称: reboot<br>命令语法: reboot<br>功能描述: 重启</p>
<h4 id="init-6命令"><a href="#init-6命令" class="headerlink" title="init 6命令"></a>init 6命令</h4><p>命令名称: init 6<br>命令语法: init 6<br>功能描述: 重启</p>
<h4 id="logout命令"><a href="#logout命令" class="headerlink" title="logout命令"></a>logout命令</h4><p>命令名称: logout<br>命令语法: logout<br>功能描述: 退出登录</p>
<h4 id="系统运行级别"><a href="#系统运行级别" class="headerlink" title="系统运行级别"></a>系统运行级别</h4><p>0  关机<br>1  单用户(root用户,与windows下安全模式类似,启动最少的核心程序进行修复)(无图形界面)<br>2  不完全多用户,不含NFS(网络文件系统)服务(NFS不太安全)(无图形界面)<br>3  完全多用户(无图形界面)<br>4  未分配<br>5  图形界面(X)<br>6  重启</p>
<h5 id="查看运行级别相关信息"><a href="#查看运行级别相关信息" class="headerlink" title="查看运行级别相关信息"></a>查看运行级别相关信息</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;inittab</span><br></pre></td></tr></table></figure>
<h5 id="查询系统当前运行级别"><a href="#查询系统当前运行级别" class="headerlink" title="查询系统当前运行级别"></a>查询系统当前运行级别</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">runlevel</span><br></pre></td></tr></table></figure>
<h2 id="文本编辑器Vim"><a href="#文本编辑器Vim" class="headerlink" title="文本编辑器Vim"></a>文本编辑器Vim</h2><p>Vim是一个功能强大的全屏幕文本编辑器,是Linux/UNIX上最常用的文本编辑器,它的作用是建立、编辑、显示文本文件.Vim没有菜单,只有命令.</p>
<p>Vim工作模式分为命令模式,插入模式和编辑模式.</p>
<h3 id="Vim常用命令"><a href="#Vim常用命令" class="headerlink" title="Vim常用命令"></a>Vim常用命令</h3><h4 id="插入命令"><a href="#插入命令" class="headerlink" title="插入命令"></a>插入命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>在光标所在字符后插入</td>
</tr>
<tr>
<td>A</td>
<td>在光标所在行行尾插入</td>
</tr>
<tr>
<td>i</td>
<td>在光标所在字符前插入</td>
</tr>
<tr>
<td>I</td>
<td>在光标所在行行首插入</td>
</tr>
<tr>
<td>o</td>
<td>在光标下插入新行</td>
</tr>
<tr>
<td>O</td>
<td>在光标上插入新行</td>
</tr>
</tbody>
</table>
</div>
<h4 id="定位命令"><a href="#定位命令" class="headerlink" title="定位命令"></a>定位命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>:set nu</td>
<td>设置行号</td>
</tr>
<tr>
<td>:set nonu</td>
<td>取消行号</td>
</tr>
<tr>
<td>gg<br />G</td>
<td>到第一行<br />到最后一行</td>
</tr>
<tr>
<td>nG</td>
<td>到第n行</td>
</tr>
<tr>
<td>:n</td>
<td>到第n行</td>
</tr>
<tr>
<td>$</td>
<td>移至行尾</td>
</tr>
<tr>
<td>0</td>
<td>移至行首</td>
</tr>
</tbody>
</table>
</div>
<h4 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>删除光标所在处字符</td>
</tr>
<tr>
<td>nx</td>
<td>删除光标所在处后n个字符</td>
</tr>
<tr>
<td>dd</td>
<td>删除光标所在行,ndd删除n行</td>
</tr>
<tr>
<td>dG</td>
<td>删除光标所在行到文件末尾内容</td>
</tr>
<tr>
<td>D</td>
<td>删除光标所在处到行尾内容</td>
</tr>
<tr>
<td>:x,yd</td>
<td>删除指定范围(x行到y行)的行</td>
</tr>
</tbody>
</table>
</div>
<h4 id="复制和剪切命令"><a href="#复制和剪切命令" class="headerlink" title="复制和剪切命令"></a>复制和剪切命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>yy</td>
<td>复制当前行</td>
</tr>
<tr>
<td>nyy</td>
<td>复制当前行(包括当前行)以下n行</td>
</tr>
<tr>
<td>dd</td>
<td>剪切当前行</td>
</tr>
<tr>
<td>ndd</td>
<td>剪切当前行(包括当前行)以下n行</td>
</tr>
<tr>
<td>p<br />P</td>
<td>粘贴在当前光标所在行下(p)<br />粘贴在当前光标所在行上(P)</td>
</tr>
</tbody>
</table>
</div>
<h4 id="替换和取消命令"><a href="#替换和取消命令" class="headerlink" title="替换和取消命令"></a>替换和取消命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>取代光标所在处字符</td>
</tr>
<tr>
<td>R</td>
<td>从光标所在处开始替换字符,按Esc结束</td>
</tr>
<tr>
<td>u</td>
<td>取消上一步操作</td>
</tr>
</tbody>
</table>
</div>
<h4 id="搜索和搜索替换命令"><a href="#搜索和搜索替换命令" class="headerlink" title="搜索和搜索替换命令"></a>搜索和搜索替换命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>/string</td>
<td>搜索指定字符串,搜索时忽略大小写:set ic(不忽略大小写:set noic)</td>
</tr>
<tr>
<td>n</td>
<td>搜索指定字符串的下一个出现位置</td>
</tr>
<tr>
<td>:%s/要被替换的字符串/新的字符串</td>
<td>全文替换指定字符串</td>
</tr>
<tr>
<td>:起始行,终止行s/要被替换的字符串/新的字符串</td>
<td>在一定范围内替换指定字符串</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:%s&#x2F;world&#x2F;世界&#x2F;g      &#x2F;&#x2F;在全文范围内,将world替换为世界(g表示不询问,c表示询问确认)</span><br><span class="line">:3,6s&#x2F;world&#x2F;世界&#x2F;c    &#x2F;&#x2F;在3到6行,将world替换为世界(&#x2F;g或&#x2F;c可加可不加)</span><br></pre></td></tr></table></figure>
<h4 id="保存和退出命令"><a href="#保存和退出命令" class="headerlink" title="保存和退出命令"></a>保存和退出命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>:w</td>
<td>保存修改</td>
</tr>
<tr>
<td>:w filename</td>
<td>另存为指定文件(可指定为某路径下的某文件)</td>
</tr>
<tr>
<td>:wq</td>
<td>保存修改并退出</td>
</tr>
<tr>
<td>ZZ</td>
<td>快捷键,保存修改并退出</td>
</tr>
<tr>
<td>:q!</td>
<td>不保存修改退出</td>
</tr>
<tr>
<td>:wq!</td>
<td>(只读文件强行保存)保存修改并退出(文件所有者及root可使用)</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Vim使用技巧"><a href="#Vim使用技巧" class="headerlink" title="Vim使用技巧"></a>Vim使用技巧</h3><h4 id="导入外部文件"><a href="#导入外部文件" class="headerlink" title="导入外部文件"></a>导入外部文件</h4><p>:r 文件位置   //导入文件到当前vim编辑的文件中</p>
<p><img src="https://i.loli.net/2021/01/31/THdxuBQmOfvpUSL.gif" alt=""></p>
<h4 id="不退出vim使用linux命令"><a href="#不退出vim使用linux命令" class="headerlink" title="不退出vim使用linux命令"></a>不退出vim使用linux命令</h4><p>:!命令      //不退出vim的情况下使用linux命令</p>
<p><img src="https://i.loli.net/2021/01/31/H71X9uAtVwZ5qkm.gif" alt=""></p>
<h4 id="将命令执行结果导入当前编辑文件"><a href="#将命令执行结果导入当前编辑文件" class="headerlink" title="将命令执行结果导入当前编辑文件"></a>将命令执行结果导入当前编辑文件</h4><p>:r !date(或其他命令)        //直接将date命令执行结果导入当前编辑文件   </p>
<p><img src="https://i.loli.net/2021/01/31/SNU56oP18fD3mrz.gif" alt=""></p>
<h4 id="自定义快捷键-单行注释"><a href="#自定义快捷键-单行注释" class="headerlink" title="自定义快捷键(单行注释)"></a>自定义快捷键(单行注释)</h4><p>:map 快捷键 触发命令   //自定义快捷键</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:map Ctrl+p I#&lt;ESC&gt;     &#x2F;&#x2F;将在首行(I)添加#并退出插入模式(ESC)设置为快捷键Ctrl+p</span><br><span class="line">:map Ctrl+b 0x          &#x2F;&#x2F;将光标移至行首并删除行首字符设置为快捷键Ctrl+b</span><br></pre></td></tr></table></figure>
<h4 id="连续行注释"><a href="#连续行注释" class="headerlink" title="连续行注释"></a>连续行注释</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:2,5s&#x2F;^&#x2F;#&#x2F;g        &#x2F;&#x2F;(类似于前面的替换)将2至5行的行首(^)增加#(g表示不询问)</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/31/yZJ6P3qH5NMKYef.gif" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:2,5s&#x2F;#&#x2F;&#x2F;g         &#x2F;&#x2F;将2至5行中所有#删除</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/31/n6IDdh45UkPYMgF.gif" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:2,5s&#x2F;^#&#x2F;&#x2F;g         &#x2F;&#x2F;将2至5行的行首的所有#删除</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/31/K9jXRYPFkE5VTJ2.gif" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:2,5s&#x2F;^&#x2F;\&#x2F;\&#x2F;&#x2F;g     &#x2F;&#x2F;将2至5行的行首添加双斜杠(&#x2F;&#x2F;),其中\&#x2F;代表一个斜杠(转义)</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/31/FYnkzh5iDVHycZK.gif" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:2,5s&#x2F;^\&#x2F;\&#x2F;&#x2F;&#x2F;g    &#x2F;&#x2F;将2至5行的行首的双斜杠(&#x2F;&#x2F;)删除</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/31/2itGncOdUS965N3.gif" alt=""></p>
<h4 id="文本替换"><a href="#文本替换" class="headerlink" title="文本替换"></a>文本替换</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ab mymail 5201314@qq.com   &#x2F;&#x2F;在文件中输入mymail,空格或回车后会自动替换为5201314@qq.com </span><br></pre></td></tr></table></figure>
<h2 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h2><h3 id="软件包管理简介"><a href="#软件包管理简介" class="headerlink" title="软件包管理简介"></a>软件包管理简介</h3><h4 id="软件包分类"><a href="#软件包分类" class="headerlink" title="软件包分类"></a>软件包分类</h4><ul>
<li>源码包(绝大多数是C语言)<ol>
<li>脚本安装包</li>
</ol>
</li>
<li>经过编译后的二进制包(RPM包,系统默认包)(现在更常用)</li>
</ul>
<h5 id="源码包"><a href="#源码包" class="headerlink" title="源码包"></a>源码包</h5><p>源码包的优点:</p>
<ul>
<li>开源,如果有足够的能力,可以修改源代码</li>
<li>可以自由选择所需的功能</li>
<li>软件是编译安装,所以更加适合自己的系统,更加稳定也效率更高</li>
<li>卸载方便(直接删除源码包)</li>
</ul>
<p>源码包的缺点:</p>
<ul>
<li>安装过程步骤较多,尤其安装较大的软件集合时( 如LAMP环境搭建),容易出现拼写错误</li>
<li>编译过程时间较长,安装比二进制包安装时间长</li>
<li>因为是编译安装,安装过程中一旦报错新手很难解决</li>
</ul>
<h5 id="二进制包"><a href="#二进制包" class="headerlink" title="二进制包"></a>二进制包</h5><p>二进制包的优点:</p>
<ul>
<li>包管理系统简单,只通过几个命令就可以实现包的安装、升级、查询和卸载</li>
<li>安装速度比源码包安装快的多</li>
</ul>
<p>二进制包的缺点:</p>
<ul>
<li>经过编译,不再可以看到源代码</li>
<li>功能选择不如源码包灵活</li>
<li>依赖性</li>
</ul>
<h3 id="RPM包管理"><a href="#RPM包管理" class="headerlink" title="RPM包管理"></a>RPM包管理</h3><h4 id="rpm命令管理"><a href="#rpm命令管理" class="headerlink" title="rpm命令管理"></a>rpm命令管理</h4><h5 id="包命名与依赖"><a href="#包命名与依赖" class="headerlink" title="包命名与依赖"></a>包命名与依赖</h5><h6 id="RPM包命名规则"><a href="#RPM包命名规则" class="headerlink" title="RPM包命名规则"></a>RPM包命名规则</h6><p>httpd-2.2.15-15.el6.centos.1.i686.rpm(包全名)<br>httpd          软件包名<br>2.2.15         软件版本<br>15                软件发布的次数<br>el6.centos  适合的Linux平台<br>i686             适合的硬件平台<br>rpm              rpm包扩展名</p>
<h6 id="RPM包依赖性"><a href="#RPM包依赖性" class="headerlink" title="RPM包依赖性"></a>RPM包依赖性</h6><ul>
<li>树形依赖: a-&gt;b-&gt;c</li>
<li>环形依赖: a-&gt;b-&gt;c-&gt;a(同时装即可)</li>
<li>模块依赖: <a href="https://www.rpmfind.net">模块依赖查询网站</a></li>
</ul>
<h5 id="安装升级与卸载"><a href="#安装升级与卸载" class="headerlink" title="安装升级与卸载"></a>安装升级与卸载</h5><h6 id="RPM包安装"><a href="#RPM包安装" class="headerlink" title="RPM包安装"></a>RPM包安装</h6><p>rpm -ivh 包全名</p>
<p>选项:<br>    -i (install)      安装<br>    -v (verbose)   显示详细信息<br>    -h (hash)        显示进度<br>    --nodeps        不检查依赖性</p>
<h6 id="RPM包升级"><a href="#RPM包升级" class="headerlink" title="RPM包升级"></a>RPM包升级</h6><p>rpm -Uvh 包全名</p>
<p>选项:<br>    -U (upgrade)      升级</p>
<h6 id="RPM包卸载"><a href="#RPM包卸载" class="headerlink" title="RPM包卸载"></a>RPM包卸载</h6><p>rpm -e 包名</p>
<p>选项:<br>    -e (erase)      卸载<br>    --nodeps       不检查依赖性</p>
<h5 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h5><h6 id="查询是否安装"><a href="#查询是否安装" class="headerlink" title="查询是否安装"></a>查询是否安装</h6><p>rpm -q 包名</p>
<p>选项:<br>    -q (query)      查询</p>
<p>rpm -qa</p>
<p>选项:<br>    -a (all)            全部</p>
<h6 id="查询软件包详细信息"><a href="#查询软件包详细信息" class="headerlink" title="查询软件包详细信息"></a>查询软件包详细信息</h6><p>rpm -qi 包名</p>
<p>选项:<br>    -i (information)      查询软件信息</p>
<p>rpm -qp 包全名</p>
<p>选项:<br>    -p (package)            查询未安装包信息 </p>
<h6 id="查询包中文件安装位置"><a href="#查询包中文件安装位置" class="headerlink" title="查询包中文件安装位置"></a>查询包中文件安装位置</h6><p>rpm -ql 包名</p>
<p>选项:<br>    -l (list)      查询文件安装位置列表</p>
<p>rpm -qlp 包全名</p>
<p>选项:<br>    -p (package)            查询未安装包的默认安装位置</p>
<h6 id="查询系统文件属于哪个RPM包"><a href="#查询系统文件属于哪个RPM包" class="headerlink" title="查询系统文件属于哪个RPM包"></a>查询系统文件属于哪个RPM包</h6><p>rpm -qf 系统文件名</p>
<p>选项:<br>    -f (file)            查询系统文件属于哪个RPM包</p>
<h6 id="查询软件包的依赖性"><a href="#查询软件包的依赖性" class="headerlink" title="查询软件包的依赖性"></a>查询软件包的依赖性</h6><p>rpm -q[p]R 包名[包全名]</p>
<p>选项:<br>    -R (requires)            查询软件包的依赖性<br>    -p (package)             查询未安装包的依赖性</p>
<h5 id="校验和文件提取"><a href="#校验和文件提取" class="headerlink" title="校验和文件提取"></a>校验和文件提取</h5><h6 id="RPM包校验"><a href="#RPM包校验" class="headerlink" title="RPM包校验"></a>RPM包校验</h6><p>判断系统文件是否更改</p>
<p>rpm -V 包名</p>
<p>选项:<br>    -V (verify)            校验指定RPM包中的文件</p>
<p>验证内容中的8个信息的具体内容如下:</p>
<ul>
<li>S  文件大小是否改变</li>
<li>M  文件的类型或文件的权限(rwx) 是否被改变</li>
<li>5    文件MD5校验和是否改变(可以看成文件内容是否<br>改变)</li>
<li>D  设备的主从代码是否改变</li>
<li>L  文件路径是否改变</li>
<li>U  文件的属主(所有者)是否改变</li>
<li>G  文件的属组是否改变</li>
<li>T  文件的修改时间是否改变</li>
</ul>
<p>文件类型:</p>
<ul>
<li>c  配置文件(config file)</li>
<li>d  普通文档(documentation)</li>
<li>g  “鬼”文件(ghost file),很少见,就是该文件不应该被这个RPM包包含</li>
<li>l  授权文件(license file)</li>
<li>r  描述文件(read me)</li>
</ul>
<h6 id="RPM包中文件提取"><a href="#RPM包中文件提取" class="headerlink" title="RPM包中文件提取"></a>RPM包中文件提取</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm2cpio 包全名 | \ cpio -idv .文件绝对路径</span><br></pre></td></tr></table></figure>
<p>“\\”代表一条命令没有输入完,(太长了)换行;”.”代表把指定路径的文件提取到当前路径下;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rmp2cpio &#x2F;mnt&#x2F;cdrom&#x2F;Package&#x2F;coreutils-8.4-19.el6.i686.rpm | cpio -idv .&#x2F;bin&#x2F;ls</span><br><span class="line">&#x2F;&#x2F;提取RPM包中ls命令到当前目录的&#x2F;bin&#x2F;ls下</span><br></pre></td></tr></table></figure>
<p>rpm2cpio     //将rpm包转换为cpio格式的命令</p>
<p>cpio    //是一个标准工具,它用于创建软件档案文件和从档案文件中提取文件</p>
<p>cpio 选项 &lt;[文件/设备]</p>
<p>选项:<br>    -i   copy-in模式,还原<br>    -d  还原时自动新建目录<br>    -v  显示还原过程<br>    &lt;    输入重定向</p>
<h4 id="yum在线管理"><a href="#yum在线管理" class="headerlink" title="yum在线管理"></a>yum在线管理</h4><h5 id="网络yum源"><a href="#网络yum源" class="headerlink" title="网络yum源"></a>网络yum源</h5><ul>
<li>[base]    容器名称,一定要放在[]中</li>
<li>name    容器说明,可以自己随便写</li>
<li>mirrorlist    镜像站点,这个可以注释掉</li>
<li>baseurl    yum源服务器的地址(为http)</li>
<li>enabled    此容器是否生效,如果不写或写成enable=1都是生效,写成enable=0就是不生效</li>
<li>gpgcheck    如果是1则指RPM的数字证书生效,如果是0则不生效</li>
<li>gpgkey    数字证书的公钥文件保存位置.不用修改</li>
</ul>
<h5 id="yum命令"><a href="#yum命令" class="headerlink" title="yum命令"></a>yum命令</h5><h6 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum list           &#x2F;&#x2F;查询所有可用软件包列表</span><br><span class="line">yum search 关键字   &#x2F;&#x2F;搜索服务器上所有和关键字相关的包</span><br></pre></td></tr></table></figure>
<h6 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install 包名</span><br></pre></td></tr></table></figure>
<p>选项:<br>    -y  自动回答yes</p>
<h6 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y update 包名   &#x2F;&#x2F;不加包名时,升级所有软件包(包括linux内核,linux内核升级完成后需要在本地做一定的配置才能正常使用)</span><br></pre></td></tr></table></figure>
<h6 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y remove 包名</span><br></pre></td></tr></table></figure>
<p>尽量不卸载</p>
<h6 id="yum软件组管理命令"><a href="#yum软件组管理命令" class="headerlink" title="yum软件组管理命令"></a>yum软件组管理命令</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum grouplist             &#x2F;&#x2F;列出所有可用的软件组列表</span><br><span class="line">yum groupinstall 软件组名  &#x2F;&#x2F;安装指定软件组,组名可以由group1ist查询出来(如果组名有空格,用双引号括起来)</span><br><span class="line">yum groupremove 软件组名   &#x2F;&#x2F;卸载指定软件组</span><br></pre></td></tr></table></figure>
<h5 id="光盘yum源搭建"><a href="#光盘yum源搭建" class="headerlink" title="光盘yum源搭建"></a>光盘yum源搭建</h5><p>1.挂载光盘</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount &#x2F;dev&#x2F;cdrom &#x2F;mnt&#x2F;cdrom</span><br></pre></td></tr></table></figure>
<p>2.让网络yum源文件失效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;etc&#x2F;yum&#x2F;repos.d&#x2F;</span><br><span class="line">将yum源文件(除了Centos-Meidia.repo)中改为enable&#x3D;0;或者将它们改名</span><br></pre></td></tr></table></figure>
<p>3.修改光盘yum源文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim Centos-Meidia.repo</span><br><span class="line">将baseurl&#x3D;http:&#x2F;&#x2F;修改baseurl&#x3D;file:&#x2F;&#x2F;光盘挂载的绝对路径</span><br><span class="line">注释多余的file:&#x2F;&#x2F;&#x2F;路径(不存在的地址)</span><br><span class="line">设置enable&#x3D;1</span><br></pre></td></tr></table></figure>
<h3 id="源码包管理"><a href="#源码包管理" class="headerlink" title="源码包管理"></a>源码包管理</h3><h4 id="源码包和RPM包的区别"><a href="#源码包和RPM包的区别" class="headerlink" title="源码包和RPM包的区别"></a>源码包和RPM包的区别</h4><ul>
<li>安装之前的区别: 概念上的区别</li>
<li>安装之后的区别: 安装位置不同</li>
</ul>
<h5 id="RPM包安装位置"><a href="#RPM包安装位置" class="headerlink" title="RPM包安装位置"></a>RPM包安装位置</h5><p>默认安装路径(绝大多数):</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>路径</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>/etc/</td>
<td>配置文件安装目录</td>
</tr>
<tr>
<td>/usr/bin/</td>
<td>可执行的命令安装目录</td>
</tr>
<tr>
<td>/usr/lib/</td>
<td>程序所使用的函数库保存位置</td>
</tr>
<tr>
<td>/usr/share/doc/</td>
<td>基本的软件使用手册保存位置</td>
</tr>
<tr>
<td>/usr/share/man/</td>
<td>帮助文件保存位置</td>
</tr>
</tbody>
</table>
</div>
<h5 id="源码包安装位置"><a href="#源码包安装位置" class="headerlink" title="源码包安装位置"></a>源码包安装位置</h5><p>安装在指定位置当中,一般是/usr/loca1/软件名/</p>
<h5 id="安装位置不同带来的影响"><a href="#安装位置不同带来的影响" class="headerlink" title="安装位置不同带来的影响"></a>安装位置不同带来的影响</h5><p>RPM包安装的服务可以使用系统服务管理命令(service)来管理,例如RPM包安装的apache的启动方法是:</p>
<ol>
<li>/etc/rc.d/init.d/httpd start    (方法1)</li>
<li>service httpd start    (方法2)</li>
</ol>
<p>而源码包安装的服务则不能被服务管理命令管理,因为没有安装到默认路径中.所以只能用绝对路径进行服务的管理,如:</p>
<ul>
<li>/usr/1oca1/apache2/bin/apachectl start</li>
</ul>
<h4 id="源码包安装过程"><a href="#源码包安装过程" class="headerlink" title="源码包安装过程"></a>源码包安装过程</h4><p>RPM包安装和源码包安装并不冲突(以apache为例)</p>
<h5 id="1-安装准备"><a href="#1-安装准备" class="headerlink" title="1.安装准备"></a>1.安装准备</h5><ol>
<li>安装gcc编译器</li>
<li>下载源码包</li>
</ol>
<h5 id="2-安装注意事项"><a href="#2-安装注意事项" class="headerlink" title="2.安装注意事项"></a>2.安装注意事项</h5><ul>
<li>源代码保存位置: /usr/local/src/</li>
<li>软件安装位置: /usr/local/</li>
<li>如何确定安装过程报错:<ul>
<li>安装过程停止</li>
<li>并出现error、warning或no的提示</li>
</ul>
</li>
</ul>
<h5 id="3-源码包安装过程"><a href="#3-源码包安装过程" class="headerlink" title="3.源码包安装过程"></a>3.源码包安装过程</h5><ol>
<li><p>解压下载的源码包</p>
</li>
<li><p>进入解压目录(INSTALL是安装说明,README是使用说明)</p>
</li>
<li><p>./configure —prefix=/usr/local/apache2(指定安装路径)</p>
<p>./configure  软件配置与检查</p>
<ul>
<li>定义需要的功能选项</li>
<li>检测系统环境是否符合安装要求</li>
<li>把定义好的功能选项和检测系统环境的信息都写入Makefile文件,用于后续的编辑</li>
</ul>
</li>
<li><p>make    编译</p>
</li>
<li><p>make install   编译安装(向真正的安装目录写入数据)</p>
</li>
<li><p>/usr/1oca1/apache2/bin/apachectl start    启动</p>
</li>
</ol>
<p>./configure和make都不会向真正的指定安装位置写任何数据,如果这两步报错不用删除软件包,只需执行make clean,清空编译产生的临时文件</p>
<h4 id="源码包的卸载"><a href="#源码包的卸载" class="headerlink" title="源码包的卸载"></a>源码包的卸载</h4><p>不需要卸载命令,直接删除安装目录即可,不会遗留任何垃圾文件.</p>
<h3 id="脚本安装包"><a href="#脚本安装包" class="headerlink" title="脚本安装包"></a>脚本安装包</h3><h4 id="脚本安装包简介"><a href="#脚本安装包简介" class="headerlink" title="脚本安装包简介"></a>脚本安装包简介</h4><ul>
<li>脚本安装包并不是独立的软件包类型,常见安装的是源码包</li>
<li>是人为把安装过程写成了自动安装的脚本,只要执行脚本,定义简单的参数,就可以完成安装</li>
<li>非常类似于Windows下软件的安装方式</li>
<li>主要是安装驱动</li>
</ul>
<h4 id="脚本安装包安装过程"><a href="#脚本安装包安装过程" class="headerlink" title="脚本安装包安装过程"></a>脚本安装包安装过程</h4><ol>
<li>下载脚本安装包</li>
<li>解压脚本安装包</li>
<li>进入解压目录</li>
<li>./setup.sh</li>
<li>可能会询问一些可选的选项(回车-&gt;默认),Ctrl+退格删除输入错误的字符</li>
</ol>
<h2 id="用户和用户组管理"><a href="#用户和用户组管理" class="headerlink" title="用户和用户组管理"></a>用户和用户组管理</h2><h3 id="用户配置文件"><a href="#用户配置文件" class="headerlink" title="用户配置文件"></a>用户配置文件</h3><h4 id="用户管理简介"><a href="#用户管理简介" class="headerlink" title="用户管理简介"></a>用户管理简介</h4><ul>
<li>越是对安全性要求高的服务器,越需要建立合理的用户权限等级制度和服务器操作规范</li>
<li>在Linux中主要是通过用户配置文件来查看和修改用户信息</li>
</ul>
<h4 id="用户信息文件"><a href="#用户信息文件" class="headerlink" title="用户信息文件"></a>用户信息文件</h4><p>用户信息文件/etc/passwd(使用man 5 passwd查看[注意:是文件名而不是绝对路径])(用冒号分开),7个字段</p>
<ol>
<li>第1字段: 用户名称</li>
<li>第2字段: 密码标志(x表示有密码,否则只允许本机登录,禁用ssh)</li>
<li><p>第3字段: UID (用户ID)</p>
<ul>
<li>0: 超级用户</li>
<li>1-499:系统用户(伪用户,不能登录,不能删除)</li>
<li>500-65535:普通用户</li>
</ul>
</li>
<li>第4字段: GID (用户初始组ID)</li>
<li>第5字段: 用户说明(备注)</li>
<li>第6字段: 家目录<ul>
<li>普通用户: /home/用户名/</li>
<li>超级用户: /root/</li>
</ul>
</li>
<li>第7字段: 登录之后的Shell</li>
</ol>
<h5 id="初始组和附加组"><a href="#初始组和附加组" class="headerlink" title="初始组和附加组"></a>初始组和附加组</h5><ul>
<li>初始组:就是指用户一登录就立刻拥有这个用户组的相关权限,每个用户的初始组必须有且只能有一个,一般就是和这个用户的用户名相同的组名作为这个用户的初始组</li>
<li>附加组:指用户可以加入多个其他的用户组,并拥有这些组的权限,附加组可以有多个</li>
</ul>
<h4 id="用户密码文件-影子文件"><a href="#用户密码文件-影子文件" class="headerlink" title="用户密码文件(影子文件)"></a>用户密码文件(影子文件)</h4><p>影子文件/etc/shadow(权限为000)(用冒号分隔),9个字段</p>
<ol>
<li>第1字段: 用户名称</li>
<li>第2字段: 加密密码<ul>
<li>加密算法升级为SHA512散列加密算法</li>
<li>如果密码位是”!!”或”*“代表没有密码,不能登录</li>
</ul>
</li>
<li><p>第3字段: 密码最后一次修改日期</p>
<ul>
<li>使用1970年1月1日作为标准时间,每过一天时间戳加1</li>
</ul>
</li>
<li>第4字段: 两次密码的修改间隔时间(和第3字段相比)(多少天后密码才能修改)</li>
<li>第5字段: 密码有效期(和第3字段相比)</li>
<li>第6字段: 密码修改到期前的警告天数(和第5字段相比)</li>
<li>第7字段: 密码过期后的宽限天数(和第5字段相比)(如果不改会禁止登陆)<ul>
<li>0: 代表密码过期后立即失效</li>
<li>-1: 代表密码永远不会失效</li>
</ul>
</li>
<li>第8字段: 账号失效时间<ul>
<li>要用时间戳表示</li>
</ul>
</li>
<li>第9字段: 保留</li>
</ol>
<h5 id="时间戳换算"><a href="#时间戳换算" class="headerlink" title="时间戳换算"></a>时间戳换算</h5><p>把时间戳换算为日期:</p>
<ul>
<li>date -d “1970-01-01 时间戳 days”</li>
</ul>
<p>把日期换算为时间戳:</p>
<ul>
<li>echo $(($(date —date=”日期” +%s)/86400+1))</li>
</ul>
<h4 id="组信息文件"><a href="#组信息文件" class="headerlink" title="组信息文件"></a>组信息文件</h4><p>组信息文件/etc/group,4个字段</p>
<ol>
<li>第1字段: 组名称</li>
<li>第2字段: 组密码标志(x)</li>
<li><p>第3字段: GID (初始组ID)</p>
</li>
<li><p>第4字段: 组中附加用户</p>
</li>
</ol>
<h4 id="组密码文件"><a href="#组密码文件" class="headerlink" title="组密码文件"></a>组密码文件</h4><p>组密码文件/etc/gshadow,4个字段</p>
<ol>
<li>第1字段: 组名称</li>
<li>第2字段: 组密码</li>
<li>第3字段: 组管理员用户名</li>
<li>第4字段: 组中附加用户</li>
</ol>
<h3 id="用户管理相关文件"><a href="#用户管理相关文件" class="headerlink" title="用户管理相关文件"></a>用户管理相关文件</h3><h4 id="用户家目录"><a href="#用户家目录" class="headerlink" title="用户家目录"></a>用户家目录</h4><ul>
<li>普通用户: /home/用户名/,所有者和所属组都是此用户,权限是700</li>
<li>超级用户: /root/, 所有者和所属组都是root用户,权限是550</li>
</ul>
<p>把普通用户变为超级用户可以修改UID,但家目录保持不变</p>
<h4 id="用户邮箱"><a href="#用户邮箱" class="headerlink" title="用户邮箱"></a>用户邮箱</h4><p>/var/spool/mail/用户名/</p>
<h4 id="用户模板目录"><a href="#用户模板目录" class="headerlink" title="用户模板目录"></a>用户模板目录</h4><p>/etc/skel/</p>
<p>创建新用户时,新用户家目录会包含这些模板</p>
<h3 id="用户管理命令-1"><a href="#用户管理命令-1" class="headerlink" title="用户管理命令"></a>用户管理命令</h3><h4 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h4><p>useradd [选项] 用户名</p>
<p>选项:<br>    -u UID               添加用户并指定用户的UID号<br>    -d 家目录          添加用户并指定用户的家目录<br>    -c 用户说明      添加用户并指定用户的说明<br>    -g 组名              添加用户并指定用户的初始组<br>    -G 组名             添加用户并指定用户的附加组(指定多个附加组用逗号分隔)<br>    -s shell              添加用户并指定用户的登录shell,默认是/bin/bash</p>
<h5 id="用户默认值文件"><a href="#用户默认值文件" class="headerlink" title="用户默认值文件"></a>用户默认值文件</h5><p>/etc/default/useradd</p>
<ul>
<li>GROUP=100            #用户默认组</li>
<li>HOME=/home        #用户家目录</li>
<li>INACTIVE=-1          #密码过期宽限天数(shadow文件第7字段)</li>
<li>EXPIRE=                   #密码失效时间(shadow文件第8字段)</li>
<li>SHELL=/bin/bash    #默认shell</li>
<li>SKEL=/etc/skel         #模板目录</li>
<li>CREATE_MAIL_SPOOL=yes    #是否建立邮箱</li>
</ul>
<p>/etc/login.defs</p>
<ul>
<li>PASS_MAX_DAYS 99999              #密码有效期(5)</li>
<li>PASS_MIN_DAYS 0                        #密码修改间隔(4)</li>
<li>PASS_MIN_LEN 5                          #密码最小5位(PAM)</li>
<li>PASS_WARN_AGE 7                      #密码到期警告(6)</li>
<li>UID_MIN        500                          #最小UID范围</li>
<li>GID_MAX      60000                       #最大UID范围</li>
<li>ENCRYPT_METHOD SHA512    #密码加密模式</li>
</ul>
<h4 id="修改用户密码"><a href="#修改用户密码" class="headerlink" title="修改用户密码"></a>修改用户密码</h4><p>passwd [选项] 用户名</p>
<p>选项:<br>    -S  查询用户密码的密码状态,仅root用户可用<br>    -l  暂时锁定用户,仅root用户可用(实际是在/etc/shadow中加密密码前添加!!)<br>    -u  解锁用户,仅root用户可用<br>    --stdin  可以通过管道符输出的数据作为用户的密码</p>
<p>root和普通用户可以使用passwd修改自己的密码,root也可以修改其他用户的密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;123&quot; | passwd --stdin user   &#x2F;&#x2F;将123作为用户user的密码</span><br></pre></td></tr></table></figure>
<h4 id="修改用户信息"><a href="#修改用户信息" class="headerlink" title="修改用户信息"></a>修改用户信息</h4><p>usermod [选项] 用户名</p>
<p>选项:<br>    -u UID               手工修改已存在用户的UID号<br>    -d 家目录          手工修改已存在用户的家目录<br>    -c 用户说明      手工修改已存在用户的说明<br>    -g 组名              手工修改已存在用户的初始组<br>    -G 组名             手工修改已存在用户的附加组(指定多个附加组用逗号分隔)<br>    -s shell              手工修改已存在用户的登录shell,默认是/bin/bash<br>    -L                       临时锁定已存在用户(Lock)<br>    -U                       解锁已存在用户锁定(Unlock)</p>
<p>usermod语法与useradd基本类似,usermod是修改已存在用户的信息,而useradd是添加一个新用户并修改相关信息(/etc/passwd)</p>
<h4 id="修改用户密码状态"><a href="#修改用户密码状态" class="headerlink" title="修改用户密码状态"></a>修改用户密码状态</h4><p>chage [选项] 用户名</p>
<p>选项:<br>    -l                   列出用户的详细密码状态<br>    -d 日期         修改密码最后一次更改日期(shadow3字段)<br>    -m 天数        两次密码修改间隔(4字段)<br>    -M 天数        密码有效期(5字段)<br>    -W 天数        密码过期前警告天数(6字段)<br>    -I 天数           密码过后宽限天数(7字段)<br>    -E 日期          账号失效时间(8字段)</p>
<p>(修改的是/etc/shadow)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chage -d 0 user   &#x2F;&#x2F;user登录后要求修改密码</span><br></pre></td></tr></table></figure>
<h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><p>userdel [-r] 用户名</p>
<p>选项:<br>    -r        删除用户的同时删除用户家目录</p>
<p>手工删除用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">手工删除用户user</span><br><span class="line">vi &#x2F;etc&#x2F;passwd    前4条命令是删除文件中与user相关的语句</span><br><span class="line">vi &#x2F;etc&#x2F;shadow</span><br><span class="line">vi &#x2F;etc&#x2F;group</span><br><span class="line">vi &#x2F;etc&#x2F;gshadow</span><br><span class="line">rm -rf &#x2F;var&#x2F;spool&#x2F;mail&#x2F;user</span><br><span class="line">rm -rf &#x2F;home&#x2F;user&#x2F;</span><br></pre></td></tr></table></figure>
<h4 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h4><p>su [选项] 用户名</p>
<p>选项:<br>    -                       选项只使用”-“代表连带用户的环境变量一起切换(这个不能省)<br>    -c 命令            仅执行一次命令,而不切换用户身份</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su -root -c &quot;useradd user&quot;  &#x2F;&#x2F;不切换成root,但是借助root执行useradd命令添加user用户</span><br></pre></td></tr></table></figure>
<h4 id="查看用户ID"><a href="#查看用户ID" class="headerlink" title="查看用户ID"></a>查看用户ID</h4><p>id 用户名</p>
<p>uid(用户id),gid(初始组id),group(附加组id)</p>
<h3 id="用户组管理命令"><a href="#用户组管理命令" class="headerlink" title="用户组管理命令"></a>用户组管理命令</h3><h4 id="添加用户组"><a href="#添加用户组" class="headerlink" title="添加用户组"></a>添加用户组</h4><p>groupadd [选项] 组名</p>
<p>选项:<br>    -g GID        指定组id(不加默认从500依次往后排)</p>
<h4 id="修改用户组"><a href="#修改用户组" class="headerlink" title="修改用户组"></a>修改用户组</h4><p>groupmod  [选项] 组名</p>
<p>选项:<br>    -g GID                           修改已存在组的组id<br>    -n 新组名 老组名        修改组名</p>
<h4 id="删除用户组"><a href="#删除用户组" class="headerlink" title="删除用户组"></a>删除用户组</h4><p>groupdel 组名</p>
<p>组中有初始用户则不能删除(必须先删除初始用户再删除组),组中只有附加用户则可以删除</p>
<h4 id="把用户添加入组或从组中删除"><a href="#把用户添加入组或从组中删除" class="headerlink" title="把用户添加入组或从组中删除"></a>把用户添加入组或从组中删除</h4><p>gpasswd 选项 组名</p>
<p>选项:<br>    -a 用户名      把用户加入组(附加用户)<br>    -d 用户名      把用户从组中删除</p>
<h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><h3 id="ACL权限"><a href="#ACL权限" class="headerlink" title="ACL权限"></a>ACL权限</h3><p>任何文件只能有一个所属组;当所有者,所属组,其他人身份不够用时,要用到ACL权限给用户分配权限</p>
<h4 id="ACL权限简介与开启"><a href="#ACL权限简介与开启" class="headerlink" title="ACL权限简介与开启"></a>ACL权限简介与开启</h4><h5 id="查看分区是否支持ACL权限"><a href="#查看分区是否支持ACL权限" class="headerlink" title="查看分区是否支持ACL权限"></a>查看分区是否支持ACL权限</h5><p>默认都支持,保险起见查一下</p>
<p>dumpe2fs -h 分区</p>
<h1 id="dumpe2fs命令是查询指定分区详细文件系统信息的命令-使用df-h查看分区信息-查看Default-mount-options处是否支持ACL"><a href="#dumpe2fs命令是查询指定分区详细文件系统信息的命令-使用df-h查看分区信息-查看Default-mount-options处是否支持ACL" class="headerlink" title="dumpe2fs命令是查询指定分区详细文件系统信息的命令(使用df -h查看分区信息),查看Default mount options处是否支持ACL"></a>dumpe2fs命令是查询指定分区详细文件系统信息的命令(使用df -h查看分区信息),查看Default mount options处是否支持ACL</h1><p>选项:<br>    -h             仅显示超级块中信息,而不显示磁盘块组的详细信息</p>
<h5 id="临时开启分区ACL权限"><a href="#临时开启分区ACL权限" class="headerlink" title="临时开启分区ACL权限"></a>临时开启分区ACL权限</h5><p>mount -o remount,acl</p>
<h1 id="重新挂载根分区-并挂载加入acl权限-o表示支持特殊挂载选项-remount重新挂载"><a href="#重新挂载根分区-并挂载加入acl权限-o表示支持特殊挂载选项-remount重新挂载" class="headerlink" title="重新挂载根分区,并挂载加入acl权限(-o表示支持特殊挂载选项,remount重新挂载)"></a>重新挂载根分区,并挂载加入acl权限(-o表示支持特殊挂载选项,remount重新挂载)</h1><h5 id="永久开启分区ACL权限"><a href="#永久开启分区ACL权限" class="headerlink" title="永久开启分区ACL权限"></a>永久开启分区ACL权限</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;fstab    #(fstab是系统开机自动挂载文件,改这个文件要谨慎)在UUID的defaults后面添加&quot;,acl&quot;,保存并重启   </span><br><span class="line">#如果不重启,将根分区重新挂载</span><br><span class="line">mount -o remount &#x2F;      #将根分区重新挂载</span><br></pre></td></tr></table></figure>
<h4 id="查看与设定ACL权限"><a href="#查看与设定ACL权限" class="headerlink" title="查看与设定ACL权限"></a>查看与设定ACL权限</h4><h5 id="查看ACL权限"><a href="#查看ACL权限" class="headerlink" title="查看ACL权限"></a>查看ACL权限</h5><p>getfacl 文件名       #查看ACL权限(不支持绝对路径,但不影响执行)</p>
<h5 id="设定ACL权限"><a href="#设定ACL权限" class="headerlink" title="设定ACL权限"></a>设定ACL权限</h5><p>setfacl 选项 文件名</p>
<p>选项:<br>    -m          设定ACL权限<br>    -x            删除指定的ACL权限<br>    -b            删除所有的ACL权限<br>    -d            设定默认ACL权限<br>    -k            删除默认ACL权限<br>    -R           递归设定ACL权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setfacl -m u:用户名:权限 文件名或目录    #其中u代表用户,g代表组</span><br><span class="line">setfacl -m u:user:rx &#x2F;project&#x2F;</span><br></pre></td></tr></table></figure>
<p>用ll命令查看会多个加号</p>
<h4 id="最大有效权限与删除ACL权限"><a href="#最大有效权限与删除ACL权限" class="headerlink" title="最大有效权限与删除ACL权限"></a>最大有效权限与删除ACL权限</h4><h5 id="最大有效权限mask"><a href="#最大有效权限mask" class="headerlink" title="最大有效权限mask"></a>最大有效权限mask</h5><p>mask是用来指定最大有效权限的.如果给用户赋予了ACL权限,是需要和mask的权限“相与”才能得到用户的真正权限</p>
<p>以读权限(r)为例</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>and</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>r</td>
<td>r</td>
</tr>
<tr>
<td>r</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>-</td>
<td>r</td>
<td>-</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<h6 id="修改最大有效权限"><a href="#修改最大有效权限" class="headerlink" title="修改最大有效权限"></a>修改最大有效权限</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setfacl -m m:权限 文件名或目录  #m表示最大有效权限mask(修改后可能会多出#effective注释,代表实际权限)</span><br></pre></td></tr></table></figure>
<h5 id="删除ACL权限"><a href="#删除ACL权限" class="headerlink" title="删除ACL权限"></a>删除ACL权限</h5><p>方法一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setfacl -x u:用户名 文件名或目录     #删除指定用户的ACL权限</span><br><span class="line">setfacl -x g:组名 文件名或目录      #删除指定用户组的ACL权限</span><br></pre></td></tr></table></figure>
<p>方法二</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setfacl -b 文件名或目录      #删除所有的ACL权限</span><br></pre></td></tr></table></figure>
<h4 id="默认ACL权限与递归ACL权限"><a href="#默认ACL权限与递归ACL权限" class="headerlink" title="默认ACL权限与递归ACL权限"></a>默认ACL权限与递归ACL权限</h4><h5 id="默认ACL权限"><a href="#默认ACL权限" class="headerlink" title="默认ACL权限"></a>默认ACL权限</h5><ul>
<li>默认ACL权限的作用是如果给父目录设定了默认ACL权限,那么父目录中所有新建的子文件都会继承父目录的ACL权限</li>
<li>setfacl -m d:u:用户名:权限 目录  (d表示设定默认ACL权限)</li>
</ul>
<h5 id="递归ACL权限"><a href="#递归ACL权限" class="headerlink" title="递归ACL权限"></a>递归ACL权限</h5><ul>
<li>递归是父目录在设定ACL权限时,所有的子文件和子目录也会拥有相同的ACL权限</li>
<li>setfacl -m u:用户名:权限 -R 目录  </li>
</ul>
<h3 id="文件特殊权限"><a href="#文件特殊权限" class="headerlink" title="文件特殊权限"></a>文件特殊权限</h3><h4 id="SetUID"><a href="#SetUID" class="headerlink" title="SetUID"></a>SetUID</h4><h5 id="SetUID的功能"><a href="#SetUID的功能" class="headerlink" title="SetUID的功能"></a>SetUID的功能</h5><ul>
<li>只有可以执行的二进制程序才能设定SUID权限(才有意义)</li>
<li>命令执行者要对该程序拥有x(执行)权限</li>
<li>命令执行者在执行该程序时获得该程序文件属主的身份(在执行程序的过程中灵魂附体为文件的属主)</li>
<li>SetUID权限只在该程序执行过程中有效,也就是说身份改变只在程序执行过程中有效</li>
<li>在所有者(u)范围拥有s权限(超级用户)</li>
<li>passwd命令拥有SetUID权限,所以普通可以修改自己的密码</li>
<li>cat命令没有SetUID权限,所以普通用户不能查看/etc/shadow文件内容</li>
</ul>
<h5 id="设定SetUID的方法"><a href="#设定SetUID的方法" class="headerlink" title="设定SetUID的方法"></a>设定SetUID的方法</h5><ol>
<li>chmod 4755 文件名     #4代表SUID,2代表SGID,1代表SBIT</li>
<li>chmod u+s 文件名     </li>
</ol>
<p>如果命令执行者对该程序没有x(执行)权限,设定后的s权限为S(大写),此时SUID不能生效</p>
<h5 id="取消SetUID的方法"><a href="#取消SetUID的方法" class="headerlink" title="取消SetUID的方法"></a>取消SetUID的方法</h5><ol>
<li>chmod 755 文件名</li>
<li