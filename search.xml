<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo的next主题实现双语功能</title>
    <url>/article/99e78227.html</url>
    <content><![CDATA[<h1 id="Hexo的next主题实现双语功能"><a href="#Hexo的next主题实现双语功能" class="headerlink" title="Hexo的next主题实现双语功能"></a>Hexo的next主题实现双语功能</h1><a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前不久,给博客添加了Google Analytics,通过数据显示,发现我这小破站寥寥无几的流量大部分竟然是国外朋友贡献的,心中便想着将博客国际化—-搞个英文版本.说干就干,经过我的一番折腾,终于给搞出来了,但我要说明一下文章的内容是要自己转换为英文,具体效果大家可以点击下面链接前往查看</p>
<p><a href="https://en.idefun.com/" class="LinkCard" target="_blank">英文版本</a></p>
<h2 id="诉求"><a href="#诉求" class="headerlink" title="诉求"></a>诉求</h2><p>首先说说我对英文网站的诉求:</p>
<ol>
<li>英文网站要与原网站的结构外观基本保持一致(我看到有的小伙伴直接换支持双语的主题了,我可不想让自己的心血白流)</li>
<li>我希望原网站和英文网站有个切换按钮,很容易切换</li>
</ol>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>在hexo本地目录创建英文文件夹(名字自定义),我的是en</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320154606919.png" alt=""></p>
<p>复制hexo目录的内容(node_modules除外)到en文件夹,复制后en文件夹如下</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320154912791.png" alt=""></p>
<p>安装相关插件,在en文件夹使用命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>修改en文件夹中_config.yml文件,将下图中的language改为en,可以比对着hexo本地目录的_config.yml文件将中文改为相应的英文(如下图的title,subtitle等)</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320155305119.png" alt=""></p>
<p>修改hexo目录next主题配置文件_config.yml文件,找到menu字段,增添language菜单,注意链接要换成自己的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">language: https:&#x2F;&#x2F;en.idefun.com&#x2F; || fa fa-language</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320155819757.png" alt=""></p>
<p>修改next主题文件夹下的languages中的zh-CN.yml,找到menu,添加language:English</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320160213558.png" alt=""></p>
<p>可以在hexo目录使用hexo s查看效果</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320160423212.png" alt=""></p>
<p>同理,修改en文件夹中next主题配置文件_config.yml文件,找到menu字段,增添中文菜单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">中文: https:&#x2F;&#x2F;www.idefun.com&#x2F; || fa fa-language</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320160547373.png" alt=""></p>
<p>修改en文件夹下themes中next主题文件夹下的languages中的en.yml,找到menu,添加language:中文</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320160801285.png" alt=""></p>
<p>可以在en目录使用hexo s查看效果</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320160357274.png" alt=""></p>
<h3 id="部署配置"><a href="#部署配置" class="headerlink" title="部署配置"></a>部署配置</h3><p>下面提供两种部署方法,第一种不用再创建仓库,第二种要再创建仓库,若想要给英文博客绑定域名建议选择第二种,关于创建仓库及打开github page就不多说了</p>
<h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>在en文件夹生成英文博客,并将生成的public文件夹中的内容复制到hexo目录下的public文件夹中的en文件夹,推送时只需在hexo目录下推送</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>使用下面命令即可实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; cd en &amp;&amp;  hexo clean &amp;&amp; hexo g &amp;&amp; cd ..&#x2F; &amp;&amp; cp -r en&#x2F;public&#x2F;. public&#x2F;en&#x2F; &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<p>可以写成shell脚本,我这里提供一份简单的脚本供大家参考</p>
<p><a href="https://idefun.lanzous.com/i4cz6n4ov7e" class="LinkCard">点击下载</a></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320162843893.png" alt=""></p>
<p>下载后改后缀为sh即可双击运行</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320162956255.png" alt=""></p>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p>在en文件夹生成英文博客,将生成英文博客推送到一个新的仓库,需要分别推送,可以编写相应脚本来简化操作</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><p>修改en文件夹在_config.yml文件,找到deploy字段,修改为自己的仓库即可</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320163232780.png" alt=""></p>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>为大家提供一种思路,希望有帮助</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows10下搭建汇编语言开发环境</title>
    <url>/article/11317.html</url>
    <content><![CDATA[<h1 id="Windows10下搭建汇编语言开发环境"><a href="#Windows10下搭建汇编语言开发环境" class="headerlink" title="Windows10下搭建汇编语言开发环境"></a>Windows10下搭建汇编语言开发环境</h1><a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本学期学校安排有汇编语言这门课,需要自己搭建汇编语言开发环境,特此写下本文记录搭建过程.</p>
<p>关于搭建汇编语言开发环境的教程,我也找了许多,可看下来却依旧一头雾水,经过本人摸索,同时结合网上教程,欲写下这篇易懂的文章.</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="1-下载DOSBox"><a href="#1-下载DOSBox" class="headerlink" title="1.下载DOSBox"></a>1.下载DOSBox</h3><p>工具介绍:DOSBox是一个DOS模拟程序,由于它采用的是SDL库,所以可以很方便的移植到其他的平台.目前,DOSBox已经支持在Windows、Linux、Mac OS X、BeOS 、palmOS、Android 、webOS、os/2等系统中运行.不少DOS下的游戏都可以直接在该平台上运行.</p>
<p>工具官网:</p>
<p><a href="http://www.dosbox.com/" class="LinkCard" target="_blank">工具官网</a></p>
<p>项目主页：</p>
<p><a href="http://sourceforge.net/projects/dosbox" class="LinkCard" target="_blank">项目主页</a></p>
<p>下载链接1(32位):</p>
<p><a href="http://sourceforge.net/projects/dosbox/files/dosbox/0.74/DOSBox0.74-win32-installer.exe/download/" class="LinkCard" target="_blank">下载链接1</a></p>
<p>下载链接2(这个是我下载好的,可能会快一点):</p>
<p><a href="https://idefun.lanzous.com/i91Xpm4qzyb" class="LinkCard">下载链接2</a></p>
<h3 id="2-下载汇编工具包"><a href="#2-下载汇编工具包" class="headerlink" title="2.下载汇编工具包"></a>2.下载汇编工具包</h3><p>下载链接:</p>
<p><a href="https://idefun.lanzous.com/i4TQgm4zjkf/" class="LinkCard" target="_blank">下载链接</a></p>
<p>汇编工具截图</p>
<p><img src="https://i.loli.net/2021/02/25/vmXynkcD7V3bwEe.png" alt=""></p>
<h2 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h2><h3 id="1-安装DOSBox"><a href="#1-安装DOSBox" class="headerlink" title="1.安装DOSBox"></a>1.安装DOSBox</h3><p>双击运行DOSBox安装程序</p>
<p><img src="https://i.loli.net/2021/02/25/X7F4cripOvBg1ex.png" alt=""></p>
<p>点击next</p>
<p><img src="https://i.loli.net/2021/02/25/QXCsuzLV2YNwFBJ.png" alt=""></p>
<p>点击next</p>
<p><img src="https://i.loli.net/2021/02/25/Tr6jgH7u5XQElVD.png" alt=""></p>
<p>选择安装位置(我选择都是D:\DOSBox)然后点击install即可</p>
<p><img src="https://i.loli.net/2021/02/25/37Nqut1AGRfmYyx.png" alt=""></p>
<p>安装位置要记得,后面要用</p>
<h3 id="2-创建工作目录"><a href="#2-创建工作目录" class="headerlink" title="2.创建工作目录"></a>2.创建工作目录</h3><p>安装完毕创建一个工作目录(目录位置及目录名可自定义)</p>
<p>我的是在D:/DOSBox/Debug</p>
<p><img src="https://i.loli.net/2021/02/25/mGS1D2g8eMP6Bpx.png" alt=""></p>
<p>之后再在Debug下创建两个文件夹ASM(放自己写的汇编程序)和MASM(放汇编工具)</p>
<p><img src="https://i.loli.net/2021/02/25/OWEklSHxi1BeqbM.png" alt=""></p>
<p>将汇编工具放入MASM文件夹</p>
<p><img src="https://i.loli.net/2021/02/25/doXaBf7hCV4MmjH.png" alt=""></p>
<h3 id="3-挂载工作目录"><a href="#3-挂载工作目录" class="headerlink" title="3.挂载工作目录"></a>3.挂载工作目录</h3><p>打开DOSBox安装目录(我的在D:\DOSBox)</p>
<p><img src="https://i.loli.net/2021/02/25/5GCfg6hOt8UHvbi.png" alt=""></p>
<p>打开后找到DOSBox 0.74 Options.bat这个批处理文件</p>
<p><img src="https://i.loli.net/2021/02/25/b15TdjRzCasUB8c.png" alt=""></p>
<p>直接双击运行会出现一个记事本</p>
<p><img src="https://i.loli.net/2021/02/25/pJPAUlga1SRvuse.png" alt=""></p>
<p>使用快捷键Ctrl+F查找其中的[autoexec]部分(一般在文件末尾)</p>
<p><img src="https://i.loli.net/2021/02/25/PFvrz5jt4GAaDQb.png" alt=""></p>
<p>在文件中添加下列内容并保存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MOUNT F D:\DOSBox\Debug</span><br><span class="line">set PATH&#x3D;%PATH%;F:\MASM;</span><br><span class="line">F:</span><br><span class="line">cd F:\ASM</span><br><span class="line">cls</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210302185912863.png" alt=""></p>
<p>命令解释:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#挂载工作目录挂载到虚拟盘符F(虚拟盘符可自定义,命令不区分大小写)</span><br><span class="line">MOUNT F D:\DOSBox\Debug</span><br><span class="line">#添加系统临时变量(此时的F代表的是D:\DOSBox\Debug）</span><br><span class="line">set PATH&#x3D;%PATH%;F:\MASM; </span><br><span class="line">#转到F盘符</span><br><span class="line">F:</span><br><span class="line">#切换到F:\ASM目录</span><br><span class="line">cd F:\ASM</span><br><span class="line">#执行一次清屏</span><br><span class="line">cls</span><br></pre></td></tr></table></figure>
<p>如果不加cls,打开会是这样</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/GtgYexwQulLnOKk.png" alt=""></p>
<p>加上cls,打开会是这样(我觉得更美观,依个人喜好)</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210302190118748.png" alt=""></p>
<p>注意:不进行此种配置的话,每次打开DOSBox是需要手动输入上述命令,非常麻烦</p>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><h3 id="DOSBox常用快捷键"><a href="#DOSBox常用快捷键" class="headerlink" title="DOSBox常用快捷键"></a>DOSBox常用快捷键</h3><div class="table-container">
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Alt+Enter</td>
<td>切换全屏</td>
</tr>
<tr>
<td>Ctr+F1</td>
<td>改变键盘映射</td>
</tr>
<tr>
<td>Alt+Pause</td>
<td>暂停模拟</td>
</tr>
<tr>
<td>Ctrl+Alt+F5</td>
<td>开始/停止录制视频</td>
</tr>
<tr>
<td>Ctrl+F4</td>
<td>交换挂载的磁盘映像,也就是更新磁盘文件</td>
</tr>
<tr>
<td>Ctrl+F5</td>
<td>截图</td>
</tr>
<tr>
<td>Ctrl+F6</td>
<td>开始/停止录制声音</td>
</tr>
<tr>
<td>Ctrl+F7</td>
<td>减少跳帧</td>
</tr>
<tr>
<td>Ctrl+F8</td>
<td>增加跳帧</td>
</tr>
<tr>
<td>Ctrl+F9</td>
<td>关闭DOSBOX</td>
</tr>
<tr>
<td>Ctrl+F10</td>
<td>捕捉/释放鼠标</td>
</tr>
<tr>
<td>Ctrl+F11</td>
<td>模拟减速</td>
</tr>
<tr>
<td>Ctrl+F12</td>
<td>加速模拟</td>
</tr>
<tr>
<td>Alt+F12</td>
<td>不锁定速</td>
</tr>
</tbody>
</table>
</div>
<p>注意:以上快捷键我并没有全部测试,更多详细信息参见README.txt(在DOSBox安装目录中的Documentation里面)</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228111902877.png" alt=""></p>
<h3 id="调整窗口大小"><a href="#调整窗口大小" class="headerlink" title="调整窗口大小"></a>调整窗口大小</h3><p>初始的界面很小,且不能直接拉伸界面,所以有需要的可以按照下面的方法调整一下<br>双击打开DOSBox 0.74 Options.bat</p>
<p>使用快捷键Ctrl+F查找windowresolution字段</p>
<p><img src="https://i.loli.net/2021/02/25/8hrbIxNBJZQ723k.png" alt=""></p>
<p>将</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">windowresolution&#x3D;original</span><br><span class="line">output&#x3D;surface</span><br></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">windowresolution&#x3D;800x500  #800x500为自定义大小,可修改</span><br><span class="line">output&#x3D;opengl </span><br></pre></td></tr></table></figure>
<p>注意:不用删除原来的语句,在前面加上#注释掉即可</p>
<p><img src="https://i.loli.net/2021/02/25/YZwN2LOQPTuG8Wv.png" alt=""></p>
<p>保存后,重启DOSBox生效</p>
<h3 id="创建并编辑文件"><a href="#创建并编辑文件" class="headerlink" title="创建并编辑文件"></a>创建并编辑文件</h3><p>关于创建并编辑文件,如果你的工作目录(挂载的目录)有EDIT.COM文件(我提供的汇编工具包中有),那么你就可以在DOSBox中创建并编辑文件,如果没有请使用我提供的工具包或者耐心往下看.</p>
<h4 id="使用DOSBox创建并编辑文件-不推荐"><a href="#使用DOSBox创建并编辑文件-不推荐" class="headerlink" title="使用DOSBox创建并编辑文件(不推荐)"></a>使用DOSBox创建并编辑文件(不推荐)</h4><p>打开DOSBox使用下面命令创建并编辑test.asm文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">edit test.asm</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/02/25/ZWr6DIB4qxb9VEd.png" alt=""></p>
<p>回车后进入下面界面即可进行编辑(注意:鼠标箭头只能在编辑器里活动,想将鼠标退出来的话可以用Ctrl+F10组合键退出)</p>
<p><img src="https://i.loli.net/2021/02/25/WYMSUboDf82N7cG.png" alt=""></p>
<h4 id="使用记事本创建并编辑文件-其他编辑器也可以"><a href="#使用记事本创建并编辑文件-其他编辑器也可以" class="headerlink" title="使用记事本创建并编辑文件(其他编辑器也可以)"></a>使用记事本创建并编辑文件(其他编辑器也可以)</h4><p>下面以此种方式创建test.asm文件</p>
<p>新建文本文档,将下面代码复制到里面并保存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">datas segment</span><br><span class="line">buf db&#39;Hello, World!$&#39;</span><br><span class="line">datas ends</span><br><span class="line"></span><br><span class="line">stacks segment stack</span><br><span class="line">db 200 dup(0)</span><br><span class="line">stacks ends</span><br><span class="line"></span><br><span class="line">codes segment</span><br><span class="line">assume cs:codes,ds:datas,ss:stacks</span><br><span class="line">start:</span><br><span class="line">mov ax,datas</span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">mov dx,seg buf</span><br><span class="line">lea dx,buf</span><br><span class="line">mov ah,09h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">mov ah,4ch</span><br><span class="line">int 21h</span><br><span class="line">codes ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/02/25/jrcGQTxs8hgupvU.png" alt=""></p>
<p>之后重命名为test.asm</p>
<p><img src="https://i.loli.net/2021/02/25/lfQUBhXntJYV5qK.png" alt=""></p>
<h3 id="编译调试"><a href="#编译调试" class="headerlink" title="编译调试"></a>编译调试</h3><p>打开DOSBox输入下面命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masm test.asm</span><br></pre></td></tr></table></figure>
<p>回车后会询问文件名,建议直接回车</p>
<p>编译程序提示输入交叉引用文件的名称,这个文件同列表文件一样,是编译器将源程序编译为目标文件过程中产生的中间结果.可以让编译器不生成这个文件,直接按Enter键即可</p>
<p><img src="https://i.loli.net/2021/02/25/VhRfkGB84zJyHAS.png" alt="image-20210225195117402"></p>
<p><img src="https://i.loli.net/2021/02/25/bYF13Vaz48fQ6uM.png" alt=""></p>
<p>可以像上图一样分别输入文件名,打开ASM查看如下</p>
<p><img src="https://i.loli.net/2021/02/25/TEDcVGa7yMz2SXJ.png" alt=""></p>
<p>本文全部默认即不分别输入文件名直接回车</p>
<p><img src="https://i.loli.net/2021/02/25/wfoIpsM62gWbFiz.png" alt=""></p>
<p>打开ASM文件夹查看如下</p>
<p><img src="https://i.loli.net/2021/02/25/TdPkfD7oRp5aZrB.png" alt=""></p>
<p>继续输入命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">link test.obj</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/02/25/d5LQbCi9n1AOPSk.png" alt=""></p>
<p>运行完毕,查看ASM文件夹</p>
<p><img src="https://i.loli.net/2021/02/25/P2G6sZqBlDQvKOE.png" alt=""></p>
<p>继续执行下列命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">debug test.exe</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/02/25/7zr4gBpDmUGi9nx.png" alt=""></p>
<h3 id="debug的简单使用"><a href="#debug的简单使用" class="headerlink" title="debug的简单使用"></a>debug的简单使用</h3><p>debug是Dos、Windows提供的实模式(8086方式)程序的调试工具</p>
<ul>
<li>可以查看CPU各种寄存器的内容</li>
<li>可以查看内存的情况</li>
<li>可以在机器码级别跟踪程序的运行</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>R命令</td>
<td>查看、改变CPU寄存器的内容</td>
</tr>
<tr>
<td>D命令</td>
<td>查看内存中的内容(机器指令形式)(以16进制显示)</td>
</tr>
<tr>
<td>E命令</td>
<td>改写内存中的内容,即提供指令(使用机器指令),用得比较少,多为A命令</td>
</tr>
<tr>
<td>U命令</td>
<td>查看内存中的内容(将机器指令形式转换为汇编指令的形式)(反编译)</td>
</tr>
<tr>
<td>T命令</td>
<td>执行一条汇编(机器)指令(就是执行当前指令缓冲器中的指令)</td>
</tr>
<tr>
<td>A命令</td>
<td>相比较E,以汇编指令形式在内存写入一条机器指令</td>
</tr>
<tr>
<td>P命令</td>
<td>在遇到汇编指令为int xx 时,使用p指令结束(否则CPU会指向一个<br>未知的地址段)</td>
</tr>
<tr>
<td>G命令</td>
<td>执行完exe运行结果显示</td>
</tr>
<tr>
<td>Q命令</td>
<td>退出debug</td>
</tr>
<tr>
<td>?命令</td>
<td>查看指令帮助</td>
</tr>
</tbody>
</table>
</div>
<h4 id="R命令"><a href="#R命令" class="headerlink" title="R命令"></a>R命令</h4><h5 id="查看CPU寄存器的内容"><a href="#查看CPU寄存器的内容" class="headerlink" title="查看CPU寄存器的内容"></a>查看CPU寄存器的内容</h5><p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210301085326154.png" alt=""></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标识名</th>
<th>置位</th>
<th>复位</th>
</tr>
</thead>
<tbody>
<tr>
<td>溢出Overflow(是否)</td>
<td>OV</td>
<td>NV</td>
</tr>
<tr>
<td>向Direction(减量/增量)</td>
<td>DN</td>
<td>UP</td>
</tr>
<tr>
<td>中断Interrupt(允许/屏蔽)</td>
<td>EI</td>
<td>DI</td>
</tr>
<tr>
<td>符号Sign(负正)</td>
<td>NG</td>
<td>PL</td>
</tr>
<tr>
<td>零Zero(是否)</td>
<td>ZR</td>
<td>NZ</td>
</tr>
<tr>
<td>辅助进位Auxiliary Carry(是否)</td>
<td>AC</td>
<td>NA</td>
</tr>
<tr>
<td>奇偶Parity(偶奇)</td>
<td>PE</td>
<td>PO</td>
</tr>
<tr>
<td>进位Carry(是否)</td>
<td>CY</td>
<td>NC</td>
</tr>
</tbody>
</table>
</div>
<h5 id="改变CPU寄存器的内容"><a href="#改变CPU寄存器的内容" class="headerlink" title="改变CPU寄存器的内容"></a>改变CPU寄存器的内容</h5><h6 id="改变寄存器的值"><a href="#改变寄存器的值" class="headerlink" title="改变寄存器的值"></a>改变寄存器的值</h6><p>若要修改一个寄存器中的值,比如AX中的值,可用R命令后加寄存器名来进行,输入”r ax”后按Enter键,将出现”:”作为输入提示,在后面输入要写入的数据后按Enter键(直接按Enter则退出修改),即完成了对AX中内容的修改.若想看一下修改的结果,可再用R命令查看(R命令与寄存器名之间也可以没有空格)</p>
<p><img src="https://i.loli.net/2021/02/25/rOLVwamUWvylcnE.png" alt=""></p>
<h6 id="改变CS-IP的值"><a href="#改变CS-IP的值" class="headerlink" title="改变CS:IP的值"></a>改变CS:IP的值</h6><p><img src="https://i.loli.net/2021/02/25/tdvuEMzlSUHI79C.png" alt=""></p>
<h6 id="改变标志位的值"><a href="#改变标志位的值" class="headerlink" title="改变标志位的值"></a>改变标志位的值</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rf</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210301095739288.png" alt=""></p>
<h4 id="D命令"><a href="#D命令" class="headerlink" title="D命令"></a>D命令</h4><p>使用D命令,可以查看内存中的内容,debug将输出3部分内容：</p>
<ol>
<li>中间是从指定地址开始的128个内存单元的内容,用16进制的格式输出,每行的输出从16的整数倍的地址开始,最多输出16个单元的内容.注意在每行的中间有一个”-“,它将每行的输出分为两部分,这样便于查看</li>
<li>左边是每行的起始地址</li>
<li>右边是每个内存单元中的数据对应的可显示的ASCII码字符.若没有对应可显示的ASCII字符,debug就用”.”来代替</li>
</ol>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228122306758.png" alt=""></p>
<blockquote>
<p>注意,我们看到的内存中的内容,在不同的计算机中是不一样的,也可能每次用<br>Debug看到的内容都不相同,因为我们用Debug看到的都是原来就在内存中的内容,这些内容受随时都有可能变化的系统环境的影响.当然,我们也可以改变内存、寄存器中的内容</p>
</blockquote>
<p>在一进入debug后,用D命令直接查看,将列出debug预设的地址处的内容</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228123326498.png" alt=""></p>
<p>使用d 段地址:偏移地址查看(以d 1000:0为例)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式:d 段地址:偏移地址</span><br><span class="line">使用&quot;d 段地址:偏移地址&quot;的格式来查看,debug将列出从指定内存单元开始的128个内存单元的内容</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228122452594.png" alt=""></p>
<p>在使用”d 段地址:偏移地址”之后,接着使用D命令,可列出后续的内容</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228123739626.png" alt=""></p>
<p>也可以指定D命令的查看范围,此时采用”d 段地址:起始偏移地址 结尾偏移地址”的格式</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228123922247.png" alt=""></p>
<p>若输入的地址不是16的倍数,则输出效果是这样的</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228123042937.png" alt=""></p>
<h4 id="E命令"><a href="#E命令" class="headerlink" title="E命令"></a>E命令</h4><p>改写内存中的内容,但是是以机器指令的形式</p>
<p>将内存1000:0-1000:9单元中的内容分别写为0、1、2、3….、9,可以用”e 段地址:起始地址 数据 数据 数据$\cdots $”的格式来进行</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228132259802.png" alt=""></p>
<p>用E命令以提问的方式来逐个地修改从某一地址开始的内存单元中的内容</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228132759807.png" alt=""></p>
<ul>
<li>红色部分为用户输入的修改的数据,到了某一内存单元的时候,可以选择修改(输入要修改的数值),也可以选择不修改(直接按空格),处理完一个内存单元之后,按空格,继续处理下一个内存单元;全部都处理完毕之后,按enter</li>
</ul>
<p>可以用E命令向内存中写入字符</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228133235259.png" alt=""></p>
<p>也可以用E命令向内存中写入字符串</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228133636393.png" alt=""></p>
<h4 id="U命令"><a href="#U命令" class="headerlink" title="U命令"></a>U命令</h4><p>对机器代码反汇编显示,U命令的显示输出分为3部分,每一条机器指令的地址、机器指令、机器指令所对应的汇编指令</p>
<h5 id="按地址反汇编"><a href="#按地址反汇编" class="headerlink" title="按地址反汇编"></a>按地址反汇编</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">u 地址</span><br></pre></td></tr></table></figure>
<p>该命令从指定地址开始,反汇编32个字节,若地址省略,则从上一个U命令的最后一个指令的下一个单元开始显示32个字节</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210301100802300.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210301100844123.png" alt=""></p>
<h5 id="按范围反汇编"><a href="#按范围反汇编" class="headerlink" title="按范围反汇编"></a>按范围反汇编</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">u 范围</span><br></pre></td></tr></table></figure>
<h4 id="T命令"><a href="#T命令" class="headerlink" title="T命令"></a>T命令</h4><h5 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T [&#x3D;地址] [指令数]</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210309132037512.png" alt=""></p>
<h5 id="使用T命令执行CS-IP指向的指令"><a href="#使用T命令执行CS-IP指向的指令" class="headerlink" title="使用T命令执行CS:IP指向的指令"></a>使用T命令执行CS:IP指向的指令</h5><p>首先用E命令向从1000:0开始的内存单元中写入了8个字节的机器码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e 1000:0 b8 01 00 b9 02 00 01 c8</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>机器码</th>
<th>对应的汇编指令</th>
</tr>
</thead>
<tbody>
<tr>
<td>b80100</td>
<td>mov ax,0001</td>
</tr>
<tr>
<td>b90200</td>
<td>mov cx,0002</td>
</tr>
<tr>
<td>01c8</td>
<td>add ax,cx</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210301075936404.png" alt=""></p>
<p>然后用R命令查看CPU中寄存器的状态,可以看到,CS=0740H、IP=0100H,指向内存0740:0100</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210309112317133.png" alt=""></p>
<p>若要用T命令控制CPU执行我们写到1000:0 的指令,必须先让CS:IP指向1000:0;接着用R命令修改CS、IP中的内容,使CS:IP指向1000:0</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210309113531977.png" alt=""></p>
<p>完成上面的步骤后,就可以使用T命令来执行我们写入的指令了(此时,CS:IP 指向我们的指令所在的内存单元).执行T命令后,CPU执行CS:IP指向的指令,则1000:0处的指令b8 01 00(mov ax,0001)得到执行,指令执行后,Debug 显示输出CPU中寄存器的状态</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210309113809478.png" alt=""></p>
<blockquote>
<p>注意:指令执行后,AX中的内容被改写为1,IP改变为IP+3(因为mov ax,0001的指令长度为3个字节),CS:IP指向下一条指令</p>
</blockquote>
<p>继续使用T命令执行下面的指令</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210309114535239.png" alt=""></p>
<blockquote>
<p>用T命令继续执行后面的指令,注意每条指令执行后,CPU相关寄存器内容的变化</p>
</blockquote>
<h4 id="A命令"><a href="#A命令" class="headerlink" title="A命令"></a>A命令</h4><p>使用E命令写入机器指令很不方便,最好能直接以汇编指令的形式写入指令.为此,Debug 提供了A命令,A命令以汇编指令的形式在内存中写入机器指令</p>
<p>首先用A命令,以汇编语言向从1000:0开始的内存单元中写入了几条指令,然后用D命令查看A命令的执行结果</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210309115331666.png" alt=""></p>
<p>可以看到,在使用A命令写入指令时,我们输入的是汇编指令,Debug将这些汇编指令翻译为对应的机器指令,将它们的机器码写入内存</p>
<blockquote>
<p>使用A命令写入汇编指令时,在给出的起始地址后直接按Enter键表示操作结束</p>
</blockquote>
<p>若A命令后不跟地址,则从预设地址开始输入指令</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210309115602136.png" alt=""></p>
<h4 id="命令"><a href="#命令" class="headerlink" title="?命令"></a>?命令</h4><p>输入?查看更多命令</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228112817615.png" alt=""></p>
<p>结果如下:</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228112748762.png" alt=""></p>
]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习笔记</title>
    <url>/article/34487.html</url>
    <content><![CDATA[<h1 id="Linux学习笔记"><a href="#Linux学习笔记" class="headerlink" title="Linux学习笔记"></a>Linux学习笔记</h1><a id="more"></a>
<h2 id="Linux注意事项"><a href="#Linux注意事项" class="headerlink" title="Linux注意事项"></a>Linux注意事项</h2><p>Ctrl+a  快速回到行首</p>
<p>Ctrl+e  快速回到行末</p>
<p>Linux严格区分大小写.</p>
<p>Linux中所有内容以文件形式保存，包括硬件</p>
<ul>
<li>硬盘文件是/dev/sd[a-p]</li>
<li>光盘文件是/dev/sr0</li>
</ul>
<p>Linux不靠扩展名区分文件类型(扩展名便于用户使用),靠文件权限</p>
<ul>
<li>压缩包: “*.gz”、”*.bz2”、”*.tar.bz2”、”*.tgz”等</li>
<li>二进制软件包: “*.rpm”</li>
<li>网页文件: “*.html”、”*.php”</li>
<li>脚本文件: “*.sh”</li>
<li>配置文件: “*.conf”</li>
</ul>
<p>Linux所有的存储设备都必须挂载,之后用户才能使用,包括硬盘、U盘和光盘</p>
<p>Windows下的程序不能直接在Iinux中安装和运行</p>
<h2 id="服务器管理和维护"><a href="#服务器管理和维护" class="headerlink" title="服务器管理和维护"></a>服务器管理和维护</h2><h3 id="目录及作用"><a href="#目录及作用" class="headerlink" title="目录及作用"></a>目录及作用</h3><div class="table-container">
<table>
<thead>
<tr>
<th>目录名</th>
<th>目录作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>/bin/</td>
<td>存放系统命令的目录，普通用户和超级用户都可以执行。不过放在/bin下的命令在单用户模式下也可以执行</td>
</tr>
<tr>
<td>/sbin/</td>
<td>保存和系统环境设置相关的命令，只有超级用户可以使用这些命令进行系统环境设置，但是有些命令可以允许普通用户查看</td>
</tr>
<tr>
<td>/usr/bin/</td>
<td>存放系统命令的目录，普通用户和超级用户都可以执行。这些命令和系统启动无关，在单用户模式下不能执行</td>
</tr>
<tr>
<td>/usr/sbin/</td>
<td>存放根文件系统不必要的系统管理命令，例如多数服务程序。只有超级用户可以使用。大家其实可以注意到Linux的系统，在所有“sbin” 目录中保存的命令只有超级用户可以使用，“bin”目录中保存的命令所有用户都可以使用</td>
</tr>
<tr>
<td>/boot/</td>
<td>系统启动目录，保存系统启动相关的文件，如内核文件和启动引导程序( grub)文件等</td>
</tr>
<tr>
<td>/dev/</td>
<td>设备文件保存位置。我们已经说过Linux中所有内容以文件形式保存，包括硬件。那么这个目录就是用来保存所有硬件设备文件的</td>
</tr>
<tr>
<td>/etc/</td>
<td>配置文件保存位置。系统内所有采用默认安装方式(rpm安装)的服务的配置文件全部都保存在这个目录当中，如用户账户和密码，服务的启动脚本，常用服务的配置文件等</td>
</tr>
<tr>
<td>/home/</td>
<td>普通用户的家目录。建立每个用户时，每个用户要有一个默认登录位置，这个位置就是这个用户的家目录，所有普通用户的家目录就是在/home下建立一个和用户名相同的目录。如用户user1 的家目录就是home/user1</td>
</tr>
<tr>
<td>/lib/</td>
<td>系统调用的函数库保存位置</td>
</tr>
<tr>
<td>/lost+found/</td>
<td>当系统意外崩溃或机器意外关机，而产生一些文件碎片放在这里。当系统启动的过程中fsck工具会检查这里，并修复已经损坏的文件系统。这个目录只在每个分区中出现，例如/lost+found就是根分区的备份恢复目录，/boot/lost+ found就是/boot分区的备份恢复目录</td>
</tr>
<tr>
<td>/media/</td>
<td>挂载目录。系统建议是用来挂载媒体设备的，例如软盘和光盘</td>
</tr>
<tr>
<td>/mnt/</td>
<td>挂载目录，早期Linux中只有这一个挂载目录，并没有细分。现在这个目录系统建议挂载额外设备，如U盘，移动硬盘和其他操作系统的分区</td>
</tr>
<tr>
<td>/misc/</td>
<td>挂载目录。系统建议用来挂载NFS服务的共享目录。只要是一个已经建立的空目录就可以作为挂载点。那么系统虽然准备了三个默认挂载目录/media、/mnt、 /misc, 但是到底在哪个目录中挂载什么设备都可以由管理员自己决定。例如在/mnt下建立不同目录挂载不同设备。如/mnt/cdrom挂载光盘，/mnt/usb挂载U盘</td>
</tr>
<tr>
<td>/opt/</td>
<td>第三方安装的软件保存位置。这个目录就是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录当中。/usr/local目录也可以用来安装软件(更为常用)</td>
</tr>
<tr>
<td>/proc/</td>
<td>虚拟文件系统，该目录中的数据并不保存到硬盘当中，而是保存到内存当中。主要保存系统的内核，进程，外部设备状态和网络状态灯。如/proc/cpuinfo是保存CPU信息的，/proc/devices是保存设备驱动的列表的，/proc/filesystems是保存文件系统列表的，/proc/net/是保存网络协议信息的</td>
</tr>
<tr>
<td>/sys/</td>
<td>虚拟文件系统。和/proc 目录相似，都是保存在内存当中的，主要是保存于内核相关信息的</td>
</tr>
<tr>
<td>/root/</td>
<td>超级用户的家目录。普通用户家目录在“home”下，超级用户家目录直接在“/”下</td>
</tr>
<tr>
<td>/srv/</td>
<td>服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据</td>
</tr>
<tr>
<td>/tmp/</td>
<td>临时目录。系统存放临时文件的目录，该目录下所有用户都可以访问和写入。建议此目录中不能保存重要数据，最好每次开机都把该目录清空</td>
</tr>
<tr>
<td>/usr/</td>
<td>系统软件资源目录。注意usr不是user的缩写，而是“Unix Softwre Resource”的缩写，所以不是存放用户数据，而是存放系统软件资源的目录。系统中安装的软件大多数保存在这里</td>
</tr>
<tr>
<td>/var/</td>
<td>动态数据保存位置。主要保存缓存、日志以及软件运行所产生的文件</td>
</tr>
</tbody>
</table>
</div>
<h3 id="服务器注意事项"><a href="#服务器注意事项" class="headerlink" title="服务器注意事项"></a>服务器注意事项</h3><ul>
<li>远程服务器不允许关机，只能重启</li>
<li>重启时应该正确关闭服务</li>
<li>不要在服务器访问高峰运行高负载命令(搜索)</li>
<li>远程配置防火墙时不要把自己踢出服务器</li>
<li>指定合理的密码规范并定期更新</li>
<li>合理分配权限</li>
<li>定期备份重要数据和日志</li>
</ul>
<h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><h3 id="文件处理命令"><a href="#文件处理命令" class="headerlink" title="文件处理命令"></a>文件处理命令</h3><h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>命令格式:命令 [-选项] [参数]<br>例:ls -la /etc<br>说明:</p>
<ol>
<li>个别命令使用不遵循此格式</li>
<li>当有多个选项时，可以写在一起,绝大多数顺序也可以改变</li>
<li>简化选项与完整选项<br>-a等于--all</li>
</ol>
<h4 id="目录处理命令"><a href="#目录处理命令" class="headerlink" title="目录处理命令"></a>目录处理命令</h4><h5 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h5><p>命令名称: ls<br>命令英文原意:list<br>命令所在路径: /bin/ls<br>执行权限:所有用户<br>功能描述:显示目录文件<br>语法: ls 选项[-ald] [文件或目录]<br>    -a  显示所有文件，包括隐藏文件<br>    -1  详细信息显示<br>    -d  查看目录属性<br>    -i  查看i节点(linux中，文件查找不是通过文件名称来查找的。实际上是通过i节点来实现文件的查找定位的。)</p>
<p>-rw-r--r--</p>
<ul>
<li>- 文件类型(-二进制文件 d目录 l软链接文件)</li>
<li>rw- r-- r--<br>u     g    o<br>u所有者 g所属组 o其他人<br>r读 w写 x执行</li>
</ul>
<h5 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h5><p>命令名称: mkdir<br>命令英文原意: make directories<br>命令所在路径: /bin/mkdir<br>执行权限: 所有用户<br>语法: mkdir -p [目录名]<br>功能描述:创建新目录<br>      -p  递归创建(不加-p只能在已有目录创建一个新目录,而不能创建一个带有子目录的目录)</p>
<p>mkdir可同时创建多个目录  </p>
<h5 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h5><p>命令名称: cd<br>命令英文原意: change directory<br>命令所在路径: shell内置命令<br>执行权限: 所有用户<br>语法: cd [目录]<br>功能描述: 切换目录</p>
<h5 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h5><p>命令名称: pwd<br>命令英文原意: print working directory<br>命令所在路径: /bin/pwd<br>执行权限: 所有用户<br>语法: pwd<br>功能描述: 显示当前目录</p>
<h5 id="rmdir命令"><a href="#rmdir命令" class="headerlink" title="rmdir命令"></a>rmdir命令</h5><p>命令名称: rmdir<br>命令英文原意: remove empty directories<br>命令所在路径: /bin/rmdir<br>执行权限: 所有用户<br>语法: rmdir [目录名]<br>功能描述: 只能删除空目录</p>
<h5 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h5><p>命令名称: cp<br>命令英文原意: copy<br>命令所在路径: /bin/cp<br>执行权限: 所有用户<br>语法: cp -rp [原文件或目录] [目标目录]<br>    -r  复制目录<br>    -p  保留文件属性(不加-p时会改变文件的修改时间)<br>功能描述: 复制文件或目录到另一个文件(改名)或目录</p>
<p>cp命令可以同时复制多个目录或文件,可以复制并同时改名</p>
<h5 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h5><p>命令名称: mv<br>命令英文原意: move<br>命令所在路径: /bin/mv<br>执行权限: 所有用户<br>语法: mv [原文件或目录] [目标目录]<br>功能描述: 剪切文件、改名</p>
<h5 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h5><p>命令名称: rm<br>命令英文原意: remove<br>命令所在路径: /bin/rm<br>执行权限: 所有用户<br>语法: rm -rf [文件或目录]<br>    -r  删除目录<br>    -f  强制执行<br>    -i  询问删除<br>功能描述: 删除文件</p>
<p>Linux没有回收站概念,删除文件要谨慎.删除文件前要备份,一旦发现误删除情况,尽量不要对硬盘做过多的读写或查找操作.</p>
<h4 id="文件处理命令-1"><a href="#文件处理命令-1" class="headerlink" title="文件处理命令"></a>文件处理命令</h4><h5 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h5><p>命令名称: touch<br>命令所在路径: /bin/touch<br>执行权限: 所有用户<br>语法: touch [文件名]<br>功能描述: 创建空文件</p>
<h5 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h5><p>命令名称: cat<br>命令所在路径: /bin/cat<br>执行权限: 所有用户<br>语法: cat -n [文件名]<br>功能描述: 显示文件内容(只能用于查看内容较少的文件,否则滚动条会一直滚动,只显示最后一页,内容较多用more命令)<br>    -n  显示行号<br>    -A  查询所有文件内容,包括隐藏字符</p>
<h5 id="tac命令"><a href="#tac命令" class="headerlink" title="tac命令"></a>tac命令</h5><p>命令名称: tac<br>命令所在路径: /usr/bin/tac<br>执行权限: 所有用户<br>语法: tac [文件名]<br>功能描述: 显示文件内容(反向列示,与cat相反)</p>
<h5 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h5><p>命令名称: more<br>命令所在路径: /bin/more<br>执行权限: 所有用户<br>语法: more [文件名]<br>    (空格)或f  翻页<br>    (Enter)  换行<br>    q或Q  退出<br>功能描述: 分页显示文件内容(无法向上翻页)</p>
<h5 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h5><p>命令名称: less<br>命令所在路径: /usr/bin/less<br>执行权限: 所有用户<br>语法: less [文件名]<br>    (空格)或f  翻页<br>    (Enter)  换行<br>    q或Q  退出<br>    pgup  向上翻页<br>    pgdn  向下翻页<br>    /[关键词]  搜索<br>    n  搜索下一个<br>功能描述: 分页显示文件内容(可向上翻页),可进行搜索</p>
<h5 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a>head命令</h5><p>命令名称: head<br>命令所在路径: /usr/bin/head<br>执行权限: 所有用户<br>语法: head -n [行数] [文件名]<br>功能描述: 显示文件前面几行<br>    -n  指定行数(不加默认显示前10行)</p>
<h5 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h5><p>命令名称: tail<br>命令所在路径: /usr/bin/tail<br>执行权限: 所有用户<br>语法: tail -n [行数] [文件名]<br>功能描述: 显示文件后面几行<br>    -n  指定行数(不加默认显示后10行)<br>    -f  动态显示文件末尾内容(监控日志)</p>
<h4 id="链接命令"><a href="#链接命令" class="headerlink" title="链接命令"></a>链接命令</h4><h5 id="ln命令"><a href="#ln命令" class="headerlink" title="ln命令"></a>ln命令</h5><p>命令名称: ln<br>命令英文原意: link<br>命令所在路径: /bin/ln<br>执行权限: 所有用户<br>语法: ln -s [原文件] [目标文件]<br>    -s  创建软链接(不加创建硬链接)<br>功能描述: 生成链接文件</p>
<h5 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h5><ol>
<li>软链接全部都为lrwxrwxrwx,软链接权限不决定源文件权限,用户对软链接操作时具有什么权限由软链接对应的源文件确定</li>
<li>文件大小只是符号链接</li>
<li>软链接有箭头指向源文件</li>
<li>源文件删除,软链接失效</li>
</ol>
<h5 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h5><ol>
<li>拷贝(保留文件属性)cp -p + 同步更新</li>
<li>通过i节点识别(ls -i [文件名])(一个文件对应一个i节点,一个i节点可以对应多个文件)</li>
<li>不能跨分区(类似将windowsC盘的文件硬链接到D盘)</li>
<li>不能针对目录使用</li>
<li>源文件删除,硬链接依旧存在</li>
</ol>
<h3 id="权限管理命令"><a href="#权限管理命令" class="headerlink" title="权限管理命令"></a>权限管理命令</h3><h4 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h4><p>命令名称: chmod<br>命令英文原意: change the permissions mode of a file<br>命令所在路径: /bin/chmod<br>执行权限: 所有用户<br>语法: chmod [{ugoa} {+-=} {rwx}] [文件或目录]<br>                        [mode=421(rwx)] [文件或目录]<br>                        -R  递归修改主目录及主目录下所有目录或文件的权限<br>功能描述:改变文件或目录权限</p>
<p>如果有几个类型的用户需要同时设置权限,用逗号分隔</p>
<h4 id="文件目录权限总结"><a href="#文件目录权限总结" class="headerlink" title="文件目录权限总结"></a>文件目录权限总结</h4><div class="table-container">
<table>
<thead>
<tr>
<th>代表字符</th>
<th>权限</th>
<th>对文件的含义</th>
<th>对目录的含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>读权限</td>
<td>可以查看文件内容</td>
<td>可以列出目录中内容</td>
</tr>
<tr>
<td>w</td>
<td>写权限</td>
<td>可以修改文件内容</td>
<td>可以在目录中创建、删除文件</td>
</tr>
<tr>
<td>x</td>
<td>执行权限</td>
<td>可以执行文件</td>
<td>可以进入目录</td>
</tr>
</tbody>
</table>
</div>
<p>只有文件所有者和root可以改变文件权限</p>
<h4 id="其他权限管理命令"><a href="#其他权限管理命令" class="headerlink" title="其他权限管理命令"></a>其他权限管理命令</h4><h5 id="chown命令"><a href="#chown命令" class="headerlink" title="chown命令"></a>chown命令</h5><p>命令名称: chown<br>命令英文原意: change file ownership<br>命令所在路径: /bin/chown<br>执行权限: 所有用户<br>语法: chown [用户] [文件或目录]<br>功能描述: 改变文件或目录的所有者</p>
<p>只有root可以改变文件或目录的所有者</p>
<h5 id="chgrp命令"><a href="#chgrp命令" class="headerlink" title="chgrp命令"></a>chgrp命令</h5><p>命令名称: chgrp<br>命令英文原意: change file group ownership<br>命令所在路径: /bin/chgrp<br>执行权限: 所有用户<br>语法: chgrp [用户组] [文件或目录]<br>功能描述: 改变文件或目录的所属组</p>
<h5 id="umask命令"><a href="#umask命令" class="headerlink" title="umask命令"></a>umask命令</h5><p>命令名称: umask<br>命令英文原意: the user file-creation mask<br>命令所在路径: Shell内置命令<br>执行权限: 所有用户<br>语法: umask [-S]<br>    -S  以rwx形式显示新建文件缺省(默认)权限<br>功能描述:显示、设置文件的缺省权限(默认)</p>
<p>新建文件默认不具有可执行权限;使用umask命令会显示0022,其中,0表示特殊权限,022为权限掩码,真正的权限(缺省)为777-022=755;修改默认权限可以通过下面方式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">umask 权限掩码</span><br></pre></td></tr></table></figure>
<h3 id="文件搜索命令"><a href="#文件搜索命令" class="headerlink" title="文件搜索命令"></a>文件搜索命令</h3><p>搜索会占用大量的系统资源</p>
<h4 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h4><p>命令名称: find<br>命令所在路径: /bin/find<br>执行权限: 所有用户<br>语法: find [搜索范围] [匹配条件]<br>    -name  根据文件名搜索(严格区分大小写)<br>    -iname  根据文件名搜索(不区分大小写)<br>    -size  根据文件大小搜索<br>    -user  根据所有者搜索<br>    -group  根据所属组搜索<br>    -amin  访问时间(access)<br>    -cmin  文件属性(change)<br>    -mmin  文件内容(modify)<br>    -a  两个条件同时满足(and)<br>    -o  两个条件满足任意一个即可(or)<br>    -type  根据文件类型查找(f文件 d目录 l软链接文件)<br>    -exec/-ok 命令 {} \;  对搜索结果执行操作(花括号表示对搜索结果做替换,反斜杠表示转义符,分号表示结束;-ok和-exec最大的区别是有一个询问确认的环节)<br>    -inum  根据i节点搜索<br>功能描述: 文件搜索</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;etc -name init &#x2F;&#x2F;在etc目录搜索文件名为init的文件和目录(精准搜索)</span><br><span class="line">find &#x2F;etc -name *init*  &#x2F;&#x2F;在etc目录搜索文件名中包含init的文件和目录(模糊搜索)</span><br><span class="line">find &#x2F;etc -name init*  &#x2F;&#x2F;在etc目录搜索以init开头的文件和目录(*匹配任意字符)</span><br><span class="line">find &#x2F;etc -name init???  &#x2F;&#x2F;在etc目录搜索以init开头并且后面还有三个字母的文件或目录(问号匹配单个字符)</span><br><span class="line">find &#x2F; -size +204800  &#x2F;&#x2F;在根目录下查找大于100MB的文件和目录  </span><br><span class="line">+n 大于    -n 小于    n 等于  1数据块&#x3D;512字节&#x3D;0.5k</span><br><span class="line">find &#x2F;etc -cmin -5 &#x2F;&#x2F;在&#x2F;etc下查找5分钟内被修改过属性的文件和目录</span><br><span class="line">find &#x2F;etc -mmin +5 &#x2F;&#x2F;在&#x2F;etc下查找5分钟前被修改过内容的文件和目录</span><br><span class="line">find &#x2F;etc -size +163840 -a -size -204800  &#x2F;&#x2F;在&#x2F;etc下查找大于8OMB小于100MB的文件和目录</span><br><span class="line">find &#x2F;etc -name init* -a -type f &#x2F;&#x2F;在etc目录搜索以init开头的文件(没有目录)</span><br><span class="line">find &#x2F;etc -name inittab -exec ls -l &#123;&#125; \;  &#x2F;&#x2F;在&#x2F;etc下查找inittab文件并显示其详细信息</span><br><span class="line">find . -inum 123 -exec rm &#123;&#125; \;  &#x2F;&#x2F;在当前目录搜索i节点为123的文件和目录并删除</span><br></pre></td></tr></table></figure>
<p>不要在服务器高峰期使用find命令;搜索范围越小越好,搜索条件越精准越好</p>
<h4 id="其他搜索命令"><a href="#其他搜索命令" class="headerlink" title="其他搜索命令"></a>其他搜索命令</h4><h5 id="locate命令"><a href="#locate命令" class="headerlink" title="locate命令"></a>locate命令</h5><p>命令名称: locate<br>命令所在路径: /usr/bin/locate<br>执行权限: 所有用户<br>语法: locate 文件名<br>功能描述: 在文件资料库(自动定期更新)中查找文件(比find快)<br>    -i  不区分大小写(不加区分大小写)</p>
<p>如果一个新建立的文件没有被收录,就查找不到,可以使用updatedb更新文件资料库;/tmp存放临时文件,(存放临时文件的目录)不在locate文件资料库收录范围,无法查找/tmp中文件</p>
<h5 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h5><p>命令名称: which<br>命令所在路径: /usr/bin/which<br>执行权限: 所有用户<br>语法: which 命令名称<br>功能描述: 搜索命令所在目录及别名信息</p>
<h5 id="whereis命令"><a href="#whereis命令" class="headerlink" title="whereis命令"></a>whereis命令</h5><p>命令名称: whereis<br>命令所在路径: /usr/bin/whereis<br>执行权限: 所有用户<br>语法: whereis [命令名称]<br>功能描述: 搜索命令所在目录及帮助文档路径(配置文件)</p>
<h5 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h5><p>命令名称: grep<br>命令所在路径: /bin/grep<br>执行权限: 所有用户<br>语法: grep -iv [指定字串] [文件]<br>功能描述: 在文件中搜寻字串匹配的行并输出<br>    -i  不区分大小写<br>    -v  排除指定字串<br>    -n  输出行号<br>    --color=auto   搜索出的关键字用颜色显示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -v ^# &#x2F;etc&#x2F;inittab  &#x2F;&#x2F;搜索时去掉以#号开头的内容</span><br></pre></td></tr></table></figure>
<h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><h4 id="man命令"><a href="#man命令" class="headerlink" title="man命令"></a>man命令</h4><p>命令名称: man<br>命令英文原意: manual<br>命令所在路径: /usr/bin/man<br>执行权限: 所有用户<br>语法: man [命令或配置文件]<br>功能描述: 获得(命令或配置文件的)帮助信息</p>
<p>man命令与more和less类似;man查看配置文件的帮助信息不要加绝对路径,只要加配置文件名称即可;1表示命令的帮助,5表示配置文件的帮助</p>
<h4 id="whatis命令"><a href="#whatis命令" class="headerlink" title="whatis命令"></a>whatis命令</h4><p>命令名称: whatis<br>命令所在路径: /usr/bin/whatis<br>执行权限: 所有用户<br>语法: whatis [命令]<br>功能描述: 获得命令(相对man命令更为简短)的帮助信息</p>
<h4 id="apropos命令"><a href="#apropos命令" class="headerlink" title="apropos命令"></a>apropos命令</h4><p>命令名称: apropos<br>命令所在路径: /usr/bin/apropos<br>执行权限: 所有用户<br>语法: apropos [配置文件]<br>功能描述: 获得配置文件(相对man命令更为简短)的帮助信息</p>
<h4 id="info命令"><a href="#info命令" class="headerlink" title="info命令"></a>info命令</h4><p>命令名称: info<br>命令英文原意: information<br>命令所在路径: /usr/bin/info<br>执行权限: 所有用户<br>语法: info [命令或配置文件]<br>功能描述: 获得(命令或配置文件的)帮助信息</p>
<p>info命令与man命令类似,只是显示方式不同</p>
<h4 id="help"><a href="#help" class="headerlink" title="--help"></a>--help</h4><p>命令名称: --help<br>执行权限: 所有用户<br>语法: 命令 --help<br>功能描述: 获得命令主要选项的帮助信息(适用于外部命令)</p>
<h4 id="help命令"><a href="#help命令" class="headerlink" title="help命令"></a>help命令</h4><p>命令名称: help<br>命令所在路径: Shell内置命令<br>执行权限: 所有用户<br>语法: help 命令<br>功能描述: 获得Shell(命令解释器)内置命令(找不到路径)的帮助信息(不能使用man查看)</p>
<p>可以使用type [命令名称],来查看是外部命令还是内置命令</p>
<h3 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h3><h4 id="useradd命令"><a href="#useradd命令" class="headerlink" title="useradd命令"></a>useradd命令</h4><p>命令名称: useradd<br>命令所在路径: /usr/sbin/useradd<br>执行权限: root<br>语法: useradd 用户名<br>功能描述: 添加新用户</p>
<h4 id="passwd命令"><a href="#passwd命令" class="headerlink" title="passwd命令"></a>passwd命令</h4><p>命令名称: passwd<br>命令所在路径: /usr/bin/passwd<br>执行权限: 所有用户<br>语法: passwd 用户名<br>功能描述: 设置用户密码</p>
<p>root用户更改密码不用遵循密码复杂度要求;普通用户更改密码必须遵循密码复杂度要求.root可以更改任何人的密码,普通用户只能更改自己的密码</p>
<h4 id="who命令"><a href="#who命令" class="headerlink" title="who命令"></a>who命令</h4><p>命令名称: who<br>命令所在路径: /usr/bin/who<br>执行权限: 所有用户<br>语法: who<br>功能描述: 查看登录用户信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">登录用户名 登录终端(tty本地终端,pts远程终端) 登录时间 登录ip</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/30/FzxVm3KoPpfQLXJ.png" alt=""></p>
<h4 id="w命令"><a href="#w命令" class="headerlink" title="w命令"></a>w命令</h4><p>命令名称: w<br>命令所在路径: /usr/bin/w<br>执行权限: 所有用户<br>语法: w<br>功能描述: 查看登录用户详细信息(比who更详细)</p>
<p><img src="https://i.loli.net/2021/01/30/CF9i24xHXTBqMKs.png" alt=""></p>
<h3 id="压缩解压命令"><a href="#压缩解压命令" class="headerlink" title="压缩解压命令"></a>压缩解压命令</h3><h4 id="du命令"><a href="#du命令" class="headerlink" title="du命令"></a>du命令</h4><p>命令名称: du<br>命令英文原意: disk usage<br>命令所在路径: /usr/bin/du<br>执行权限: 所有用户<br>语法: du [文件或目录] -h<br>    -h  以K,M,G为单位,提高信息的可读性<br>    -s  仅显示每个参数的总计<br>功能描述: 显示文件或目录的大小</p>
<h4 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h4><p>命令名称: tar<br>命令所在路径: /bin/tar<br>执行权限:所有用户<br>语法: tar 选项[-cvf] 打包文件 源文件(可以有多个源文件,只打包解包不压缩)<br>    -c  创建tar包<br>    -x  解tar包<br>    -v  显示详细信息(进度)<br>    -f  备份文件(f必须放在后面)<br>    -C  解包到指定路径<br>    -z  压缩为.gz文件(将.gz文件解压)<br>    -j   压缩为.bz2文件(将.bz2文件解压)<br>功能描述: 归档管理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -cvf xxx.tar 1.c 2.c 3.c    &#x2F;&#x2F;将1.c,2.c,3.c打包至tar文件(* 全部打包)</span><br><span class="line">tar -xvf xxx.tar -C 路径    &#x2F;&#x2F;指定目录解包,不指定路径,默认在当前路径解包</span><br><span class="line">tar -czvf xxx.tar.gz 1.c 2.c   &#x2F;&#x2F;打包同时压缩为.gz文件</span><br><span class="line">tar -xzvf xxx.tar.gz      &#x2F;&#x2F;解压并解包</span><br><span class="line">tar -cjvf xxx.tar.bz2 1.c 2.c   &#x2F;&#x2F;打包同时压缩为.bz2文件</span><br><span class="line">tar -xjvf xxx.tar.bz2      &#x2F;&#x2F;解压并解包</span><br></pre></td></tr></table></figure>
<h4 id="gzip命令"><a href="#gzip命令" class="headerlink" title="gzip命令"></a>gzip命令</h4><p>命令名称: gzip<br>命令英文原意: GNU zip<br>命令所在路径: /bin/gzip<br>执行权限: 所有用户<br>语法: gzip [文件]<br>功能描述: 压缩文件(自动生成.gz文件,且不保留源文件)<br>    -d  解压文件<br>    -r  压缩所有子目录中文件(不能压缩目录)<br>压缩后文件格式: .gz</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip -r 目录(假设为test) &#x2F;&#x2F;将test目录及其子目录下所有文件压缩为.gz文件</span><br><span class="line">gzip -d -r 目录(假设为test) &#x2F;&#x2F;将test目录及其子目录下所有文件解压</span><br></pre></td></tr></table></figure>
<h4 id="gunzip命令"><a href="#gunzip命令" class="headerlink" title="gunzip命令"></a>gunzip命令</h4><p>命令名称: gunzip<br>命令英文原意: GNU unzip<br>命令所在路径: /bin/gunzip<br>执行权限: 所有用户<br>语法: gunzip [压缩文件]<br>功能描述: 解压.gz的压缩文件</p>
<h4 id="bzip2命令"><a href="#bzip2命令" class="headerlink" title="bzip2命令"></a>bzip2命令</h4><p>命令名称: bzip2<br>命令所在路径: /usr/bin/bzip2<br>执行权限: 所有用户<br>语法: bzip2 [文件]<br>功能描述: 压缩文件(自动生成.bz2文件,且不保留源文件,不能压缩目录,没有-r选项)<br>    -d  解压文件<br>    -k  产生压缩文件后保留源文件<br>压缩后文件格式: .bz2</p>
<h4 id="bunzip2命令"><a href="#bunzip2命令" class="headerlink" title="bunzip2命令"></a>bunzip2命令</h4><p>命令名称: bunzip2<br>命令所在路径: /usr/bin/bunzip2<br>执行权限: 所有用户<br>语法: bunzip2 选项[-k] [压缩文件]<br>    -k  解压后保留原文件<br>功能描述: 解压.bz2文件</p>
<h4 id="zip命令"><a href="#zip命令" class="headerlink" title="zip命令"></a>zip命令</h4><p>命令名称: zip<br>命令所在路径: /usr/bin/zip<br>执行权限: 所有用户<br>语法: zip 选项[-r] [压缩后文件名] [文件或目录]<br>    -r  压缩目录<br>功能描述: 压缩文件或目录(能保留源文件)<br>压缩后文件格式: .zip</p>
<h4 id="unzip命令"><a href="#unzip命令" class="headerlink" title="unzip命令"></a>unzip命令</h4><p>命令名称: unzip<br>命令所在路径: /usr/bin/unzip<br>执行权限: 所有用户<br>语法: unzip [压缩文件]<br>功能描述: 解压.zip的压缩文件</p>
<h3 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h3><h4 id="write命令"><a href="#write命令" class="headerlink" title="write命令"></a>write命令</h4><p>命令名称: write<br>命令所在路径: /usr/bin/write<br>执行权限: 所有用户<br>语法: write &lt;用户名&gt;<br>功能描述: 给指定在线用户发信息,以Ctrl+D保存结束</p>
<h4 id="wall命令"><a href="#wall命令" class="headerlink" title="wall命令"></a>wall命令</h4><p>命令名称: wall<br>命令英文原意: write all<br>命令所在路径: /usr/bin/yvall<br>执行权限: 所有用户<br>语法: wall [message]<br>功能描述: 发广播信息(给所有在线用户发送)</p>
<h4 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h4><p>命令名称: ping<br>命令所在路径: /bin/ping<br>执行权限: 所有用户<br>语法: ping 选项 IP地址<br>    -c  指定发送次数<br>功能描述: 测试网络连通性<br>范例: ping -c 3 ip地址  //ping三次</p>
<h4 id="ifconfig命令"><a href="#ifconfig命令" class="headerlink" title="ifconfig命令"></a>ifconfig命令</h4><p>命令名称: ifconfig<br>命令英文原意: interface configure<br>命令所在路径: /sbin/ifconfig<br>执行权限: root<br>语法: ifconfig 网卡名称 IP地址<br>功能描述:查看和设置网卡信息<br>范例: #ifconfig eth0 192.168.8.250</p>
<h4 id="mail-命令"><a href="#mail-命令" class="headerlink" title="mail 命令"></a>mail 命令</h4><p>命令名称: mail<br>命令所在路径: /bin/mail<br>执行权限: 所有用户<br>语法: mail [用户名]<br>功能描述: 查看发送电子邮件(以Ctrl+D保存结束)(查看邮件时直接使用mail,按q退出)</p>
<h4 id="last命令"><a href="#last命令" class="headerlink" title="last命令"></a>last命令</h4><p>命令名称: last<br>命令所在路径: /usr/bin/last<br>执行权限: 所有用户<br>语法: last<br>功能描述: 列出目前与过去登入系统的用户信息</p>
<h4 id="lastlog命令"><a href="#lastlog命令" class="headerlink" title="lastlog命令"></a>lastlog命令</h4><p>命令名称: lastlog<br>命令所在路径: /usr/bin/lastlog<br>执行权限: 所有用户<br>语法: lastlog<br>    -u 用户uid  查看指定用户登录<br>功能描述:检查某特定用户上次登录的时间</p>
<h4 id="traceroute命令"><a href="#traceroute命令" class="headerlink" title="traceroute命令"></a>traceroute命令</h4><p>命令名称: traceroute<br>命令所在路径: /bin/traceroute<br>执行权限: 所有用户<br>语法: traceroute<br>功能描述:显示数据包到主机间的路径</p>
<h4 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h4><p>命令名称: netstat<br>命令所在路径: /bin/netstat<br>执行权限: 所有用户<br>语法: netstat [选项]<br>    -a  全部信息<br>    -t  TCP协议<br>    -u  UDP协议<br>    -l  监听<br>    -r  路由(网关)<br>    -n  显示IP地址和端口号<br>功能描述: 显示网络相关信息<br>范例:<br>    netstat -tlun       查看本机监听的端口<br>    netstat -an          查看本机所有的网络连接<br>    netstat -rn           查看本机路由表</p>
<h4 id="setup命令-red-hat专有"><a href="#setup命令-red-hat专有" class="headerlink" title="setup命令(red hat专有)"></a>setup命令(red hat专有)</h4><p>命令名称: setup<br>命令所在路径: /usr/bin/setup<br>执行权限: root<br>语法: setup<br>功能描述:配置网络</p>
<h4 id="mount命令"><a href="#mount命令" class="headerlink" title="mount命令"></a>mount命令</h4><p>命令名称: mount<br>命令位置: /bin/mount<br>执行权限: 所有用户<br>命令语法: mount [-t 文件系统] 设备文件名 挂载点<br>功能描述: 挂载设备<br>范例: mount -t iso9660 /dev/sr0 /mnt/cdrom</p>
<h4 id="umount命令"><a href="#umount命令" class="headerlink" title="umount命令"></a>umount命令</h4><p>命令名称: umount<br>命令位置: /bin/umount<br>执行权限: 所有用户<br>命令语法: umount 设备文件名<br>功能描述: 卸载设备<br>范例: umount /dev/sr0</p>
<h3 id="关机重启命令"><a href="#关机重启命令" class="headerlink" title="关机重启命令"></a>关机重启命令</h3><h4 id="shutdown命令"><a href="#shutdown命令" class="headerlink" title="shutdown命令"></a>shutdown命令</h4><p>命令名称: shutdown<br>命令语法: shutdown [选项] 时间<br>    -c  取消前一个关机命令<br>    -h  关机<br>    -r  重启<br>功能描述: 关机重启<br>范例:<br>shutdown -h now   现在关机<br>shutdown -r 12:00   12:00重启<br>shutdown -c    取消前一个关机命令</p>
<h4 id="halt命令"><a href="#halt命令" class="headerlink" title="halt命令"></a>halt命令</h4><p>命令名称: halt<br>命令语法: halt<br>功能描述: 关机</p>
<h4 id="poweroff命令"><a href="#poweroff命令" class="headerlink" title="poweroff命令"></a>poweroff命令</h4><p>命令名称: poweroff<br>命令语法: poweroff<br>功能描述: 关机</p>
<p>相当于直接断电</p>
<h4 id="init-0命令"><a href="#init-0命令" class="headerlink" title="init 0命令"></a>init 0命令</h4><p>命令名称: init 0<br>命令语法: init 0<br>功能描述: 关机</p>
<h4 id="reboot命令"><a href="#reboot命令" class="headerlink" title="reboot命令"></a>reboot命令</h4><p>命令名称: reboot<br>命令语法: reboot<br>功能描述: 重启</p>
<h4 id="init-6命令"><a href="#init-6命令" class="headerlink" title="init 6命令"></a>init 6命令</h4><p>命令名称: init 6<br>命令语法: init 6<br>功能描述: 重启</p>
<h4 id="logout命令"><a href="#logout命令" class="headerlink" title="logout命令"></a>logout命令</h4><p>命令名称: logout<br>命令语法: logout<br>功能描述: 退出登录</p>
<h4 id="系统运行级别"><a href="#系统运行级别" class="headerlink" title="系统运行级别"></a>系统运行级别</h4><p>0  关机<br>1  单用户(root用户,与windows下安全模式类似,启动最少的核心程序进行修复)(无图形界面)<br>2  不完全多用户,不含NFS(网络文件系统)服务(NFS不太安全)(无图形界面)<br>3  完全多用户(无图形界面)<br>4  未分配<br>5  图形界面(X)<br>6  重启</p>
<h5 id="查看运行级别相关信息"><a href="#查看运行级别相关信息" class="headerlink" title="查看运行级别相关信息"></a>查看运行级别相关信息</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;inittab</span><br></pre></td></tr></table></figure>
<h5 id="查询系统当前运行级别"><a href="#查询系统当前运行级别" class="headerlink" title="查询系统当前运行级别"></a>查询系统当前运行级别</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">runlevel</span><br></pre></td></tr></table></figure>
<h2 id="文本编辑器Vim"><a href="#文本编辑器Vim" class="headerlink" title="文本编辑器Vim"></a>文本编辑器Vim</h2><p>Vim是一个功能强大的全屏幕文本编辑器,是Linux/UNIX上最常用的文本编辑器,它的作用是建立、编辑、显示文本文件.Vim没有菜单,只有命令.</p>
<p>Vim工作模式分为命令模式,插入模式和编辑模式.</p>
<h3 id="Vim常用命令"><a href="#Vim常用命令" class="headerlink" title="Vim常用命令"></a>Vim常用命令</h3><h4 id="插入命令"><a href="#插入命令" class="headerlink" title="插入命令"></a>插入命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>在光标所在字符后插入</td>
</tr>
<tr>
<td>A</td>
<td>在光标所在行行尾插入</td>
</tr>
<tr>
<td>i</td>
<td>在光标所在字符前插入</td>
</tr>
<tr>
<td>I</td>
<td>在光标所在行行首插入</td>
</tr>
<tr>
<td>o</td>
<td>在光标下插入新行</td>
</tr>
<tr>
<td>O</td>
<td>在光标上插入新行</td>
</tr>
</tbody>
</table>
</div>
<h4 id="定位命令"><a href="#定位命令" class="headerlink" title="定位命令"></a>定位命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>:set nu</td>
<td>设置行号</td>
</tr>
<tr>
<td>:set nonu</td>
<td>取消行号</td>
</tr>
<tr>
<td>gg<br />G</td>
<td>到第一行<br />到最后一行</td>
</tr>
<tr>
<td>nG</td>
<td>到第n行</td>
</tr>
<tr>
<td>:n</td>
<td>到第n行</td>
</tr>
<tr>
<td>$</td>
<td>移至行尾</td>
</tr>
<tr>
<td>0</td>
<td>移至行首</td>
</tr>
</tbody>
</table>
</div>
<h4 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>删除光标所在处字符</td>
</tr>
<tr>
<td>nx</td>
<td>删除光标所在处后n个字符</td>
</tr>
<tr>
<td>dd</td>
<td>删除光标所在行,ndd删除n行</td>
</tr>
<tr>
<td>dG</td>
<td>删除光标所在行到文件末尾内容</td>
</tr>
<tr>
<td>D</td>
<td>删除光标所在处到行尾内容</td>
</tr>
<tr>
<td>:x,yd</td>
<td>删除指定范围(x行到y行)的行</td>
</tr>
</tbody>
</table>
</div>
<h4 id="复制和剪切命令"><a href="#复制和剪切命令" class="headerlink" title="复制和剪切命令"></a>复制和剪切命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>yy</td>
<td>复制当前行</td>
</tr>
<tr>
<td>nyy</td>
<td>复制当前行(包括当前行)以下n行</td>
</tr>
<tr>
<td>dd</td>
<td>剪切当前行</td>
</tr>
<tr>
<td>ndd</td>
<td>剪切当前行(包括当前行)以下n行</td>
</tr>
<tr>
<td>p<br />P</td>
<td>粘贴在当前光标所在行下(p)<br />粘贴在当前光标所在行上(P)</td>
</tr>
</tbody>
</table>
</div>
<h4 id="替换和取消命令"><a href="#替换和取消命令" class="headerlink" title="替换和取消命令"></a>替换和取消命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>取代光标所在处字符</td>
</tr>
<tr>
<td>R</td>
<td>从光标所在处开始替换字符,按Esc结束</td>
</tr>
<tr>
<td>u</td>
<td>取消上一步操作</td>
</tr>
</tbody>
</table>
</div>
<h4 id="搜索和搜索替换命令"><a href="#搜索和搜索替换命令" class="headerlink" title="搜索和搜索替换命令"></a>搜索和搜索替换命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>/string</td>
<td>搜索指定字符串,搜索时忽略大小写:set ic(不忽略大小写:set noic)</td>
</tr>
<tr>
<td>n</td>
<td>搜索指定字符串的下一个出现位置</td>
</tr>
<tr>
<td>:%s/要被替换的字符串/新的字符串</td>
<td>全文替换指定字符串</td>
</tr>
<tr>
<td>:起始行,终止行s/要被替换的字符串/新的字符串</td>
<td>在一定范围内替换指定字符串</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:%s&#x2F;world&#x2F;世界&#x2F;g      &#x2F;&#x2F;在全文范围内,将world替换为世界(g表示不询问,c表示询问确认)</span><br><span class="line">:3,6s&#x2F;world&#x2F;世界&#x2F;c    &#x2F;&#x2F;在3到6行,将world替换为世界(&#x2F;g或&#x2F;c可加可不加)</span><br></pre></td></tr></table></figure>
<h4 id="保存和退出命令"><a href="#保存和退出命令" class="headerlink" title="保存和退出命令"></a>保存和退出命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>:w</td>
<td>保存修改</td>
</tr>
<tr>
<td>:w filename</td>
<td>另存为指定文件(可指定为某路径下的某文件)</td>
</tr>
<tr>
<td>:wq</td>
<td>保存修改并退出</td>
</tr>
<tr>
<td>ZZ</td>
<td>快捷键,保存修改并退出</td>
</tr>
<tr>
<td>:q!</td>
<td>不保存修改退出</td>
</tr>
<tr>
<td>:wq!</td>
<td>(只读文件强行保存)保存修改并退出(文件所有者及root可使用)</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Vim使用技巧"><a href="#Vim使用技巧" class="headerlink" title="Vim使用技巧"></a>Vim使用技巧</h3><h4 id="导入外部文件"><a href="#导入外部文件" class="headerlink" title="导入外部文件"></a>导入外部文件</h4><p>:r 文件位置   //导入文件到当前vim编辑的文件中</p>
<p><img src="https://i.loli.net/2021/01/31/THdxuBQmOfvpUSL.gif" alt=""></p>
<h4 id="不退出vim使用linux命令"><a href="#不退出vim使用linux命令" class="headerlink" title="不退出vim使用linux命令"></a>不退出vim使用linux命令</h4><p>:!命令      //不退出vim的情况下使用linux命令</p>
<p><img src="https://i.loli.net/2021/01/31/H71X9uAtVwZ5qkm.gif" alt=""></p>
<h4 id="将命令执行结果导入当前编辑文件"><a href="#将命令执行结果导入当前编辑文件" class="headerlink" title="将命令执行结果导入当前编辑文件"></a>将命令执行结果导入当前编辑文件</h4><p>:r !date(或其他命令)        //直接将date命令执行结果导入当前编辑文件   </p>
<p><img src="https://i.loli.net/2021/01/31/SNU56oP18fD3mrz.gif" alt=""></p>
<h4 id="自定义快捷键-单行注释"><a href="#自定义快捷键-单行注释" class="headerlink" title="自定义快捷键(单行注释)"></a>自定义快捷键(单行注释)</h4><p>:map 快捷键 触发命令   //自定义快捷键</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:map Ctrl+p I#&lt;ESC&gt;     &#x2F;&#x2F;将在首行(I)添加#并退出插入模式(ESC)设置为快捷键Ctrl+p</span><br><span class="line">:map Ctrl+b 0x          &#x2F;&#x2F;将光标移至行首并删除行首字符设置为快捷键Ctrl+b</span><br></pre></td></tr></table></figure>
<h4 id="连续行注释"><a href="#连续行注释" class="headerlink" title="连续行注释"></a>连续行注释</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:2,5s&#x2F;^&#x2F;#&#x2F;g        &#x2F;&#x2F;(类似于前面的替换)将2至5行的行首(^)增加#(g表示不询问)</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/31/yZJ6P3qH5NMKYef.gif" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:2,5s&#x2F;#&#x2F;&#x2F;g         &#x2F;&#x2F;将2至5行中所有#删除</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/31/n6IDdh45UkPYMgF.gif" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:2,5s&#x2F;^#&#x2F;&#x2F;g         &#x2F;&#x2F;将2至5行的行首的所有#删除</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/31/K9jXRYPFkE5VTJ2.gif" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:2,5s&#x2F;^&#x2F;\&#x2F;\&#x2F;&#x2F;g     &#x2F;&#x2F;将2至5行的行首添加双斜杠(&#x2F;&#x2F;),其中\&#x2F;代表一个斜杠(转义)</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/31/FYnkzh5iDVHycZK.gif" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:2,5s&#x2F;^\&#x2F;\&#x2F;&#x2F;&#x2F;g    &#x2F;&#x2F;将2至5行的行首的双斜杠(&#x2F;&#x2F;)删除</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/31/2itGncOdUS965N3.gif" alt=""></p>
<h4 id="文本替换"><a href="#文本替换" class="headerlink" title="文本替换"></a>文本替换</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ab mymail 5201314@qq.com   &#x2F;&#x2F;在文件中输入mymail,空格或回车后会自动替换为5201314@qq.com </span><br></pre></td></tr></table></figure>
<h2 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h2><h3 id="软件包管理简介"><a href="#软件包管理简介" class="headerlink" title="软件包管理简介"></a>软件包管理简介</h3><h4 id="软件包分类"><a href="#软件包分类" class="headerlink" title="软件包分类"></a>软件包分类</h4><ul>
<li>源码包(绝大多数是C语言)<ol>
<li>脚本安装包</li>
</ol>
</li>
<li>经过编译后的二进制包(RPM包,系统默认包)(现在更常用)</li>
</ul>
<h5 id="源码包"><a href="#源码包" class="headerlink" title="源码包"></a>源码包</h5><p>源码包的优点:</p>
<ul>
<li>开源,如果有足够的能力,可以修改源代码</li>
<li>可以自由选择所需的功能</li>
<li>软件是编译安装,所以更加适合自己的系统,更加稳定也效率更高</li>
<li>卸载方便(直接删除源码包)</li>
</ul>
<p>源码包的缺点:</p>
<ul>
<li>安装过程步骤较多,尤其安装较大的软件集合时( 如LAMP环境搭建),容易出现拼写错误</li>
<li>编译过程时间较长,安装比二进制包安装时间长</li>
<li>因为是编译安装,安装过程中一旦报错新手很难解决</li>
</ul>
<h5 id="二进制包"><a href="#二进制包" class="headerlink" title="二进制包"></a>二进制包</h5><p>二进制包的优点:</p>
<ul>
<li>包管理系统简单,只通过几个命令就可以实现包的安装、升级、查询和卸载</li>
<li>安装速度比源码包安装快的多</li>
</ul>
<p>二进制包的缺点:</p>
<ul>
<li>经过编译,不再可以看到源代码</li>
<li>功能选择不如源码包灵活</li>
<li>依赖性</li>
</ul>
<h3 id="RPM包管理"><a href="#RPM包管理" class="headerlink" title="RPM包管理"></a>RPM包管理</h3><h4 id="rpm命令管理"><a href="#rpm命令管理" class="headerlink" title="rpm命令管理"></a>rpm命令管理</h4><h5 id="包命名与依赖"><a href="#包命名与依赖" class="headerlink" title="包命名与依赖"></a>包命名与依赖</h5><h6 id="RPM包命名规则"><a href="#RPM包命名规则" class="headerlink" title="RPM包命名规则"></a>RPM包命名规则</h6><p>httpd-2.2.15-15.el6.centos.1.i686.rpm(包全名)<br>httpd          软件包名<br>2.2.15         软件版本<br>15                软件发布的次数<br>el6.centos  适合的Linux平台<br>i686             适合的硬件平台<br>rpm              rpm包扩展名</p>
<h6 id="RPM包依赖性"><a href="#RPM包依赖性" class="headerlink" title="RPM包依赖性"></a>RPM包依赖性</h6><ul>
<li>树形依赖: a-&gt;b-&gt;c</li>
<li>环形依赖: a-&gt;b-&gt;c-&gt;a(同时装即可)</li>
<li>模块依赖: <a href="https://www.rpmfind.net">模块依赖查询网站</a></li>
</ul>
<h5 id="安装升级与卸载"><a href="#安装升级与卸载" class="headerlink" title="安装升级与卸载"></a>安装升级与卸载</h5><h6 id="RPM包安装"><a href="#RPM包安装" class="headerlink" title="RPM包安装"></a>RPM包安装</h6><p>rpm -ivh 包全名</p>
<p>选项:<br>    -i (install)      安装<br>    -v (verbose)   显示详细信息<br>    -h (hash)        显示进度<br>    --nodeps        不检查依赖性</p>
<h6 id="RPM包升级"><a href="#RPM包升级" class="headerlink" title="RPM包升级"></a>RPM包升级</h6><p>rpm -Uvh 包全名</p>
<p>选项:<br>    -U (upgrade)      升级</p>
<h6 id="RPM包卸载"><a href="#RPM包卸载" class="headerlink" title="RPM包卸载"></a>RPM包卸载</h6><p>rpm -e 包名</p>
<p>选项:<br>    -e (erase)      卸载<br>    --nodeps       不检查依赖性</p>
<h5 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h5><h6 id="查询是否安装"><a href="#查询是否安装" class="headerlink" title="查询是否安装"></a>查询是否安装</h6><p>rpm -q 包名</p>
<p>选项:<br>    -q (query)      查询</p>
<p>rpm -qa</p>
<p>选项:<br>    -a (all)            全部</p>
<h6 id="查询软件包详细信息"><a href="#查询软件包详细信息" class="headerlink" title="查询软件包详细信息"></a>查询软件包详细信息</h6><p>rpm -qi 包名</p>
<p>选项:<br>    -i (information)      查询软件信息</p>
<p>rpm -qp 包全名</p>
<p>选项:<br>    -p (package)            查询未安装包信息 </p>
<h6 id="查询包中文件安装位置"><a href="#查询包中文件安装位置" class="headerlink" title="查询包中文件安装位置"></a>查询包中文件安装位置</h6><p>rpm -ql 包名</p>
<p>选项:<br>    -l (list)      查询文件安装位置列表</p>
<p>rpm -qlp 包全名</p>
<p>选项:<br>    -p (package)            查询未安装包的默认安装位置</p>
<h6 id="查询系统文件属于哪个RPM包"><a href="#查询系统文件属于哪个RPM包" class="headerlink" title="查询系统文件属于哪个RPM包"></a>查询系统文件属于哪个RPM包</h6><p>rpm -qf 系统文件名</p>
<p>选项:<br>    -f (file)            查询系统文件属于哪个RPM包</p>
<h6 id="查询软件包的依赖性"><a href="#查询软件包的依赖性" class="headerlink" title="查询软件包的依赖性"></a>查询软件包的依赖性</h6><p>rpm -q[p]R 包名[包全名]</p>
<p>选项:<br>    -R (requires)            查询软件包的依赖性<br>    -p (package)             查询未安装包的依赖性</p>
<h5 id="校验和文件提取"><a href="#校验和文件提取" class="headerlink" title="校验和文件提取"></a>校验和文件提取</h5><h6 id="RPM包校验"><a href="#RPM包校验" class="headerlink" title="RPM包校验"></a>RPM包校验</h6><p>判断系统文件是否更改</p>
<p>rpm -V 包名</p>
<p>选项:<br>    -V (verify)            校验指定RPM包中的文件</p>
<p>验证内容中的8个信息的具体内容如下:</p>
<ul>
<li>S  文件大小是否改变</li>
<li>M  文件的类型或文件的权限(rwx) 是否被改变</li>
<li>5    文件MD5校验和是否改变(可以看成文件内容是否<br>改变)</li>
<li>D  设备的主从代码是否改变</li>
<li>L  文件路径是否改变</li>
<li>U  文件的属主(所有者)是否改变</li>
<li>G  文件的属组是否改变</li>
<li>T  文件的修改时间是否改变</li>
</ul>
<p>文件类型:</p>
<ul>
<li>c  配置文件(config file)</li>
<li>d  普通文档(documentation)</li>
<li>g  “鬼”文件(ghost file),很少见,就是该文件不应该被这个RPM包包含</li>
<li>l  授权文件(license file)</li>
<li>r  描述文件(read me)</li>
</ul>
<h6 id="RPM包中文件提取"><a href="#RPM包中文件提取" class="headerlink" title="RPM包中文件提取"></a>RPM包中文件提取</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm2cpio 包全名 | \ cpio -idv .文件绝对路径</span><br></pre></td></tr></table></figure>
<p>“\\”代表一条命令没有输入完,(太长了)换行;”.”代表把指定路径的文件提取到当前路径下;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rmp2cpio &#x2F;mnt&#x2F;cdrom&#x2F;Package&#x2F;coreutils-8.4-19.el6.i686.rpm | cpio -idv .&#x2F;bin&#x2F;ls</span><br><span class="line">&#x2F;&#x2F;提取RPM包中ls命令到当前目录的&#x2F;bin&#x2F;ls下</span><br></pre></td></tr></table></figure>
<p>rpm2cpio     //将rpm包转换为cpio格式的命令</p>
<p>cpio    //是一个标准工具,它用于创建软件档案文件和从档案文件中提取文件</p>
<p>cpio 选项 &lt;[文件/设备]</p>
<p>选项:<br>    -i   copy-in模式,还原<br>    -d  还原时自动新建目录<br>    -v  显示还原过程<br>    &lt;    输入重定向</p>
<h4 id="yum在线管理"><a href="#yum在线管理" class="headerlink" title="yum在线管理"></a>yum在线管理</h4><h5 id="网络yum源"><a href="#网络yum源" class="headerlink" title="网络yum源"></a>网络yum源</h5><ul>
<li>[base]    容器名称,一定要放在[]中</li>
<li>name    容器说明,可以自己随便写</li>
<li>mirrorlist    镜像站点,这个可以注释掉</li>
<li>baseurl    yum源服务器的地址(为http)</li>
<li>enabled    此容器是否生效,如果不写或写成enable=1都是生效,写成enable=0就是不生效</li>
<li>gpgcheck    如果是1则指RPM的数字证书生效,如果是0则不生效</li>
<li>gpgkey    数字证书的公钥文件保存位置.不用修改</li>
</ul>
<h5 id="yum命令"><a href="#yum命令" class="headerlink" title="yum命令"></a>yum命令</h5><h6 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum list           &#x2F;&#x2F;查询所有可用软件包列表</span><br><span class="line">yum search 关键字   &#x2F;&#x2F;搜索服务器上所有和关键字相关的包</span><br></pre></td></tr></table></figure>
<h6 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install 包名</span><br></pre></td></tr></table></figure>
<p>选项:<br>    -y  自动回答yes</p>
<h6 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y update 包名   &#x2F;&#x2F;不加包名时,升级所有软件包(包括linux内核,linux内核升级完成后需要在本地做一定的配置才能正常使用)</span><br></pre></td></tr></table></figure>
<h6 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y remove 包名</span><br></pre></td></tr></table></figure>
<p>尽量不卸载</p>
<h6 id="yum软件组管理命令"><a href="#yum软件组管理命令" class="headerlink" title="yum软件组管理命令"></a>yum软件组管理命令</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum grouplist             &#x2F;&#x2F;列出所有可用的软件组列表</span><br><span class="line">yum groupinstall 软件组名  &#x2F;&#x2F;安装指定软件组,组名可以由group1ist查询出来(如果组名有空格,用双引号括起来)</span><br><span class="line">yum groupremove 软件组名   &#x2F;&#x2F;卸载指定软件组</span><br></pre></td></tr></table></figure>
<h5 id="光盘yum源搭建"><a href="#光盘yum源搭建" class="headerlink" title="光盘yum源搭建"></a>光盘yum源搭建</h5><p>1.挂载光盘</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount &#x2F;dev&#x2F;cdrom &#x2F;mnt&#x2F;cdrom</span><br></pre></td></tr></table></figure>
<p>2.让网络yum源文件失效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;etc&#x2F;yum&#x2F;repos.d&#x2F;</span><br><span class="line">将yum源文件(除了Centos-Meidia.repo)中改为enable&#x3D;0;或者将它们改名</span><br></pre></td></tr></table></figure>
<p>3.修改光盘yum源文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim Centos-Meidia.repo</span><br><span class="line">将baseurl&#x3D;http:&#x2F;&#x2F;修改baseurl&#x3D;file:&#x2F;&#x2F;光盘挂载的绝对路径</span><br><span class="line">注释多余的file:&#x2F;&#x2F;&#x2F;路径(不存在的地址)</span><br><span class="line">设置enable&#x3D;1</span><br></pre></td></tr></table></figure>
<h3 id="源码包管理"><a href="#源码包管理" class="headerlink" title="源码包管理"></a>源码包管理</h3><h4 id="源码包和RPM包的区别"><a href="#源码包和RPM包的区别" class="headerlink" title="源码包和RPM包的区别"></a>源码包和RPM包的区别</h4><ul>
<li>安装之前的区别: 概念上的区别</li>
<li>安装之后的区别: 安装位置不同</li>
</ul>
<h5 id="RPM包安装位置"><a href="#RPM包安装位置" class="headerlink" title="RPM包安装位置"></a>RPM包安装位置</h5><p>默认安装路径(绝大多数):</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>路径</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>/etc/</td>
<td>配置文件安装目录</td>
</tr>
<tr>
<td>/usr/bin/</td>
<td>可执行的命令安装目录</td>
</tr>
<tr>
<td>/usr/lib/</td>
<td>程序所使用的函数库保存位置</td>
</tr>
<tr>
<td>/usr/share/doc/</td>
<td>基本的软件使用手册保存位置</td>
</tr>
<tr>
<td>/usr/share/man/</td>
<td>帮助文件保存位置</td>
</tr>
</tbody>
</table>
</div>
<h5 id="源码包安装位置"><a href="#源码包安装位置" class="headerlink" title="源码包安装位置"></a>源码包安装位置</h5><p>安装在指定位置当中,一般是/usr/loca1/软件名/</p>
<h5 id="安装位置不同带来的影响"><a href="#安装位置不同带来的影响" class="headerlink" title="安装位置不同带来的影响"></a>安装位置不同带来的影响</h5><p>RPM包安装的服务可以使用系统服务管理命令(service)来管理,例如RPM包安装的apache的启动方法是:</p>
<ol>
<li>/etc/rc.d/init.d/httpd start    (方法1)</li>
<li>service httpd start    (方法2)</li>
</ol>
<p>而源码包安装的服务则不能被服务管理命令管理,因为没有安装到默认路径中.所以只能用绝对路径进行服务的管理,如:</p>
<ul>
<li>/usr/1oca1/apache2/bin/apachectl start</li>
</ul>
<h4 id="源码包安装过程"><a href="#源码包安装过程" class="headerlink" title="源码包安装过程"></a>源码包安装过程</h4><p>RPM包安装和源码包安装并不冲突(以apache为例)</p>
<h5 id="1-安装准备"><a href="#1-安装准备" class="headerlink" title="1.安装准备"></a>1.安装准备</h5><ol>
<li>安装gcc编译器</li>
<li>下载源码包</li>
</ol>
<h5 id="2-安装注意事项"><a href="#2-安装注意事项" class="headerlink" title="2.安装注意事项"></a>2.安装注意事项</h5><ul>
<li>源代码保存位置: /usr/local/src/</li>
<li>软件安装位置: /usr/local/</li>
<li>如何确定安装过程报错:<ul>
<li>安装过程停止</li>
<li>并出现error、warning或no的提示</li>
</ul>
</li>
</ul>
<h5 id="3-源码包安装过程"><a href="#3-源码包安装过程" class="headerlink" title="3.源码包安装过程"></a>3.源码包安装过程</h5><ol>
<li><p>解压下载的源码包</p>
</li>
<li><p>进入解压目录(INSTALL是安装说明,README是使用说明)</p>
</li>
<li><p>./configure —prefix=/usr/local/apache2(指定安装路径)</p>
<p>./configure  软件配置与检查</p>
<ul>
<li>定义需要的功能选项</li>
<li>检测系统环境是否符合安装要求</li>
<li>把定义好的功能选项和检测系统环境的信息都写入Makefile文件,用于后续的编辑</li>
</ul>
</li>
<li><p>make    编译</p>
</li>
<li><p>make install   编译安装(向真正的安装目录写入数据)</p>
</li>
<li><p>/usr/1oca1/apache2/bin/apachectl start    启动</p>
</li>
</ol>
<p>./configure和make都不会向真正的指定安装位置写任何数据,如果这两步报错不用删除软件包,只需执行make clean,清空编译产生的临时文件</p>
<h4 id="源码包的卸载"><a href="#源码包的卸载" class="headerlink" title="源码包的卸载"></a>源码包的卸载</h4><p>不需要卸载命令,直接删除安装目录即可,不会遗留任何垃圾文件.</p>
<h3 id="脚本安装包"><a href="#脚本安装包" class="headerlink" title="脚本安装包"></a>脚本安装包</h3><h4 id="脚本安装包简介"><a href="#脚本安装包简介" class="headerlink" title="脚本安装包简介"></a>脚本安装包简介</h4><ul>
<li>脚本安装包并不是独立的软件包类型,常见安装的是源码包</li>
<li>是人为把安装过程写成了自动安装的脚本,只要执行脚本,定义简单的参数,就可以完成安装</li>
<li>非常类似于Windows下软件的安装方式</li>
<li>主要是安装驱动</li>
</ul>
<h4 id="脚本安装包安装过程"><a href="#脚本安装包安装过程" class="headerlink" title="脚本安装包安装过程"></a>脚本安装包安装过程</h4><ol>
<li>下载脚本安装包</li>
<li>解压脚本安装包</li>
<li>进入解压目录</li>
<li>./setup.sh</li>
<li>可能会询问一些可选的选项(回车-&gt;默认),Ctrl+退格删除输入错误的字符</li>
</ol>
<h2 id="用户和用户组管理"><a href="#用户和用户组管理" class="headerlink" title="用户和用户组管理"></a>用户和用户组管理</h2><h3 id="用户配置文件"><a href="#用户配置文件" class="headerlink" title="用户配置文件"></a>用户配置文件</h3><h4 id="用户管理简介"><a href="#用户管理简介" class="headerlink" title="用户管理简介"></a>用户管理简介</h4><ul>
<li>越是对安全性要求高的服务器,越需要建立合理的用户权限等级制度和服务器操作规范</li>
<li>在Linux中主要是通过用户配置文件来查看和修改用户信息</li>
</ul>
<h4 id="用户信息文件"><a href="#用户信息文件" class="headerlink" title="用户信息文件"></a>用户信息文件</h4><p>用户信息文件/etc/passwd(使用man 5 passwd查看[注意:是文件名而不是绝对路径])(用冒号分开),7个字段</p>
<ol>
<li>第1字段: 用户名称</li>
<li>第2字段: 密码标志(x表示有密码,否则只允许本机登录,禁用ssh)</li>
<li><p>第3字段: UID (用户ID)</p>
<ul>
<li>0: 超级用户</li>
<li>1-499:系统用户(伪用户,不能登录,不能删除)</li>
<li>500-65535:普通用户</li>
</ul>
</li>
<li>第4字段: GID (用户初始组ID)</li>
<li>第5字段: 用户说明(备注)</li>
<li>第6字段: 家目录<ul>
<li>普通用户: /home/用户名/</li>
<li>超级用户: /root/</li>
</ul>
</li>
<li>第7字段: 登录之后的Shell</li>
</ol>
<h5 id="初始组和附加组"><a href="#初始组和附加组" class="headerlink" title="初始组和附加组"></a>初始组和附加组</h5><ul>
<li>初始组:就是指用户一登录就立刻拥有这个用户组的相关权限,每个用户的初始组必须有且只能有一个,一般就是和这个用户的用户名相同的组名作为这个用户的初始组</li>
<li>附加组:指用户可以加入多个其他的用户组,并拥有这些组的权限,附加组可以有多个</li>
</ul>
<h4 id="用户密码文件-影子文件"><a href="#用户密码文件-影子文件" class="headerlink" title="用户密码文件(影子文件)"></a>用户密码文件(影子文件)</h4><p>影子文件/etc/shadow(权限为000)(用冒号分隔),9个字段</p>
<ol>
<li>第1字段: 用户名称</li>
<li>第2字段: 加密密码<ul>
<li>加密算法升级为SHA512散列加密算法</li>
<li>如果密码位是”!!”或”*“代表没有密码,不能登录</li>
</ul>
</li>
<li><p>第3字段: 密码最后一次修改日期</p>
<ul>
<li>使用1970年1月1日作为标准时间,每过一天时间戳加1</li>
</ul>
</li>
<li>第4字段: 两次密码的修改间隔时间(和第3字段相比)(多少天后密码才能修改)</li>
<li>第5字段: 密码有效期(和第3字段相比)</li>
<li>第6字段: 密码修改到期前的警告天数(和第5字段相比)</li>
<li>第7字段: 密码过期后的宽限天数(和第5字段相比)(如果不改会禁止登陆)<ul>
<li>0: 代表密码过期后立即失效</li>
<li>-1: 代表密码永远不会失效</li>
</ul>
</li>
<li>第8字段: 账号失效时间<ul>
<li>要用时间戳表示</li>
</ul>
</li>
<li>第9字段: 保留</li>
</ol>
<h5 id="时间戳换算"><a href="#时间戳换算" class="headerlink" title="时间戳换算"></a>时间戳换算</h5><p>把时间戳换算为日期:</p>
<ul>
<li>date -d “1970-01-01 时间戳 days”</li>
</ul>
<p>把日期换算为时间戳:</p>
<ul>
<li>echo $(($(date —date=”日期” +%s)/86400+1))</li>
</ul>
<h4 id="组信息文件"><a href="#组信息文件" class="headerlink" title="组信息文件"></a>组信息文件</h4><p>组信息文件/etc/group,4个字段</p>
<ol>
<li>第1字段: 组名称</li>
<li>第2字段: 组密码标志(x)</li>
<li><p>第3字段: GID (初始组ID)</p>
</li>
<li><p>第4字段: 组中附加用户</p>
</li>
</ol>
<h4 id="组密码文件"><a href="#组密码文件" class="headerlink" title="组密码文件"></a>组密码文件</h4><p>组密码文件/etc/gshadow,4个字段</p>
<ol>
<li>第1字段: 组名称</li>
<li>第2字段: 组密码</li>
<li>第3字段: 组管理员用户名</li>
<li>第4字段: 组中附加用户</li>
</ol>
<h3 id="用户管理相关文件"><a href="#用户管理相关文件" class="headerlink" title="用户管理相关文件"></a>用户管理相关文件</h3><h4 id="用户家目录"><a href="#用户家目录" class="headerlink" title="用户家目录"></a>用户家目录</h4><ul>
<li>普通用户: /home/用户名/,所有者和所属组都是此用户,权限是700</li>
<li>超级用户: /root/, 所有者和所属组都是root用户,权限是550</li>
</ul>
<p>把普通用户变为超级用户可以修改UID,但家目录保持不变</p>
<h4 id="用户邮箱"><a href="#用户邮箱" class="headerlink" title="用户邮箱"></a>用户邮箱</h4><p>/var/spool/mail/用户名/</p>
<h4 id="用户模板目录"><a href="#用户模板目录" class="headerlink" title="用户模板目录"></a>用户模板目录</h4><p>/etc/skel/</p>
<p>创建新用户时,新用户家目录会包含这些模板</p>
<h3 id="用户管理命令-1"><a href="#用户管理命令-1" class="headerlink" title="用户管理命令"></a>用户管理命令</h3><h4 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h4><p>useradd [选项] 用户名</p>
<p>选项:<br>    -u UID               添加用户并指定用户的UID号<br>    -d 家目录          添加用户并指定用户的家目录<br>    -c 用户说明      添加用户并指定用户的说明<br>    -g 组名              添加用户并指定用户的初始组<br>    -G 组名             添加用户并指定用户的附加组(指定多个附加组用逗号分隔)<br>    -s shell              添加用户并指定用户的登录shell,默认是/bin/bash</p>
<h5 id="用户默认值文件"><a href="#用户默认值文件" class="headerlink" title="用户默认值文件"></a>用户默认值文件</h5><p>/etc/default/useradd</p>
<ul>
<li>GROUP=100            #用户默认组</li>
<li>HOME=/home        #用户家目录</li>
<li>INACTIVE=-1          #密码过期宽限天数(shadow文件第7字段)</li>
<li>EXPIRE=                   #密码失效时间(shadow文件第8字段)</li>
<li>SHELL=/bin/bash    #默认shell</li>
<li>SKEL=/etc/skel         #模板目录</li>
<li>CREATE_MAIL_SPOOL=yes    #是否建立邮箱</li>
</ul>
<p>/etc/login.defs</p>
<ul>
<li>PASS_MAX_DAYS 99999              #密码有效期(5)</li>
<li>PASS_MIN_DAYS 0                        #密码修改间隔(4)</li>
<li>PASS_MIN_LEN 5                          #密码最小5位(PAM)</li>
<li>PASS_WARN_AGE 7                      #密码到期警告(6)</li>
<li>UID_MIN        500                          #最小UID范围</li>
<li>GID_MAX      60000                       #最大UID范围</li>
<li>ENCRYPT_METHOD SHA512    #密码加密模式</li>
</ul>
<h4 id="修改用户密码"><a href="#修改用户密码" class="headerlink" title="修改用户密码"></a>修改用户密码</h4><p>passwd [选项] 用户名</p>
<p>选项:<br>    -S  查询用户密码的密码状态,仅root用户可用<br>    -l  暂时锁定用户,仅root用户可用(实际是在/etc/shadow中加密密码前添加!!)<br>    -u  解锁用户,仅root用户可用<br>    --stdin  可以通过管道符输出的数据作为用户的密码</p>
<p>root和普通用户可以使用passwd修改自己的密码,root也可以修改其他用户的密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;123&quot; | passwd --stdin user   &#x2F;&#x2F;将123作为用户user的密码</span><br></pre></td></tr></table></figure>
<h4 id="修改用户信息"><a href="#修改用户信息" class="headerlink" title="修改用户信息"></a>修改用户信息</h4><p>usermod [选项] 用户名</p>
<p>选项:<br>    -u UID               手工修改已存在用户的UID号<br>    -d 家目录          手工修改已存在用户的家目录<br>    -c 用户说明      手工修改已存在用户的说明<br>    -g 组名              手工修改已存在用户的初始组<br>    -G 组名             手工修改已存在用户的附加组(指定多个附加组用逗号分隔)<br>    -s shell              手工修改已存在用户的登录shell,默认是/bin/bash<br>    -L                       临时锁定已存在用户(Lock)<br>    -U                       解锁已存在用户锁定(Unlock)</p>
<p>usermod语法与useradd基本类似,usermod是修改已存在用户的信息,而useradd是添加一个新用户并修改相关信息(/etc/passwd)</p>
<h4 id="修改用户密码状态"><a href="#修改用户密码状态" class="headerlink" title="修改用户密码状态"></a>修改用户密码状态</h4><p>chage [选项] 用户名</p>
<p>选项:<br>    -l                   列出用户的详细密码状态<br>    -d 日期         修改密码最后一次更改日期(shadow3字段)<br>    -m 天数        两次密码修改间隔(4字段)<br>    -M 天数        密码有效期(5字段)<br>    -W 天数        密码过期前警告天数(6字段)<br>    -I 天数           密码过后宽限天数(7字段)<br>    -E 日期          账号失效时间(8字段)</p>
<p>(修改的是/etc/shadow)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chage -d 0 user   &#x2F;&#x2F;user登录后要求修改密码</span><br></pre></td></tr></table></figure>
<h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><p>userdel [-r] 用户名</p>
<p>选项:<br>    -r        删除用户的同时删除用户家目录</p>
<p>手工删除用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">手工删除用户user</span><br><span class="line">vi &#x2F;etc&#x2F;passwd    前4条命令是删除文件中与user相关的语句</span><br><span class="line">vi &#x2F;etc&#x2F;shadow</span><br><span class="line">vi &#x2F;etc&#x2F;group</span><br><span class="line">vi &#x2F;etc&#x2F;gshadow</span><br><span class="line">rm -rf &#x2F;var&#x2F;spool&#x2F;mail&#x2F;user</span><br><span class="line">rm -rf &#x2F;home&#x2F;user&#x2F;</span><br></pre></td></tr></table></figure>
<h4 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h4><p>su [选项] 用户名</p>
<p>选项:<br>    -                       选项只使用”-“代表连带用户的环境变量一起切换(这个不能省)<br>    -c 命令            仅执行一次命令,而不切换用户身份</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su -root -c &quot;useradd user&quot;  &#x2F;&#x2F;不切换成root,但是借助root执行useradd命令添加user用户</span><br></pre></td></tr></table></figure>
<h4 id="查看用户ID"><a href="#查看用户ID" class="headerlink" title="查看用户ID"></a>查看用户ID</h4><p>id 用户名</p>
<p>uid(用户id),gid(初始组id),group(附加组id)</p>
<h3 id="用户组管理命令"><a href="#用户组管理命令" class="headerlink" title="用户组管理命令"></a>用户组管理命令</h3><h4 id="添加用户组"><a href="#添加用户组" class="headerlink" title="添加用户组"></a>添加用户组</h4><p>groupadd [选项] 组名</p>
<p>选项:<br>    -g GID        指定组id(不加默认从500依次往后排)</p>
<h4 id="修改用户组"><a href="#修改用户组" class="headerlink" title="修改用户组"></a>修改用户组</h4><p>groupmod  [选项] 组名</p>
<p>选项:<br>    -g GID                           修改已存在组的组id<br>    -n 新组名 老组名        修改组名</p>
<h4 id="删除用户组"><a href="#删除用户组" class="headerlink" title="删除用户组"></a>删除用户组</h4><p>groupdel 组名</p>
<p>组中有初始用户则不能删除(必须先删除初始用户再删除组),组中只有附加用户则可以删除</p>
<h4 id="把用户添加入组或从组中删除"><a href="#把用户添加入组或从组中删除" class="headerlink" title="把用户添加入组或从组中删除"></a>把用户添加入组或从组中删除</h4><p>gpasswd 选项 组名</p>
<p>选项:<br>    -a 用户名      把用户加入组(附加用户)<br>    -d 用户名      把用户从组中删除</p>
<h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><h3 id="ACL权限"><a href="#ACL权限" class="headerlink" title="ACL权限"></a>ACL权限</h3><p>任何文件只能有一个所属组;当所有者,所属组,其他人身份不够用时,要用到ACL权限给用户分配权限</p>
<h4 id="ACL权限简介与开启"><a href="#ACL权限简介与开启" class="headerlink" title="ACL权限简介与开启"></a>ACL权限简介与开启</h4><h5 id="查看分区是否支持ACL权限"><a href="#查看分区是否支持ACL权限" class="headerlink" title="查看分区是否支持ACL权限"></a>查看分区是否支持ACL权限</h5><p>默认都支持,保险起见查一下</p>
<p>dumpe2fs -h 分区</p>
<h1 id="dumpe2fs命令是查询指定分区详细文件系统信息的命令-使用df-h查看分区信息-查看Default-mount-options处是否支持ACL"><a href="#dumpe2fs命令是查询指定分区详细文件系统信息的命令-使用df-h查看分区信息-查看Default-mount-options处是否支持ACL" class="headerlink" title="dumpe2fs命令是查询指定分区详细文件系统信息的命令(使用df -h查看分区信息),查看Default mount options处是否支持ACL"></a>dumpe2fs命令是查询指定分区详细文件系统信息的命令(使用df -h查看分区信息),查看Default mount options处是否支持ACL</h1><p>选项:<br>    -h             仅显示超级块中信息,而不显示磁盘块组的详细信息</p>
<h5 id="临时开启分区ACL权限"><a href="#临时开启分区ACL权限" class="headerlink" title="临时开启分区ACL权限"></a>临时开启分区ACL权限</h5><p>mount -o remount,acl</p>
<h1 id="重新挂载根分区-并挂载加入acl权限-o表示支持特殊挂载选项-remount重新挂载"><a href="#重新挂载根分区-并挂载加入acl权限-o表示支持特殊挂载选项-remount重新挂载" class="headerlink" title="重新挂载根分区,并挂载加入acl权限(-o表示支持特殊挂载选项,remount重新挂载)"></a>重新挂载根分区,并挂载加入acl权限(-o表示支持特殊挂载选项,remount重新挂载)</h1><h5 id="永久开启分区ACL权限"><a href="#永久开启分区ACL权限" class="headerlink" title="永久开启分区ACL权限"></a>永久开启分区ACL权限</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;fstab    #(fstab是系统开机自动挂载文件,改这个文件要谨慎)在UUID的defaults后面添加&quot;,acl&quot;,保存并重启   </span><br><span class="line">#如果不重启,将根分区重新挂载</span><br><span class="line">mount -o remount &#x2F;      #将根分区重新挂载</span><br></pre></td></tr></table></figure>
<h4 id="查看与设定ACL权限"><a href="#查看与设定ACL权限" class="headerlink" title="查看与设定ACL权限"></a>查看与设定ACL权限</h4><h5 id="查看ACL权限"><a href="#查看ACL权限" class="headerlink" title="查看ACL权限"></a>查看ACL权限</h5><p>getfacl 文件名       #查看ACL权限(不支持绝对路径,但不影响执行)</p>
<h5 id="设定ACL权限"><a href="#设定ACL权限" class="headerlink" title="设定ACL权限"></a>设定ACL权限</h5><p>setfacl 选项 文件名</p>
<p>选项:<br>    -m          设定ACL权限<br>    -x            删除指定的ACL权限<br>    -b            删除所有的ACL权限<br>    -d            设定默认ACL权限<br>    -k            删除默认ACL权限<br>    -R           递归设定ACL权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setfacl -m u:用户名:权限 文件名或目录    #其中u代表用户,g代表组</span><br><span class="line">setfacl -m u:user:rx &#x2F;project&#x2F;</span><br></pre></td></tr></table></figure>
<p>用ll命令查看会多个加号</p>
<h4 id="最大有效权限与删除ACL权限"><a href="#最大有效权限与删除ACL权限" class="headerlink" title="最大有效权限与删除ACL权限"></a>最大有效权限与删除ACL权限</h4><h5 id="最大有效权限mask"><a href="#最大有效权限mask" class="headerlink" title="最大有效权限mask"></a>最大有效权限mask</h5><p>mask是用来指定最大有效权限的.如果给用户赋予了ACL权限,是需要和mask的权限“相与”才能得到用户的真正权限</p>
<p>以读权限(r)为例</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>and</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>r</td>
<td>r</td>
</tr>
<tr>
<td>r</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>-</td>
<td>r</td>
<td>-</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<h6 id="修改最大有效权限"><a href="#修改最大有效权限" class="headerlink" title="修改最大有效权限"></a>修改最大有效权限</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setfacl -m m:权限 文件名或目录  #m表示最大有效权限mask(修改后可能会多出#effective注释,代表实际权限)</span><br></pre></td></tr></table></figure>
<h5 id="删除ACL权限"><a href="#删除ACL权限" class="headerlink" title="删除ACL权限"></a>删除ACL权限</h5><p>方法一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setfacl -x u:用户名 文件名或目录     #删除指定用户的ACL权限</span><br><span class="line">setfacl -x g:组名 文件名或目录      #删除指定用户组的ACL权限</span><br></pre></td></tr></table></figure>
<p>方法二</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setfacl -b 文件名或目录      #删除所有的ACL权限</span><br></pre></td></tr></table></figure>
<h4 id="默认ACL权限与递归ACL权限"><a href="#默认ACL权限与递归ACL权限" class="headerlink" title="默认ACL权限与递归ACL权限"></a>默认ACL权限与递归ACL权限</h4><h5 id="默认ACL权限"><a href="#默认ACL权限" class="headerlink" title="默认ACL权限"></a>默认ACL权限</h5><ul>
<li>默认ACL权限的作用是如果给父目录设定了默认ACL权限,那么父目录中所有新建的子文件都会继承父目录的ACL权限</li>
<li>setfacl -m d:u:用户名:权限 目录  (d表示设定默认ACL权限)</li>
</ul>
<h5 id="递归ACL权限"><a href="#递归ACL权限" class="headerlink" title="递归ACL权限"></a>递归ACL权限</h5><ul>
<li>递归是父目录在设定ACL权限时,所有的子文件和子目录也会拥有相同的ACL权限</li>
<li>setfacl -m u:用户名:权限 -R 目录  </li>
</ul>
<h3 id="文件特殊权限"><a href="#文件特殊权限" class="headerlink" title="文件特殊权限"></a>文件特殊权限</h3><h4 id="SetUID"><a href="#SetUID" class="headerlink" title="SetUID"></a>SetUID</h4><h5 id="SetUID的功能"><a href="#SetUID的功能" class="headerlink" title="SetUID的功能"></a>SetUID的功能</h5><ul>
<li>只有可以执行的二进制程序才能设定SUID权限(才有意义)</li>
<li>命令执行者要对该程序拥有x(执行)权限</li>
<li>命令执行者在执行该程序时获得该程序文件属主的身份(在执行程序的过程中灵魂附体为文件的属主)</li>
<li>SetUID权限只在该程序执行过程中有效,也就是说身份改变只在程序执行过程中有效</li>
<li>在所有者(u)范围拥有s权限(超级用户)</li>
<li>passwd命令拥有SetUID权限,所以普通可以修改自己的密码</li>
<li>cat命令没有SetUID权限,所以普通用户不能查看/etc/shadow文件内容</li>
</ul>
<h5 id="设定SetUID的方法"><a href="#设定SetUID的方法" class="headerlink" title="设定SetUID的方法"></a>设定SetUID的方法</h5><ol>
<li>chmod 4755 文件名     #4代表SUID,2代表SGID,1代表SBIT</li>
<li>chmod u+s 文件名     </li>
</ol>
<p>如果命令执行者对该程序没有x(执行)权限,设定后的s权限为S(大写),此时SUID不能生效</p>
<h5 id="取消SetUID的方法"><a href="#取消SetUID的方法" class="headerlink" title="取消SetUID的方法"></a>取消SetUID的方法</h5><ol>
<li>chmod 755 文件名</li>
<li>chmod u-s 文件名</li>
</ol>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li>关键目录应严格控制写权限.比如”/“、”/usr”等</li>
<li>用户的密码设置要严格遵守密码三原则</li>
<li>对系统中默认应该具有SetUID权限的文件作一列表,定时检查有没有这之外的文件被设置了SetUID权限</li>
</ul>
<h4 id="SetGID"><a href="#SetGID" class="headerlink" title="SetGID"></a>SetGID</h4><p>在所属组(g)范围拥有s权限(locate具有SGID)</p>
<h5 id="SetGID针对文件的作用"><a href="#SetGID针对文件的作用" class="headerlink" title="SetGID针对文件的作用"></a>SetGID针对文件的作用</h5><ul>
<li>只有可执行的二进制程序才能设置SGID权限</li>
<li>命令执行者要对该程序拥有x(执行)权限</li>
<li>命令执行在执行程序的时候,组身份升级为该程序文件的属组</li>
<li>SetGID权限同样只在该程序执行过程中有效,也就是说组身份改变只在程序执行过程中有效</li>
</ul>
<h5 id="SetGID针对目录的作用"><a href="#SetGID针对目录的作用" class="headerlink" title="SetGID针对目录的作用"></a>SetGID针对目录的作用</h5><ul>
<li>普通用户必须对此目录拥有r和x权限,才能进入此目录</li>
<li>普通用户在此目录中的有效组会变成此目录的属组</li>
<li>若普通用户对此目录拥有w权限时,新建的文件的默认属组是这个目录的属组</li>
</ul>
<h5 id="设定SetGID"><a href="#设定SetGID" class="headerlink" title="设定SetGID"></a>设定SetGID</h5><ol>
<li>chmod 2755 文件名  (2代表SGID)</li>
<li>chmod g+s 文件名</li>
</ol>
<h5 id="取消SetGID的方法"><a href="#取消SetGID的方法" class="headerlink" title="取消SetGID的方法"></a>取消SetGID的方法</h5><ol>
<li>chmod 755 文件名</li>
<li>chmod g-s 文件名</li>
</ol>
<h4 id="Sticky-BIT"><a href="#Sticky-BIT" class="headerlink" title="Sticky BIT"></a>Sticky BIT</h4><p>在其他人范围拥有t权限(/tmp)</p>
<h5 id="SBIT粘着位作用"><a href="#SBIT粘着位作用" class="headerlink" title="SBIT粘着位作用"></a>SBIT粘着位作用</h5><ul>
<li>粘着位目前只对目录有效</li>
<li>普通用户对该目录拥有w和x权限,即普通用户可以在此目录拥有写入权限</li>
<li>如果没有粘着位,因为普通用户拥有w权限,所以可以删除此目录下所有文件,包括其他用户建立的文件.一但赋予了粘着位,除了root可以删除所有文件,普通用户就算拥有w权限,也只能删除自己建立的文件,但是不能删除其他用户建立的文件</li>
</ul>
<h5 id="设置粘着位"><a href="#设置粘着位" class="headerlink" title="设置粘着位"></a>设置粘着位</h5><ol>
<li>chmod 1755 目录名</li>
<li>chmod o+t 目录名</li>
</ol>
<h5 id="取消粘着位"><a href="#取消粘着位" class="headerlink" title="取消粘着位"></a>取消粘着位</h5><ol>
<li>chmod 755 目录名</li>
<li>chmod o-t 目录名</li>
</ol>
<h3 id="文件系统属性chattr权限"><a href="#文件系统属性chattr权限" class="headerlink" title="文件系统属性chattr权限"></a>文件系统属性chattr权限</h3><h4 id="chattr命令"><a href="#chattr命令" class="headerlink" title="chattr命令"></a>chattr命令</h4><p>chattr [+-=][选项] 文件或目录名   #对root用户也生效</p>
<ul>
<li>+        增加权限</li>
<li>-         删除权限</li>
<li>\=         赋予权限</li>
</ul>
<p>选项:</p>
<ul>
<li>i:如果对文件设置i属性,那么不允许对文件进行删除、改名,也不能添加和修改数据;如果对目录设置i属性,那么只能修改目录下文件的数据,但不允许建立和删除文件</li>
<li>a:如果对文件设置a属性,那么只能在文件中增加数据,但是不能删除也不能修改已有数据;如果对目录设置a属性,那么只允许在目录中建立和修改文件,但是不允许删除</li>
</ul>
<h4 id="查看文件系统属性"><a href="#查看文件系统属性" class="headerlink" title="查看文件系统属性"></a>查看文件系统属性</h4><p>lsattr 选项 文件名</p>
<p>选项:<br>    -a    显示所有文件和目录<br>    -d    若目标是目录,仅列出目录本身的属性,而不是子文件的</p>
<h3 id="系统命令sudo权限"><a href="#系统命令sudo权限" class="headerlink" title="系统命令sudo权限"></a>系统命令sudo权限</h3><h4 id="sudo权限"><a href="#sudo权限" class="headerlink" title="sudo权限"></a>sudo权限</h4><ul>
<li>root把本来只能超级用户执行的命令赋普通用户执行</li>
<li>sudo的操作对象是系统命令</li>
</ul>
<h4 id="sudo使用"><a href="#sudo使用" class="headerlink" title="sudo使用"></a>sudo使用</h4><h5 id="sudo赋予命令"><a href="#sudo赋予命令" class="headerlink" title="sudo赋予命令"></a>sudo赋予命令</h5><p>sudo的配置文档是/etc/sudoers ,我们能够用他的专用编辑工具visudo对其进行编辑 ,此工具的好处是在添加规则有误时,保存退出会提示给我们错误信息</p>
<p>[root@localhost ~ ]# visudo</p>
<h1 id="实际修改的是-etc-sudoers文件"><a href="#实际修改的是-etc-sudoers文件" class="headerlink" title="实际修改的是/etc/sudoers文件"></a>实际修改的是/etc/sudoers文件</h1><p>root    ALL=(ALL)   ALL </p>
<h1 id="用户名-被管理主机的地址-本机IP或ALL-可使用的身份-授权命令-绝对路径"><a href="#用户名-被管理主机的地址-本机IP或ALL-可使用的身份-授权命令-绝对路径" class="headerlink" title="用户名  被管理主机的地址(本机IP或ALL)=(可使用的身份)     授权命令    (绝对路径)"></a>用户名  被管理主机的地址(本机IP或ALL)=(可使用的身份)     授权命令    (绝对路径)</h1><h1 id="wheel-ALL-ALL-ALL"><a href="#wheel-ALL-ALL-ALL" class="headerlink" title="%wheel     ALL=(ALL)        ALL"></a>%wheel     ALL=(ALL)        ALL</h1><h1 id="组名-被管理主机的地址-可使用的身份-授权命令-绝对路径"><a href="#组名-被管理主机的地址-可使用的身份-授权命令-绝对路径" class="headerlink" title="%组名     被管理主机的地址= (可使用的身份)    授权命令   (绝对路径)"></a>%组名     被管理主机的地址= (可使用的身份)    授权命令   (绝对路径)</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~ ]#visudo      修改&#x2F;etc&#x2F;sudoers文件</span><br><span class="line">user ALL&#x3D;&#x2F;sbin&#x2F;shutdown -r now  授权user用户可以重启服务器</span><br></pre></td></tr></table></figure>
<h5 id="普通用户执行sudo赋予的命令"><a href="#普通用户执行sudo赋予的命令" class="headerlink" title="普通用户执行sudo赋予的命令"></a>普通用户执行sudo赋予的命令</h5><p>sudo -l         #查看可用的sudo命令</p>
<p>sudo /sbin/shutdown -r now         #sudo执行重启</p>
<h2 id="文件系统管理"><a href="#文件系统管理" class="headerlink" title="文件系统管理"></a>文件系统管理</h2><h3 id="分区与文件系统"><a href="#分区与文件系统" class="headerlink" title="分区与文件系统"></a>分区与文件系统</h3><h4 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h4><ul>
<li>主分区:总共最多只能分四个</li>
<li>扩展分区:只能有一个,也算作主分区的一种,也就是说主分区加扩展分区最多有四个.但是扩展分区不能存储数据和格式化,必须再划分成逻辑分区才能使用</li>
<li>逻辑分区:逻辑分区是在扩展分区中划分的,如果是IDE硬盘(hd),Linux最多持59个逻辑分区,如果是SCSI硬盘(sd)Linux最多支持11个逻辑分区</li>
</ul>
<h5 id="分区方法一"><a href="#分区方法一" class="headerlink" title="分区方法一"></a>分区方法一</h5><p><img src="https://i.loli.net/2021/02/02/3UKiabOH2JSjokI.png" alt=""></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>分区</th>
<th>设备文件名</th>
</tr>
</thead>
<tbody>
<tr>
<td>主分区1</td>
<td>/dev/sda1(a代表第一块硬盘)</td>
</tr>
<tr>
<td>主分区2</td>
<td>/dev/sda2</td>
</tr>
<tr>
<td>主分区3</td>
<td>/dev/sda3</td>
</tr>
<tr>
<td>拓展分区</td>
<td>/dev/sda4</td>
</tr>
<tr>
<td>逻辑分区1</td>
<td>/dev/sda5</td>
</tr>
<tr>
<td>逻辑分区2</td>
<td>/dev/sda6</td>
</tr>
<tr>
<td>逻辑分区3</td>
<td>/dev/sda7</td>
</tr>
</tbody>
</table>
</div>
<h5 id="分区方法二"><a href="#分区方法二" class="headerlink" title="分区方法二"></a>分区方法二</h5><p><img src="https://i.loli.net/2021/02/02/RMuzJQ6ODpsiecN.png" alt=""></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>分区</th>
<th>设备文件名</th>
</tr>
</thead>
<tbody>
<tr>
<td>主分区1</td>
<td>/dev/sda1</td>
</tr>
<tr>
<td>拓展分区</td>
<td>/dev/sda2</td>
</tr>
<tr>
<td>逻辑分区1</td>
<td>/dev/sda5</td>
</tr>
<tr>
<td>逻辑分区2</td>
<td>/dev/sda6</td>
</tr>
<tr>
<td>逻辑分区3</td>
<td>/dev/sda7</td>
</tr>
</tbody>
</table>
</div>
<h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><ul>
<li>ext2: 是ext文件系统的升级版本,Red Hat Linux7.2版本以前的系统默认都是ext2文件系统.最大支持16TB的分区和最大2TB的文件</li>
<li>ext3 : ext3文件系统是ext2文件系统的升级版本,最大的区别就是带日志功能,以便在系统突然停止时提高文件系统的可靠性.支持最大16TB的分区和最大2TB的文件</li>
<li>ext4: 它是ext3文件系统的升级版.ext4在性能、伸缩性和可靠性方面进行了大量改进.ext4的变化可以说是翻天覆地的,比如向下兼容ext3、最大1EB文件系统和16TB文件、无限数量子目录、Extents连续数据块概念、多块分配、延迟分配、持久预分配、快速FSCK、日志校验、无日志模式、在线碎片整理、inode增强、默认启用barrier等.是CentOS 6.3的默认文件系统.<br>(1EB=1024PB=1 024*1024TB )</li>
</ul>
<h3 id="文件系统常见命令"><a href="#文件系统常见命令" class="headerlink" title="文件系统常见命令"></a>文件系统常见命令</h3><h4 id="文件系统查看命令-df"><a href="#文件系统查看命令-df" class="headerlink" title="文件系统查看命令(df)"></a>文件系统查看命令(df)</h4><p>df [选项] [挂载点]</p>
<p>选项:<br>    -a    显示所有的文件系统信息,包括特殊文件系统,如/proc、/sysfs<br>    -h    使用习惯单位显示容量,如KB,MB或GB等<br>    -T    显示文件系统类型<br>    -m   以MB为单位显示容量<br>    -k    以KB为单位显示容量,默认就是以KB为单位</p>
<h4 id="统计目录或文件大小-du"><a href="#统计目录或文件大小-du" class="headerlink" title="统计目录或文件大小(du)"></a>统计目录或文件大小(du)</h4><p>du [选项] [目录或文件名]</p>
<p>选项:<br>    -a  显示每个子文件的磁盘占用量,默认只统计子目录的磁盘占用量<br>    -h  使用习惯单位显示磁盘占用量,如KB,MB或GB等<br>    -s   统计总占用量,而不列出子目录和子文件的占用量</p>
<p>统计文件大小一般用ls;统计目录大小用du命令,不要用ls命令</p>
<h4 id="df命令与du命令的区别"><a href="#df命令与du命令的区别" class="headerlink" title="df命令与du命令的区别"></a>df命令与du命令的区别</h4><ul>
<li>df命令是从文件系统考虑的,不光要考虑文件占用的空间,还要统计被命令或程序占用的空间(最常见的就是文件已经删除但是程序并没有释放空间)(df看到的一般比du大)(df更准确)</li>
<li>du命令是面向文件的,只会计算文件或目录占用的空间</li>
</ul>
<h4 id="文件系统修复命令-fsck"><a href="#文件系统修复命令-fsck" class="headerlink" title="文件系统修复命令(fsck)"></a>文件系统修复命令(fsck)</h4><p>fsck [选项] 分区设备文件名</p>
<p>选项:<br>    -a  不用显示用户提示,自动修复文件系统<br>    -y  自动修复,和-a作用一致,不过有些文件系统只支持-y</p>
<p>一般不需要手工执行</p>
<h4 id="显示磁盘状态命令-dump2fs"><a href="#显示磁盘状态命令-dump2fs" class="headerlink" title="显示磁盘状态命令(dump2fs)"></a>显示磁盘状态命令(dump2fs)</h4><p>dump2fs 分区设备名</p>
<p>可以查看硬盘的UUID</p>
<h4 id="挂载命令-mount"><a href="#挂载命令-mount" class="headerlink" title="挂载命令(mount)"></a>挂载命令(mount)</h4><h5 id="查询与自动挂载"><a href="#查询与自动挂载" class="headerlink" title="查询与自动挂载"></a>查询与自动挂载</h5><p>mount [-l]         #查询系统中已经挂载的设备,-l会显示卷标名称</p>
<p>mount -a          #依据配置文件/etc/fstab的内容,自动挂载</p>
<h5 id="挂载命令格式"><a href="#挂载命令格式" class="headerlink" title="挂载命令格式"></a>挂载命令格式</h5><p>mount [-t 文件系统] [-L 卷标名] [-o 特殊选项] 设备文件名 挂载点</p>
<p>选项:<br>    -t 文件系统   加入文件系统类型来指定挂载的类型,可以是ext3、ext4、iso9660等文件系统<br>    -L 卷标名       挂载指定卷标的分区,而不是安装设备文件名挂载<br>    -o 特殊选项   可以指定挂载的额外选项</p>
<p>特殊选项汇总:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>atime/noatime</td>
<td>更新访问时间/不更新访问时间.访问分区文件时,是否更新文件的访问时间,默认为更新</td>
</tr>
<tr>
<td>async/sync</td>
<td>异步/同步,默认为异步</td>
</tr>
<tr>
<td>auto/noauto</td>
<td>自动/手动,mount -a命令执行时,是否会自动安装/etc/fstab文件内容挂载,默认为自动</td>
</tr>
<tr>
<td>defaults</td>
<td>定义默认值,相当于rw,suid,dev,exec,auto,nouser,async这七个选项</td>
</tr>
<tr>
<td>exec/noexec</td>
<td>执行/不执行,设定是否允许在文件系统中执行可执行文件,默认是exec允许(如果不允许,则里面文件无法执行)</td>
</tr>
<tr>
<td>remount</td>
<td>重新挂载已经挂载的文件系统,一般用于指定修改特殊权限</td>
</tr>
<tr>
<td>rw/ro</td>
<td>读写/只读,文件系统挂载时,是否具有读写权限,默认是rw</td>
</tr>
<tr>
<td>suid/nosuid</td>
<td>具有/不具有SUID权限,设定文件系统是否具有SUID和SGID的权限,默认是具有</td>
</tr>
<tr>
<td>user/nouser</td>
<td>允许/不允许普通用户挂载,设定文件系统是否允许普通用户挂载,默认是不允许,只有root可以挂载分区</td>
</tr>
<tr>
<td>usrquota</td>
<td>写入代表文件系统支持用户磁盘配额,默认不支持</td>
</tr>
<tr>
<td>grpquota</td>
<td>写入代表文件系统支持组磁盘配额,默认不支持</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount -o remount,noexec &#x2F;home</span><br></pre></td></tr></table></figure>
<h5 id="挂载光盘和U盘"><a href="#挂载光盘和U盘" class="headerlink" title="挂载光盘和U盘"></a>挂载光盘和U盘</h5><h6 id="挂载光盘"><a href="#挂载光盘" class="headerlink" title="挂载光盘"></a>挂载光盘</h6><ol>
<li>mkdir /mnt/cdrom    #建立挂载点</li>
<li>mount -t iso9660 /dev/cdrom /mnt/cdrom     #挂载光盘</li>
<li>mount /dev/sr0 /mnt/cdrom   #2,3均可以挂载光盘</li>
<li>去挂载点访问光盘</li>
<li>umount 设备文件名或挂载点     #卸载光盘,注意不能在光盘中执行此命令</li>
</ol>
<p>光盘设备名:</p>
<ul>
<li>/dev/cdrom  </li>
<li>/dev/sr0</li>
</ul>
<h6 id="挂载U盘"><a href="#挂载U盘" class="headerlink" title="挂载U盘"></a>挂载U盘</h6><p>U盘设备文件名是自动分配的</p>
<ol>
<li>fdisk -l      #查看U盘设备文件名</li>
<li>mount -t vfat /dev/sdb1 /mnt/usb   #挂载U盘</li>
<li>umount 设备文件名或挂载点     </li>
</ol>
<p>注意:Linux把fat16识别为fat,把fat32识别为vfat;Linux默认是不支持NTFS文件系统的</p>
<h5 id="支持NTFS文件系统"><a href="#支持NTFS文件系统" class="headerlink" title="支持NTFS文件系统"></a>支持NTFS文件系统</h5><p>可通过内核编译(复杂且使用较少)或使用NTFS插件使Linux支持NTFS文件系统,详细过程点击<a href="https://www.codenong.com/cs105317766/">链接</a>查看</p>
<h3 id="fdisk分区"><a href="#fdisk分区" class="headerlink" title="fdisk分区"></a>fdisk分区</h3><h4 id="fdisk命令分区过程"><a href="#fdisk命令分区过程" class="headerlink" title="fdisk命令分区过程"></a>fdisk命令分区过程</h4><ol>
<li>添加新硬盘</li>
<li>fdisk -l    #查看新硬盘</li>
<li>fdisk /dev/sdb     #使用fdisk命令分区(Ctrl+退格删除)</li>
<li>partprobe或重启         #重新读取分区表信息(如果分区表被占用)</li>
<li>mkfs -t ext4 /dev/sdb1     #格式化分区</li>
<li>mkdir /disk1    #建立挂载点</li>
<li>mount /dev/sdb1 /disk1/    #挂载</li>
</ol>
<p><img src="https://i.loli.net/2021/02/02/dipW8GsbrjTZNJ5.png" alt=""></p>
<p>Linux通过id识别Linux分区到底是什么,Linux标准分区id是83,swap分区id是82;详细过程点击<a href="https://blog.csdn.net/keith6785753/article/details/107324335/">链接</a>查看</p>
<h4 id="分区自动挂载与fstab文件修复"><a href="#分区自动挂载与fstab文件修复" class="headerlink" title="分区自动挂载与fstab文件修复"></a>分区自动挂载与fstab文件修复</h4><h5 id="etc-fstab文件"><a href="#etc-fstab文件" class="headerlink" title="/etc/fstab文件"></a>/etc/fstab文件</h5><ul>
<li>第一字段: 分区设备文件名或UUID(硬盘通用唯一识别码)</li>
<li>第二字段: 挂载点</li>
<li>第三字段: 文件系统名称</li>
<li>第四字段: 挂载参数</li>
<li>第五字段: 指定分区是否被dump备份,0代表不备份,1代表每天备份,2代表不定期备份</li>
<li>第六字段: 指定分区是否被fsck检测,0代表不检测,其他数字代表检测的优先级,那么当然1的优先级比2高</li>
</ul>
<h5 id="分区自动挂载"><a href="#分区自动挂载" class="headerlink" title="分区自动挂载"></a>分区自动挂载</h5><p>方法1:手工修改/etc/fstab(写错会系统崩溃)</p>
<ol>
<li>vi /etc/fstab</li>
<li>/dev/sdb1      /disk1       ext4       defaults     1   2    #安装格式填入挂载内容</li>
</ol>
<p>方法2:使用mount命令</p>
<ol>
<li>mount -a           #依据配置文件/etc/fstab的内容,自动挂载</li>
</ol>
<h5 id="etc-fstab文件修复"><a href="#etc-fstab文件修复" class="headerlink" title="/etc/fstab文件修复"></a>/etc/fstab文件修复</h5><p>系统崩溃后,修改/etc/fstab文件时无法写入,使用下面命令</p>
<ol>
<li>mount -o remount,rw /     #这种修复方式不是万能的</li>
</ol>
<h3 id="分配swap分区"><a href="#分配swap分区" class="headerlink" title="分配swap分区"></a>分配swap分区</h3><h4 id="free命令"><a href="#free命令" class="headerlink" title="free命令"></a>free命令</h4><p>[root@localhost ~]# free -m         #查看内存与swap分区使用状况,m不是按照MB查看</p>
<ul>
<li>cached(缓存): 是指把读取出来的数据保存在内存当中,当再次读取时,不用读取硬盘而直接从内存当中读取,加速了数据的读取过程</li>
<li>buffer(缓冲): 是指在写入数据时,先把分散的写入操作保存到内存当中,当达到一定程度再集中写入硬盘,减少了磁盘碎片和硬盘的反复寻道,加速了数据的写入过程</li>
</ul>
<h4 id="新建swap分区"><a href="#新建swap分区" class="headerlink" title="新建swap分区"></a>新建swap分区</h4><p>[root@localhost ~]# fdisk /dev/sdb   #注意要把swap分区id改为82</p>
<h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><p>[root@localhost ~]# mkswap /dev/sdb6</p>
<h4 id="加入swap分区"><a href="#加入swap分区" class="headerlink" title="加入swap分区"></a>加入swap分区</h4><p>[root@localhost ~]# swapon /dev/sdb6        #加入swap分区</p>
<p>[root@localhost ~]# swapoff /dev/sdb6       #取消swap分区</p>
<h4 id="swap分区开机自动挂载"><a href="#swap分区开机自动挂载" class="headerlink" title="swap分区开机自动挂载"></a>swap分区开机自动挂载</h4><p>[root@localhost ~]# vi /etc/fstab<br>/dev/sdb6    swap       swap     defaults     0    0</p>
<h2 id="shell基础"><a href="#shell基础" class="headerlink" title="shell基础"></a>shell基础</h2><h3 id="Shell概述"><a href="#Shell概述" class="headerlink" title="Shell概述"></a>Shell概述</h3><h4 id="Shell简介"><a href="#Shell简介" class="headerlink" title="Shell简介"></a>Shell简介</h4><ul>
<li>Shell是一个命令行解释器,它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序,用户可以用Shell来启动、挂起、停止甚至是编写一些程序</li>
<li>Shell还是一个功能相当强大的编程语言,易编写,易调试,灵活性较强.Shell是解释执行的脚本语言,在Shell中可以直接调用Linux系统命令</li>
</ul>
<h4 id="Shell的分类"><a href="#Shell的分类" class="headerlink" title="Shell的分类"></a>Shell的分类</h4><ul>
<li>Bourne Shell: 从1979起Unix就开始使用Bourne Shell,Bourne Shell的主文件名为sh</li>
<li>C Shell: C Shell主要在BSD版的Unix系统中使用,其语法和C语言相类似而得名</li>
<li>Shell的两种主要语法类型有Bourne和C,这两种语法彼此不兼容.Bourne家族主要包括sh、ksh、Bash、psh、zsh; C家族主要包括: csh、tcsh</li>
<li>Bash: Bash与sh兼容,现在使用的Linux就是使用Bash作为用户的基本Shell</li>
</ul>
<h4 id="Linux支持的Shell"><a href="#Linux支持的Shell" class="headerlink" title="Linux支持的Shell"></a>Linux支持的Shell</h4><p>打开/etc/shells文件查看Linux支持的Shell</p>
<h3 id="Shell脚本的执行方式"><a href="#Shell脚本的执行方式" class="headerlink" title="Shell脚本的执行方式"></a>Shell脚本的执行方式</h3><h4 id="echo输出命令"><a href="#echo输出命令" class="headerlink" title="echo输出命令"></a>echo输出命令</h4><p>[root@localhost ~]# echo [选项] [输出内容]<br>选项:<br>    -e      支持反斜线控制的字符转换</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>控制字符</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>\\\\</td>
<td>输出\本身</td>
</tr>
<tr>
<td>\\a</td>
<td>输出警告音</td>
</tr>
<tr>
<td>\\b</td>
<td>退格键,也就是向左删除键</td>
</tr>
<tr>
<td>\\c</td>
<td>取消输出行末的换行符,和“-n”选项一致</td>
</tr>
<tr>
<td>\\e</td>
<td>ESCAPE键</td>
</tr>
<tr>
<td>\\f</td>
<td>换页符</td>
</tr>
<tr>
<td>\\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\\r</td>
<td>回车键</td>
</tr>
<tr>
<td>\\t</td>
<td>制表符,也就是Tab键</td>
</tr>
<tr>
<td>\\v</td>
<td>垂直制表符</td>
</tr>
<tr>
<td>\\0nnn</td>
<td>按照八进制ASCII码表输出字符,其中0为数字零,nnn是三位八进制数</td>
</tr>
<tr>
<td>\\xhh</td>
<td>按照十六进制ASCII码表输出字符,其中hh是两位十六进制数</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo -e &quot;\e[1;31mabcd\e[0m&quot;    #输出颜色</span><br><span class="line">#30m&#x3D;黑色，31m&#x3D;红色，32m&#x3D;绿色，33m&#x3D;黄色</span><br><span class="line">#34m&#x3D;蓝色，35m&#x3D;洋红，36m&#x3D;青色，37m&#x3D;白色</span><br></pre></td></tr></table></figure>
<h4 id="脚本执行"><a href="#脚本执行" class="headerlink" title="脚本执行"></a>脚本执行</h4><ol>
<li>赋予执行权限,直接运行<ul>
<li>chmod 755 hello.sh </li>
<li>./hello.sh</li>
</ul>
</li>
<li>通过Bash调用执行脚本<ul>
<li>bash hello.sh </li>
</ul>
</li>
</ol>
<p>在Linux中回车符识别为$,windows回车符识别为^M$,所以Linux无法识别在windows编写的脚本,将在windows编写的脚本转换为Linux可识别的脚本,可使用dos2unix命令</p>
<p>格式: dos2unix 文件名</p>
<h3 id="Bash的基本功能"><a href="#Bash的基本功能" class="headerlink" title="Bash的基本功能"></a>Bash的基本功能</h3><h4 id="历史命令与命令补全"><a href="#历史命令与命令补全" class="headerlink" title="历史命令与命令补全"></a>历史命令与命令补全</h4><h5 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h5><p>[root@localhost~]#  history [选项] [历史命令保存文件]<br>选项:<br>    -c      清空历史命令<br>    -w    把缓存中的历史命令写入历史命令保存文件~/.bash_history</p>
<p>历史命令默认会保存1000条,可以在环境变量配置文件/etc/profile中进行修改,超过1000条会删除前面的,保留后面的.</p>
<ul>
<li>使用上、下箭头调用以前的历史命令</li>
<li>使用”!n”重新执行第n条历史命令</li>
<li>使用”!!”重新执行上一条命令</li>
<li>使用”!字串”重新执行最后一条以该字串开头的命令</li>
</ul>
<h5 id="命令补全"><a href="#命令补全" class="headerlink" title="命令补全"></a>命令补全</h5><p>在Bash中,命令与文件补全是非常方便与常用的功能,我们只要在输入命令或文件<br>时,按”Tab”键就会自动进行补全,如果有很多条可能不会显示,再按一下即可</p>
<h4 id="命令别名与常用快捷键"><a href="#命令别名与常用快捷键" class="headerlink" title="命令别名与常用快捷键"></a>命令别名与常用快捷键</h4><h5 id="命令别名"><a href="#命令别名" class="headerlink" title="命令别名"></a>命令别名</h5><p>[root@localhost ~]# alias 别名=’原命令’</p>
<h1 id="设定命令别名"><a href="#设定命令别名" class="headerlink" title="设定命令别名"></a>设定命令别名</h1><p>[root@localhost ~]# alias</p>
<h1 id="查询命令别名"><a href="#查询命令别名" class="headerlink" title="查询命令别名"></a>查询命令别名</h1><p>使用命令行设定别名只会临时生效;使用别名时要注意命令执行顺序</p>
<h6 id="命令执行顺序"><a href="#命令执行顺序" class="headerlink" title="命令执行顺序"></a>命令执行顺序</h6><ol>
<li>第一顺位执行用绝对路径或相对路径执行的命令</li>
<li>第二顺位执行别名</li>
<li>第三顺位执行Bash的内部命令</li>
<li>第四顺位执行按照$PATH环境变量定义的目录查找顺序找到的第一个命令</li>
</ol>
<h6 id="让别名永久生效"><a href="#让别名永久生效" class="headerlink" title="让别名永久生效"></a>让别名永久生效</h6><p>[root@localhost ~]# vi /用户名/.bashrc    #修改其中相关内容</p>
<h5 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h5><div class="table-container">
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctr1+a</td>
<td>把光标移动到命令行开头</td>
</tr>
<tr>
<td>Ctrl+e</td>
<td>把光标移动到命令行结尾</td>
</tr>
<tr>
<td>Ctrl+c</td>
<td>强制终止当前的命令</td>
</tr>
<tr>
<td>Ctrl+l</td>
<td>清屏,相当于clear命令</td>
</tr>
<tr>
<td>Ctrl+u</td>
<td>删除或剪切光标之前的命令</td>
</tr>
<tr>
<td>Ctrl+k</td>
<td>删除或剪切光标之后的内容</td>
</tr>
<tr>
<td>Ctrl+y</td>
<td>粘贴Ctrl+u或Ctrl+k剪切的内容</td>
</tr>
<tr>
<td>Ctrl+r</td>
<td>在历史命令中搜索,按下Ctrl+r之后,就会出现搜索界面,只要输入搜索内容,就会从历史命令中搜索</td>
</tr>
<tr>
<td>Ctrl+d</td>
<td>退出当前终端</td>
</tr>
<tr>
<td>Ctrl+z</td>
<td>暂停,并放入后台.这个快捷键与工作管理有关</td>
</tr>
<tr>
<td>Ctrl+s</td>
<td>暂停屏幕输出</td>
</tr>
<tr>
<td>Ctrl+q</td>
<td>恢复屏幕输出</td>
</tr>
</tbody>
</table>
</div>
<h4 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h4><h5 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h5><div class="table-container">
<table>
<thead>
<tr>
<th>设备</th>
<th>设备文件名</th>
<th>文件描述符</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>键盘</td>
<td>/dev/stdin</td>
<td>0</td>
<td>标准输入</td>
</tr>
<tr>
<td>显示器</td>
<td>/dev/stdout</td>
<td>1</td>
<td>标准输出</td>
</tr>
<tr>
<td>显示器</td>
<td>/dev/stderr</td>
<td>2</td>
<td>标准错误输出</td>
</tr>
</tbody>
</table>
</div>
<h5 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h5><table>
    <tr>
        <th>类型</th>
        <th>符号</th>
        <th>作用</th>
    </tr>
    <tr>
        <td rowspan="2">标准输出重定向</td>
        <td>命令 > 文件</td>
        <td>以覆盖的方式,把命令的正确输出输出到指定的文件或设备当中</td>
    </tr>
    <tr>
        <td>命令 >> 文件</td>
        <td>以追加的方式,把命令的正确输出输出到指定的文件或设备当中</td>
    </tr>
    <tr>
        <td rowspan="2">标准错误输出重定向</td>
        <td>错误命令 2> 文件</td>
        <td>以覆盖的方式,把命令的错误输出输出到指定的文件或设备当中</td>
    </tr>
    <tr>
        <td>错误命令 2>> 文件</td>
        <td>以追加的方式,把命令的错误输出输出到指定的文件或设备当中</td>
    </tr>
    <tr>
        <td rowspan="5">正确输出和错误输出同时保存</td>
        <td>命令 > 文件 2>&1</td>
        <td>以覆盖的方式,把正确输出和错误输出都保存到同一个文件当中</td>
    </tr>
    <tr>
        <td>命令 >> 文件 2>&1</td>
        <td>以追加的方式,把正确输出和错误输出都保存到同一个文件当中</td>
    </tr>
    <tr>
        <td>命令 &> 文件</td>
        <td>以覆盖的方式,把正确输出和错误输出都保存到同一个文件当中</td>
    </tr>
    <tr>
        <td>命令 &>> 文件</td>
        <td>以追加的方式,把正确输出和错误输出都保存到同一个文件当中</td>
    </tr>
    <tr>
        <td>命令 >> 文件1 2>>文件2</td>
        <td>把正确的输出追加到文件1中,把错误的输出追加到文件2中</td>
    </tr>
</table>



<ul>
<li>注意2与大于号(&gt;)之间不能有空格,命令与大于号之间,文件与大于号之间最好也有空格</li>
<li>2&gt;&amp;1表示把错误输出保存到正确输出中</li>
<li>ls &amp;&gt; /dev/null     #把ls结果丢进垃圾箱</li>
</ul>
<h5 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h5><p>[root@localhost~] # wc [选项] [文件名]<br>选项:<br>    -c  统计字节数<br>    -w  统计单词数<br>    -l  统计行数</p>
<p>Ctrl+d结束输入(wc会统计回车符)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wc &lt; 文件名   #统计该文件行数等信息</span><br><span class="line">wc &lt;&lt; test   #当第一次遇到test时停止,统计test之前的内容</span><br></pre></td></tr></table></figure>
<h4 id="多命令顺序执行与管道符"><a href="#多命令顺序执行与管道符" class="headerlink" title="多命令顺序执行与管道符"></a>多命令顺序执行与管道符</h4><h5 id="多命令顺序执行"><a href="#多命令顺序执行" class="headerlink" title="多命令顺序执行"></a>多命令顺序执行</h5><div class="table-container">
<table>
<thead>
<tr>
<th>多命令执行符</th>
<th>格式</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>;</td>
<td>命令1 ; 命令2</td>
<td>多个命令顺序执行,命令之间没有任何逻辑联系</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>命令1 &amp;&amp; 命令2</td>
<td>逻辑与<br>当命令1正确执行,则命令2才会执行 <br>当命令1执行不正确,则命令2不会执行</td>
</tr>
<tr>
<td>\</td>
<td>\</td>
<td></td>
<td>命令1 \</td>
<td>\</td>
<td>命令2</td>
<td>逻辑或<br/>当命令1执行不正确,则命令2才会执行<br>当命令1正确执行,则命令2不会执行</td>
</tr>
</tbody>
</table>
</div>
<h5 id="dd命令"><a href="#dd命令" class="headerlink" title="dd命令"></a>dd命令</h5><p>用于磁盘复制</p>
<p>[root@localhost ~]# dd if=输入文件 of=输出文件 bs=字节数 count=个数<br>选项:<br>    if=输入文件       指定源文件或源设备<br>    of=输出文件      指定目标文件或目标设备<br>    bs=字节数          指定一次输入/输出多少字节,即把这些字节看做一个数据块<br>    count=个数        指定输入/输出多少个数据块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">date ; dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;root&#x2F;test bs&#x3D;1k count&#x3D;102400 ; date     #记录&#x2F;dev&#x2F;zero向&#x2F;root&#x2F;test复制100MB</span><br><span class="line">命令 &amp;&amp; echo yes || echo no   #如果命令正确执行则输出yes,否则输出no</span><br></pre></td></tr></table></figure>
<h5 id="管道符"><a href="#管道符" class="headerlink" title="管道符"></a>管道符</h5><p>[root@localhost ~]# 命令1|命令2</p>
<h1 id="命令1的正确输出作为命令2的操作对象"><a href="#命令1的正确输出作为命令2的操作对象" class="headerlink" title="命令1的正确输出作为命令2的操作对象"></a>命令1的正确输出作为命令2的操作对象</h1><h4 id="通配符与其他特殊符号"><a href="#通配符与其他特殊符号" class="headerlink" title="通配符与其他特殊符号"></a>通配符与其他特殊符号</h4><h5 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h5><div class="table-container">
<table>
<thead>
<tr>
<th>通配符</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>?</td>
<td>匹配一个任意字符</td>
</tr>
<tr>
<td>*</td>
<td>匹配0个或任意多个任意字符,也就是可以匹配任何内容</td>
</tr>
<tr>
<td>[]</td>
<td>匹配中括号中任意一个字符.例如:[abc]代表一定匹配一个字符,或者是a,或者是b,或者是c</td>
</tr>
<tr>
<td>[-]</td>
<td>匹配中括号中任意一个字符,代表一个范围.例如: [a-z]代表匹配一个小写字母</td>
</tr>
<tr>
<td><sup><a href="#fn_" id="reffn_"></a></sup></td>
<td>逻辑非,表示匹配不是中括号内的一个字符.例如: [\^0-9]代表匹配一个不是数字的字符</td>
</tr>
</tbody>
</table>
</div>
<h5 id="其他特殊符号"><a href="#其他特殊符号" class="headerlink" title="其他特殊符号"></a>其他特殊符号</h5><div class="table-container">
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>‘’</td>
<td>单引号.在单引号中所有的特殊符号,如”$“和”`”(反引号)都没有特殊含义</td>
</tr>
<tr>
<td>“”</td>
<td>双引号.在双引号中特殊符号都没有特殊含义,但是”$“、”`”和”\\”是例外,拥有”调用变量的值”、”引用命令”和”转义符”的特殊含义</td>
</tr>
<tr>
<td>`</td>
<td>反引号.反引号括起来的内容是系统命令,在bash中会先执行它.和$()作用一样,不过推荐使用​$(),因为反引号非常容易看错</td>
</tr>
<tr>
<td>$()</td>
<td>和反引号作用一样,用来引用系统命令</td>
</tr>
<tr>
<td>#</td>
<td>在Shell脚本中,#开头的行代表注释</td>
</tr>
<tr>
<td>$</td>
<td>用于调用变量的值,如需要调用变量name的值时,需要用$name的方式得到变量的值</td>
</tr>
<tr>
<td>\\</td>
<td>转义符.跟在\\之后的特殊符号将失去特殊含义,变为普通字符.如$将输出”$“符号,而不当做是变量引用</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Bash的变量"><a href="#Bash的变量" class="headerlink" title="Bash的变量"></a>Bash的变量</h3><p>shell中默认变量类型为字符型</p>
<h4 id="变量分类"><a href="#变量分类" class="headerlink" title="变量分类"></a>变量分类</h4><ul>
<li>用户自定义变量(本地变量)</li>
<li>环境变量: 这种变量中主要保存的是和系统操作环境相关的数据</li>
<li>位置参数变量: 这种变量主要是用来向脚本当中传递参数或数据的,变量名不能自定义,变量作用是固定的</li>
<li>预定义变量: 是Bash中已经定义好的变量,变量名不能自定义,变量作用也是固定的</li>
</ul>
<h4 id="用户自定义变量"><a href="#用户自定义变量" class="headerlink" title="用户自定义变量"></a>用户自定义变量</h4><p>或者叫本地变量</p>
<h5 id="变量设置规则"><a href="#变量设置规则" class="headerlink" title="变量设置规则"></a>变量设置规则</h5><ul>
<li>变量名称可以由字母、数字和下划线组成,但是不能以数字开头</li>
<li>在Bash中,变量的默认类型都是字符串型,如果要进行数值运算,则必需指定变量类型为数值型</li>
<li>变量用等号连接值,等号左右两侧不能有空格</li>
<li>变量的值如果有空格,需要使用单引号或双引号括起来</li>
<li>在变量的值中,可以使用”\\”转义符</li>
<li>如果需要增加变量的值,那么可以进行变量值的叠加.不过变量需要用双引号包含”$变量名”或用${变量名}包含</li>
<li>如果是把命令的结果作为变量值赋予变量,则需要使用反引号或$()包含命令</li>
<li>环境变量名建议大写,便于区分</li>
</ul>
<h5 id="变量叠加"><a href="#变量叠加" class="headerlink" title="变量叠加"></a>变量叠加</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abc&#x3D;123           #abc值为123</span><br><span class="line">abc&#x3D;&quot;$abc&quot;456     #给abc的值追加456</span><br><span class="line">abc&#x3D;$&#123;abc&#125;789     #给abc的值追加789</span><br></pre></td></tr></table></figure>
<h5 id="变量调用"><a href="#变量调用" class="headerlink" title="变量调用"></a>变量调用</h5><p>echo $变量名</p>
<h5 id="变量查看"><a href="#变量查看" class="headerlink" title="变量查看"></a>变量查看</h5><p>set</p>
<blockquote>
<p>查看系统所有变量</p>
</blockquote>
<h5 id="变量删除"><a href="#变量删除" class="headerlink" title="变量删除"></a>变量删除</h5><p>unset 变量名</p>
<h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><h5 id="环境变量特点"><a href="#环境变量特点" class="headerlink" title="环境变量特点"></a>环境变量特点</h5><ul>
<li>用户自定义变量只在当前的Shell中生效,而环境变量会在当前Shell和这个Shell的所有子Shell当中生效.如果把环境变量写入相应的配置文件,那么这个环境变量就会在所有的Shell中生效</li>
</ul>
<h5 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h5><p>export 变量名[=变量值]        #声明变量(export表示把变量声明为全局变量)</p>
<h5 id="查询环境变量"><a href="#查询环境变量" class="headerlink" title="查询环境变量"></a>查询环境变量</h5><p>env</p>
<blockquote>
<p>专门用于查询环境变量(删除变量依旧是unset+变量名)</p>
</blockquote>
<h5 id="系统常见环境变量"><a href="#系统常见环境变量" class="headerlink" title="系统常见环境变量"></a>系统常见环境变量</h5><h6 id="PATH"><a href="#PATH" class="headerlink" title="PATH"></a>PATH</h6><blockquote>
<p>系统查找命令的路径</p>
</blockquote>
<p>如果想令自己的脚本在任何路径都能直接运行,可以将其加入PATH</p>
<p>方法一:</p>
<blockquote>
<p>直接将脚本拷贝到PATH所指向的路径</p>
</blockquote>
<p>方法二:</p>
<blockquote>
<p>通过变量叠加,为PATH增加新的路径(临时生效,必须写入指定文件)</p>
<p>例如:PATH=”$PATH”:/root   #将root目录加入环境变量</p>
</blockquote>
<h6 id="PS1"><a href="#PS1" class="headerlink" title="PS1"></a>PS1</h6><blockquote>
<p>定义系统提示符的变量</p>
<p>严格来说PS1不是环境变量(env查询不到,set可以查询到),PS1是系统预留的专门用来定义系统操作环境的变量</p>
</blockquote>
<p>\d: 显示日期,格式为“星期 月 日”<br>\h: 显示简写主机名.如默认主机名“localhost”<br>\t: 显示24小时制时间,格式为“HH:MM:SS”<br>\T: 显示12小时制时间,格式为“HH:MM:SS”<br>\A: 显示24小时制时间,格式为“HH:MM”<br>\u: 显示当前用户名<br>\w: 显示当前所在目录的完整名称<br>\W: 显示当前所在目录的最后一个目录<br>\#: 执行的第几个命令<br>\\$: 提示符.如果是root用户会显示提示符为“#”,如果是普通用户会显示提示符为“$”</p>
<h4 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h4><div class="table-container">
<table>
<thead>
<tr>
<th>位置参数变量</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>$n</td>
<td>n为数字,$0代表命令本身,$1-$9代表第一到第九个参数,十以上的参数需要用大括号包含,如${10}</td>
</tr>
<tr>
<td>$*</td>
<td>这个变量代表命令行中所有的参数,$*把所有的参数看成一个整体</td>
</tr>
<tr>
<td>$@</td>
<td>这个变量也代表命令行中所有的参数,$@把每个参数区分对待</td>
</tr>
<tr>
<td>$#</td>
<td>这个变量代表命令行中所有参数的个数</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for x in &quot;$*&quot;</span><br><span class="line">	do</span><br><span class="line">		echo $x</span><br><span class="line">	done</span><br><span class="line">for y in &quot;$@&quot;</span><br><span class="line">	do</span><br><span class="line">		echo $y</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/02/21/VM2n9QGFRwhLBdJ.png" alt=""></p>
<h4 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h4><div class="table-container">
<table>
<thead>
<tr>
<th>预定义变量</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>$?</td>
<td>最后一次执行的命令的返回状态.如果这个变量的值为0,证明<br/>上一个命令正确执行;如果这个变量的值为非0(具体是哪个<br/>数,由命令自己来决定),则证明上一个命令执行不正确</td>
</tr>
<tr>
<td>$$</td>
<td>当前进程的进程号(PID)</td>
</tr>
<tr>
<td>$!</td>
<td>后台运行的最后一个进程的进程号(PID)</td>
</tr>
</tbody>
</table>
</div>
<h5 id="接收键盘输入"><a href="#接收键盘输入" class="headerlink" title="接收键盘输入"></a>接收键盘输入</h5><p>[root@localhost ~]# read [选项] [变量名]<br>选项:<br>    -p “提示信息”      在等待read输入时,输出提示信息<br>    -t 秒数                  read命令会一直等待用户输入,使用此选项可以指定等待时间<br>    -n 字符数             read命令只接受指定的字符数,就会执行<br>    -s                           隐藏输入的数据,适用于机密信息的输入</p>
<h3 id="Bash的运算符"><a href="#Bash的运算符" class="headerlink" title="Bash的运算符"></a>Bash的运算符</h3><h4 id="数值运算与运算符"><a href="#数值运算与运算符" class="headerlink" title="数值运算与运算符"></a>数值运算与运算符</h4><p><img src="https://i.loli.net/2021/02/22/mbBqaXHsEU9RGSe.png" alt=""></p>
<p>变量直接相加无法达到预计的效果.</p>
<h5 id="declare声明变量类型"><a href="#declare声明变量类型" class="headerlink" title="declare声明变量类型"></a>declare声明变量类型</h5><p>[root@localhost ~]# declare [+/-] [选项] 变量名<br>选项:<br>    -      给变量设定类型属性<br>    +      取消变量的类型属性<br>    -i     将变量声明为整数型(integer)<br>    -x    将变量声明为环境变量<br>    -p    显示指定变量的被声明的类型</p>
<p>使用export声明环境变量其实就是赋予变量declare -x属性</p>
<h5 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h5><h6 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h6><p>使用declare将变量声明为整数型</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">x=11</span><br><span class="line">y=22</span><br><span class="line">declare -i z=$x+$y</span><br><span class="line">echo $z</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/02/22/6TuSNE4ylFZiJ7V.png" alt=""></p>
<h6 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h6><p>使用expr或let数值运算工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">x=11</span><br><span class="line">y=22</span><br><span class="line">z=$(expr $x + $y)    注意“+”号左右两侧必须有空格</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/02/22/avOuV1fIxPZcUrn.png" alt=""></p>
<h6 id="方法3-推荐"><a href="#方法3-推荐" class="headerlink" title="方法3(推荐)"></a>方法3(推荐)</h6><p>“$((运算式))”或”$[运算式]”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">x=11</span><br><span class="line">y=22</span><br><span class="line">m=$(($x+$y))</span><br><span class="line">n=$[$y-$x]</span><br><span class="line">echo $m</span><br><span class="line">echo $n</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/02/22/5x7IA1mcwFVn6pj.png" alt=""></p>
<h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><p><img src="https://i.loli.net/2021/02/22/RsryJHD18EGS9jf.png" alt=""></p>
<h4 id="变量测试与内容替换"><a href="#变量测试与内容替换" class="headerlink" title="变量测试与内容替换"></a>变量测试与内容替换</h4><p><img src="https://i.loli.net/2021/02/22/GhwCUnPTuS7QJol.png" alt=""></p>
<h3 id="环境变量配置文件"><a href="#环境变量配置文件" class="headerlink" title="环境变量配置文件"></a>环境变量配置文件</h3><h4 id="环境变量配置文件简介"><a href="#环境变量配置文件简介" class="headerlink" title="环境变量配置文件简介"></a>环境变量配置文件简介</h4><h5 id="source命令"><a href="#source命令" class="headerlink" title="source命令"></a>source命令</h5><p>[root@localhost~]# source 配置文件<br>或<br>[root@localhost~]# . 配置文件</p>
<p>让配置文件直接生效而不用注销或重新登录</p>
<h5 id="环境变量配置文件简介-1"><a href="#环境变量配置文件简介-1" class="headerlink" title="环境变量配置文件简介"></a>环境变量配置文件简介</h5><ul>
<li>环境变量配置文件中主要是定义对系统的操作环境生效的系统默认环境变量,比如PATH、HISTSIZE、PS1、HOSTNAME等默认环境变量</li>
<li>/etc/profile</li>
<li>/etc/profile.d/*.sh</li>
<li>~/.bash_profile</li>
<li>~/.bashrc</li>
<li>/etc/bashrc</li>
<li>位于/etc目录下的环境变量配置文件对全局(任何用户)起作用</li>
</ul>
<h4 id="环境变量配置文件作用"><a href="#环境变量配置文件作用" class="headerlink" title="环境变量配置文件作用"></a>环境变量配置文件作用</h4><p>越往后文件优先级越高</p>
<p><img src="https://i.loli.net/2021/02/23/1CZxXnVHYudBjvf.png" alt=""></p>
<h5 id="etc-profile的作用"><a href="#etc-profile的作用" class="headerlink" title="/etc/profile的作用"></a>/etc/profile的作用</h5><ul>
<li>USER变量</li>
<li>LOGNAME变量</li>
<li>MAIL变量</li>
<li>PATH变量</li>
<li>HOSTNAME变量</li>
<li>HISTSIZE变量</li>
<li>umask</li>
<li>调用/etc/profile.d/* .sh文件</li>
</ul>
<h5 id="bash-profile的作用"><a href="#bash-profile的作用" class="headerlink" title="~/.bash_profile的作用"></a>~/.bash_profile的作用</h5><ul>
<li>调用了~/.bashrc文件</li>
<li>在PATH变量后面加入了”:$HOME/bin”这个目录</li>
</ul>
<h5 id="etc-bashrc的作用"><a href="#etc-bashrc的作用" class="headerlink" title="/etc/bashrc的作用"></a>/etc/bashrc的作用</h5><ul>
<li>定义登录提示符</li>
</ul>
<h4 id="其他配置文件和登录信息"><a href="#其他配置文件和登录信息" class="headerlink" title="其他配置文件和登录信息"></a>其他配置文件和登录信息</h4><h5 id="注销时生效的环境变量配置文件"><a href="#注销时生效的环境变量配置文件" class="headerlink" title="注销时生效的环境变量配置文件"></a>注销时生效的环境变量配置文件</h5><ul>
<li>~/.bash_logout</li>
<li>默认为空</li>
</ul>
<h5 id="其他配置文件"><a href="#其他配置文件" class="headerlink" title="其他配置文件"></a>其他配置文件</h5><ul>
<li>~/bash_history</li>
</ul>
<h5 id="shell登录信息"><a href="#shell登录信息" class="headerlink" title="shell登录信息"></a>shell登录信息</h5><ul>
<li>本地终端欢迎信息(登录前):/etc/issue</li>
</ul>
<p><img src="https://i.loli.net/2021/02/23/gZB7KiHf9kWltDx.png" alt=""></p>
<ul>
<li>远程终端欢迎信息(登录前):/etc/issue.net<ul>
<li>转义符在/etc/issue.net文件中不能使用</li>
<li>是否显示此欢迎信息,由ssh的配置文件/etc/ssh/sshd_config决定,加入“Banner /etc/issue.net”行才能显示(记得重启SSH服务:service sshd restart)</li>
</ul>
</li>
<li>登录后欢迎信息:/etc/motd<ul>
<li>不管是本地登录,还是远程登录,都可以显示此欢迎信息,只不过是登录后显示欢迎信息</li>
</ul>
</li>
</ul>
<h2 id="shell编程"><a href="#shell编程" class="headerlink" title="shell编程"></a>shell编程</h2><h3 id="基础正则表达式"><a href="#基础正则表达式" class="headerlink" title="基础正则表达式"></a>基础正则表达式</h3><h4 id="正则表达式与通配符"><a href="#正则表达式与通配符" class="headerlink" title="正则表达式与通配符"></a>正则表达式与通配符</h4><ul>
<li>正则表达式用来在文件中匹配符合条件的字符串,正则是包含匹配. grep、awk、sed等命令可以支持正则表达式</li>
<li>通配符用来在系统中匹配符合条件的文件名,通配符是完全匹配. ls、find、cp这些命令不支持正则表达式,所以只能使用shell自己的通配符来进行匹配了</li>
</ul>
<h4 id="基础正则表达式-1"><a href="#基础正则表达式-1" class="headerlink" title="基础正则表达式"></a>基础正则表达式</h4><div class="table-container">
<table>
<thead>
<tr>
<th>元字符</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>前一个字符匹配0次或任意多次</td>
</tr>
<tr>
<td>.</td>
<td>匹配除了换行符外任意一个字符</td>
</tr>
<tr>
<td>\^</td>
<td>匹配行首.例如:^hello会匹配以hello开头的行</td>
</tr>
<tr>
<td>$</td>
<td>匹配行尾.例如:hello$会匹配以hello结尾的行</td>
</tr>
<tr>
<td>[]</td>
<td>匹配中括号中指定的任意一个字符,只匹配一个字符.<br/>例如:[aoeiu]匹配任意一个元音字母,[0-9]匹配任意一位数字,<br/>[a-z] [0-9]匹配小写字母和一位数字构成的两位字符</td>
</tr>
<tr>
<td><sup><a href="#fn_" id="reffn_"></a></sup></td>
<td>匹配除中括号中的字符以外的任意一个字符.<br/>例如: [\^0-9]表示匹配任意一位非数字的字符,<br/>[\^a-z] 表示匹配任意一位非小写字母的字符</td>
</tr>
<tr>
<td>\</td>
<td>转义符.将特殊字符进行转义,忽略其特殊意义</td>
</tr>
<tr>
<td>\ {n\\}</td>
<td>表示其前面的字符恰好出现n次.<br/>例如: [0-9]\\{4\\}匹配4位数字,[1] [3-8] [0-9]\\{9\\} 匹配手机号码</td>
</tr>
<tr>
<td>\\ {n,\\}</td>
<td>表示其前面的字符出现不小于n次.<br/>例如: [0-9]\\{2,\\} 表示两位及以上的数字</td>
</tr>
<tr>
<td>\\ {n,m\\}</td>
<td>表示其前面的字符至少出现n次,最多出现m次.<br/>例如:[a-z]\\{6,8\\}匹配6到8位的小写字母</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="string">&quot;*&quot;</span> 前一个字符匹配0次或任意多次</span></span><br><span class="line">grep &quot;a*&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配所有内容，包括空白行</span></span><br><span class="line">grep &quot;aa*&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配至少包含有一个a的行</span></span><br><span class="line">grep &quot;aaa*&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配最少包含两个连续a的字符串</span></span><br><span class="line">grep &quot;aaaaa*&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配最少包含四个连续a的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">&quot;.&quot;</span> 匹配除了换行符外任意一个字符</span></span><br><span class="line">grep &quot;s..d&quot; test.txt </span><br><span class="line"><span class="meta">#</span><span class="bash">“s..d”会匹配在s和d这两个字母之间一定有两个字符的单词</span></span><br><span class="line">grep &quot;s.*d&quot; test.txt </span><br><span class="line"><span class="meta">#</span><span class="bash">匹配在s和d字母之间有任意字符(任意个)</span></span><br><span class="line">grep &quot;.*&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配所有内容</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">&quot;^&quot;</span> 匹配行首,<span class="string">&quot;$&quot;</span> 匹配行尾</span></span><br><span class="line">grep &quot;^M&quot; test.txt </span><br><span class="line"><span class="meta">#</span><span class="bash">匹配以大写“M”开头的行</span></span><br><span class="line">grep &quot;n$&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配以小写“n”结尾的行</span></span><br><span class="line">grep -n &quot;^$&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配空白行</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">&quot;[]&quot;</span>匹配中括号里面指定的任意一个字符,只匹配一个字符</span></span><br><span class="line">grep &quot;s[ao]id&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配s和i字母之间,要不是a、要不是o</span></span><br><span class="line">grep &quot;[0-9]&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配任意0到9中一个数字</span></span><br><span class="line">grep&quot;^[a-z]&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配用小写字母开头的行</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">&quot;[^]&quot;</span>匹配除中括号里面字符以外的任意一个字符</span></span><br><span class="line">grep &quot;^[^a-z]&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配不用小写字母开头的行</span></span><br><span class="line">grep &quot;^[^a-zA-Z]&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配不用字母开头的行</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">&quot;\&quot; 转义符</span></span></span><br><span class="line">grep &quot;\.$&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配使用“.”结尾的行</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">“\&#123;n\&#125;”表示其前面的字符恰好出现n次</span></span><br><span class="line">grep &quot;a\&#123;3\&#125;&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配a字母连续出现三次的字符串</span></span><br><span class="line">grep &quot;[0-9]\&#123;3\&#125;&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配包含连续的三个数字的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">“\&#123;n,\&#125;”表示其前面的字符出现不小于n次</span></span><br><span class="line">grep &quot;^[0-9]\&#123;3,\&#125;&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配最少用连续三个数字开头的行</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">“\&#123;n,m)&#125;”匹配其前面的字符至少出现n次,最多出现m次</span></span><br><span class="line">grep &quot;sa\&#123;1,3\&#125;i&quot; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">匹配在字母s和字母i之间有最少一个a,最多三个a</span></span><br></pre></td></tr></table></figure>
<p><a href="https://man.linuxde.net/docs/shell_regex.html">拓展</a></p>
<h3 id="字符截取命令"><a href="#字符截取命令" class="headerlink" title="字符截取命令"></a>字符截取命令</h3><h4 id="cut命令"><a href="#cut命令" class="headerlink" title="cut命令"></a>cut命令</h4><p>cut命令要和grep命令结合使用</p>
<p>[root@localhost ~]# cut [选项] 文件名<br>选项:<br>    -f 列号        提取第几列(列与列之间是制表符(Tab键),不能是空格)<br>    -d 分隔符   按照指定分隔符分割列(默认为制表符)</p>
<p>下面以test.txt为例说明</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210226172810850.png" alt=""></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cut -f 2 test.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210226172721757.png" alt=""></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cut -f 2,3 test.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210226172849456.png" alt=""></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cut -d &quot;:&quot; -f 1,3 /etc/passwd</span><br><span class="line"><span class="meta">#</span><span class="bash">/etc/passwd以冒号分隔</span></span><br></pre></td></tr></table></figure>
<h5 id="使用cut截取用户名"><a href="#使用cut截取用户名" class="headerlink" title="使用cut截取用户名"></a>使用cut截取用户名</h5><p>使用cut截取登录shell为/bin/bash的用户(root除外)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd | grep /bin/bash | grep -v root | cut -d &quot;:&quot; -f 1</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<ul>
<li>cat /etc/passwd   查看/etc/passwd文件</li>
<li>grep /bin/bash     查找/etc/passwd中含有/bin/bash的行(root也在内)</li>
<li>grep -v root           排除含有/bin/bash的行中的root</li>
<li>cut -d “:” -f 1          以”:”为分隔符截取第一列的用户名</li>
</ul>
<h5 id="cut命令的局限"><a href="#cut命令的局限" class="headerlink" title="cut命令的局限"></a>cut命令的局限</h5><p>根据下面例子感受cut命令的局限</p>
<p>使用df -h查看系统占用情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210226193910604.png" alt=""></p>
<p>我们想要达到这样的效果,当根目录的Use%(使用率,上图中为14%)达到70%会警告用户,因此我们需要截取根目录的Use%部分</p>
<p>首先查找根目录所在行,可以看到根目录在/dev/vad1,使用grep查找其中含有vad1字段的行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -h | grep &quot;vda1&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210226193536662.png" alt=""></p>
<p>接下来截取图中的14%,我们使用cut截取,可以看到14%在第5列</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -h | grep &quot;vda1&quot; | cut -f 5 </span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210226194606942.png" alt=""></p>
<p>可以看出并没有截取到14%,这是因为列与列的间隙不是制表符,而是空格,那么我们使用下面这个命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -h | grep &quot;vda1&quot; | cut -d &quot; &quot; -f 5 </span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210226194901137.png" alt=""></p>
<p>可见提取出的是空白,这是因为我们选择的分隔符为一个空格,所以提取到空白列</p>
<p>想要实现该功能需要借助awk命令,cut命令无法做到</p>
<h4 id="awk命令"><a href="#awk命令" class="headerlink" title="awk命令"></a>awk命令</h4><p>在awk命令的输出中支持print和printf命令</p>
<ul>
<li>print命令:print会在每个输出之后自动加入一个换行符(Linux 默认没有print命令)</li>
<li>printf命令:printf是标准格式输出命令,并不会自动加入换行符,如果需要换行,需要手工加入换行符</li>
</ul>
<h5 id="printf命令"><a href="#printf命令" class="headerlink" title="printf命令"></a>printf命令</h5><p>printf命令后不能直接跟文件名,cat命令运行的结果也不能通过管道符使用printf输出</p>
<p>格式化输出命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">printf &#x27;输出类型输出格式&#x27; 输出内容</span><br></pre></td></tr></table></figure>
<h6 id="输出类型"><a href="#输出类型" class="headerlink" title="输出类型"></a>输出类型</h6><p>%ns        输出字符串,n是数字指代输出几个字符<br>%ni        输出整数,n是数字指代输出几个数字<br>%m.nf   输出浮点数,m和n是数字,指代输出的数字位数和小数位数.如%8.2f代表共输出8位数,其中2位是小数,6位是整数</p>
<h6 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h6><p>\a          输出警告声音<br>\b          输出退格键,也就是Backspace键<br>\f           清除屏幕<br>\n          换行<br>\r           回车,也就是Enter键<br>\t           水平输出退格键,也就是Tab键<br>\v          垂直输出退格键,也就是Tab键</p>
<p>例子</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">printf %s 1 2 3 4 5 6</span><br><span class="line"><span class="meta">#</span><span class="bash">没有加引号,把后面的数字当成整体输出</span></span><br><span class="line">printf %s %s %s 1 2 3 4 5 6</span><br><span class="line"><span class="meta">#</span><span class="bash">只有第一个%s起了作用,后面其他的被当成普通字符串输出</span></span><br><span class="line">printf &#x27;%s %s %s&#x27; 1 2 3 4 5 6</span><br><span class="line"><span class="meta">#</span><span class="bash">三个%s均起作用,分别输出1,2,3,(空格输出空格)然后直接输出4 5 6,因为最后一个%s后面没有空格,使用3和4之间没有空格</span> </span><br><span class="line">printf &#x27;%s %s %s\n&#x27; 1 2 3 4 5 6</span><br><span class="line"><span class="meta">#</span><span class="bash">三个%s均起作用,分别输出1,2,3,然后\n换行,再输出4 5 6</span></span><br><span class="line">printf &#x27;%s %s %s &#x27; 1 2 3 4 5 6</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210227164005664.png" alt=""></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用cat查看test.txt</span></span><br><span class="line">cat test.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210227164805994.png" alt=""></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">将cat test.txt的结果作为<span class="built_in">printf</span>的输入</span></span><br><span class="line">printf &#x27;%s&#x27; $(cat test.txt)</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">printf</span>命令后不能直接跟文件名</span></span><br><span class="line">printf &#x27;%s&#x27; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">cat命令运行的结果也不能通过管道符使用<span class="built_in">printf</span>输出</span></span><br><span class="line">cat test.txt | printf &#x27;%s&#x27;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210227165459937.png" alt=""></p>
<h5 id="awk命令格式"><a href="#awk命令格式" class="headerlink" title="awk命令格式"></a>awk命令格式</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;条件1&#123;动作1&#125; 条件2&#123;动作2&#125;...&#x27; 文件名</span><br></pre></td></tr></table></figure>
<p>条件:</p>
<ul>
<li>关系表达式,例如: x&gt;10,x&lt;=10</li>
<li>BEGIN (在读取数据之前执行其后的动作)</li>
<li>END (在所有动作执行完,再执行其后动作)</li>
</ul>
<p>动作:</p>
<ul>
<li>格式化输出</li>
<li>流程控制语句</li>
</ul>
<p>下面以test.txt为例说明:</p>
<blockquote>
<p>查看test.txt    cat test.txt</p>
</blockquote>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228185800661.png" alt=""></p>
<blockquote>
<p>使用awk截取其中的第2,4列</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;&#123;printf $2 &quot;\t&quot; $4&quot;\n&quot;&#125;&#x27; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="variable">$2</span>表示第2列,<span class="variable">$4</span>表示第4列</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228190025765.png" alt=""></p>
<p>关于cut命令的局限,awk命令则不存在,下面举例说明</p>
<blockquote>
<p>使用df -h查看系统相关信息</p>
</blockquote>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228190527438.png" alt=""></p>
<blockquote>
<p>使用awk截取/dev/vda1行中的14%</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -h | grep vda1 | awk &#x27;&#123;print $5&#125;&#x27; | cut -d &quot;%&quot; -f 1</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228190815576.png" alt=""></p>
<h5 id="关系表达式"><a href="#关系表达式" class="headerlink" title="关系表达式"></a>关系表达式</h5><blockquote>
<p>使用cat test.txt查看test.txt</p>
</blockquote>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228194934658.png" alt=""></p>
<blockquote>
<p>提取其中Mark小于80的姓名</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat test.txt | grep -v Name | awk &#x27;$4&lt;=80&#123;print $2&quot;\n&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228194925571.png" alt="image-20210228194925571"></p>
<h5 id="BEGIN"><a href="#BEGIN" class="headerlink" title="BEGIN"></a>BEGIN</h5><p>在读取数据之前执行其后的动作</p>
<blockquote>
<p>在截取test.txt第2,4列之前先执行BEGIN后的命令</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;print &quot;hello world!&quot;&#125; &#123;print $2 &quot;\t&quot; $4&quot;\n&quot;&#125;&#x27; test.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228191408806.png" alt=""></p>
<blockquote>
<p>截取/etc/passwd的第1,3列</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;&#123;FS=&quot;:&quot;&#125; &#123;print $1 &quot;\t&quot; $3&#125;&#x27; /etc/passwd</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由下图可见,/etc/passwd中的第一行并没有处理</p>
<p>awk会先读入第一行数据,再执行命令</p>
</blockquote>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228193119168.png" alt=""></p>
<blockquote>
<p>加上BEGIN,会在读入第一行数据之前,先执行命令</p>
</blockquote>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228193512426.png" alt=""></p>
<h5 id="END"><a href="#END" class="headerlink" title="END"></a>END</h5><p>在所有命令执行完毕,再执行其后的命令</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228194138995.png" alt="太长了,拼的图"></p>
<h5 id="FS内置变量"><a href="#FS内置变量" class="headerlink" title="FS内置变量"></a>FS内置变量</h5><p>用于指定分隔符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;&#123;print $1 &quot;\t&quot; $3&#125;&#x27; /etc/passwd</span><br></pre></td></tr></table></figure>
<blockquote>
<p>并没有起到提取第1列和第3列的效果</p>
</blockquote>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228192029233.png" alt=""></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;&#123;FS=&quot;:&quot;&#125; &#123;print $1 &quot;\t&quot; $3&#125;&#x27; /etc/passwd</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228192406633.png" alt=""></p>
<h4 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h4><p>sed是一种几乎包括在所有UNIX平台(包括Linux)的轻量级流编辑器.sed主要是用来将数据进行选取、替换、删除、新增的命令</p>
<h3 id="字符处理命令"><a href="#字符处理命令" class="headerlink" title="字符处理命令"></a>字符处理命令</h3><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言学习笔记</title>
    <url>/article/42633.html</url>
    <content><![CDATA[<h1 id="汇编语言学习笔记"><a href="#汇编语言学习笔记" class="headerlink" title="汇编语言学习笔记"></a>汇编语言学习笔记</h1><a id="more"></a>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="机器语言"><a href="#机器语言" class="headerlink" title="机器语言"></a>机器语言</h3><p>机器语言是机器指令的集合.机器指令展开来讲就是一台机器可以正确执行的命令.电子计算机的机器指令是一列二进制数字.计算机将之转变为一列高低电平,以使计算机的电子器件受到驱动,进行运算.</p>
<ul>
<li>因为是以逻辑状态0和1直接命令,不需翻译直接执行,速度快</li>
<li>不同的处理器使用不同的机器语言,所以其可移植差</li>
<li>只有0和1变化组合,不仅难学、难懂、也不容易维护</li>
<li>机器指令能被计算机直接识别</li>
</ul>
<p><img src="https://i.loli.net/2021/02/26/mUXbFMxCcBv3KSI.png" alt=""></p>
<h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><p>由于机器语言在使用上的不便,因此工程师们便从机器语言中找出规则,而以英文字、数字符号来描述机器语言,使成为有意义的语言,这种语言便称为汇编语言.</p>
<p>汇编语言的主体是汇编指令.汇编指令和机器指令的差别在于指令的表示方法上.汇编指令是机器指令便于记忆的书写格式.</p>
<ul>
<li>这些具有特定功能的符号指令称为指令,例如:ADD代表[相加]、MOV代表[移动]</li>
<li>这些指令比起机器语言来说可算是较有意义、容易学习多了,而负责翻译的工具则称之为编译器</li>
<li>汇编指令需要通过编译器转为机器指令</li>
<li>每种CPU都有自己的汇编指令集</li>
</ul>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210226201333082.png" alt=""></p>
<h4 id="汇编语言的组成"><a href="#汇编语言的组成" class="headerlink" title="汇编语言的组成"></a>汇编语言的组成</h4><p>汇编语言发展至今,有以下3类指令组成:</p>
<ol>
<li>汇编指令:机器码的助记符,有对应的机器码</li>
<li>伪指令:没有对应的机器码,由编译器执行,计算机并不执行</li>
<li>其他符号:如+、-、*、/等,由编译器识别,没有对应的机器码</li>
</ol>
<p>汇编语言的核心是汇编指令,它决定了汇编语言的特性.</p>
<h3 id="指令和数据"><a href="#指令和数据" class="headerlink" title="指令和数据"></a>指令和数据</h3><p>指令和数据是应用上的概念.在内存或磁盘上,指令和数据没有任何区别,都是二进制信息.CPU在工作的时候把有的信息看作指令,有的信息看作数据,为同样的信息赋予了不同的意义.</p>
<h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><p>存储器:用于存储数据并在需要时提供数据</p>
<h4 id="存储器分类"><a href="#存储器分类" class="headerlink" title="存储器分类"></a>存储器分类</h4><p>CPU是计算机的核心部件,它控制整个计算机的运作并进行运算.要想让一个CPU工作,就必须向它提供指令和数据.指令和数据在存储器中存放,也就是我们平时所说的<br>内存.在一台PC机中内存的作用仅次于CPU.离开了内存.性能再好的CPU也无法工作.磁盘不同于内存,磁盘上的数据或程序如果不读到内存中,就无法被CPU使用.</p>
<p>一台PC机中,装有多个存储器芯片,这些存储器芯片从物理连接上看是独立的、不同的器件.从读写属性上看分为两类:随机存储器(RAM)和只读存储器(ROM).随机存储<br>器可读可写,但必须带电存储,关机后存储的内容丢失:只读存储器只能读取不能写入,关机后其中的内容不丢失.</p>
<ul>
<li>外部存储器:硬盘、光盘等等</li>
<li>内部存储器:<ul>
<li>RAM:内存条(随机存储器,断电消失)</li>
<li>ROM: BIOS芯片(只读存储器,断电不消失)</li>
</ul>
</li>
</ul>
<p>这些存储器从功能和连接上又可分为以下几类</p>
<ul>
<li><p>随机存储器</p>
<p>用于存放供CPU使用的绝大部分程序和数据,主随机存储器一般由两个位置上的RAM组成,装在主板上RAM和插在扩展插槽上的RAM</p>
</li>
<li><p>装有BIOS(Basic Input/Output System,基本输入/输出系统)的ROM<br>BIOS是由主板和各类接口卡(如显卡、网卡等)厂商提供的软件系统,可以通过它利用该硬件设备进行最基本的输入输出.在主板和某些接口卡上插有存储相应BIOS的ROM.例如,主板上的ROM中存储着主板的BIOS(通常称为系统BIOS);显卡上的ROM中存储着显卡的BIOS;如果网卡上装有ROM,那其中就可以存储网卡的BIOS</p>
</li>
<li><p>接口卡上的RAM<br>某些接口卡需要对大批量输入、输出数据进行暂时存储,在其上装有RAM.最典型的是显示卡上的RAM,一般称为显存.显示卡随时将显存中的数据向显示器上输出.换句话说,我们将需要显示的内容写入显存,就会出现在显示器上</p>
</li>
</ul>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228064800853.png" alt=""></p>
<h4 id="内存地址空间"><a href="#内存地址空间" class="headerlink" title="内存地址空间"></a>内存地址空间</h4><p>上述的那些存储器,在物理上是独立的器件,但是在以下两点上相同:</p>
<ul>
<li>都和CPU的总线相连</li>
<li>CPU对它们进行读或写的时候都通过控制线发出内存读写命令</li>
</ul>
<p>这也就是说,CPU在操控它们的时候,把它们都当作内存来对待,把它们总的看作一个由若干存储单元组成的逻辑存储器,这个逻辑存储器就是我们所说的内存地址空间<br>,我们所面对的是内存地址空间.</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210228065349151.png" alt=""></p>
<p>所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器,每个物理存储器在这个逻辑存储器中占有一个地址段,即一段地址空间.CPU在这段地址空间中读写数据,实际上就是在相对应的物理存储器中读写数据.</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210302165200886.png" alt=""></p>
<div class="note success">
            <p>不同的计算机系统的内存地址空间分配情况是不同的</p>
          </div>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210302165529743.png" alt="8086PC机的内存地址空间分配"></p>
<div class="note info">
            <p>最终运行程序的是CPU,我们用汇编语言编程的时候,必须要从CPU的角度考虑问题.对CPU来讲,系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中,它的容量受CPU寻址能力的限制.这个逻辑存储器即是我们所说的内存地址空间</p>
          </div>
<h4 id="存储单位"><a href="#存储单位" class="headerlink" title="存储单位"></a>存储单位</h4><ul>
<li>计算机中最小的信息单位是bit(比特),也就是一个二进制位</li>
<li>计算机中存储数据的最小单位是Byte(B字节)</li>
<li>8个bit组成一个B,也就是一字节</li>
<li>还可以用以下单位来计量容量:<ul>
<li>1024B=1KB (B=Byte)</li>
<li>1024KB=1MB</li>
<li>1024MB=1GB</li>
<li>1024GB=1TB</li>
</ul>
</li>
</ul>
<h4 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h4><ul>
<li>存储器被划分成了若干个存储单元,一个存储单元可以存储一个字节,也就是8个二进制位,每个存储单元是从0开始顺序编号</li>
<li>对于一个有128个存储单元的存储器:<ul>
<li>容量为128字节</li>
<li>编号就是从0-127</li>
</ul>
</li>
<li>每个单元由两部分构成:<ul>
<li>一个是存储单元的地址,一般用十六进制表示</li>
<li>一个是存储单元的内容,一般用十六进制表示</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2021/02/26/T8EseXqMoVFRv6m.png" alt=""></p>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><ul>
<li>一个典型的CPU由运算器、控制器、寄存器等器件组成,这些器件靠内部总线相连</li>
<li>内部总线实现CPU内部各个器件之间的联系</li>
<li>外部总线实现CPU和主板上其它器件的联系</li>
<li>运算器:对数据进行各种算术运算和逻辑运算,即对数据进行加工处理</li>
<li>控制器:完成协调和指挥整个计算机系统的操作</li>
<li>寄存器:暂存指令、数据和地址</li>
</ul>
<h4 id="CPU对存储器读写"><a href="#CPU对存储器读写" class="headerlink" title="CPU对存储器读写"></a>CPU对存储器读写</h4><p><img src="https://i.loli.net/2021/02/26/UXnIRztYfdlSyrG.png" alt=""></p>
<p>CPU对存储器的读写是通过三种总线来完成的,地址总线、数据总线与控制总线,如下图:</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/6hf937BniMrgTqL.png" alt=""></p>
<p>CPU要想进行数据的读写,必须和外部器件(标准的说法是芯片)进行下面3类<br>信息的交互</p>
<ul>
<li>存储单元的地址(地址信息)</li>
<li>器件的选择,读或写的命令(控制信息)</li>
<li>读或写的数据(数据信息)</li>
</ul>
<h4 id="总线宽度与CPU性能"><a href="#总线宽度与CPU性能" class="headerlink" title="总线宽度与CPU性能"></a>总线宽度与CPU性能</h4><ul>
<li>地址总线的宽度决定了CPU的寻址能力</li>
<li>数据总线的宽度决定了CPU与其它器件进行数据传送时的一次数据传送量</li>
<li>控制总线宽度决定了CPU对系统中其它器件的控制能力</li>
</ul>
<h4 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h4><ul>
<li><p>一根导线可以传送的稳定状态只有两种,高电平或是低电平,也就是0或1</p>
</li>
<li><p>一个CPU有N根地址线,则可以说这个CPU的地址总线的宽度为N.这样的CPU最多可以寻找2的N次方个内存单元</p>
</li>
<li><p>示例:<br>8080、8088、8086、80286、80386是16根、20根、20根、24根、32根,则他们的寻址能力分别为6的地址总线宽度分别64KB、1MB、1MB、16MB 、4GB.<br>2\^16B=2^16/ 1024=64KB<br>2\^20B-2^20/ 1024/ 1024=1M<br>2\^24B=2^24/ 1024/ 1024=16M<br>2\^32B=2\^32/1024/1024/1024=4G</p>
</li>
</ul>
<h4 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h4><p>CPU与内存或其他器件之间的数据传送是通过数据总线来进行的.数据总线的宽度决定了CPU和外界的数据传送速度.8根数据总线一次可传送一个 8位二进制数据(即一个字节)16根数据总线一次可传送两个字节.</p>
<ul>
<li>一根数据总线只能传输一个0或1,即1bit</li>
<li>示例:<br>8080、8088、8086、80286、80386的数据总线宽度分别为8根、8根、16根、16根、32根.则它们一次可以传送的数据为:1B、1B、2B、2B、4B</li>
</ul>
<h4 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a>控制总线</h4><p>CPU对外部器件的控制是通过控制总线来进行的.在这里控制总线是个总称,控制总线是一些不同控制线的集合.有多少根控制总线,就意味着CPU提供了对外部器件的多少种控制.所以,控制总线的宽度决定了CPU对外部器件的控制能力.</p>
<p>内存读或写命令是由几根控制线综合发出的,其中有一根称为“读信号输出”的控制线负责由CPU向外传送读信号,CPU向该控制线上输出低电平表示将要读取数据;有一根称为“写信号输出”的控制线则负责传送写信号.</p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>寄存器是CPU内的组成部分.有限存贮容量的高速存贮部件,它们可用来暂存指令、数据和地址</p>
<ul>
<li>存在于CPU</li>
<li>用于存储数据</li>
<li>速度快</li>
<li>数量有限</li>
<li>8086CPU含有14个寄存器,所有的寄存器都是16位(bit)的,可以存放两个字节,即存放一个字(两个字节等于一个字)</li>
<li>80386CPU含有16个寄存器,所有的寄存器都是32位的,可以存放四个字节,即存放两个字</li>
</ul>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210227201858133.png" alt=""></p>
<p>在CPU中:</p>
<ul>
<li>运算器进行信息处理</li>
<li>寄存器进行信息存储</li>
<li>控制器控制各种器件进行工作</li>
<li>内部总线连接各种器件,在它们之间进行数据的传送</li>
</ul>
<p>16位CPU所含有的寄存器有(共14个) :</p>
<ul>
<li>4个数据寄存器(AX、BX、CX和DX)</li>
<li>2个变址寄存器(SI和DI) 2个指针寄存器(SP和BP)</li>
<li>4个段寄存器(ES、CS、SS、DS)</li>
<li>1个指令指针寄存器(IP)1个标志寄存器(Flags)</li>
</ul>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210301085326154.png" alt=""></p>
<p>32位CPU所含有的寄存器有(共16个):</p>
<ul>
<li>4个数据寄存器(EAX、EBX、ECX和EDX)</li>
<li>2个变址和指针寄存器(ESI和EDD)2个指针寄存器(ESP和EBP)</li>
<li>6个段寄存器(ES、CS、SS、DS、<strong>FS</strong>和<strong>GS</strong>)</li>
<li>1个指令指针寄存器(EIP)1个标志寄存器(EFlags)</li>
</ul>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210227202835381.png" alt=""></p>
<h3 id="数据寄存器"><a href="#数据寄存器" class="headerlink" title="数据寄存器"></a>数据寄存器</h3><p>数据寄存器主要用来保存操作数和运算结果等信息,从而节省读取操作数所需占用总线和访问存储器的时间</p>
<p>32位CPU有4个32位通用寄存器：EAX、EBX、ECX和EDX,对低16位数据的取存,不会影响高16位的数据,这些低16位寄存器分别命名为AX、BX、CX和DX,它和先前的CPU中的寄存器相一致.4个16位寄存器又可分割成8个独立的8位寄存器(AX:ah-al、BX:bh-bl、CX:ch-cl、DX:dh-dl)</p>
<blockquote>
<p>由于在8086之前的CPU为8位CPU,为了兼容以前的8位程序,在8086CPU中,每一个数据寄存器都可以当做两个单独的寄存器来使用,由此,每一个16位寄存器可以当做2个独立的8位寄存器来使用</p>
</blockquote>
<p>每个寄存器都有自己的名称,可独立存取.程序员可利用数据寄存器的这种”可合可分”的特性,灵活地处理字或字节的信息</p>
<p>AX和al通常称为累加器,用累加器进行的操作可能需要更少时间,累加器可用于乘、除、输入/输出等操作,它们的使用频率很高</p>
<p>BX称为基地址寄存器,它可作为存储器指针来使用</p>
<p>CX称为计数寄存器,在循环和字符串操作时,要用它来控制循环次数;在位操作中,当移多位时,要用cl来指明位移的位数</p>
<p>DX称为数据寄存器,在进行乘、除运算时,它可以为默认的操作数参与运算,也可用于存放I/O的端口地址</p>
<ul>
<li>AX、BX、CX、DX这4个寄存器通常用来存放一般性的数据,被称为通用寄存器</li>
</ul>
<p>注意:除了上面4个数据寄存器以外,其他寄存器均不可以分为两个独立的8位寄存器</p>
<table>
    <tr>
        <th colspan="2">寄存器</th>
        <th>说明</th>
    </tr>
    <tr>
        <td rowspan="2">AX</td>
        <td>AL</td>
        <td rowspan="2">累加寄存器(Accumulator):可用于乘、除、输入/输出等操作
        </td>
    </tr>
    <tr>
        <td>AH</td>
    </tr>
    <tr>
        <td rowspan="2">BX</td>
        <td>BL</td>
        <td rowspan="2">基地址寄存器(Base):可作为存储器指针来使用
        </td>
    </tr>
    <tr>
        <td>BH</td>
    </tr>
    <tr>
        <td rowspan="2">CX</td>
        <td>CL</td>
        <td rowspan="2">计数寄存器(Count):在循环和字符串操作时,要用它来控制循环次数;在位操作中,当移多位时,要用CL来指明移位的位数
        </td>
    </tr>
    <tr>
    <td>CH</td>
    </tr>
    <tr>
    <td rowspan="2">DX</td>
    <td>DL</td>
    <td rowspan="2">数据寄存器(Data):在进行乘、除运算时,它可作为默认的操作数参与运算,也可用于存放I/O的端口地址
    </td>
</tr>
<tr>
    <td>DH</td>
</tr>
</table>

<p>下图表示16位寄存器AX,可以表示成两个8位寄存器,其中AH表示高位的8位寄存器,<br>AL表示低位的8位寄存器</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210227205722337.png" alt=""></p>
<p>  <img src="https://gitee.com/wxpgitee/images/raw/master/image-20210227205939995.png" alt=""></p>
<p>注意:</p>
<ul>
<li>在16位CPU中,AX、BX、CX和DX不能存放存储单元的地址</li>
<li>在32位CPU中,其32位寄存器EAX、EBX、ECX和EDX不仅可传送数据、暂存数据保存算术逻辑运算结果,而且也可作为指针寄存器,所以,这些32位寄存器更具有通用性</li>
</ul>
<h3 id="变址寄存器"><a href="#变址寄存器" class="headerlink" title="变址寄存器"></a>变址寄存器</h3><p>32位CPU有2个32位通用寄存器ESI和EDI,其低16位对应先前CPU中的SI和DI,对低16位数据的存取,不影响高16位的数据</p>
<p>ESI、EDI、SI和DI称为变址寄存器,它们主要用于存放存储单元在段内的偏移量,用它们可实现多种存储器操作数的寻址方式,为以不同的地址形式访问存储单元提供方便</p>
<p>变址寄存器不可分割成8位寄存器,作为通用寄存器,也可存储算术逻辑运算的操作数和运算结果</p>
<p>它们可作一般的存储器指针使用,在字符串操作指令的执行过程中,对它们有特定的要求,而且还具有特殊的功能</p>
<h3 id="指针寄存器"><a href="#指针寄存器" class="headerlink" title="指针寄存器"></a>指针寄存器</h3><p>32位CPU有2个32位通用寄存器EBP和ESP,其低16位对应先前CPU中的BP和SP,对低16位数据的存取,不影响高16位的数据</p>
<p>EBP、ESP、BP和SP称为指针寄存器,主要用于存放堆栈内存储单元的偏移量,用它们可实现多种存储器操作数的寻址方式,为以不同的地址形式访问存储单元提供方便</p>
<p>指针寄存器不可分割成8位寄存器,作为通用寄存器,也可存储算术逻辑运算的操作数和运算结果</p>
<p>它们主要用于访问堆栈内的存储单元,并且规定:</p>
<p>BP为基指针寄存器,用它可直接存取堆栈中的数据</p>
<p>SP为堆栈指针寄存器,用它只可访问栈顶</p>
<h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><p>段寄存器是根据内存分段的管理模式而设置的.内存单元的物理地址由段寄存器的值和一个偏移量组合而成的,这样可用两个较少位数的值组合成一个可访问较大物理空间的内存地址</p>
<p>32位CPU有6个段寄存器,分别如下:</p>
<p>CS：代码段寄存器  ES：附加段寄存器</p>
<p>DS：数据段寄存器  FS：附加段寄存器</p>
<p>SS：堆栈段寄存器  GS：附件段寄存器</p>
<blockquote>
<p>在16位CPU系统中,只有4个段寄存器,所以,程序在任何时刻至多有4个正在使用的段可直接访问,在32位微机系统中,它有6个段寄存器,所以在此环境下开发的程序最多可同时访问6个段</p>
</blockquote>
<p>32位CPU有两个不同的工作方式:实方式和保护方式.在每种方式下,段寄存器的作用是不同的,有关规定简单描述如下:</p>
<ul>
<li><p>实方式:段寄存器CS、DS、ES和SS与先前CPU中的所对应的段寄存器的含义完全一致,内存单元的逻辑地址仍为”段地址:偏移地址”的形式,为访问某内存段内的数据,必须使用该段寄存器和存储单元的偏移地址</p>
</li>
<li><p>保护方式:在此方式下,情况要复杂得多,装入段寄存器的不再是段值,而是称为”选择子”的某个值</p>
</li>
</ul>
<p>8086CPU有4个段寄存器:</p>
<ul>
<li>CS:代码段寄存器(Code Segment)</li>
<li>DS:数据段寄存器(Data Segment)</li>
<li>SS:栈段寄存器(Stack Segment)</li>
<li>ES:附加段寄存器(Extra Segment)</li>
</ul>
<p>8086机中,任意时刻,CPU将CS:IP指向的内容作为即将执行的指令</p>
<h3 id="指令指针寄存器"><a href="#指令指针寄存器" class="headerlink" title="指令指针寄存器"></a>指令指针寄存器</h3><p>32位CPU把指令指针扩展到32位,并记作EIP,EIP的低16位与先前CPU中的IP作用相同</p>
<p>指令指针EIP、IP是存放下次将要执行的指令在代码段的偏移地址,在具有预取指令功能的系统中,下次要执行的指令通常已被预取到指令队列中,除非发生转移情况,所以,在理解它们的功能时不考虑存在指令队列的情况</p>
<p>在实方式下,由于每个段的最大范围为64KB,所以,EIP的高16位肯定都为0,此时,相当于只用其低16位的IP来反映程序中的指令的执行次序</p>
<h3 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h3><p>1.运算结果标志位.一共6个,包括:CF进位标志位、PF奇偶标志位、AF辅助进位标志位、ZF零标志位、SF符号标志位、OF溢出标志位</p>
<p>2.状态控制标志位.一共3个,包括:TF追踪标志位、IF中断允许标志位、DF方向标志位</p>
<p>32位标志寄存器增加的4个标志位:</p>
<p> 1.I/O特权标志IOPL</p>
<p>IOPL用两位二进制位来表示,也称为I/O特权级字段,该字段指定了要求执行I/O指令的特权级,如果当前的特权级别在数值上小于等于IOPL的值,那么,该I/O指令可执行,否则将发生一个保护异常</p>
<p>2.嵌套任务标志NT</p>
<p>NT用来控制中断返回指令IRET的执行.具体规定如下:</p>
<p>（1）   当NT=0,用堆栈中保存的值恢复EFlags、CS和EIP,执行常规的中断返回操作</p>
<p>（2）   当NT=1,通过任务转换实现中断返回</p>
<p>3.重启动标志RF</p>
<p>RF用来控制是否接受调试故障.规定:RF=0时,表示接受,否则拒绝</p>
<p>4.虚拟8086方式标志VM</p>
<p>如果VM=1,表示处理机处于虚拟的8086方式下的工作状态,否则,处理机处于一般保护方式下的工作状态</p>
<h3 id="CS-IP"><a href="#CS-IP" class="headerlink" title="CS:IP"></a>CS:IP</h3><h4 id="程序的简要运行流程"><a href="#程序的简要运行流程" class="headerlink" title="程序的简要运行流程"></a>程序的简要运行流程</h4><ol>
<li>程序加载到内存中</li>
<li>CPU找到程序即将执行指令的位置,并执行游戏程序</li>
</ol>
<p>而在这个过程中,需要使用到寄存器(CS:IP)寻址来确定即将执行指令位置</p>
<h4 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h4><p>通常文件中至少有两个段:</p>
<ul>
<li>代码段:存储程序的指令<ul>
<li>一般可读、不可写、可执行</li>
</ul>
</li>
<li>数据段:存储程序中要用到的数据<ul>
<li>一般可读、可写、可执行</li>
</ul>
</li>
</ul>
<p>物理地址=基础地址+偏移地址<br>基础地址=段地址×10H</p>
<p>CPU可以用不同的段地址和偏移地址形成同一个物理地址</p>
<h4 id="修改CS-IP"><a href="#修改CS-IP" class="headerlink" title="修改CS:IP"></a>修改CS:IP</h4><ul>
<li>CPU是由CS:IP中的内容决定执行命令</li>
<li><p>修改:</p>
<ul>
<li><p>同时修改CS:IP的内容</p>
<ul>
<li><p>jmp 段地址:偏移地址</p>
</li>
<li><p>例如: jmp 2AE3:3→从2AE33H处读取指令<br>jmp 3:0B16 →从00B46H处读取指令</p>
</li>
</ul>
</li>
<li>修改IP的内容<ul>
<li>jmp 某一合法寄存器</li>
<li>例如: jmp bx;<ul>
<li>指令执行前: bx=0B16H,CS=2000H,IP=0003H</li>
<li>指令执行后: bx=0B16H,CS=2000H, IP=0B16H</li>
</ul>
</li>
<li>jmp bx;在含义上好似:mov IP,bx</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="字在寄存器的存储"><a href="#字在寄存器的存储" class="headerlink" title="字在寄存器的存储"></a>字在寄存器的存储</h3><p>出于对兼容性的考虑,8086CPU可以一次性处理以下两种尺寸的数据:</p>
<ul>
<li>字节:记为byte,一个字节由8个bit组成,可以存在8位寄存器中</li>
<li>字:记为word,一个字由两个字节组成,这两个字节分别称为这个字的高位字节和低位字节</li>
</ul>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210302134231838.png" alt=""></p>
<div class="note info">
            <p>用十六进制来表示数据可以直观地看出这个数据是由哪些8位数据构成的.比如20000写成4E20就可以直观地看出,这个数据是由4E和20两个8位数据构成的,如果AX中存放4E20,则AH里是4E,AL里是20.这种表示方法便于许多问题的直观分析.以后我们多用十六进制来表示一个数据</p>
          </div>
<h3 id="简单汇编指令"><a href="#简单汇编指令" class="headerlink" title="简单汇编指令"></a>简单汇编指令</h3><div class="table-container">
<table>
<thead>
<tr>
<th>汇编指令</th>
<th>控制CPU完成的操作</th>
<th>用高级语言的语法描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>mov ax,18</td>
<td>将18送入寄存器AX</td>
<td>AX=18</td>
</tr>
<tr>
<td>mov ah,78</td>
<td>将78送入寄存器AH</td>
<td>AH=78</td>
</tr>
<tr>
<td>add ax,8</td>
<td>将寄存器AX中的数值加上8</td>
<td>AX=AX+8</td>
</tr>
<tr>
<td>mov ax,bx</td>
<td>将寄存器BX中的数据送入寄存器AX</td>
<td>AX=BX</td>
</tr>
<tr>
<td>add ax,bx</td>
<td>将AX和BX中的数值相加,结果存在AX中</td>
<td>AX=AX+BX</td>
</tr>
</tbody>
</table>
</div>
<h2 id="寄存器-内存访问"><a href="#寄存器-内存访问" class="headerlink" title="寄存器(内存访问)"></a>寄存器(内存访问)</h2>]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库学习笔记</title>
    <url>/article/49140.html</url>
    <content><![CDATA[<h1 id="数据库学习笔记"><a href="#数据库学习笔记" class="headerlink" title="数据库学习笔记"></a>数据库学习笔记</h1><a id="more"></a>
<h2 id="数据库的相关概念"><a href="#数据库的相关概念" class="headerlink" title="数据库的相关概念"></a>数据库的相关概念</h2><h3 id="DB"><a href="#DB" class="headerlink" title="DB"></a>DB</h3><p>数据库(database) :存储数据的”仓库”,它保存了一系列有组织的数据</p>
<h4 id="数据库存储的特点"><a href="#数据库存储的特点" class="headerlink" title="数据库存储的特点"></a>数据库存储的特点</h4><ol>
<li>将数据放到表中,表再放到库中</li>
<li>一个数据库中可以有多个表,每个表都有一个的名字,用来标识自己.表名具有唯一性</li>
<li>表具有一些特性,这些特性定义了数据在表中如何存储</li>
<li>表由列组成,我们也称为字段.所有表都是由一个或多个列组成的</li>
<li>表中的数据是按行存储的</li>
</ol>
<h3 id="DBMS"><a href="#DBMS" class="headerlink" title="DBMS"></a>DBMS</h3><p>数据库管理系统(Database Management System).数据库是通过DBMS创建和操作的容器</p>
<p>常见的数据库管理系统:MySQL、Oracle、DB2、SqlServer等</p>
<h4 id="DBMS分为两类"><a href="#DBMS分为两类" class="headerlink" title="DBMS分为两类"></a>DBMS分为两类</h4><ul>
<li>基于共享文件系统的DBMS(Access)</li>
<li>基于客户机—服务器的DBMS(MySQL、Oracle、SqlServer)</li>
</ul>
<h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><ul>
<li>成本低,开放源代码,一般可以免费试用</li>
<li>性能高,执行很快,可移植性好</li>
<li>简单,很容易安装和使用</li>
<li>社区版(免费),企业版(收费)</li>
</ul>
<h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>结构化查询语言(Structure Query Language) :专门用来与数据库通信的语言</p>
<h4 id="SQL的优点"><a href="#SQL的优点" class="headerlink" title="SQL的优点"></a>SQL的优点</h4><ol>
<li>不是某个特定数据库供应商专有的语言,几乎所有DBMS都支持SQL</li>
<li>简单易学</li>
<li>虽然简单,但实际上是一种强有力的语言,灵活使用其语言元素,可以进行非常复杂和高级的数据库操作</li>
</ol>
<h2 id="MySQL的下载安装"><a href="#MySQL的下载安装" class="headerlink" title="MySQL的下载安装"></a>MySQL的下载安装</h2><h3 id="下载MySQL"><a href="#下载MySQL" class="headerlink" title="下载MySQL"></a>下载MySQL</h3><p><a href="https://dev.mysql.com/downloads/installer/">下载地址</a></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210302094528470.png" alt=""></p>
<p>点击Download后,可能出现下面的页面,点击红框所选部分</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210302094703889.png" alt=""></p>
<h3 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h3><p>找到下载的MySQL安装文件,双击运行</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210302095639682.png" alt=""></p>
<p>等待片刻</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210302095740307.png" alt=""></p>
<p>选择Developer Default,点击next</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303093015459.png" alt=""></p>
<p>点击Execute</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303093138351.png" alt=""></p>
<p>等待下载,之后点击Next</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303093211445.png" alt=""></p>
<p>点击Next</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303094141765.png" alt=""></p>
<p>点击Next</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303094228963.png" alt=""></p>
<p>点击Next</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303094310677.png" alt=""></p>
<p>设置管理员密码,之后点击Next</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303094452191.png" alt=""></p>
<p>点击Next</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303094649157.png" alt=""></p>
<p>点击Execute</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303094735428.png" alt=""></p>
<p>点击Finish</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303095153339.png" alt=""></p>
<p>点击Next</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303095216696.png" alt=""></p>
<p>点击Finish</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303095243443.png" alt=""></p>
<p>点击Next</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303095315014.png" alt=""></p>
<p>输入密码,之后点击Check</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303095359691.png" alt=""></p>
<p>连接成功,点击Next</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303095426064.png" alt=""></p>
<p>点击Execute</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303095459981.png" alt=""></p>
<p>点击Finish</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303095531238.png" alt=""></p>
<p>点击Next</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303095601082.png" alt=""></p>
<p>点击Finish,安装完毕</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303095619642.png" alt=""></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>github无法打开或加载慢的解决方法</title>
    <url>/article/7cc3ca60.html</url>
    <content><![CDATA[<h1 id="github无法打开或加载慢的解决方法"><a href="#github无法打开或加载慢的解决方法" class="headerlink" title="github无法打开或加载慢的解决方法"></a>github无法打开或加载慢的解决方法</h1><a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><em>GitHub 是一个面向开源及私有软件项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。<br>作为开源代码库以及版本控制系统，Github拥有超过900万开发者用户。随着越来越多的应用程序转移到了云上，Github已经成为了管理软件开发以及发现已有代码的首选方法。</em><br>最近也想鼓捣鼓捣一下，但却发现一个问题，根本进不去GitHub网站（难道我的念想刚萌芽就要被掐灭吗），没错就是下图<br><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210305133853283.png" alt=""><br>这可急坏了我，连忙求助百度，我也是集结多方教程（尝试各路大神的方法），最终解决了这个问题。(注意检查一下自己是不是正在科学上网,这个也会导致访问不了)</p>
<p>在此给出解决方法（亲测有用哟）</p>
<h2 id="一-修改hosts文件"><a href="#一-修改hosts文件" class="headerlink" title="一:修改hosts文件"></a>一:修改hosts文件</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><p>1.找到hosts文件<br>路径为：<strong>C:\Windows\System32\drivers\etc\hosts</strong><br>2.编辑该文件<br>可以用记事本打开，将下面文本拷贝进去即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.30.253.112 github.com</span><br><span class="line">192.30.253.119 gist.github.com</span><br><span class="line">151.101.100.133 assets-cdn.github.com</span><br><span class="line">151.101.100.133 raw.githubusercontent.com</span><br><span class="line">151.101.100.133 gist.githubusercontent.com</span><br><span class="line">151.101.100.133 cloud.githubusercontent.com</span><br><span class="line">151.101.100.133 camo.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars0.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars1.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars2.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars3.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars4.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars5.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars6.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars7.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars8.githubusercontent.com</span><br></pre></td></tr></table></figure>
<p>3.保存（再尝试能不能打开GitHub）</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>1.同样找到hosts文件<br>不过路径变为：<strong>/etc/hosts</strong><br>2.编辑hosts文件<br>同样将下面代码块（和上面一样）拷贝进去并保存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.30.253.112 github.com</span><br><span class="line">192.30.253.119 gist.github.com</span><br><span class="line">151.101.100.133 assets-cdn.github.com</span><br><span class="line">151.101.100.133 raw.githubusercontent.com</span><br><span class="line">151.101.100.133 gist.githubusercontent.com</span><br><span class="line">151.101.100.133 cloud.githubusercontent.com</span><br><span class="line">151.101.100.133 camo.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars0.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars1.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars2.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars3.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars4.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars5.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars6.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars7.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars8.githubusercontent.com</span><br></pre></td></tr></table></figure>
<p>3.一般修改时会权限不够，需要获取root权限， 当然临时root权限也是OK的。<br>输入     vim /etc/hosts 进行修改</p>
<h3 id="使用上述内容无法解决问题-自行查询相关IP"><a href="#使用上述内容无法解决问题-自行查询相关IP" class="headerlink" title="使用上述内容无法解决问题,自行查询相关IP"></a>使用上述内容无法解决问题,自行查询相关IP</h3><p>下面演示几个节点的IP查询方法,其他的自行查找</p>
<p>首先确定GitHub的IP<br>打开</p>
<p><a href="https://github.com.ipaddress.com" class="LinkCard">链接</a></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210305134032797.png" alt=""><br>可以看到IP地址为：140.82.114.4（依据个人情况）<br>确定域名的IP:<br>打开<br><a href="https://fastly.net.ipaddress.com/github.global.ssl.fastly.net" class="LinkCard">链接</a><br><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210305134153763.png" alt=""><br>IP为192.232.69.194<br>确定静态资源的IP:<br>打开<br><a href="https://github.com.ipaddress.com/assets-cdn.github.com" class="LinkCard">链接</a><br><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210305134239499.png" alt=""><br>依据上述方法一或者方法二给出hosts内容逐个查询，编写hosts文件<br>添加如下（依据个人情况编写,下面是我的）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">140.82</span><span class="number">.114</span><span class="number">.4</span> github.com</span><br><span class="line"><span class="number">199.232</span><span class="number">.69</span><span class="number">.194</span> github.global.ssl.fastly.net</span><br><span class="line"><span class="number">185.199</span><span class="number">.108</span><span class="number">.153</span> github.github.io</span><br><span class="line"><span class="number">185.199</span><span class="number">.109</span><span class="number">.153</span> github.github.io</span><br><span class="line"><span class="number">185.199</span><span class="number">.110</span><span class="number">.153</span> github.github.io</span><br><span class="line"><span class="number">185.199</span><span class="number">.111</span><span class="number">.153</span> github.github.io</span><br><span class="line"><span class="number">185.199</span><span class="number">.108</span><span class="number">.153</span> avatars0.githubusercontent.com</span><br><span class="line"><span class="number">185.199</span><span class="number">.108</span><span class="number">.153</span> avatars1.githubusercontent.com</span><br><span class="line"><span class="number">185.199</span><span class="number">.108</span><span class="number">.153</span> avatars2.githubusercontent.com</span><br><span class="line"><span class="number">185.199</span><span class="number">.108</span><span class="number">.153</span> avatars3.githubusercontent.com</span><br><span class="line"><span class="number">185.199</span><span class="number">.108</span><span class="number">.153</span> avatars4.githubusercontent.com</span><br><span class="line"><span class="number">185.199</span><span class="number">.108</span><span class="number">.153</span> avatars5.githubusercontent.com</span><br><span class="line"><span class="number">185.199</span><span class="number">.108</span><span class="number">.153</span> avatars6.githubusercontent.com</span><br><span class="line"><span class="number">185.199</span><span class="number">.108</span><span class="number">.153</span> avatars7.githubusercontent.com</span><br><span class="line"><span class="number">185.199</span><span class="number">.108</span><span class="number">.153</span> avatars8.githubusercontent.com</span><br></pre></td></tr></table></figure>
<h2 id="二-修改DNS解析"><a href="#二-修改DNS解析" class="headerlink" title="二:修改DNS解析"></a>二:修改DNS解析</h2><p>1.鼠标右键点击网络图标</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210305192211702.png" alt=""></p>
<p>2.点击打开”网络和Internet”设置</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210305192038638.png" alt=""></p>
<p>3.下拉找到网络和共享中心,点击进入</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210305192314232.png" alt=""></p>
<p>4.点击红框选中部分</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210305192434702.png" alt=""></p>
<p>5.点击属性</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210305192546615.png" alt=""></p>
<p>6.选中Internet协议版本4,点击属性</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210305192818507.png" alt=""></p>
<p>7.选择使用下面的DNS服务器地址,并输入DNS地址</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210305192919627.png" alt=""></p>
<p>8.这里我推荐两个4.2.2.2(微软)和223.5.5.5(阿里),之后点击确定即可</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210305193610294.png" alt=""></p>
<h2 id="三-刷新DNS解析缓存"><a href="#三-刷新DNS解析缓存" class="headerlink" title="三:刷新DNS解析缓存"></a>三:刷新DNS解析缓存</h2><p>更改完hosts文件后,建议刷新一下DNS缓存</p>
<p>1.win+R打开运行窗口,输入cmd,点击确定打开cmd窗口</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210305135140751.png" alt=""></p>
<p>2.输入下列命令并回车</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">ipconfig /flushdns</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/20210303193228786.png" alt=""></p>
<h2 id="四-github镜像访问"><a href="#四-github镜像访问" class="headerlink" title="四:github镜像访问"></a>四:github镜像访问</h2><p>这里提供两个github的镜像站,以备不测</p>
<p><a href="https://github.com.cnpmjs.org/" class="LinkCard">https://github.com.cnpmjs.org</a></p>
<p><a href="https://hub.fastgit.org/" class="LinkCard">https://hub.fastgit.org</a></p>
<h2 id="五-新增"><a href="#五-新增" class="headerlink" title="五:新增"></a>五:新增</h2><h3 id="新增一"><a href="#新增一" class="headerlink" title="新增一"></a>新增一</h3><p>1.打开DNS查询工具(这是一个查询域名映射关系的工具)</p>
<p><a href="http://tool.chinaz.com/dns" class="LinkCard">点击前往</a></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210307164529324.png" alt=""></p>
<p>2.输入github.com,点击检测</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210307164417959.png" alt=""></p>
<p>你也可以检测一下下面的网址(我就检测了一下github官网),然后安照下面的步骤走</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">github.global.ssl.fastly.net</span><br><span class="line">assets-cdn.github.com</span><br></pre></td></tr></table></figure>
<p>3.找到查询结果中TTL值最小的,复制下其ip</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210307164649882.png" alt=""></p>
<p>4.写入hosts文件,保存即可,关于如何写入前面已经提到,就不再赘述</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210307164826147.png" alt="image-20210307164826147"></p>
<h3 id="新增二"><a href="#新增二" class="headerlink" title="新增二"></a>新增二</h3><p>自己查询ip很累吧,我也是在github发现了很多自动查询的项目,小伙伴们可以去看看</p>
<p><a href="https://github.com/521xueweihan/GitHub520" class="LinkCard">Github520</a></p>
<p><a href="https://github.com/12218/python/tree/master/github_ip" class="LinkCard">Python自动查询ip</a></p>
<p><a href="https://github.com/yjacks/GithubHighSpeed" class="LinkCard">GithubHighSpeed</a></p>
<p>具体食用方法不懂的可以问我哦(个人比较推荐第一个)</p>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>此文仅为记载本人如何解决GitHub无法进入的问题</p>
<p>建议自行查找IP,失效是正常的</p>
]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>git报错及解决方法盘点</title>
    <url>/article/fe55cae0.html</url>
    <content><![CDATA[<h1 id="git报错及解决方法盘点"><a href="#git报错及解决方法盘点" class="headerlink" title="git报错及解决方法盘点"></a>git报错及解决方法盘点</h1><a id="more"></a>
<h2 id="错误一"><a href="#错误一" class="headerlink" title="错误一"></a>错误一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fatal: unable to access &#39;https:&#x2F;&#x2F;github.com&#x2F;.......git&#x2F;&#39;: Failed to connect to github. com port 443: Timed out</span><br></pre></td></tr></table></figure>
<h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><p> 1.查看看你的git配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global -l </span><br></pre></td></tr></table></figure>
<p>如果你没有任何与https代理相关的内容,例如https_proxy = …,则问题不在这里. 如果您有与https代理相关的内容,请将其从〜/ .gitconfig文件中删除,然后重试 </p>
<p>2.如果仍然不起作用,请取消设置环境变量 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">env|grep -i proxy  </span><br></pre></td></tr></table></figure>
<p>你应该有一行或几行https_proxy = … 使用以下内容逐个取消设置:取消设置https_proxy(或HTTPS_PROXY,具体取决于变量的名称)</p>
<p>3.再次检查环境变量    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">env|grep -i proxy</span><br></pre></td></tr></table></figure>
<p>如果它没有显示任何你应该是好的. 注意:此解决方案可以应用于http和https代理问题.只是变量名称从https更改为http </p>
<h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3><p>1.手动配置git的代理.git客户端输入如下两个命令即可 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy http:&#x2F;&#x2F;127.0.0.1:1080 </span><br><span class="line">git config --global https.proxy http:&#x2F;&#x2F;127.0.0.1:1080</span><br></pre></td></tr></table></figure>
<p>2.取消代理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global --unset http.proxy  </span><br><span class="line">git config --global --unset https.proxy  </span><br></pre></td></tr></table></figure>
<h2 id="错误二"><a href="#错误二" class="headerlink" title="错误二"></a>错误二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fatal: unable to access &#39;https:&#x2F;&#x2F;github.com&#x2F;.......git&#x2F;&#39;: failed to receive handshake ssl&#x2F;tls connection failed</span><br></pre></td></tr></table></figure>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global http.sslBackend &quot;openssl&quot;</span><br><span class="line">git config --global http.sslCAInfo [path to .pem file]</span><br></pre></td></tr></table></figure>
<h2 id="错误三"><a href="#错误三" class="headerlink" title="错误三"></a>错误三</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fatal: unable to access &#39;https:&#x2F;&#x2F;github.com&#x2F;.......git&#x2F;&#39;: OpenSSL SSL_read: Connection was reset, errno 10054</span><br></pre></td></tr></table></figure>
<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global http.sslVerify &quot;false&quot;</span><br></pre></td></tr></table></figure>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>遇到这些问题很可能是因为科学上网,可以关闭试试,暂时就遇到这些问题,后续遇到会补上</p>
]]></content>
  </entry>
  <entry>
    <title>教你定时发送天气邮件</title>
    <url>/article/a1a28d7.html</url>
    <content><![CDATA[<h1 id="教你定时发送天气邮件"><a href="#教你定时发送天气邮件" class="headerlink" title="教你定时发送天气邮件"></a>教你定时发送天气邮件</h1><a id="more"></a>
]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github action</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理</title>
    <url>/article/51917.html</url>
    <content><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><a id="more"></a>
<h2 id="计算机系统概论"><a href="#计算机系统概论" class="headerlink" title="计算机系统概论"></a>计算机系统概论</h2>]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机病毒原理与防治</title>
    <url>/article/53598.html</url>
    <content><![CDATA[<h1 id="计算机病毒原理与防治"><a href="#计算机病毒原理与防治" class="headerlink" title="计算机病毒原理与防治"></a>计算机病毒原理与防治</h1><a id="more"></a>
<h2 id="计算机病毒概述"><a href="#计算机病毒概述" class="headerlink" title="计算机病毒概述"></a>计算机病毒概述</h2><h3 id="计算机病毒的简介和特征"><a href="#计算机病毒的简介和特征" class="headerlink" title="计算机病毒的简介和特征"></a>计算机病毒的简介和特征</h3><h4 id="计算机病毒的简介"><a href="#计算机病毒的简介" class="headerlink" title="计算机病毒的简介"></a>计算机病毒的简介</h4><ul>
<li>F.Cohen博士:计算机病毒是一段附着在其它程序上的、可以自我繁殖的程序代码.复制后生成的新病毒同样具有感染其它程序的功能</li>
<li>《中华人民共和国计算机病毒防治管理办法》:计算机病毒是指编制或者在计算机程序中插入的破坏计算机功能或者毁坏数据,影响计算机使用,并能自我复制的一组计算机指令或者程序代码</li>
<li>狭义: 一组能够进行自我传播、需要用户干预来触发执行的破坏性程序或代码</li>
<li>广义:包含狭义上的计算机病毒,还包含蠕虫、木马、后门、僵尸、Rootkit、流氓软件、间谍软件、广告软件、Exploit、黑客工具等</li>
<li>在生命周期中,病毒一般会经历如下四个阶段:<ul>
<li>潜伏阶段</li>
<li>传染阶段</li>
<li>触发阶段</li>
<li>发作阶段(表现/破坏)</li>
</ul>
</li>
</ul>
<blockquote>
<p>潜伏阶段:该阶段病毒处于休眠状态,这些病毒最终会被某些条件(如日期，某特定程序或特定文件的出现,内存的容量超过一定范围等)所激活.当然,并不是所有的病毒都经历此阶段</p>
<p>传播阶段:病毒程序将自身复制到其他程序或磁盘的某个区域上,或者传播到其他计算机中,每个被感染的程序或者计算机又因此包含了病毒的复制品,从而也就进入了传播阶段</p>
<p>触发阶段:病毒在被激活后,会执行某一特定功能从而达到某种目的.和处于潜伏期的病毒一样,触发阶段病毒的触发条件是一些系统事件,譬如可以为病毒复制自身的次数,也可以是系统日期或者时间,如CIH1.2病毒于4月26日爆发</p>
<p>发作阶段:病毒在触发条件成熟时,即可在系统中发作.由病毒发作体现出来的破坏程度是不同的:有些是无害的,有些则给系统带来巨大危害</p>
</blockquote>
<h4 id="计算机病毒的特征"><a href="#计算机病毒的特征" class="headerlink" title="计算机病毒的特征"></a>计算机病毒的特征</h4><ul>
<li>传染性<ul>
<li>具有把自身复制到其它程序中的能力</li>
</ul>
</li>
<li>非授权性</li>
<li>隐蔽性、潜伏性</li>
<li>不可预见性</li>
<li><p>破坏性(破坏性取决于病毒设计者的目的和水平)</p>
<ul>
<li>破坏数据信息</li>
<li>抢占系统资源</li>
<li>破坏硬件</li>
</ul>
</li>
<li><p>可触发性</p>
<ul>
<li>计算机病毒因某个事件或数值的出现,诱使病毒实施感染或进行攻击的特性称为可触发性</li>
</ul>
</li>
</ul>
<h4 id="计算机病毒的结构方式"><a href="#计算机病毒的结构方式" class="headerlink" title="计算机病毒的结构方式"></a>计算机病毒的结构方式</h4><ul>
<li>编码方式:大多数采用汇编语言编写</li>
<li>破坏机制:循环执行,破坏系统</li>
<li>结构方式:指令程序的物理存储</li>
</ul>
<blockquote>
<p>计算机所能识别的语言只有<a href="https://www.baidu.com/s?wd=机器语言&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">机器语言</a>,即由0和1构成的代码.但通常人们编程时,不采用<a href="https://www.baidu.com/s?wd=机器语言&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">机器语言</a>,因为它非常难于记忆和识别.目前通用的<a href="https://www.baidu.com/s?wd=编程语言&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">编程语言</a>有两种形式<a href="https://www.baidu.com/s?wd=汇编语言&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">汇编语言</a>和高级语言.<a href="https://www.baidu.com/s?wd=汇编语言&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">汇编语言</a>的实质和机器语言是相同的,都是直接对硬件操作,只不过指令采用了英文缩写的标识符,更容易识别和记忆</p>
</blockquote>
<h3 id="计算机病毒的分类"><a href="#计算机病毒的分类" class="headerlink" title="计算机病毒的分类"></a>计算机病毒的分类</h3><h4 id="按病毒攻击的机型分类"><a href="#按病毒攻击的机型分类" class="headerlink" title="按病毒攻击的机型分类"></a>按病毒攻击的机型分类</h4><ul>
<li>攻击微型机的病毒</li>
<li>攻击小型机的病毒</li>
<li>攻击工作站的病毒</li>
</ul>
<h4 id="按病毒攻击的操作系统分类"><a href="#按病毒攻击的操作系统分类" class="headerlink" title="按病毒攻击的操作系统分类"></a>按病毒攻击的操作系统分类</h4><ul>
<li>DOS (PingPong,YanKee,DirII…)</li>
<li>Windows (Boza,Punch,CIH…)</li>
<li>UNIX (Bliss,Adore…)</li>
<li>Macintosh 麦金托什(Mac.simpsons)</li>
<li>OS/2 (蓝色怪人) </li>
<li>其它操作系统(手机病毒、PDA病毒)</li>
</ul>
<h4 id="按病毒的破坏情况分类"><a href="#按病毒的破坏情况分类" class="headerlink" title="按病毒的破坏情况分类"></a>按病毒的破坏情况分类</h4><ul>
<li>良性病毒(无害病毒、无危险病毒)<ul>
<li>是不包含对计算机系统产生直接破坏作用的代码的计算机病毒</li>
</ul>
</li>
<li>恶性病毒(危险病毒、极为危险病毒)<ul>
<li>指在代码中包含有破坏计算机系统操作代码的计算机病毒</li>
</ul>
</li>
</ul>
<h4 id="按传播媒介分类"><a href="#按传播媒介分类" class="headerlink" title="按传播媒介分类"></a>按传播媒介分类</h4><ul>
<li>单机病毒<ul>
<li>单机病毒的载体是磁盘或光盘.常见的是通过从软盘传入硬盘,感染系统后,再传染其它软盘.软盘又感染其它系统</li>
</ul>
</li>
<li>网络病毒<ul>
<li>网络为病毒提供了最好的传播途径,它的破坏力是前所未有的.网络病毒利用计算机网络的协议或命令以及Email等进行传播,常见的是通过QQ、BBS、Email、FTP、Web等传播</li>
</ul>
</li>
</ul>
<h4 id="按病毒的寄生方式和感染途径分类"><a href="#按病毒的寄生方式和感染途径分类" class="headerlink" title="按病毒的寄生方式和感染途径分类"></a>按病毒的寄生方式和感染途径分类</h4><ul>
<li>引导型病毒<ul>
<li>主要使用病毒的全部或部分代码取代正常的引导记录,而将正常的引导记录隐藏在其他地方(感染硬盘,软盘主引导扇区)</li>
</ul>
</li>
<li>文件型病毒<ul>
<li>寄生在可执行程序中,一旦程序执行,病毒就被激活,进行预定活动</li>
</ul>
</li>
<li>混合型病毒<ul>
<li>多型病毒(文件和引导型)感染文件和引导扇区两种目标,这样的病毒通常都具有复杂的算法,它们使用非常规的办法侵入系统,同时使用了加密和变形算法</li>
</ul>
</li>
</ul>
<h3 id="计算机病毒的传播途径"><a href="#计算机病毒的传播途径" class="headerlink" title="计算机病毒的传播途径"></a>计算机病毒的传播途径</h3><ul>
<li>感染本地文件、局域网共享目录中的文件(复制副本到对方目录)</li>
<li>寻找Email地址,发送垃圾邮件(携带病毒体)</li>
<li>通过网络共享软件(如KaZza)传播</li>
<li>通过后门进行传播</li>
<li>通过IRC传播(QQ、MSN…)</li>
<li>通过U盘、硬盘、光盘等磁介质传播</li>
<li>利用软件漏洞进行传播</li>
<li>无线电、短信…</li>
</ul>
<h3 id="计算机病毒的基本防治方法"><a href="#计算机病毒的基本防治方法" class="headerlink" title="计算机病毒的基本防治方法"></a>计算机病毒的基本防治方法</h3><h4 id="应持有的态度"><a href="#应持有的态度" class="headerlink" title="应持有的态度"></a>应持有的态度</h4><ul>
<li>不存在这样一种反病毒软硬件,能够防治未来产生的所有病毒</li>
<li>不存在这样一种病毒程序,能够让未来的所有反病毒软硬件都无法检测</li>
<li>目前的反病毒软件和硬件以及安全产品都是易耗品</li>
<li>必须经常进行更新、升级</li>
<li>病毒产生在前,反病毒手段滞后的现状,将是一个长期的过程</li>
</ul>
<h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><blockquote>
<p>预防为主,防治结合</p>
</blockquote>
<h4 id="基本防治方法"><a href="#基本防治方法" class="headerlink" title="基本防治方法"></a>基本防治方法</h4><ul>
<li>提高防范意识<ul>
<li>个人不传播、编制计算机病毒</li>
<li>不打开来历不明、未预期收到的邮件</li>
<li>不随便访问某些网站、不随便在这些网站上下载文件</li>
<li>重要文件定期备份</li>
</ul>
</li>
<li>提高操作系统的抗病毒能力<ul>
<li>问题:操作系统漏洞</li>
<li>解决:提高操作系统的抗病毒能力.打开系统自动更新,尽快获得补丁</li>
</ul>
</li>
<li>安装反病毒软件和防火墙<ul>
<li>瑞星、金山、Norton、卡巴斯基、Macfee…</li>
<li>注意定期更新病毒库</li>
</ul>
</li>
</ul>
<h2 id="计算机病毒基础知识"><a href="#计算机病毒基础知识" class="headerlink" title="计算机病毒基础知识"></a>计算机病毒基础知识</h2><h2 id="计算机病毒的基本机制"><a href="#计算机病毒的基本机制" class="headerlink" title="计算机病毒的基本机制"></a>计算机病毒的基本机制</h2><h2 id="DOS病毒分析"><a href="#DOS病毒分析" class="headerlink" title="DOS病毒分析"></a>DOS病毒分析</h2><h2 id="Windows病毒分析"><a href="#Windows病毒分析" class="headerlink" title="Windows病毒分析"></a>Windows病毒分析</h2><h2 id="病毒技巧"><a href="#病毒技巧" class="headerlink" title="病毒技巧"></a>病毒技巧</h2><h2 id="漏洞与网络蠕虫"><a href="#漏洞与网络蠕虫" class="headerlink" title="漏洞与网络蠕虫"></a>漏洞与网络蠕虫</h2><h2 id="特洛伊木马与Rootkit"><a href="#特洛伊木马与Rootkit" class="headerlink" title="特洛伊木马与Rootkit"></a>特洛伊木马与Rootkit</h2><h2 id="病毒对抗技术"><a href="#病毒对抗技术" class="headerlink" title="病毒对抗技术"></a>病毒对抗技术</h2><h2 id="计算机病毒的防范"><a href="#计算机病毒的防范" class="headerlink" title="计算机病毒的防范"></a>计算机病毒的防范</h2><h2 id="Unix病毒和手机病毒"><a href="#Unix病毒和手机病毒" class="headerlink" title="Unix病毒和手机病毒"></a>Unix病毒和手机病毒</h2>]]></content>
      <categories>
        <category>病毒</category>
      </categories>
      <tags>
        <tag>病毒</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>通用管理知识概论</title>
    <url>/article/2887.html</url>
    <content><![CDATA[<h1 id="通用管理知识概论"><a href="#通用管理知识概论" class="headerlink" title="通用管理知识概论"></a>通用管理知识概论</h1><a id="more"></a>]]></content>
      <categories>
        <category>通用管理知识</category>
      </categories>
      <tags>
        <tag>通用管理知识</tag>
      </tags>
  </entry>
  <entry>
    <title>通信原理基础</title>
    <url>/article/44284.html</url>
    <content><![CDATA[<h1 id="通信原理基础"><a href="#通信原理基础" class="headerlink" title="通信原理基础"></a>通信原理基础</h1><a id="more"></a>
<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><h3 id="计算机与通信-C-amp-C"><a href="#计算机与通信-C-amp-C" class="headerlink" title="计算机与通信(C&amp;C)"></a>计算机与通信(C&amp;C)</h3><p>计算机通信系统是典型的数字通信系统.它是计算机技术和通信技术结合的产物.二者互相促进.</p>
<h4 id="C-amp-C的特点"><a href="#C-amp-C的特点" class="headerlink" title="C&amp;C的特点"></a>C&amp;C的特点</h4><ul>
<li>数据处理设备与通信设备没有本质区别</li>
<li>数据、声音、图象的信息没有本质区别</li>
<li>单处理机、多处理机之间,局域网、城域网、广域网之间的界限变得模糊不清</li>
</ul>
<h4 id="计算机通信的发展方向"><a href="#计算机通信的发展方向" class="headerlink" title="计算机通信的发展方向"></a>计算机通信的发展方向</h4><ul>
<li>由过去的单组(集团)通信向个人通信发展,满足人们个性化的需求(BP机、手机)</li>
<li>计算机通信网络由专业网络向公用网络发展,又向互联网进步</li>
<li>信息交换形式:电路交换→报文交换→分组交换(Datagram虚电路)</li>
<li>由单一的通信网向综合业务数字网发展</li>
<li>网络体系结构:主从关系→对等关系→客户机与服务器→站点到浏览器</li>
</ul>
<h3 id="通信系统模型"><a href="#通信系统模型" class="headerlink" title="通信系统模型"></a>通信系统模型</h3><h4 id="最简单的通信系统"><a href="#最简单的通信系统" class="headerlink" title="最简单的通信系统"></a>最简单的通信系统</h4><p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210304095254344.png" alt="最简单的通信系统"></p>
<blockquote>
<p>但是很多信号(如语音),如果不经过处理,传输距离很短,而且很容易被干扰.所以,在大多数通信系统中,需要”发送设备”和”接收设备”,它们作用就是使信号传输得更远,质量更好</p>
</blockquote>
<h4 id="通信系统的基本模型"><a href="#通信系统的基本模型" class="headerlink" title="通信系统的基本模型"></a>通信系统的基本模型</h4><p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210304095541318.png" alt="通信系统的基本模型"></p>
<ul>
<li>信源:将原始信号转换成电信号的设备</li>
<li>发送设备:调制器,天线等</li>
<li>信道:光纤,同轴电缆,自由空间等</li>
<li>接收设备:解调,发送设备的逆过程</li>
<li>信宿:将电信号还原成原始信号的设备</li>
<li>噪声源:一种随机信号,对通信有害,但不可避免</li>
</ul>
<blockquote>
<p>在传输介质上传送的信号,由于各种噪声源的干扰,受到各种形式的损伤,使得接收到的信号产生畸变.为了尽可能减小信号损伤,需要在发送数据之前,将信号进行编码,用以控制接收端的信号尽量接近发送信号.—-差错控制</p>
</blockquote>
<h3 id="数据通信基本概念"><a href="#数据通信基本概念" class="headerlink" title="数据通信基本概念"></a>数据通信基本概念</h3><ul>
<li><p>通信:在信源点和信宿点之间通过传递消息的形式来交流信息</p>
</li>
<li><p>通信系统:完成通信过程的全部设备和传输介质的总和</p>
</li>
<li><p>信源:产生/形成消息(消息的形式有多种,如:符号、文字、语音、数据、图像、视频等)</p>
</li>
<li><p>发送器:将消息转换成为适合在信道中传输的信号(又分为模拟信号和数字信号)</p>
</li>
<li><p>信道:信号的传输媒介/通道,将信号由发送器传输到接收器,它的传输特性对通信质量有着直接影响</p>
</li>
<li><p>接收器:发生器的逆过程</p>
</li>
<li><p>信宿:接收消息</p>
</li>
<li><p>知识:是人们根据某种目的, 从自然界收集得来的数据中,整理、概括、提取得到有价值的、人们所需要的信息.知识是具有普遍和概括性质的高层次的信息</p>
</li>
<li><p>消息:是信息的载体;是表达信息的形式;是通信统中传输的具体对象</p>
<ul>
<li>消息的形式是多样的,它包括符号、文字、语音、数据、图像、视频等</li>
<li>同一种信息的内容可用不同形式的消息来表达.而一则消息也可载荷不同的信息</li>
<li>消息又分成模拟消息、数字消息</li>
</ul>
</li>
<li><p>数据:是以”数”(number)来表达信息的一类消息表示形式,即数据类消息.</p>
<ul>
<li>在信息社会的发展过程中,数据的概念逐渐从狭义过渡到广义</li>
<li>模拟数据:如果数据在某个时间取连续值,则称为模拟数据.例如温度和压力</li>
<li>数字数据:若数据取离散值,则称数字数据.例如文本信息、整数、二进制数字等</li>
</ul>
</li>
<li><p>信息:是消息所包含的内容</p>
<ul>
<li>香浓(Shannon)定义—-信息是事物运动状态或存在方式的不确定性的描述.因此,通信过程是一种消除不确定性的过程.消除不确定性,就获得了信息.原先的不确定性消除得越多,获得的信息就越多</li>
<li>通信系统中形式上传输的是消息,实质上传输的是信息.信息是有价值的消息</li>
<li>同一种信息的内容可用不同形式的消息来表达</li>
</ul>
</li>
<li><p>信号:是为消息的传播而用来表达消息的一种载体</p>
<ul>
<li>消息的自然形式必须转换成信号形式才能进行传输</li>
<li>连续信号:如果在讨论的时间间隔内,除若干不连续点之外,对于任意时间值都可以给出确定的函数值,此信号就称为连续信号</li>
</ul>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210304184234280.png" alt="连续信号"></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210304184308653.png" alt="连续信号"></p>
<ul>
<li>离散信号:在时间上是离散的,代表离散信号的时间函数只在某些不连续的时间值上给定函数值,在其他时间没有定义</li>
</ul>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210304184441523.png" alt="离散信号"></p>
<ul>
<li>模拟信号:时间和幅值都为连续的信号又称为模拟信号.(在实际应用,模拟信号与连续信号两名词往往不予区分)</li>
</ul>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210304191605076.png" alt="模拟信号"></p>
<ul>
<li>数字信号:时间与幅度取值都具有离散性的信号.(即离散信号的幅值也被限定为某些离散值)</li>
<li>模拟通信:用模拟信号来表示和传递消息的通信方式</li>
<li>数字通信:用数字信号来表示和传递消息的通信方式</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210304191700895.png" alt="数字信号"></p>
<h3 id="模拟通信系统"><a href="#模拟通信系统" class="headerlink" title="模拟通信系统"></a>模拟通信系统</h3><ul>
<li>是指利用模拟信号传递消息的系统<ul>
<li>信源发出的是模拟信号</li>
<li>信道上传输的也是模拟信号</li>
<li>信宿收到的仍然是模拟信号</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210304200949342.png" alt="模拟通信系统"></p>
<ul>
<li>信源:产生状态连续的模拟消息</li>
<li>发信机:非电/电变换器</li>
<li>调制器:将基带信号→已调信号(频带信号)<ul>
<li>调制:为让模拟信号与模拟信道匹配,通常采用调制的方法</li>
</ul>
</li>
<li>解调器:将已调信号→基带信号,与调制器作用相反</li>
<li>收信机:电/非电变换器:基带信号→非电信号</li>
</ul>
<h4 id="模拟通信系统优缺点"><a href="#模拟通信系统优缺点" class="headerlink" title="模拟通信系统优缺点"></a>模拟通信系统优缺点</h4><ul>
<li>信号频谱较窄,信道利用率高</li>
<li>信号连续,混入噪声后不易清除即:抗干扰能力差;不宜保密</li>
<li>设备不易大规模集成化;不适应飞速发展的计算机通信要求</li>
</ul>
<h3 id="数字通信系统"><a href="#数字通信系统" class="headerlink" title="数字通信系统"></a>数字通信系统</h3><p>是指传输和处理数字信号的通信系统</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210304201451007.png" alt="数字通信系统"></p>
<h4 id="数字通信系统优缺点"><a href="#数字通信系统优缺点" class="headerlink" title="数字通信系统优缺点"></a>数字通信系统优缺点</h4><ul>
<li>抗干扰能力强,可靠性高 </li>
<li>信号传输一般采用进制编码,易于使用计算机处理(因而易于构建计算机通信系统) </li>
<li>能传输各种信号,系统灵活性高,能够进行加密处理,数字通信保密强</li>
<li>系统设备易于集成,但成本较高</li>
</ul>
<h3 id="计算机通信与通信网"><a href="#计算机通信与通信网" class="headerlink" title="计算机通信与通信网"></a>计算机通信与通信网</h3><h4 id="数据通信网"><a href="#数据通信网" class="headerlink" title="数据通信网"></a>数据通信网</h4><p>由分布各处的数据传输、交换设备以及通信线路组成的网络系统,其功能是完成网络内部各设备之间的数据/信息的通信</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210304201901463.png" alt="数据通信网"></p>
<h5 id="数据通信网的硬件组成"><a href="#数据通信网的硬件组成" class="headerlink" title="数据通信网的硬件组成"></a>数据通信网的硬件组成</h5><ul>
<li>节点:完成数据处理和交换功能的点</li>
<li>链路:提供传输数据的通道,即传输媒介</li>
</ul>
<h5 id="数据通信网的网络结构"><a href="#数据通信网的网络结构" class="headerlink" title="数据通信网的网络结构"></a>数据通信网的网络结构</h5><ul>
<li>硬件:设备(数据传输设备、数据交换设备及通信线路等)</li>
<li>软件:支持上述设备而配置的网络协议</li>
</ul>
<h5 id="数据通信网的拓扑结构"><a href="#数据通信网的拓扑结构" class="headerlink" title="数据通信网的拓扑结构"></a>数据通信网的拓扑结构</h5><p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210304202242943.png" alt=""></p>
<p>前三个可选择路径,用于传输距离远的远程通信网,后两个共享链路,用于传输距离较<br>近的局部网中</p>
<h4 id="计算机通信网"><a href="#计算机通信网" class="headerlink" title="计算机通信网"></a>计算机通信网</h4><ul>
<li>用数据通信网将分布在不同位置,具备独立功能的多台计算机、终端及其附属设备(I/O设备)连接起来,并实现资源共享的计算机系统</li>
<li>在数据通信网基础上再加上计算机资源处理设备就构成了计算机通信网</li>
<li>通信子网+资源子网<ul>
<li>通信子网:完成数据传输、交换以及通信控制,即上述数据通信网(网络边界线内)</li>
<li>资源子网:由计算机、终端及其附属设备组成,完成数据处理并提供网络所需的硬件,软件数据资源(网络边界线外)</li>
</ul>
</li>
</ul>
<h3 id="计算机通信网与计算机网"><a href="#计算机通信网与计算机网" class="headerlink" title="计算机通信网与计算机网"></a>计算机通信网与计算机网</h3><ul>
<li>计算机通信网:用户必须具体了解网内某一计算机系统的资源情况,用户利用数据通信功能参与对资源的管理和使用,网络对用户来说是”不透明”的</li>
<li>计算机网:由网络操作系统实现资源共享, 网络对用户来说是透明的</li>
</ul>
<h3 id="通信系统的主要性能指标"><a href="#通信系统的主要性能指标" class="headerlink" title="通信系统的主要性能指标"></a>通信系统的主要性能指标</h3><ul>
<li>有效性:如何用最低的成本尽可能快的传递信息,即系统传输信息的速度,又称传输速率</li>
<li>可靠性:量化传输信息的可靠程度, 又称误码率/误比特率</li>
</ul>
<blockquote>
<p>提高通信系统的性能:提高传输速率,降低误码率</p>
</blockquote>
<h2 id="数据通信基础"><a href="#数据通信基础" class="headerlink" title="数据通信基础"></a>数据通信基础</h2><h2 id="差错控制技术"><a href="#差错控制技术" class="headerlink" title="差错控制技术"></a>差错控制技术</h2><h2 id="多路复用技术"><a href="#多路复用技术" class="headerlink" title="多路复用技术"></a>多路复用技术</h2><h2 id="频带传输及调制技术"><a href="#频带传输及调制技术" class="headerlink" title="频带传输及调制技术"></a>频带传输及调制技术</h2><h2 id="数据交换技术"><a href="#数据交换技术" class="headerlink" title="数据交换技术"></a>数据交换技术</h2><h2 id="物理层接口及标准"><a href="#物理层接口及标准" class="headerlink" title="物理层接口及标准"></a>物理层接口及标准</h2><h2 id="数据链路控制规程"><a href="#数据链路控制规程" class="headerlink" title="数据链路控制规程"></a>数据链路控制规程</h2>]]></content>
      <categories>
        <category>通信原理</category>
      </categories>
      <tags>
        <tag>通信原理</tag>
      </tags>
  </entry>
  <entry>
    <title>概率论与数理统计</title>
    <url>/article/6768.html</url>
    <content><![CDATA[<h1 id="概率论与数理统计"><a href="#概率论与数理统计" class="headerlink" title="概率论与数理统计"></a>概率论与数理统计</h1><a id="more"></a>
<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p>概率论与数理统计是研究随机现象统计规律的数学学科<br>概率论:研究如何定量描述随机现象及其规律<br>数理统计:以概率论为基础,研究怎样有效地收集、整理和分析带有随机性的数据,以对所考察的问题作出推断与决策的科学</p>
<h2 id="概率论的基本概念"><a href="#概率论的基本概念" class="headerlink" title="概率论的基本概念"></a>概率论的基本概念</h2><h3 id="随机事件与样本空间"><a href="#随机事件与样本空间" class="headerlink" title="随机事件与样本空间"></a>随机事件与样本空间</h3><h4 id="两类现象"><a href="#两类现象" class="headerlink" title="两类现象"></a>两类现象</h4><ol>
<li>确定性现象:在一定条件下必然发生的现象称为确定性现象</li>
<li>随机现象:在一定条件下可能出现也可能不出现的现象称为随机现象(在个别试验中试验结果呈现不确定性,在大量重复试验中结果具有统计规律性)</li>
</ol>
<h4 id="随机试验"><a href="#随机试验" class="headerlink" title="随机试验"></a>随机试验</h4><p>对随机现象的观察、记录、实验统称为随机试验,通常用E表示<br>随机试验具有以下共同特点:</p>
<ol>
<li>可以在相同的条件下重复进行</li>
<li>每次试验的可能的结果不止一个,并且能事先明确试验的所有可能结果</li>
<li>试验之前不能确定哪一个结果会出现</li>
</ol>
<h4 id="样本空间"><a href="#样本空间" class="headerlink" title="样本空间"></a>样本空间</h4><p>随机试验E的所有可能结果所组成的集合称为E的样本空间,通常记作Ω</p>
<p>样本空间的<strong>元素</strong>,即E的每个结果,称为样本点</p>
<blockquote>
<p>注:试验目的不同,对应的样本空间也不一定相同</p>
<p>例如:</p>
<p>E :拋两枚硬币<br>若观察正面H和反面T出现的情况,则样本空间为 Ω={HH,HT,TH,TT}<br>若观察出现正面的次数,则样本空间为Ω={0,1,2}</p>
</blockquote>
<h4 id="随机事件"><a href="#随机事件" class="headerlink" title="随机事件"></a>随机事件</h4><p>试验E的样本空间Ω的子集称为E的随机事件,简称事件,用A,B,C,…表示</p>
<p>若某事件A中所包含的某个样本点出现,则称事件A发生</p>
<blockquote>
<p>基本事件:由一个样本点组成的单点集</p>
<p>必然事件:在试验中必定发生的事件</p>
<p>不可能事件:在一次试验中不可能发生的事件,记作Φ(空集)</p>
</blockquote>
<h3 id="事件的关系与运算"><a href="#事件的关系与运算" class="headerlink" title="事件的关系与运算"></a>事件的关系与运算</h3><h4 id="事件的关系"><a href="#事件的关系" class="headerlink" title="事件的关系"></a>事件的关系</h4><h5 id="包含关系"><a href="#包含关系" class="headerlink" title="包含关系"></a>包含关系</h5><p>若事件A发生,必然导致事件B发生,则称事件B包含事件A,或称事件A包含于事件B,记作B⊃A或A⊂B</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303135755095.png" alt="包含关系"></p>
<h5 id="相等"><a href="#相等" class="headerlink" title="相等"></a>相等</h5><p>若事件A包含事件B,且事件B包含事件A,则称事件A与事件B相等,记作A=B</p>
<h5 id="事件的并-和"><a href="#事件的并-和" class="headerlink" title="事件的并(和)"></a>事件的并(和)</h5><p>事件A、B至少有一个发生所构成的事件叫做事件A与事件B的和,记作A∪B或A+B</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303141506346.png" alt="事件的并"></p>
<blockquote>
<p>推广:$\bigcup_{i=1}^{n}A_{i}$为事件$A_{1},A_{2}…A_{n}$的和事件或并事件</p>
<p>含义:$A_{1},A_{2}…A_{n}$至少有一个发生</p>
</blockquote>
<h5 id="事件的交-积"><a href="#事件的交-积" class="headerlink" title="事件的交(积)"></a>事件的交(积)</h5><p>事件A、B同时发生所构成的事件叫做事件A与事件B的积,记作A∩B或AB</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303141523907.png" alt="事件的交"></p>
<blockquote>
<p>推广:$\bigcap_{i=1}^{n}A_{i}$为事件$A_{1},A_{2}…A_{n}$的交事件或积事件</p>
<p>含义:$A_{1},A_{2}…A_{n}$同时发生</p>
</blockquote>
<h5 id="事件的差"><a href="#事件的差" class="headerlink" title="事件的差"></a>事件的差</h5><p>由事件A发生且事件B不发生所组成的事件称为事件A与B的差,记作A-B</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303141705094.png" alt="事件的差"></p>
<blockquote>
<p>重要恒等式:A-B=A-AB=A$\bar B$</p>
</blockquote>
<h5 id="事件的互不相容-互斥"><a href="#事件的互不相容-互斥" class="headerlink" title="事件的互不相容(互斥)"></a>事件的互不相容(互斥)</h5><p>若A∩B=Φ中,即A与B不能同时发生,则称事件A与事件B是互不相容或互斥</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303144734089.png" alt="事件的互斥"></p>
<h5 id="事件的互逆-对立"><a href="#事件的互逆-对立" class="headerlink" title="事件的互逆(对立)"></a>事件的互逆(对立)</h5><p>若A∩B=Φ且A∪B=Ω,即A与B有且只有一个发生,则称事件A与事件B是互逆的或互为对立事件,记作B=$\bar A$,则有A$\bar A$=Φ,A∪$\bar A$=Ω</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210303151455230.png" alt="事件的互逆"></p>
<blockquote>
<p>注:事件的互斥与对立的关系对立一定互斥,但是互斥不一定对立</p>
</blockquote>
<h4 id="事件的运算"><a href="#事件的运算" class="headerlink" title="事件的运算"></a>事件的运算</h4><p>设A,B,C为事件,则有</p>
<ol>
<li><p>交换律  A∪B=B∪A,   AB=BA</p>
</li>
<li><p>结合律  (A∪B)∪C=A∪(B∪C)=(A∪C)∪B,  (AB)C=A(BC)=(AC)B</p>
</li>
<li><p>分配律<br>(A∪B)∩C=(A∩C)∪(B∩C)=AC∪BC,<br>(A∩B)∪C=(A∪C)∩(B∪C)=(A∪C)(B∪C)</p>
</li>
<li><p>德$\cdot $摩根律(对偶律): $\overline{A\cup B} =\bar{A} \cap \bar{B} $ , $\overline{A\cap B} =\bar{A} \cup \bar{B} $</p>
<p>$\overline{\bigcup_{i=1}^{n}A_{i}}$=${\bigcap_{i=1}^{n}\bar{A_{i}}}$ , $\overline{\bigcap_{i=1}^{n}A_{i}}$=${\bigcup_{i=1}^{n}\bar{A_{i}}}$</p>
<p>$\overline{\bigcup_{i=1}^{\infty}A_{i}}$=${\bigcap_{i=1}^{\infty }\bar{A_{i}}}$ , $\overline{\bigcap_{i=1}^{\infty}A_{i}}$=${\bigcup_{i=1}^{\infty }\bar{A_{i}}}$</p>
</li>
</ol>
<blockquote>
<p>例:设A,B,C为三事件,用A,B,C的运算关系表示下列各事件<br>(1)A发生,B与C不发生<br>(2)A,B,C中至少有一个发生<br>(3)A,B,C中不多于一个发生<br>(4)A,B,C中不多于两个发生</p>
<p>解:<br>(1) A$\bar B\bar C$ 或 A-B-C<br>(2)A$\cup $B$\cup $C 或 $\overline{\bar{A}\bar{B}\bar{C}} $<br>(3) $A\bar{B} \bar{C} \cup\bar{A} B\bar{C}  \cup \bar{A}\bar{B}C\cup \bar{A} \bar{B}\bar{C} $ 或  $\overline{AB\cup BC\cup AC} $ 或 $\overline{AB} \cap \overline{BC} \cap \overline{AC} $<br>(4)$\overline{ABC}$ 或  $\bar{A} \cup\bar{B} \cup \bar{C}$</p>
</blockquote>
<h3 id="随机事件的概率"><a href="#随机事件的概率" class="headerlink" title="随机事件的概率"></a>随机事件的概率</h3><h4 id="频率与概率"><a href="#频率与概率" class="headerlink" title="频率与概率"></a>频率与概率</h4><h5 id="频率"><a href="#频率" class="headerlink" title="频率"></a>频率</h5><p>在相同的条件下,进行了n次试验,在这n次试验中,事件A发生的次数$n_{A}$,称为事件A发生的<strong>频数</strong><br>比值$\frac{n_{A} }{n} $称为事件A发生的<strong>频率</strong>,并记成$f_{n} (A)$</p>
<p><strong>性质</strong>  设A是随机试验E的任一事件,则</p>
<ol>
<li>0$\le f_{n} (A)\le 1$</li>
<li>$f_{n} (\Omega )= 1$,$f_{n} (\Phi )=0$</li>
<li>若$A_{1} ,A_{2},…,A_{k}$是两两互不相容的事件,则$f(A_{1} \cup A_{2} \cup \cdots \cup A_{k} )=f_{n}(A_{1} )+f_{n}(A_{2} )+\cdots+f_{n}(A_{k} )$</li>
</ol>
<h5 id="概率"><a href="#概率" class="headerlink" title="概率"></a>概率</h5><h6 id="概率的统计学定义"><a href="#概率的统计学定义" class="headerlink" title="概率的统计学定义"></a>概率的统计学定义</h6><p>在随机试验中,若事件A出现的频率m/n随着试验次数n的增加,趋于某一常数p,则定义事件A的概率为p($0\le p\le 1$),记作P(A)=p</p>
<p>缺陷:无法用此定义直接计算概率</p>
<h6 id="概率的公理化定义"><a href="#概率的公理化定义" class="headerlink" title="概率的公理化定义"></a>概率的公理化定义</h6><p>设试验E的样本空间为$\Omega $,对于每一事件A,定义事件P(A),满足如下条件:<br>(1)非负性:P(A)≥0</p>
<p>规范性:P($\Omega$)=1</p>
<p>可列可加性:若$A_{1} ,A_{2},…$是两两互不相容的事件,则$P(A_{1} \cup A_{2} \cup \cdots  )=P_{n}(A_{1} )+P_{n}(A_{2} )+\cdots$</p>
<h6 id="概率的性质"><a href="#概率的性质" class="headerlink" title="概率的性质"></a>概率的性质</h6><ol>
<li>P($\phi $)= 0</li>
<li>若$A_{1} ,A_{2},…$是两两互不相容的事件,则$P(A_{1} \cup A_{2} \cup \cdots \cup A_{n}  )=P_{n}(A_{1} )+P_{n}(A_{2} )+\cdots+P_{n}(A_{n})$(概率的有限可加性)</li>
<li>对于任意事件A有P(A)≤1</li>
<li>设$\bar{A} $是A的对立事件,则P($\bar{A} $)=1- P(A)</li>
<li>A, B是两事件,若A$\subset $B,则<ol>
<li>P(B-A)=P(B)-P(A) </li>
<li>P(A)≤P(B)</li>
<li>一般地,对于任意时间A,B有P(A-B)=P(A)-P(AB)(减法公式)</li>
</ol>
</li>
<li>加法公式  P($A \cup B$)=P(A)+P(B)-P(AB)<ol>
<li>推广:P($A \cup B \cup C$)=P(A)+P(B)+P(C)-P(AB)-P(AC)-P(BC)+P(ABC)</li>
</ol>
</li>
</ol>
<h4 id="古典概型"><a href="#古典概型" class="headerlink" title="古典概型"></a>古典概型</h4><p>若随机试验 E满足:</p>
<ol>
<li>E的样本空间$\Omega$中含有有限个样本点</li>
<li>每个样本点出现的可能性相同,则试验E称为古典概型(有限等可能概型)</li>
</ol>
<p>设$\Omega$={$\omega _{1} ,\omega _{2} ,\cdots ,\omega _{n} $},则$P(\omega _{i})=\frac{1}{n}  $(i=1,2,$\cdots$,n)</p>
<p>设A为E的任意一个事件,A中包含k个基本事件,则P(A)=$\frac{k}{n}$,即P(A)=$\frac{A所含样本点个数}{\Omega 所含样本点个数} $</p>
<h5 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h5><h6 id="无放回摸球"><a href="#无放回摸球" class="headerlink" title="无放回摸球"></a>无放回摸球</h6><div class="note info">
            <p>例:设袋中有M个红球和N个黑球,现从袋中无放回地依次摸出m+n个球,求所取球恰好含m个红球,n个黑球的概率?</p>
          </div>
<div class="note success">
            <p>解: 设A:”所取球恰好含m个红球,n个黑球”</p><p>样本点总数为$C_{M+N}^{m+n} $</p><p>A所含的样本点个数为$C_{M}^{m} C_{N}^{n}$</p><p>故P(A)=$\frac{C_{M}^{m} C_{N}^{n}}{C_{M+N}^{m+n} } $</p>
          </div>
<h6 id="有放回摸球"><a href="#有放回摸球" class="headerlink" title="有放回摸球"></a>有放回摸球</h6><div class="note primary">
            <p>一般地: 一批产品共M+N件,其中M件正品,N件次品,从中依次取出n件,A:”其中恰有k件次品”,分别在”有放回”和”不放回”抽取方式下求P(A).</p>
          </div>
<div class="note info">
            <p><strong>无放回</strong></p><p>$P(A)=C_{n}^{k}\left (  \frac{N}{M+N}\right ) ^{k}  \left (  \frac{M}{M+N}\right ) ^{n-k} $,$k=0,1,\cdots ,n$</p><p><strong>不放回(一块取)</strong></p><p>样本点总数为$C_{M+N}^{n} $</p><p>A所含的样本点个数为$C_{M}^{n-k} C_{N}^{k}$</p><p>故P(A)=$\frac{C_{M}^{n-k} C_{N}^{k}}{C_{M+N}^{n} } $</p>
          </div>
<div class="note ">
            <p>例:某班共有n名同学,全年按365天计算,求下列事件的概率.<br>A:”某指定n天,每位同学生日各占一天”<br>B:”全年某天,恰有两人在这一天生日相同”<br>C:”全班同学生日各不相同”</p>
          </div>
<div class="note info">
            <p>解:先求样本空间中所含样本点的个数<br>n个人在365天中过生日共有$365^{n} $种可能<br>(1)某指定n天,每位同学生日各占一天共有n!种可能,从而P(A)=$\frac{n!}{365^{n} } $<br>(2)全年某天,恰有两人在这一天生日相同</p>
          </div>
<h4 id="几何概型"><a href="#几何概型" class="headerlink" title="几何概型"></a>几何概型</h4><h3 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h3><h4 id="条件概率公式"><a href="#条件概率公式" class="headerlink" title="条件概率公式"></a>条件概率公式</h4><p>设A,B是两个事件,且P(A)&gt; 0,称P(B|A)=$\frac{P(AB)}{P(A)} $为在事件A发生的条件下事件B发生的条件概率;同理可得,P(A|B)=$\frac{P(AB)}{P(B)} $(P(B)&gt;0)为在事件B发生的条件下事件A发生的条件概率</p>
<h4 id="条件概率的性质"><a href="#条件概率的性质" class="headerlink" title="条件概率的性质"></a>条件概率的性质</h4><ol>
<li>非负性: P(B|A)≥0</li>
<li>规范性: P($\Omega $|B)=1, P($\phi $|B)= 0</li>
<li>可列可加性:设$B_{1} ,B_{2},\cdots $是两两不相容的事件,则有$P\left ( \bigcup_{i=1}^{\infty }\mid A  \right ) =\sum_{i=1}^{\infty } P(B_{i}|A )$</li>
<li>P(A|B)=1-P($\bar{A} $|B)</li>
<li>$P(A_{1} \cup A_{2}|B)=P(A_{1}|B)+P(A_{2}|B)-P(A_{1}A_{2}|B)$$P(A_{1}\cup A_{2})=P(A_{1})+P(A_{2})-P(A_{1}A_{2})$</li>
</ol>
<h4 id="乘法公式"><a href="#乘法公式" class="headerlink" title="乘法公式"></a>乘法公式</h4><p>$P(AB)=P(A|B)P(B)=P(B|A)P(A)$</p>
<p>推广:$P(A_{1}A_{2}\cdots A_{n})=P(A_{1})P(A_{2}|A_{1})P(A_{3}|A_{1}A_{2})\cdots P(A_{n}|A_{1}A_{2}\cdots A_{n-1})$</p>
<h4 id="全概率公式"><a href="#全概率公式" class="headerlink" title="全概率公式"></a>全概率公式</h4><h5 id="样本空间的划分"><a href="#样本空间的划分" class="headerlink" title="样本空间的划分"></a>样本空间的划分</h5><p>设$\Omega $为试验E的样本空间$B_{1},B_{2},\cdots ,B_{n}$为E的一组事件,若</p>
<ol>
<li>$B_{i}B_{j}=\emptyset;i\ne  j; i,j=1,2,\cdots ,n$</li>
<li>$B_{1}\cup B_{2}\cup \cdots \cup B_{n}=\Omega $</li>
</ol>
<p>则称$B_{1},B_{2},\cdots ,B_{n}$为样本空间$\Omega $的一个划分</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210316215147380.png" alt=""></p>
<h5 id="全概率公式-1"><a href="#全概率公式-1" class="headerlink" title="全概率公式"></a>全概率公式</h5><p>设试验E的样本空间为$\Omega $, A为任意事件, $B_{1},B_{2},\cdots ,B_{n}$为$\Omega $的一个划分,且$P(B_{i})&gt;0$,(i=1,2,$\cdots$n),则$P(A)=P(A|B_{1})P(B_{1})+P(A|B_{2})P(B_{2})+\cdots P(A|B_{n})P(B_{n})$<br><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210316215952637.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210316220207899.png" alt=""></p>
<h5 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h5><p>设试验E的样本空间为$\Omega $, A为任意事件, $B_{1},B_{2},\cdots ,B_{n}$为$\Omega $的一个划分,且P(A)&gt;0,$P(B_{i})&gt;0$,(i=1,2,$\cdots$n), 则</p>
<p>$P(B_{i}|A)=\frac{P(A|B_{i})P(B_{i})}{\sum_{j=1}^{n}P(A|B_{j})P(B_{j}) } $,(i=1,2,$\cdots$n)</p>
<h4 id="事件的独立性"><a href="#事件的独立性" class="headerlink" title="事件的独立性"></a>事件的独立性</h4><p>对两个事件A、B,如果P(AB)= P(A)P(B),则称A、B相互独立</p>
<blockquote>
<p><strong>定理一</strong>:设A、B是相互独立的两事件,若P(A)&gt;0,则P(B|A)=P(B),若P(B)&gt;0,则P(A|B)=P(A)</p>
<p>定理二:设A、B是相互独立的两事件,则下列各对事件也相互独立:</p>
<ol>
<li>A与$\bar{B} $;</li>
<li>$\bar{A} $与B;</li>
<li>$\bar{A} $与$\bar{B} $</li>
</ol>
</blockquote>
<p>对于三个事件A、B、C,</p>
<ol>
<li>P(AB)= P(A)P(B)</li>
<li>P(AC)= P(A)P(C)</li>
<li>P(BC)= P(B)P(C)</li>
<li>P(ABC)= P(A)P(B)P(C)</li>
</ol>
<p>若(1)、(2)、(3)同时成立,则称事件A、B、C两两独立;若(1)、(2)、(3)、(4)同时成立,则称事件A、B、C相互独立;相互独立必定两两独立,两两独立不一定相互独立.</p>
<blockquote>
<p>推广:设$A_{1},A_{2},\cdots A_{n}$为n个事件,如果对其中任意s(2≤s≤n)个事件$A_{k1},A_{k2},\cdots A_{ks}$,均有:$P(A_{k1},A_{k2},\cdots A_{ks})=P(A_{k1})P(A_{k2})\cdots P(A_{ks})$则称$A_{1},A_{2},\cdots A_{n}$这n个事件相互独立</p>
</blockquote>
<h2 id="随机变量及其分布"><a href="#随机变量及其分布" class="headerlink" title="随机变量及其分布"></a>随机变量及其分布</h2><h3 id="随机变量的概念"><a href="#随机变量的概念" class="headerlink" title="随机变量的概念"></a>随机变量的概念</h3><p>设E是随机试验,它的样本空间为$\Omega ={\omega }$,如果对于每$\omega \in \Omega $,都有一个实数$X(\omega )$与之对应,这样就得到一个定义在$\Omega$上的单值实值函数$X(\omega )$,称$X(\omega )$为随机变量函数,简称<strong>随机变量</strong>.常用X、Y、Z$\cdots $或$\xi、\eta $表示</p>
<p>注意:</p>
<ol>
<li>随机变量与普通的函数不同<br>随机变量是一个函数,普通函数是定义在实数轴上的,而随机变量是定义在样本空间上的(样本空间的元素不一定是实数)</li>
<li>随机变量的取值具有一定的概率规律<br>随机变量随着试验的结果不同而取不同的值,由于试验的各个结果的出现具有一定的概率,因此随机变量的取值也有一定的概率规律</li>
</ol>
<h4 id="随机变量的分类"><a href="#随机变量的分类" class="headerlink" title="随机变量的分类"></a>随机变量的分类</h4><p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210317165450008.png" alt=""></p>
<h4 id="离散型随机变量"><a href="#离散型随机变量" class="headerlink" title="离散型随机变量"></a>离散型随机变量</h4><p>随机变量的取值是有限多个或无限可列多个,这样的随机变量称为<strong>离散型随机变量</strong></p>
<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>设离散型随机变量X所有可能取的值为$x_{k}(k=1,2,\cdots )$,X取各个可能值的概率,即事件$\{X=x_{k}\}$的概率,为$P\{X=x_{k}\}=p_{k},k=1,2,\cdots  $,称此为离散型随机变量X的<strong>分布律</strong></p>
<h5 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h5><ol>
<li>$p_{k}\ge 0,k=1,2,\cdots $</li>
<li>$\sum_{k=1}^{\infty }p_{k}=1$</li>
</ol>
<h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><p>某高校选修课”电影鉴赏”选中率为0.1,某同学有4次选课机会,选中为止,用随机变量X表示选择”电影鉴赏”课程的次数,求X的分布律</p>
<blockquote>
<p>解:X所有可能取的值为1,2,3,4<br>P{X=1}=0.1<br>P{X=2}=(1-0.1)×0.1=0.09<br>P{X=3}=(1-0.1)$^{2}$×0.1=0.081<br>P{X=4}=(1-0.1)$^{3}$=0.729</p>
</blockquote>
<h3 id="两点分布与二项分布"><a href="#两点分布与二项分布" class="headerlink" title="两点分布与二项分布"></a>两点分布与二项分布</h3><h4 id="两点分布-0-1分布"><a href="#两点分布-0-1分布" class="headerlink" title="两点分布(0-1分布)"></a>两点分布(0-1分布)</h4><p>设随机变量X只可能取0与1两个值,它的分布律为P(X=k)=p$^{k}$(1-p)$^{1-k}$,k=0,1(0&lt;p&lt;1),则称X服从(0-1)分布或两点分布</p>
<p>对于一次随机试验,事件A与$\bar{A} $有且只有一个发生,若P(A)=p,则P($\bar{A} $)=1-p,这样的试验称为<strong>伯努利试验</strong></p>
<h4 id="二项分布"><a href="#二项分布" class="headerlink" title="二项分布"></a>二项分布</h4><p>将伯努利试验独立地重复进行了n次,称为n重伯努利试验</p>
<p>n重伯努利试验需满足:</p>
<ol>
<li>独立,即各次试验的结果互不影响</li>
<li>同一结果在每次试验中出现的概率相同,即P(A)=p</li>
<li>事件A与A有且只有一个发生</li>
</ol>
<p>用X表示n重伯努利试验中事件A发生的次数,则P{X=k}=$C^{k}_{n}p^{k}(1-p)^{n-k}$,(k=1,2,$\cdots $n),此时称X服从参数为(n,p)的二项分布,记作X~B(n,p),且$\sum_{n}^{k=0}C^{k}_{n}P^{k}(1-p)^{n-k} =[p+(1-p)]=1$</p>
<h3 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a>泊松分布</h3><p>设随机变量所有可能取的值为0,1,2,$\cdots $,而取各个值的概率为$P\{X=k\}=\frac{\lambda ^{k}e^{-\lambda }}{k!} ,k=0,1,2,\cdots $,其中$\lambda$&gt; 0是常数,则称X服从参数为$\lambda$的泊松分布,记为X~P($\lambda$)或X~$\pi(\lambda)$</p>
<p>$\sum_{k=0}^{\infty }\frac{\lambda ^{k}e^{-\lambda }}{k!}=e^{-\lambda}\sum_{k=0}^{\infty }\frac{\lambda ^{k}}{k!}=e^{-\lambda } e^{\lambda}$,其中$\sum_{k=0}^{\infty }\frac{\lambda ^{k}}{k!}=e^{\lambda }$(根据麦克劳林公式)</p>
<blockquote>
<p>泊松分布适用于描述单位时间内随机事件发生的次数</p>
</blockquote>
<p>一般地,当n&gt;10,p&lt;0.1时,$C^{k}_{n}p^{k}(1-p)^{n-k}\approx \frac{\lambda ^{k}e^{-\lambda }}{k!}$其中,$\lambda =np$</p>
<h3 id="几何分布"><a href="#几何分布" class="headerlink" title="几何分布"></a>几何分布</h3><p>在伯努利试验中,若每次试验中事件A发生的概率为p, X表示试验中A首次发生的试验次数,X的取值为1,2,$\cdots $,则称X服从参数为p的几何分布,其分布律为P{X=k}=(1-p)$^{k-1}$p ,k=1,2,$\cdots $,记为X~G(p)</p>
<p>几何分布用来描述事件首次成功的概率模型</p>
<blockquote>
<p>例题<br>若小李每次射击的命中率为0.6,用X表示小李首次命中目标所用的射击次数,求X的分布律</p>
<p>解:<br>P{X=k}=(1- 0.6)$^{k-1}$0.6= (0.4)$^{k-1}$0.6,k=1,2,$\cdots$</p>
</blockquote>
<p><strong>P{X&gt;m+n|X&gt;m}=P{X&gt;n}</strong></p>
<h3 id="超几何分布"><a href="#超几何分布" class="headerlink" title="超几何分布"></a>超几何分布</h3><p>相当于古典概型中的无放回问题</p>
<p>设N件产品中有M件次品,从中任取n件产品,得到的次品数X为随机变量P{X=k}=$\frac{C^{k}_{m}C^{n-k}_{N-M}}{C^{n}_{N}} $,k=0,1,2,$\cdots$,min(n,M),则称X服从<strong>超几何分布</strong></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210319194619072.png" alt=""></p>
<blockquote>
<p>当n$\ll$N时,即抽取的产品数远小于产品总数时,作无放回抽取,随着M产品总数改变,次品率p=$\frac{M}{N} $改变微乎其微,因此,当n$\ll$N时,无放回抽取可看作有放回抽取</p>
</blockquote>
<h3 id="随机变量的分布函数"><a href="#随机变量的分布函数" class="headerlink" title="随机变量的分布函数"></a>随机变量的分布函数</h3><p>设X是一个随机变量,x是任意实数,函数F(x)= P{X$\le $x}称为X的概率分布函数,简称分布函数, F(x)也写成F$_{X}$(x)</p>
<ol>
<li><p>分布函数主要研究随机变量在某一区间内取值的概率情况</p>
<p>$P\{a&lt;X\le b\}=P\{X\le b\}-P\{X\le a\}=F(b)-F(a)$</p>
<p>$P\{a\le X\le b\}=F(b)-F(a)+P\{X=a\}$</p>
<p>$P\{a&lt;X&lt;b\}=F(b)-F(a)-P\{X=b\}$</p>
</li>
<li><p>分布函数F(x)是关于x的一个普通实函数,而不是随机变量函数</p>
</li>
</ol>
<h4 id="分布函数的性质"><a href="#分布函数的性质" class="headerlink" title="分布函数的性质"></a>分布函数的性质</h4><ol>
<li><p>$0\le F(x)\le 1,x\in (-\infty ,\infty )$</p>
<p>$F(-\infty )=\lim_{x \to \infty} F(x)=0,F(+\infty )=\lim_{x \to \infty} F(x)=1$</p>
</li>
<li><p>$F(x_{}1)\le F(x_{}2),(x_{1}\le x_{2})$ (单调不减)</p>
</li>
<li><p>$\lim_{x \to x^{+}_{0}} F(x)=F(x_{0}),(-\infty &lt;x_{0}&lt;\infty )$ (右连续)</p>
</li>
</ol>
<h3 id="连续型随机变量"><a href="#连续型随机变量" class="headerlink" title="连续型随机变量"></a>连续型随机变量</h3><p>若对于随机变量X的分布函数F(x),存在非负可积函数f(x),使对于$\forall $x∈R,有$ F(x)=\int_{-\infty }^{x} f(t)dt$,则称X为<strong>连续型随机变量</strong>,其中f(x)称为X的概率密度函数,简称<strong>概率密度</strong></p>
<h4 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h4><ol>
<li><p>f(x)$\ge$0</p>
</li>
<li><p>$\int_{-\infty }^{+\infty } f(x)dx=1$</p>
</li>
<li><p>$ P\{x_{1}&lt;X&lt;x_{2}\}=F(x_{2})-F(x_{1})=\int_{x_{1}}^{x_{2}}f(x)dx$</p>
</li>
<li><p>$P\{X\le a\}=F(a)=\int_{-\infty }^{a} f(x)dx$</p>
<p>$P\{X&gt;a\}=1-P\{X\le a\}=1-F(a)=\int_{-\infty }^{a} f(x)dx$</p>
</li>
<li><p>对于任意可能值a,连续型随机变量取a的概率等于零,即P{X=a}=0,$\int_{a}^{a} f(x)dx=0$,故$P\{x_{1}&lt;X\le x_{2}\}=P\{x_{1}\le X\le x_{2}\}=P\{x_{1}&lt;X&lt;x_{2}\}$</p>
<p>连续型随机变量取值落在某一区间的概率与区间的开闭无关</p>
</li>
<li><p>若f(x)在点x处连续,则有F(x)`=f(x)</p>
</li>
</ol>
<blockquote>
<p>若X是连续型随机变量,{X=a}是不可能事件,则有P{X=a}=0;若P{ X=a}=0,事件{X=a}未必是不可能事件<br>若X是离散型随机变量,概率{X=a}是不可能事件$\rightleftharpoons $P{X=a}=0</p>
</blockquote>
<h4 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h4><p>定义设连续型随机变量X具有概率密度$f(x)=\left\{\begin{matrix}<br>  \frac{1}{b-a}, &amp;a&lt;x&lt;b ,\\0 ,<br>  &amp;其它.<br>\end{matrix}\right.$,则称X在区间(a,b)服从均匀分布,记为X~U(a,b)</p>
<blockquote>
<p>X~U(a,b),则X落在区间(a,b)中任意等长度的子区间内的可能性是相同的</p>
<p>均匀分布的本质—几何概型</p>
</blockquote>
<h5 id="分布函数"><a href="#分布函数" class="headerlink" title="分布函数"></a>分布函数</h5><p>$F(x)=\int_{-\infty }^{x} f(t)dt=\left\{\begin{matrix}<br> 0, &amp; x&lt;a,\\<br>  \frac{x-a}{b-a}, &amp;a\le x&lt;b, \\<br>  1,&amp;x\ge b.<br>\end{matrix}\right.$</p>
<h4 id="指数分布"><a href="#指数分布" class="headerlink" title="指数分布"></a>指数分布</h4><p>定义设连续型随机变量X的概率密度为$f(x)=\left\{\begin{matrix}<br>  \lambda e^{-\lambda x},&amp;x&gt;0, \\<br>  0,&amp;x\le 0.<br>\end{matrix}\right.$,其中$\lambda$&gt;0为常数,则称X服从参数为$\lambda$的指数分布,记为X~e($\lambda$)或X~Exp($\lambda$)</p>
<h5 id="分布函数-1"><a href="#分布函数-1" class="headerlink" title="分布函数"></a>分布函数</h5><p>$ F(x)=\left\{\begin{matrix}<br>  1-e^{-\lambda x},&amp;x&gt;0 ,\\<br>  0,&amp;x\le 0.<br>\end{matrix}\right.$</p>
<blockquote>
<p>指数分布是独立事件发生的时间间隔的分布</p>
<p>无记忆性:P{X&gt;s+t|X&gt;s}=P{X&gt;t}</p>
</blockquote>
<p>指数分布的应用:某些元件或设备的寿命服从指数分布</p>
<h4 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h4><p>设连续型随机变量X的概率密度为$f(x)=\frac{1}{\sqrt{2\pi \sigma } }e^{-\frac{(x-\mu )^{2}}{2\sigma^{2} } } ,-\infty <x<+\infty $,其中$\mu ,\sigma (\sigma >0)$为常数,则称X服从参数为$\mu ,\sigma^{2}$的正态分布或高斯分布,记为X~N($\mu ,\sigma^{2}$)</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320094806673.png" alt=""></p>
<ol>
<li><p>f(x)关于x=$\mu$对称</p>
</li>
<li><p>当x=$\mu$时,f(x)取得最大值$\frac{1}{\sqrt{2\pi \sigma } } $</p>
</li>
<li><p>当$x\to \pm \infty $,f(x)$\to $0</p>
</li>
<li><p>曲线在x=$\mu \pm \sigma $处有拐点</p>
</li>
<li><p>当固定$\sigma$,改变$\mu$的大小时,f(x)图形的形状不变,只是沿着x轴作平移变换</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320095039164.png" alt=""></p>
</li>
<li><p>当固定$\mu$,改变$\sigma$的大小时,f(x)图形的对称轴不变,而形状在改变,$\sigma$越小,图形越高越瘦;$\sigma$越大,图形越矮越胖</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320095310748.png" alt=""></p>
</li>
</ol>
<h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210320095402940.png" alt=""></p>
<h5 id="标准正态分布"><a href="#标准正态分布" class="headerlink" title="标准正态分布"></a>标准正态分布</h5><p>当正态分布N($\mu ,\sigma ^{2}$)中的$\mu$=0,$\sigma $= 1时,这样的正态分布称为标准正态分布,记为N(0,1)</p>
<p>概率密度为$\varphi (x)=\frac{1}{\sqrt{2\pi } } e^{\frac{x^{2}}{2} },-\infty &lt;x&lt;\infty $</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210322155311224.png" alt=""></p>
<p>分布函数为$\Phi (x)=\int_{-\infty }^{x} \frac{1}{\sqrt{2\pi } } e^{\frac{r^{2}}{2} } dt,-\infty &lt;x&lt;\infty $</p>
<h6 id="性质-2"><a href="#性质-2" class="headerlink" title="性质"></a>性质</h6><ol>
<li>$\Phi (-x)=1-\Phi (x)$</li>
<li>$若X\sim N(\mu ,\sigma ^{2}),则Z=\frac{X-\mu }{\sigma } \sim N(0,1)$</li>
</ol>
<h4 id="一维随机变量的函数的分布"><a href="#一维随机变量的函数的分布" class="headerlink" title="一维随机变量的函数的分布"></a>一维随机变量的函数的分布</h4><h5 id="离散型随机变量-1"><a href="#离散型随机变量-1" class="headerlink" title="离散型随机变量"></a>离散型随机变量</h5><p>若X是离散型随机变量,则Y=g(X)也一定是离散型随机变量</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210323201736451.png" alt=""></p>
<h5 id="连续性随机变量"><a href="#连续性随机变量" class="headerlink" title="连续性随机变量"></a>连续性随机变量</h5><p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210323203204058.png" alt=""></p>
<p>设随机变量X的具有概率密度$f_{x}(x)$,其中-∞&lt;x&lt;+∞,又设函数g(x)处处可导,且恒有${g}’ (x)&gt;0$[或恒有${g}’ (x)&lt;0$],则称Y=g(X)是连续型随机变量,其概率密度为<br>$f_{Y}(y)=\left\{\begin{matrix}<br>  f_{X}[h(y)]|{h}’(y)| ,&amp; \alpha &lt;y&lt;\beta \\<br>  0,&amp;其他<br>\end{matrix}\right.$<br>其中$\alpha$=min(g(-∞),g(+)),$ \beta $= max(g(-∞),g(+∞)),h(y)是g(x)的反函数</p>
<h2 id="多维随机变量及其分布"><a href="#多维随机变量及其分布" class="headerlink" title="多维随机变量及其分布"></a>多维随机变量及其分布</h2><h2 id="随机变量的数字特征"><a href="#随机变量的数字特征" class="headerlink" title="随机变量的数字特征"></a>随机变量的数字特征</h2><h2 id="大数定律和中心极限定律"><a href="#大数定律和中心极限定律" class="headerlink" title="大数定律和中心极限定律"></a>大数定律和中心极限定律</h2>]]></content>
      <categories>
        <category>概率论与数理统计</category>
      </categories>
      <tags>
        <tag>概率论与数理统计</tag>
      </tags>
  </entry>
  <entry>
    <title>为hexo博客添加二级域名</title>
    <url>/article/49509.html</url>
    <content><![CDATA[<h1 id="为hexo博客添加二级域名"><a href="#为hexo博客添加二级域名" class="headerlink" title="为hexo博客添加二级域名"></a>为hexo博客添加二级域名</h1><a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在未添加二级域名时,只能通过<a href="https://www.idefun.com/blog">https://www.idefun.com/blog</a>访问本网站,添加后可通过<a href="https://blog.idefun.com">https://blog.idefun.com</a>访问本网站</p>
<h2 id="添加二级域名解析"><a href="#添加二级域名解析" class="headerlink" title="添加二级域名解析"></a>添加二级域名解析</h2><p>打开域名控制台(我都是阿里云的),找到要设置二级域名的域名</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210301130052576.png" alt=""></p>
<p>点击解析</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210301130127605.png" alt=""></p>
<p>点击添加记录</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210301130154820.png" alt=""></p>
<p>记录类型选择CNAME,主机记录自定义(我都是blog),解析线路选择默认,记录值为github用户名.github.io,TTL选择默认(10分钟)</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210301130313587.png" alt=""></p>
<h2 id="添加CNAME文件"><a href="#添加CNAME文件" class="headerlink" title="添加CNAME文件"></a>添加CNAME文件</h2><p>在hexo博客本地文件夹的source下,创建CNAME.txt</p>
<p>里面内容填写为你的二级域名并保存</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210301130827139.png" alt=""></p>
<p>之后重命名为CNAME,将.txt去除即可</p>
<h2 id="修改hexo配置文件"><a href="#修改hexo配置文件" class="headerlink" title="修改hexo配置文件"></a>修改hexo配置文件</h2><p>打开_config.yml文件,修改其中内容</p>
<p>找到url字段,更改为你的二级域名,root改为/即可</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210301131052806.png" alt=""></p>
<h2 id="上传本地更改"><a href="#上传本地更改" class="headerlink" title="上传本地更改"></a>上传本地更改</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>无处安放</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>域名</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学原理学习笔记</title>
    <url>/article/32664.html</url>
    <content><![CDATA[<h1 id="密码学原理学习笔记"><a href="#密码学原理学习笔记" class="headerlink" title="密码学原理学习笔记"></a>密码学原理学习笔记</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h3 id="我国的密码分级"><a href="#我国的密码分级" class="headerlink" title="我国的密码分级"></a>我国的密码分级</h3><ol>
<li>核心密码:用于保护党政军的核心机密</li>
<li>普通密码:用于保护国家和事企业单位的低于核心机密,高于商用机密信息</li>
<li>商用密码:用于保护国家和事企业单位的非机密的敏感信息</li>
<li>个人密码:用于保护个人的隐私信息</li>
</ol>
<blockquote>
<p>前三种密码均有国家密码管理局统一管理</p>
</blockquote>
<h3 id="密码学的组成"><a href="#密码学的组成" class="headerlink" title="密码学的组成"></a>密码学的组成</h3><ul>
<li>研究密码编制的科学:密码编制学(Cryptography )</li>
<li>研究密码破译的科学:密码分析学(Cryptanalysis)</li>
<li>密码编制学+密码分析学=密码学(Cryptology)</li>
</ul>
<h3 id="保密系统"><a href="#保密系统" class="headerlink" title="保密系统"></a>保密系统</h3><p>简单地说,一个保密系统主要由明文信源、信道、加密器、解密器以及密钥源<br>等五个基本部分组成</p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210301210414677.png" alt=""></p>
<p>明文信息的产生和发送者称为明文信源(source). 我们一般称由明文信源产生的信息为消息(message).由明文信源输出的消息要经过某种通信渠道传送给称为信宿的接收者(receiver). 所谓信道(channel)就是将明文信源消息传送给接收者的渠道.加密器将明文信源输出的消息变换为密文,然后再输出到信道.解密器接收信道的输出,并恢复出原始的明文信源消息.密钥源用于产生加密器和解密器所使用的密钥</p>
<blockquote>
<p>存储系统也可以看做是一种特殊的保密系统</p>
</blockquote>
<p>保密系统的使用者通常称为用户(user). 保密系统的破坏者有时称为对手(adversary).对手分为“窃听型”和“干扰型”两种.“ 窃听型”对手只是截取信道上传送的信息,然后进行分析.而“干扰型”对手则会篡改信道上传送的信息.</p>
<h3 id="密码体制"><a href="#密码体制" class="headerlink" title="密码体制"></a>密码体制</h3><p>没有加密的信息称为明文(plaintext).加密后的信息称为密文(ciphertext).从明文到密文的变换称为加密(encryption). 从密文到明文的变换称为解密(decryption).</p>
<blockquote>
<p>加密和解密都是在密钥(key) 的控制下进行的.给定一个密钥,就可确定一对具体的加密变换和解密变换.</p>
</blockquote>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210301212036997.png" alt=""></p>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210301212533141.png" alt=""></p>
<blockquote>
<p>密钥空间中不同密钥的个数称为密码体制的密钥量.它是衡量密码体制安全性的一个重要指标.</p>
</blockquote>
<p>如果一个密码体制的加密密钥与解密密钥相同,则称其为单密钥密码体制或对称密码体制;否则,称其为双密钥密码体制或非对称密码体制.</p>
<p>在一个双密钥密码体制中,如果由加密密钥ke计算解密密钥kd是困难的,公开ke不会损害kd的安全性,则可以将加密密钥ke公开.这样的密码体制称为公钥密码体制(public-key cryptosystem).(kd更重要)</p>
<h4 id="密码体制的分类"><a href="#密码体制的分类" class="headerlink" title="密码体制的分类"></a>密码体制的分类</h4><h5 id="从加密密钥与解密密钥是否相等划分"><a href="#从加密密钥与解密密钥是否相等划分" class="headerlink" title="从加密密钥与解密密钥是否相等划分"></a>从加密密钥与解密密钥是否相等划分</h5><ol>
<li>传统密码: <ul>
<li>ke=kd</li>
<li>典型密码: DES, AES, SMS4, RC4</li>
</ul>
</li>
<li>公开密钥密码:<ul>
<li>ke!=kd</li>
<li>且由ke不能计算出kd</li>
<li>可将ke公开,不会危害kd安全</li>
<li>典型密码: RSA,EIGAMAL,ECC</li>
</ul>
</li>
</ol>
<h5 id="从密钥的使用方式划分"><a href="#从密钥的使用方式划分" class="headerlink" title="从密钥的使用方式划分"></a>从密钥的使用方式划分</h5><ol>
<li>序列密码:<ul>
<li>明文、密文、密钥以位(字符)为单位加解密</li>
<li>核心密码的主流</li>
<li>典型密码: RC4,ZUC </li>
</ul>
</li>
<li>分组密码:<ul>
<li>明文、密文、密钥以分组为单位加解密</li>
<li>商用密码的主流</li>
<li>典型密码: DES,AES,SMS4</li>
</ul>
</li>
</ol>
<h5 id="从密码算法是否变化划分"><a href="#从密码算法是否变化划分" class="headerlink" title="从密码算法是否变化划分"></a>从密码算法是否变化划分</h5><ol>
<li>固定算法密码:<ul>
<li>密码工作过程中算法固定不变,密钥可变</li>
<li>迄今为止的绝大多数密码都是固定算法密码</li>
<li>典型密码:DES, AES, SMS4, RC4,RSA, EIGAMAL, ECC</li>
</ul>
</li>
<li>演化密码:<ul>
<li>借鉴生物进化,将密码学与演化计算结合</li>
<li>密码算法不断演化变化,越变越好</li>
<li>实现密码设计与密码分析自动化的一种方法</li>
<li>密码系统智能化的一种成功实践</li>
</ul>
</li>
</ol>
<h5 id="从是否基于数学划分"><a href="#从是否基于数学划分" class="headerlink" title="从是否基于数学划分"></a>从是否基于数学划分</h5><ol>
<li>基于数学:上述所有密码</li>
<li>基于非数学:量子密码,DNA密码<ul>
<li>在唯密文攻击下无条件安全的密码</li>
<li>基于量子的保密物理属性</li>
<li>利用量子力学产生真随机数作密钥</li>
<li>利用量子通信的保密性传输密钥</li>
<li>利用模2加进行加密</li>
<li>一次一密方式工作</li>
</ul>
</li>
</ol>
<h3 id="密码分析"><a href="#密码分析" class="headerlink" title="密码分析"></a>密码分析</h3><p>密码分析指的是对密码体制的攻击.如果能够根据密文系统地确定出明文或密钥,或者能够根据明密文对系统地确定出密钥,则该密码是可破译的.<br>一个密码,如果无论密码分析者截获了多少密文和用什么方法进行攻击都不能被攻破,则称为是绝对不可破译的</p>
<blockquote>
<p>理论上,绝对不可破译的密码是存在的(一次一密)<br>理论上,任何可实用的密码都是可破译的</p>
</blockquote>
<h4 id="密码学假设"><a href="#密码学假设" class="headerlink" title="密码学假设"></a>密码学假设</h4><ol>
<li>攻击者总能获得密文</li>
<li>攻击者总能知道密码算法,但不知道密钥</li>
<li>攻击者有足够的计算资源</li>
</ol>
<p><img src="https://gitee.com/wxpgitee/images/raw/master/image-20210301215206694.png" alt=""></p>
<ul>
<li>唯密文攻击(ciphertext-only attack):密码分析者仅知道一些密文</li>
<li>已知明文攻击(known-plaintext attack):密码分析者知道一些明文和相应的密文</li>
<li>选择明文攻击(chosen-plaintext attack):密码分析者可以选择一些明文, 并得到相应的密文</li>
<li>选择密文攻击(chosen-ciphertext attack):密码分析者可以选择一些密文,并得到相应的明文</li>
</ul>
<blockquote>
<p>攻击强度依次加强</p>
</blockquote>
<h4 id="穷举攻击"><a href="#穷举攻击" class="headerlink" title="穷举攻击"></a>穷举攻击</h4><p>密码分析者采用依次试遍所有可能的密钥对所获密文进行解密,直至得到正确明文;或者依次用一个确定的密钥对所有可能的明文进行加密,直至得到所获得的密文.</p>
<blockquote>
<p>显然,理论上,对于任何可实用密码只要有足够的资源,都可以用穷举攻击将其攻破.<br>可通过增大密钥量来对抗穷举攻击</p>
</blockquote>
<h4 id="统计分析攻击-基于数学的分析"><a href="#统计分析攻击-基于数学的分析" class="headerlink" title="统计分析攻击(基于数学的分析)"></a>统计分析攻击(基于数学的分析)</h4><p>所谓基于数学的密码分析是指密码分析者针对加解密算法的数学依据通过数学分析的方法来破译密码.</p>
<ul>
<li>统计分析攻击:密码分析者通过分析密文和明文的统计规律来破译密码</li>
<li>解密变换攻击:通过数学求解的方法来设法找到相应的解密变换</li>
</ul>
<p>为了基于数学的分析攻击,应当选用具有坚实数学基础和足够复杂的加解密算法</p>
<h4 id="基于非数学的分析"><a href="#基于非数学的分析" class="headerlink" title="基于非数学的分析"></a>基于非数学的分析</h4><p>所谓基于非数学的密码分析是指密码分析者获取并分析密码芯片的物理参数(如:功率、电流、声音、执行时间等)来破译密码.</p>
<ul>
<li>侧信道攻击<ul>
<li>攻击原理:密码芯片在执行不同的指令、处理不同数据时所消耗的功率、电流、时间等不同</li>
<li>两种攻击目的:获取密钥和获取密码算法</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>python笔记</title>
    <url>/article/45014.html</url>
    <content><![CDATA[<h1 id="python笔记"><a href="#python笔记" class="headerlink" title="python笔记"></a>python笔记</h1><a id="more"></a>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h3><p>例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#这是单行注释</span></span><br></pre></td></tr></table></figure>
<h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><p>例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">这是多行注释</span></span><br><span class="line"><span class="string">这是多行注释</span></span><br><span class="line"><span class="string">这是多行注释</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这是多行注释</span></span><br><span class="line"><span class="string">这是多行注释</span></span><br><span class="line"><span class="string">这是多行注释</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="python2中文的解决"><a href="#python2中文的解决" class="headerlink" title="python2中文的解决"></a>python2中文的解决</h2><p>如果python程序中出现中文,使用python2会出现下面情形</p>
<p><img src="https://i.loli.net/2021/02/23/EkdVvtGlWsgimcM.png" alt=""></p>
<p>方法一:</p>
<p>在.py文件首行加如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding&#x3D;utf-8</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/02/23/2Emov5c6zDVNHeX.png" alt=""></p>
<p>方法二(python推荐):</p>
<p>在.py文件首行加如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#-*- coding:utf-8 -*-</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/02/23/5mZEGStriAYQPuq.png" alt=""></p>
<h2 id="python2与python3的区别"><a href="#python2与python3的区别" class="headerlink" title="python2与python3的区别"></a>python2与python3的区别</h2><p>python2中的input与python3的不同,python2中input将从键盘得到的数据当成代码执行;python2中的raw_input()类似python3(没有raw_input())中为input() ,所以python2中可用raw_input()</p>
<p>注意：raw_input()和input()都获取的是字符串,字符串不能做-,*,/运算,做+运算只是拼接,可用int()函数获得数字,如int(input())</p>
<p>python2中的不等于号&lt;&gt;,而python3中&lt;&gt;则不能使用</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>教你如何获取腾讯视频源地址链接</title>
    <url>/article/28328.html</url>
    <content><![CDATA[<h1 id="教你如何获取腾讯视频源地址链接"><a href="#教你如何获取腾讯视频源地址链接" class="headerlink" title="教你如何获取腾讯视频源地址链接"></a>教你如何获取腾讯视频源地址链接</h1><a id="more"></a>
<p>下面以<a href="https://v.qq.com/x/cover/umpnsyqfu7f60se/n003547u6to.html">星骸骑士第5集</a>为例获取其视频源链接</p>
<h2 id="1-获取视频vid"><a href="#1-获取视频vid" class="headerlink" title="1.获取视频vid"></a>1.获取视频vid</h2><p><img src="https://i.loli.net/2021/01/28/qaZ7UP3RvO2p9wn.png" alt="image-20210128094307061"></p>
<p>本视频的vid为:<strong>n003547u6to</strong></p>
<h2 id="2-获取视频相关信息"><a href="#2-获取视频相关信息" class="headerlink" title="2.获取视频相关信息"></a>2.获取视频相关信息</h2><p>将获取的vid替换到以下接口地址中的vid</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">http://vv.video.qq.com/getinfo?vids=n003547u6to&amp;platform=101001&amp;charge=0&amp;otype=json</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/28/bKydUeomPDJ26pv.png" alt="image-20210128094934650"></p>
<p>替换后直接访问<a href="https://vv.video.qq.com/getinfo?vids=n003547u6to&amp;platform=101001&amp;charge=0&amp;otype=json">此接口地址</a>,得到视频相关信息</p>
<p><img src="https://i.loli.net/2021/01/28/6WDMa4ZYCpmK9c7.png" alt="image-20210128095135162"></p>
<h2 id="3-记录fn值-fvkey值-url值"><a href="#3-记录fn值-fvkey值-url值" class="headerlink" title="3.记录fn值,fvkey值,url值"></a>3.记录fn值,fvkey值,url值</h2><p><img src="https://i.loli.net/2021/01/28/ClqnVZ8i17ymrbQ.png" alt="image-20210128095804655" style="zoom:150%;" /></p>
<p>fn值:n003547u6to.mp4</p>
<p>fvkey值:C6BC3B0988CA19AA2F174E5D78E2B423980D558135C5C2D121533A22C4296B58AC52A0CCA5E0D1F2999B20CF4B4A9DCE560088AA238AFA2DD377158F603EEF853EF7FE56F25027CCEE6856BC6C53C831D055DF618F89D9405DE9A84A9B3D3F183F50B8B26BD49B564C9B733F27791429</p>
<p>url值:<a href="http://101.206.186.29/vlive.qqvideo.tc.qq.com/A8q7f567bhHzdteBgaLoRWLtIt01ZxK4F-vSY8TLLzUo/uwMROfz2r5zAoaQXGdGlC2dfDmYqGCmd2Ymfgp6_SfoyIMNz/">http://101.206.186.29/vlive.qqvideo.tc.qq.com/A8q7f567bhHzdteBgaLoRWLtIt01ZxK4F-vSY8TLLzUo/uwMROfz2r5zAoaQXGdGlC2dfDmYqGCmd2Ymfgp6_SfoyIMNz/</a></p>
<h2 id="4-通过公式组合成源视频链接"><a href="#4-通过公式组合成源视频链接" class="headerlink" title="4.通过公式组合成源视频链接"></a>4.通过公式组合成源视频链接</h2><p>组合公式为：url值 + fn值? + vkey值 + fvkey值(注意fn值后面要加个问号)</p>
<p><img src="https://i.loli.net/2021/01/28/AeaLG8kNQ5Y9Cc7.png" alt="image-20210128100914780"></p>
<p>源视频链接为:<a href="http://101.206.186.29/vlive.qqvideo.tc.qq.com/A8q7f567bhHzdteBgaLoRWLtIt01ZxK4F-vSY8TLLzUo/uwMROfz2r5zAoaQXGdGlC2dfDmYqGCmd2Ymfgp6_SfoyIMNz/n003547u6to.mp4?C6BC3B0988CA19AA2F174E5D78E2B423980D558135C5C2D121533A22C4296B58AC52A0CCA5E0D1F2999B20CF4B4A9DCE560088AA238AFA2DD377158F603EEF853EF7FE56F25027CCEE6856BC6C53C831D055DF618F89D9405DE9A84A9B3D3F183F50B8B26BD49B564C9B733F27791429">http://101.206.186.29/vlive.qqvideo.tc.qq.com/A8q7f567bhHzdteBgaLoRWLtIt01ZxK4F-vSY8TLLzUo/uwMROfz2r5zAoaQXGdGlC2dfDmYqGCmd2Ymfgp6_SfoyIMNz/n003547u6to.mp4?C6BC3B0988CA19AA2F174E5D78E2B423980D558135C5C2D121533A22C4296B58AC52A0CCA5E0D1F2999B20CF4B4A9DCE560088AA238AFA2DD377158F603EEF853EF7FE56F25027CCEE6856BC6C53C831D055DF618F89D9405DE9A84A9B3D3F183F50B8B26BD49B564C9B733F27791429</a></p>
]]></content>
      <categories>
        <category>无处安放</category>
      </categories>
      <tags>
        <tag>视频解析</tag>
      </tags>
  </entry>
  <entry>
    <title>Kail Linux虚拟机安装配置Nessus漏洞扫描器</title>
    <url>/article/57445.html</url>
    <content><![CDATA[<h1 id="Kail-Linux虚拟机安装配置Nessus漏洞扫描器"><a href="#Kail-Linux虚拟机安装配置Nessus漏洞扫描器" class="headerlink" title="Kail Linux虚拟机安装配置Nessus漏洞扫描器"></a>Kail Linux虚拟机安装配置Nessus漏洞扫描器</h1><a id="more"></a>
<h2 id="1-获取激活码"><a href="#1-获取激活码" class="headerlink" title="1.获取激活码"></a>1.获取激活码</h2><p>前往<a href="https://www.tenable.com/products/nessus/nessus-essentials">官网</a>进行注册</p>
<p><img src="https://i.loli.net/2021/01/26/HVptOeBDnJZlF6w.png" alt=""></p>
<h2 id="2-下载nessus"><a href="#2-下载nessus" class="headerlink" title="2.下载nessus"></a>2.下载nessus</h2><p>注册完毕后前往下载页面</p>
<p><img src="https://i.loli.net/2021/01/26/SaI7x2nDEHRfMOu.png" alt=""></p>
<p>选择deb结尾的(我选择的64位)</p>
<p><img src="https://i.loli.net/2021/01/26/hPzGvds7T2bXirE.png" alt=""></p>
<p>官网下载较慢,这里我准备了一份,<a href="https://idefun.lanzous.com/iQnR4kvm5oh">点击下载</a></p>
<h2 id="3-安装nessus"><a href="#3-安装nessus" class="headerlink" title="3.安装nessus"></a>3.安装nessus</h2><p>将nessus拖入kail linux虚拟机</p>
<p><img src="https://i.loli.net/2021/01/26/Mca54FXCQuY6x7p.png" alt=""></p>
<p>打开终端,切换至桌面</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd 桌面</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/26/ekf7ri8R54ZuwDW.png" alt=""></p>
<p>安装nessus(需要密码)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i Nessus-8.13.1-debian6_amd64.deb</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/26/hYk1gFqJplIuQw9.png" alt=""></p>
<p>安装完成</p>
<p><img src="https://i.loli.net/2021/01/26/KWfAuHosZB7vJ1F.png" alt=""></p>
<h2 id="4-启动nessus"><a href="#4-启动nessus" class="headerlink" title="4.启动nessus"></a>4.启动nessus</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/bin/systemctl start nessusd.service</span><br></pre></td></tr></table></figure>
<p>同样需要密码</p>
<p><img src="https://i.loli.net/2021/01/26/1Wjf7rMiImHSk4A.png"  /></p>
<p>在浏览器中访问</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">https://kali:8834/</span><br></pre></td></tr></table></figure>
<p>选择Managed Scanner</p>
<p><img src="https://i.loli.net/2021/01/26/Y9wajpE7ye1JhVv.png" alt=""></p>
<p>选择Tenable.sc</p>
<p><img src="https://i.loli.net/2021/01/26/ONiI4T2EJeylcZ5.png" alt=""></p>
<p>创建账号</p>
<p><img src="https://i.loli.net/2021/01/26/1KLS8misZR7DVCI.png" alt=""></p>
]]></content>
      <categories>
        <category>Hack</category>
      </categories>
      <tags>
        <tag>Nessus</tag>
        <tag>Kail</tag>
      </tags>
  </entry>
  <entry>
    <title>BurpSuite的设置及使用</title>
    <url>/article/13804.html</url>
    <content><![CDATA[<h1 id="BurpSuite的设置及使用"><a href="#BurpSuite的设置及使用" class="headerlink" title="BurpSuite的设置及使用"></a>BurpSuite的设置及使用</h1><h2 id="1-BurpSuite安装与配置"><a href="#1-BurpSuite安装与配置" class="headerlink" title="1.BurpSuite安装与配置"></a>1.BurpSuite安装与配置</h2><h3 id="BurpSuite功能介绍"><a href="#BurpSuite功能介绍" class="headerlink" title="BurpSuite功能介绍"></a>BurpSuite功能介绍</h3><p>BurpSuite是用于攻击web应用程序的集成平台，包含了许多工具。BurpSuite为这些工具设计了许多接口，以加快攻击应用程序的过程。所有工具都共享-一个请求， 并能处理对应的HTTP消息、持久性、认证、代理、日志、警报。</p>
<p>Burpsuite是由JAVA语言编写,所以Burpsuite是-款跨平台的软件。 但是在测试过程中Buripsuite不像其他自动化测试工具不需要输入任何内容即可完成测试，而需要手动的配置某些参数触发对应的行为才会完成测试。</p>
<h2 id="2-BurpSuite-Proxy模块"><a href="#2-BurpSuite-Proxy模块" class="headerlink" title="2.BurpSuite Proxy模块"></a>2.BurpSuite Proxy模块</h2><p>Burp Proxy 是Burp Suite以用户驱动测试流程功能的核心，通过代理模式，可以让我们拦截、查看、修改所有在客户端和服务端之间传输的数据。</p>
<h3 id="1-Intercept"><a href="#1-Intercept" class="headerlink" title="1.Intercept"></a>1.Intercept</h3><p>Forward表示将截断的HTTP或HTTPS请求发送到服务器。<br>Drop表示将截断的HTTP或HTTPS请求丢弃。<br>Intercept is on和Intercept is off表示开启或关闭代理截断功能。<br>Action表示将代理截断的HT TP或HT TPS请求发送到其他模块或做其他处理。<br>对Intercept进行Raw Hex Params Header切换查看不同的数据格式。</p>
<h3 id="2-HTTP-history"><a href="#2-HTTP-history" class="headerlink" title="2.HTTP history"></a>2.HTTP history</h3><p>HTTP history用来查看提交过的HTTP请求。<br>Fiter可以过滤显示某些HTTP请求。点击Filter就可以打开。对于指定URL可以选中右键点击,执行其他操作。WebSockets history与HTTP history功能类似。</p>
<h3 id="3-options"><a href="#3-options" class="headerlink" title="3.options"></a>3.options</h3><p>Options具有的功能:代理监听设置、戳断客户端请求、截断服务器响应、截断WebSocket通信、服务端响应修改(绕过JS验证文件上传)、匹配与替换HTTP消息中的内容、通过SSL连接Web服务器配置、其他配置选项。</p>
<h3 id="4-设置proxy-listener"><a href="#4-设置proxy-listener" class="headerlink" title="4.设置proxy listener"></a>4.设置proxy listener</h3><p>通过设置Proxy Listeners来截断数据流量。比如设置监听端口等。BurpSuite默认监听8080端口.</p>
<p>修改端口:</p>
<p>1.关闭截断</p>
<p>2.options-&gt;edit</p>
<p>3.修改端口,点击running</p>
<p>4.修改浏览器端口</p>
<p>5.Internet选项-&gt;连接-&gt;局域网设置</p>
<p>6.修改端口</p>
<h3 id="5-设置intercept-client-requests"><a href="#5-设置intercept-client-requests" class="headerlink" title="5.设置intercept client requests"></a>5.设置intercept client requests</h3><p>通过设置Intercept Client Requests来截断符合条件的HTTP请求。</p>
<h3 id="6-设置Intercept-Server-Response"><a href="#6-设置Intercept-Server-Response" class="headerlink" title="6.设置Intercept Server Response"></a>6.设置Intercept Server Response</h3><p>通过设置Intercept Server Response来筛选出符合条件的HTTP响应。</p>
<h3 id="7-设置截断Websocket通信以及修改Response的内容"><a href="#7-设置截断Websocket通信以及修改Response的内容" class="headerlink" title="7.设置截断Websocket通信以及修改Response的内容"></a>7.设置截断Websocket通信以及修改Response的内容</h3><h3 id="8-匹配以及修改HTTP消息"><a href="#8-匹配以及修改HTTP消息" class="headerlink" title="8.匹配以及修改HTTP消息"></a>8.匹配以及修改HTTP消息</h3><p>可以修改HTTP请求和HTTP响应中的内容。</p>
<h2 id="3-Burpsuite抓取手机APP流量"><a href="#3-Burpsuite抓取手机APP流量" class="headerlink" title="3.Burpsuite抓取手机APP流量"></a>3.Burpsuite抓取手机APP流量</h2><p>目前WebApp(手机App)的通信任然使用HTTP协议进行对应的通信.可以通过Burp设置代理,然后手机设置网络代理,通过Burp截断手机APP流量.</p>
<p>1.Burpsuite设置截断所有网卡的流量，那么局城网中所有的主机都可以通过该代理进行网络访问。</p>
<p><img src="https://i.loli.net/2021/01/24/n1owBAfCMJXqvhW.png" alt=""></p>
<p><img src="https://i.loli.net/2021/01/24/Cu6NGxn2SI57hBs.png" alt=""></p>
<p>2.查看电脑ip</p>
<p>3.在手机网络设置中，填写对应的代理。</p>
<p><img src="https://i.loli.net/2021/01/24/gcYyFBzhjZEKOev.png" alt=""></p>
<p><img src="https://i.loli.net/2021/01/24/US7BIW1oNuXlHhJ.png" alt=""></p>
<p><img src="https://i.loli.net/2021/01/24/o8hED3xYzjUlvC9.png" alt=""></p>
<p>4.Burpsuite开启截断</p>
<p><img src="https://i.loli.net/2021/01/24/nU8QWAlJGESgP96.png" alt=""></p>
<h2 id="4-Burpsuite剔除JS脚本-绕过JS文件上传验证"><a href="#4-Burpsuite剔除JS脚本-绕过JS文件上传验证" class="headerlink" title="4.Burpsuite剔除JS脚本(绕过JS文件上传验证)"></a>4.Burpsuite剔除JS脚本(绕过JS文件上传验证)</h2><p>JavaScript—-种直译式脚本语言，是一种动态类型、 弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML (标准通用标记语言下的一个应用)网页上使用，用来给HTML网页增加动态功能。例如:对于上传文件进行JS验证。</p>
<p><img src="https://i.loli.net/2021/01/25/P1A6G4zFDUpbRs3.png" alt=""></p>
<p>也可以使用浏览器审计工具直接删除JS</p>
<h2 id="5-Burpsuite-Target介绍"><a href="#5-Burpsuite-Target介绍" class="headerlink" title="5.Burpsuite Target介绍"></a>5.Burpsuite Target介绍</h2><p>Burp Target组件主要包含站点地图、目标域、Target 工具三部分组成，他们帮助渗透测试人员更好地了解目标应用的整体状况、当前的工作涉及哪些目标域、分析可能存在的攻击面等信息</p>
<p>Target Scope中作用域的定义比较宽泛，通常来说，当我们对某个产品进行渗透测试时，可以通过域名或者主机名去限制拦截内容，这里域名或主机名就是我们说的作用域;如果我们想限制得更为细粒度化，比如，你只想拦截login目录下的所有请求，这时我们也可以在此设置，此时，作用域就是目录。</p>
]]></content>
      <categories>
        <category>Hack</category>
      </categories>
      <tags>
        <tag>BurpSuite</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法总结</title>
    <url>/article/42825.html</url>
    <content><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="一-绪论"><a href="#一-绪论" class="headerlink" title="一.绪论"></a>一.绪论</h2><p>算法是为了解决实际问题而设计的.数据结构是算法需要处理的问题载体.</p>
<h3 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语:"></a>基本概念和术语:</h3><ul>
<li><p>数据:数据是指能输入到计算机中并能够被计算机处理的一切对象.</p>
</li>
<li><p>数据元素:数据元素是数据的基本单位.</p>
</li>
<li><p>数据项:一个数据元素可由若干数据项组成.</p>
</li>
<li><p>数据对象:数据对象是具有相同性质的数据元素的集合.</p>
</li>
</ul>
<ul>
<li>数据结构:数据结构是指互相之间存在着一种或多种关系的数据元素的集合.</li>
</ul>
<hr>
<h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构:"></a>逻辑结构:</h3><p>1.集合结构:数据元素同属一个集合，单个数据元素之间没有任何关系</p>
<p><img src="https://i.loli.net/2021/01/11/qoiHNkTzsJxjBGD.png" alt=""></p>
<p>​    2.线性结构:类似于线性关系,数据元素之间是一对一的关系</p>
<p><img src="https://i.loli.net/2021/01/11/a3LdovfMAlmkNxE.png" alt=""></p>
<p>​    3.树形结构:树形结构中的数据元素之间存在一对多的关系</p>
<p><img src="https://i.loli.net/2021/01/11/c7e6tdFC3w1NAlo.png" alt=""></p>
<p>​    4.图形结构:数据元素之间是多对多的关系</p>
<p><img src="https://i.loli.net/2021/01/11/nGcsUypoHmbizL9.png" alt=""></p>
<hr>
<h3 id="存储结构-物理结构"><a href="#存储结构-物理结构" class="headerlink" title="存储结构(物理结构):"></a>存储结构(物理结构):</h3><p>(数据结构种类很多， 甚至你也可以发明自己的数据结构， 但是底层存储无非数组或者链表 ,那些多样化的数据结构， 究其源头， 都是在链表或者数组上的特殊操作 )</p>
<p>1.顺序存储:一段连续的内存空间</p>
<ul>
<li>优点：随机访问</li>
</ul>
<ul>
<li>缺点：插入删除效率低，大小固定</li>
</ul>
<p>2.链式存储:不连续的内存空间</p>
<ul>
<li>优点：大小动态扩展，插入删除效率高</li>
</ul>
<ul>
<li>缺点：不能随机访问</li>
</ul>
<p>3.索引:为了方便查找，整体无序，但索引块之间有序，需要额外空间存储索引表</p>
<ul>
<li><p>优点：对顺序查找的一种改进，查找效率高</p>
</li>
<li><p>缺点：需额外空间存储索引</p>
</li>
</ul>
<p>4.散列:选取某个函数，数据元素根据函数计算存储位置,可能存在多个数据元素存储在同一位置，引起地址冲突</p>
<ul>
<li>优点：查找基于数据本身即可找到，查找效率高，存取效率高</li>
</ul>
<ul>
<li>缺点：存取随机，不便于顺序查找</li>
</ul>
<p>队列,栈这两种数据结构既可以使用链表也可以使用数组实现.用数组实现,就要处理扩容缩容的问题; 用链表实现,则没有这个问题,但需要更多的内存空间存储节点指针</p>
<p>图的两种表示方法,邻接表就是链表,邻接矩阵就是二维数组.邻接矩阵判断连通性迅速,并可以进行矩阵运算解决一些问题,但是如果图比较稀疏的话很耗费空间.邻接表比较节省空间,但是很多操作的效率上肯定比不过邻接矩阵。</p>
<p>散列表就是通过散列函数把键映射到一个大数组里,而且对于解决散列冲突的方法,拉链法需要链表特性,操作简单,但需要额外的空间存储指针;线性探查法就需要数组特性,以便连续寻址,不需要指针的存储空间,但操作稍微复些.  </p>
<hr>
<h3 id="影响算法运行时间的因素"><a href="#影响算法运行时间的因素" class="headerlink" title="影响算法运行时间的因素:"></a>影响算法运行时间的因素:</h3><p>1.运行程序的计算机的机器指令的品质与速度</p>
<p>2.书写程序的语言(一般实现语言级别越高,其执行效率越低)</p>
<p>3.编译程序所生成目标代码的质量</p>
<p>4.问题的规模</p>
<hr>
<h3 id="大O表示法-用来表示时间复杂度函数的增长率的上界"><a href="#大O表示法-用来表示时间复杂度函数的增长率的上界" class="headerlink" title="大O表示法:用来表示时间复杂度函数的增长率的上界"></a>大O表示法:用来表示时间复杂度函数的增长率的上界</h3><p>时间复杂度:嵌套(求积),并列(求和),只关注最高次项</p>
<p>空间复杂度:算法运行所需存储空间:</p>
<p>1.程序本身占用的空间</p>
<p>2.算法的输入,输出占用的空间</p>
<p>3.算法运行中占用的空间</p>
<p>评价一个算法的空间复杂度一般只考虑算法运行中所占用的临时空间.</p>
<p>对于一个算法,其时间复杂度和空间复杂度往往是相互影响的.</p>
<h2 id="二-线性表"><a href="#二-线性表" class="headerlink" title="二.线性表"></a>二.线性表</h2><p>线性结构的特点是在数据元素的非空有限集合中,存在唯一的首元素和唯一的尾元素,首元素无直接前驱,尾元素无直接后继,集合中其他数据元素都有唯一的直接前驱和唯一的直接后继.线性表是最简单,最基本,也是最常用的一种线性结构.</p>
<hr>
<p>线性表是具有相同数据类型的n(n&gt;=0)个数据元素的有限序列.</p>
<h3 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构:"></a>线性表的顺序存储结构:</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20  <span class="comment">//存储空间初始分配量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType; <span class="comment">//ElemType类型根据实际情况而定,这里假设为int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data[MAXSIZE]; <span class="comment">//数组存储数据元素,最大值为MAXSIZE</span></span><br><span class="line">    <span class="keyword">int</span> length;  <span class="comment">//线性表当前长度</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>
<p>线性表顺序存储结构需要三个属性:</p>
<ul>
<li>存储空间的起始位置</li>
<li>线性表的最大存储容量(数组的长度)</li>
<li>线性表的当前长度(小于等于数组长度)</li>
</ul>
<p>顺序表的初始化:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SqList *<span class="title">init_SqList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqList *L;</span><br><span class="line">    L=(SqList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SqList)); <span class="comment">//动态分配内存空间</span></span><br><span class="line">    <span class="keyword">if</span>(!L) <span class="built_in">exit</span>(<span class="number">1</span>);  <span class="comment">//如果存储分配失败,运行exit()函数终止程序运行</span></span><br><span class="line">    L-&gt;length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺序表的插入运算:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SqList *<span class="title">Insert_SqList</span><span class="params">(SqList *L,<span class="keyword">int</span> i,ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在顺序表L第i个位置插入值为x的元素</span></span><br><span class="line">    <span class="keyword">if</span>(L-&gt;length&gt;=MAXSIZE<span class="number">-1</span>)<span class="comment">//判断表是否满</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;顺序表已满!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;L-&gt;length+<span class="number">1</span>)<span class="comment">//判断插入位置是否合理</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入位置i不合理!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> m=L-&gt;length<span class="number">-1</span>;m&gt;=i<span class="number">-1</span>;m--)</span><br><span class="line">    &#123;</span><br><span class="line">        L-&gt;data[m+<span class="number">1</span>]=L-&gt;data[m];<span class="comment">//节点后移</span></span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;data[i<span class="number">-1</span>]=x;<span class="comment">//新元素插入</span></span><br><span class="line">    L-&gt;length++;<span class="comment">//表长加1</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺序表的删除运算:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SqList *<span class="title">Delete_SqList</span><span class="params">(SqList *L,<span class="keyword">int</span> i,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//删除顺序表L中第i个元素,删除元素的值保存在e中</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;L-&gt;length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入位置i不合理!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    e=L-&gt;data[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i;i&lt;=L-&gt;length<span class="number">-1</span>;++i)</span><br><span class="line">        L-&gt;data[i<span class="number">-1</span>]=L-&gt;data[i];</span><br><span class="line">    L-&gt;length--;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺序表按值查找运算:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem_Sq</span><span class="params">(SqList *L,ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在顺序表中查找值为x的元素,查找成功返回元素存储位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L-&gt;data[i]==x)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺序表合并算法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SqList *<span class="title">Merge_SqList</span><span class="params">(SqList *A,SqList *B)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//将两个非递减次序排列的顺序表A和B合并为一个新的有序顺序表C</span></span><br><span class="line">    SqList *C;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    i=<span class="number">0</span>;j=<span class="number">0</span>;k=<span class="number">0</span>;</span><br><span class="line">    C=(SqList *)<span class="built_in">malloc</span>(<span class="number">2</span>*MAXSIZE*<span class="keyword">sizeof</span>(SqList));</span><br><span class="line">    <span class="keyword">if</span>(!C) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    C-&gt;length=A-&gt;length+B-&gt;length;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=A-&gt;length<span class="number">-1</span>&amp;&amp;j&lt;=B-&gt;length)</span><br><span class="line">        <span class="keyword">if</span>(A-&gt;data[i]&lt;B-&gt;data[j])</span><br><span class="line">        &#123;</span><br><span class="line">            C-&gt;data[k]=A-&gt;data[i];k++;i++;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            C-&gt;data[k]=B-&gt;data[j];k++;j++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//前面部分是先将A,B中较短的填入C,后面再填入另一个</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=A-&gt;length<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        C-&gt;data[k]=A-&gt;data[i];k++;i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;B-&gt;length<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        C-&gt;data[k]=B-&gt;data[j];k++;j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构:"></a>线性表的链式存储结构:</h3><h4 id="1-单链表-动态链表"><a href="#1-单链表-动态链表" class="headerlink" title="1.单链表(动态链表)"></a>1.单链表(动态链表)</h4><p>静态链表是用类似于数组方法实现的，是顺序的存储结构，在物理地址上是连续的，而且需要预先分配地址空间大小。所以静态链表的初始长度一般是固定的，在做插入和删除操作时不需要移动元素，仅需修改指针</p>
<p>单链表节点数据类型:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">LinkList</span>;</span></span><br></pre></td></tr></table></figure>
<p>头插入法建立单链表:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">CreatList_L1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList L;</span><br><span class="line">    LinkList P;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    L=(LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p=(LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        p-&gt;data=x;</span><br><span class="line">        p-&gt;next=L-&gt;next;</span><br><span class="line">        L-&gt;next=p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尾插入法建立单链表:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">CreatList_L2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList L,p,r;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    r=L=(LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p=(LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        p-&gt;data=x;</span><br><span class="line">        p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        r-&gt;next=p;</span><br><span class="line">        r=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求链表长度的算法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Listlength</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找操作:</p>
<p>​            1.按序号查找</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">Get_LinkList</span><span class="params">(LinkList L,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在链表L中查找第i个元素,找到返回其指针,否则返回空</span></span><br><span class="line">    LinkList p;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j==i)<span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​            2.按值查找</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">Locate_LinkList</span><span class="params">(LinkList L,ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>&amp;&amp;p-&gt;data!=x)</span><br><span class="line">       p=p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入运算:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">ListInsert</span><span class="params">(LinkList L,<span class="keyword">int</span> i,ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在单链表第i个节点前插入新元素x</span></span><br><span class="line">    LinkList p,s;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>&amp;&amp;j&lt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||j&gt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;<span class="built_in">printf</span>(<span class="string">&quot;参数i错误!&quot;</span>);<span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line">    s=(LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除运算:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">ListDelete</span><span class="params">(LinkList L,<span class="keyword">int</span> i,ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//删除单链表L中第i个元素</span></span><br><span class="line">    LinkList p,q;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>&amp;&amp;j&lt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next=<span class="literal">NULL</span>||j&gt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;参数i错误!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    q=p-&gt;next;</span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    *e=q-&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有序链表归并算法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">Merge_LinkList</span><span class="params">(LinkList A,LinkList B)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//A,B均为带头节点的单链表</span></span><br><span class="line">    LinkList C,p,q,s;</span><br><span class="line">    p=A-&gt;next;</span><br><span class="line">    q=B-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">    C=A;</span><br><span class="line">    C-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data&lt;q-&gt;data)&#123;s=p;p=p-&gt;next;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;s=q;q=q-&gt;next;&#125;</span><br><span class="line">        s-&gt;next=C-&gt;next;</span><br><span class="line">        C-&gt;next=s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)p=q;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        s=p;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        s-&gt;next=C-&gt;next;</span><br><span class="line">        C-&gt;next=s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-循环链表"><a href="#2-循环链表" class="headerlink" title="2.循环链表"></a>2.循环链表</h4><p>1.单向循环链表</p>
<p>单链表尾节点的指针域是空指针.而单向循环链表的最后一个节点的指针指向链表头节点.</p>
<p>对于单链表,从一已知节点只能访问该节点及其后继节点,无法访问该节点之前的节点;而对于单向循环链表,只要知道表中任一节点的地址,就可搜寻到所有其他节点的地址,遍历整个链表.</p>
<p>单向循环链表的数据类型定义与单链表相同.在单循环链表上的操作也与单链表基本相同,二者主要区别在于:判断是否达到表尾的条件不同.在单链表中,用指针域是否为NULL作为判断表尾节点的条件;而在循环链表中,则以节点指针域是否等于表头节点(头指针)作为判断到达表尾的条件.</p>
<p>2.双向链表</p>
<p>双向链表的结构:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLnode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span></span><br><span class="line">&#125;DuLnode;</span><br><span class="line"><span class="keyword">typedef</span> DuLnode *DuLinkList;</span><br></pre></td></tr></table></figure>
<p>双向链表的插入运算:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DuLinkList <span class="title">ListInsert_Dul</span><span class="params">(DuLinkList L,<span class="keyword">int</span> i,ElemType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在双向链表的第i个节点前插入一个新元素x</span></span><br><span class="line">	DuLinkList p,s;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    p=L;</span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)</span><br><span class="line">    &#123;p=p-&gt;next;j++&#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||j&lt;i)</span><br><span class="line">    &#123;<span class="built_in">printf</span>(<span class="string">&quot;参数i错误!&quot;</span>);<span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line">    <span class="keyword">if</span>(!(s=(DuLinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DuLnode))))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;prior=p-&gt;prior;p-&gt;prior-&gt;next=s;</span><br><span class="line">    s-&gt;next=p;p-&gt;prior=s;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双向链表的删除运算:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DuLinkList <span class="title">ListDelete_Dul</span><span class="params">(DuLinkList L,<span class="keyword">int</span> i,ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//删除双向链表中第i数据元素</span></span><br><span class="line">    DuLinkList p;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    p=L;</span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)</span><br><span class="line">    &#123;p=p-&gt;next;j++;&#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||j&gt;i)</span><br><span class="line">    &#123;<span class="built_in">printf</span>(<span class="string">&quot;参数i错误!&quot;</span>);<span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        e=p-&gt;data;</span><br><span class="line">        p-&gt;prior-&gt;next=p-&gt;next;</span><br><span class="line">        p-&gt;next-&gt;prior=p-&gt;prior;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三-栈与队列"><a href="#三-栈与队列" class="headerlink" title="三.栈与队列"></a>三.栈与队列</h2><p>栈和队列是在程序设计中被广泛使用的两种数据结构.由于从数据结构角度看,栈和队列是两种特殊的线性表.它们的逻辑结构和线性表相同,只是其运算规则较线性表有更多的限制,因此,也可以将栈和队列称为操作受限的线性表.</p>
<p>栈是限定仅在表尾进行插入和删除操作的线性表.队列是只允许在一端进行插入操作,而在另一端进行删除操作的线性表.</p>
<h3 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h3><ul>
<li>栈是一种特殊的线性表,是一种只允许在表的一端进行插入或删除操作的线性表.把栈中允许进行插入,删除操作的一端称为栈顶,栈的另一端称为栈底.</li>
<li>当栈中没有数据元素时,称之为空栈.栈顶是动态的,对栈顶位置的标记称为栈顶指针.栈的插入操作通常称为进栈(入栈或压栈),栈的删除操作通常称为退栈或出栈.</li>
<li>根据栈的定义,每次进栈的数据元素都放在当前栈顶元素之前而成为新的栈顶元素,每次退栈的数据元素都是当前栈顶元素.这样,最后进入栈的数据元素总是最先退出栈,因此,栈具有”后进先出”的特性,所以栈又称为后进先出的线性表,简称LIFO表.</li>
</ul>
<h3 id="栈的存储结构"><a href="#栈的存储结构" class="headerlink" title="栈的存储结构"></a>栈的存储结构</h3><p>栈有两种存储表示方法,即顺序存储和链式存储.顺序存储的栈称为顺序栈,链式存储的栈称为链式栈.</p>
<h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><p>顺序栈的存储结构:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> StackInitSize 100;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> StackElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    StackElementType data[StackInitSize];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125;SeqStack;</span><br></pre></td></tr></table></figure>
<p>顺序栈的初始化:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SeqStack *<span class="title">InitStack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SeqStack *s;</span><br><span class="line">    s=(SeqStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SeqStack));</span><br><span class="line">    <span class="keyword">if</span>(s!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;s-&gt;top=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> s;&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;没有足够的内存空间,申请失败,程序运行终止!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断栈空的函数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(SeqStack *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(s-&gt;top==<span class="number">-1</span>)?<span class="number">1</span>:<span class="number">0</span>;<span class="comment">//栈空返回1,否则返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>销毁栈的函数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestoryStack</span><span class="params">(SeqStack *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈已销毁!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进栈操作:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(SeqStack *s,StackElementType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;top==StackInitSize)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈满!栈发生上溢,程序停止运行!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        s-&gt;top++;</span><br><span class="line">        s-&gt;data[s-&gt;top]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>退栈操作:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">StackElementType <span class="title">Pop</span><span class="params">(SeqStack *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StackElementType temp;</span><br><span class="line">    <span class="keyword">if</span>(IsElpty(s))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈空!栈发生下溢,程序停止运行!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        temp=s-&gt;data[s-&gt;top];</span><br><span class="line">        s-&gt;top--;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取栈顶元素:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">StackElementType <span class="title">GetTop</span><span class="params">(SeqStack *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;空栈,程序停止运行!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> s-&gt;data[s-&gt;top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>栈浮动技术:</p>
<p>当一个程序中同时使用多个顺序栈时,为了防止上溢错误,需要为每个栈分配较大的存储空间.在多栈使用过程中通常会出现:在某一栈发生上溢的同时,其余栈尚有大量未用空间存在,这样不利于内存空间的共享,会降低内存空间的使用效率.如果将多个栈安排在同一个连续的存储空间中,这样多个栈共享存储空间,并使它们根据实际情况互相调节余缺.如此既节省了存储空间的开销,又降低了上溢现象发生的概率.这种多栈共享空间的技术,通常称为栈浮动技术.</p>
<p>当程序中同时使用两个栈时,两个栈可以共享同一存储空间.此时,将两个栈的栈底分别设在同一存储空间的两端,让两个栈各自向中间延伸.这样只有当整个共享空间被两个栈占满(两个栈的栈顶相遇)时,才会发生上溢.</p>
<p>两栈共享空间的结构:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    StackElementType data[StackInitSize];</span><br><span class="line">    <span class="keyword">int</span> top1;<span class="comment">//栈1栈顶指针</span></span><br><span class="line">    <span class="keyword">int</span> top2;<span class="comment">//栈2栈顶指针</span></span><br><span class="line">&#125;SqDoubleStack;</span><br></pre></td></tr></table></figure>
<p>对于两栈共享空间的进栈方法,我们除了要插入元素值参数外,还需要有一个判断是栈1还是栈2的栈号参数stackNumber</p>
<h4 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h4><p>链式栈的存储结构:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> StackElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    StackElementType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkStack;</span><br></pre></td></tr></table></figure>
<p>链式栈的进栈操作:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkStack *<span class="title">Push</span><span class="params">(LinkStack *top,StackElementType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkStack *p;</span><br><span class="line">    p=(LinkStack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkStack));</span><br><span class="line">    <span class="keyword">if</span>(p)&#123;p-&gt;data=x;</span><br><span class="line">         p-&gt;next=top;</span><br><span class="line">         top=p;</span><br><span class="line">         <span class="keyword">return</span> top;&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;内存不足,程序运行停止!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链式栈的退栈操作:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkStack *<span class="title">Pop</span><span class="params">(LinkStack *top,StackElementType *elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkStack *temp;</span><br><span class="line">    <span class="keyword">if</span>(top)</span><br><span class="line">    &#123;</span><br><span class="line">        temp=top;</span><br><span class="line">        *elem=top-&gt;data;</span><br><span class="line">        top=top-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链式栈读取栈顶元素:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">StackElementType <span class="title">GetTop</span><span class="params">(LinkStack *top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> top?top-&gt;data:<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h3><ul>
<li>队列(Queue)是一种只允许在一端进行插入,另一端进行删除的运算受限的线性表,允许删除的一端叫队头(front),允许插入的一端叫队尾(rear).</li>
<li>队列的插入操作通常称为入队,删除操作通常称为出队,当队列中没有元素时称为空队列.</li>
<li>队列具有”先进先出”(FIFO)特性,简称为FIFO表.</li>
</ul>
<h4 id="队列的存储结构"><a href="#队列的存储结构" class="headerlink" title="队列的存储结构"></a>队列的存储结构</h4><h5 id="循环队列-顺序队列"><a href="#循环队列-顺序队列" class="headerlink" title="循环队列(顺序队列)"></a>循环队列(顺序队列)</h5><p>在顺序队列中,进行入队和出队操作时可能产生溢出现象:</p>
<p>1.”下溢”现象</p>
<p>当队列为空时,进行出队运算产生的溢出现象,称为”下溢”.可通过判断队列是否为空来控制</p>
<p>2.”真上溢”现象</p>
<p>当队列满时,进行入队运算时产生空间溢出的现象,称为”真上溢”.可通过判断队列是否满来控制</p>
<p>3.”假上溢”现象</p>
<p>由于在入队和出队操作中,队头指针与队尾指针只增加不减小,致使被删元素的空间永远无法重新利用.当队列中实际的元素个数远远小于存储空间的规模时,也可能由于队尾指针已超越队列空间的上界而不能做入队操作.这种现象称为”假下溢”.</p>
<p>为防止假溢出现象发生,充分利用存储空间,最巧妙的解决方法就是把队列存储空间看作首尾相连的环,而这种队列的循环顺序存储结构称为循环队列.</p>
<p>循环队列存储结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QueueElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    QueueElementType *base;<span class="comment">//base指向队列存储区首地址</span></span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">&#125;SeqQueue;</span><br></pre></td></tr></table></figure>
<p>循环队列的特点</p>
<ul>
<li>队头,队尾指针加1时从MaxSize-1直接进到0,这种变化可用C语言的取模(余数)运算实现</li>
<li>队空与队满时头尾指针均相等,无法通过front==rear来判断队列的”空”和”满”,解决此问题有两种方法:<ol>
<li>另设一个状态标志位来区别”队空”和”队满”</li>
<li>少用一个存储空间,约定以队头指针在队尾指针的下一位置上作为队列满的标志</li>
</ol>
</li>
</ul>
<p>采用第二种处理方法:</p>
<p>循环队列空的标志:front==rear</p>
<p>循环队列满的标志:(rear+1)%MaxSize==front</p>
<p>循环队列初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SeqQueue <span class="title">InitQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SeqQueue Q;</span><br><span class="line">    Q.base=(QueueElementType*)<span class="built_in">malloc</span>(MaxSize*<span class="keyword">sizeof</span>(QueueElementType));</span><br><span class="line">    <span class="keyword">if</span>(!Q.base)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;申请存储空间失败,程序运行终止!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Q.front=<span class="number">0</span>;</span><br><span class="line">    Q.rear=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断循环队列为空</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueEmpty</span><span class="params">(SeqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front==Q.rear)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断循环队列为满</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueFull</span><span class="params">(SeqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front==(Q.rear+<span class="number">1</span>)%MaxSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入队操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SeqQueue <span class="title">EnQUeue</span><span class="params">(SeqQueue Q,QueueElementType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(QueueFull(Q)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;队满!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        *(Q.base+Q.rear)=x;</span><br><span class="line">        Q.rear=(Q.rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出队操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SeqQueue <span class="title">DeQueue</span><span class="params">(SeqQueue Q,QueueElementType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(QueueEmpty(Q))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队空!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        *e=*(Q.base+Q.front);</span><br><span class="line">        Q.front=(Q.front+<span class="number">1</span>)%MaxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取队头元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">QueueElementType <span class="title">GetHead</span><span class="params">(SeqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(QueueEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队空!读取失败!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> *(Q.base+Q.front);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>销毁队列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestoryQueue</span><span class="params">(SeqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(Q.base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队列已被销毁!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>队列遍历操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueueDisplay</span><span class="params">(SeqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(QueueEmpty(Q))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队空!队列遍历完成!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列遍历(队头-&gt;队尾):\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=Q.front;i!=Q.rear;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>,*(Q.base+i));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\b\b \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h5><p>一个链式队列由一个头指针和一个尾指针唯一地确定.</p>
<p>链式队列节点类型定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QueueElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    QueueElementType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QueueNode;</span><br></pre></td></tr></table></figure>
<p>链式队列数据类型定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    QueueNode *front;</span><br><span class="line">    QueueNode *rear;</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>
<p>链式队列的初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkQueue <span class="title">InitQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    QueueNode *p;</span><br><span class="line">    p=(QueueNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">    <span class="keyword">if</span>(p)&#123;</span><br><span class="line">        Q.front=Q.rear=p;</span><br><span class="line">        Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> Q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;初始化失败!程序运行终止!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断链式队列是否为空</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueEmpty</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front=Q.rear)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入队操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkQueue <span class="title">EnQueue</span><span class="params">(LinkQueue Q,QueueElementType x)</span></span>&#123;</span><br><span class="line">    QueueNode *p;</span><br><span class="line">    p=(QueueNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">    <span class="keyword">if</span>(!p)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;申请空间失败!程序运行终止!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        p-&gt;data=x;</span><br><span class="line">        p-&gt;next=<span class="literal">NULL</span>;<span class="comment">//尾节点的next置空</span></span><br><span class="line">        Q.rear-&gt;next=p;</span><br><span class="line">        Q.rear=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出队操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkQueue <span class="title">DeQueue</span><span class="params">(LinkQueue Q,QueueELementType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QueueNode *p;</span><br><span class="line">    <span class="keyword">if</span>(QueueEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空!出队失败!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        p=Q.front-&gt;next;</span><br><span class="line">        *e=p-&gt;data;</span><br><span class="line">        Q.front-&gt;next=p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(Q.rear==p)</span><br><span class="line">            Q.rear=Q.front;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取队头操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">QueueElementType <span class="title">GetHead</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(QueueEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;队列为空!读取队头失败!\n&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (Q.front-&gt;next.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四-矩阵的压缩存储"><a href="#四-矩阵的压缩存储" class="headerlink" title="四.矩阵的压缩存储"></a>四.矩阵的压缩存储</h2><h2 id="五-递归"><a href="#五-递归" class="headerlink" title="五.递归"></a>五.递归</h2><h2 id="六-树与二叉树"><a href="#六-树与二叉树" class="headerlink" title="六.树与二叉树"></a>六.树与二叉树</h2><h2 id="七-图"><a href="#七-图" class="headerlink" title="七.图"></a>七.图</h2><p>图形结构是一种比树形结构更复杂的非线性结构.在树形结构中,节点间具有分支层次关系,每一层上的节点只能和上一层中的至多一个节点相关,但可能和下一层的多个节点相关.而在图形结构中,任意两个节点之间都可能相关,即节点之间的邻接关系可以是任意的.</p>
<h3 id="图及其相关概念"><a href="#图及其相关概念" class="headerlink" title="图及其相关概念"></a>图及其相关概念</h3><ul>
<li>图是由顶点(vertex)集合及顶点间的关系组成的一种数据结构.</li>
<li>图分为无向图和有向图.具有n个顶点,n(n-1)/2条边的无向图,称为完全无向图.具有n个顶点,n(n-1)条弧的有向图称为完全有向图.完全无向图和完全有向图统称为完全图.</li>
<li>当一个图接近完全图时,称它为稠密图.相反称为稀疏图.</li>
<li>与边有关的数据信息称为权.带权图又称为网络.如果边是有方向的带权图,则是一个有向网络.</li>
<li>在无向图中,一个顶点依附的边的数目称为该顶点的度.在有向图中,指向顶点的弧的数目称为该顶点的入度(这种弧也称为入弧).从顶点发出的弧的数目称为该顶点的出度.有向图的某个顶点的入度和出度之和称为该顶点的度.</li>
<li>除第一个顶点与最后一个顶点之外,其它顶点不重复出现的回路称为简单回路(简单环).</li>
<li>若G中任意两个顶点都是连通的,则称G为连通图,否则称为非连通图.</li>
</ul>
<h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><h4 id="邻接矩阵表示法"><a href="#邻接矩阵表示法" class="headerlink" title="邻接矩阵表示法"></a>邻接矩阵表示法</h4><p>在图的邻接矩阵表示中,除用一个一维数组存放顶点本身的信息外,还用一个n×n的矩阵表示各个顶点之间的邻接关系.即若(i,j)或<i,j>属于边集E,则矩阵中第i行,第j列元素值为1,否则为0.</p>
<p>从无向图的邻接矩阵存储方法可以看出:</p>
<ol>
<li>无向图的邻接矩阵一定是一个对称矩阵</li>
<li>第i行或第i列中1的个数是顶点i的度</li>
<li>矩阵中1的个数的一半为图中边的数目</li>
</ol>
<p>从有向图的邻接矩阵存储方法可以看出:</p>
<ol>
<li>有向图的邻接矩阵不一定是一个对称矩阵</li>
<li>第i行中1的个数为顶点i的出度</li>
<li>第i列中1的个数为顶点i的入度</li>
<li>矩阵中1的个数为图中弧的数目</li>
</ol>
<p>从无向网络的邻接矩阵存储方法可以看出:</p>
<ol>
<li>无向网络的邻接矩阵一定是一个对称矩阵</li>
<li>第i行或第i列中非∞元素的个数为顶点i的度</li>
<li>矩阵中非∞元素的个数的一半为网络中边的数目</li>
</ol>
<p>从有向网络的邻接矩阵存储方法可以看出:</p>
<ol>
<li>有向网络的邻接矩阵不一定是一个对称矩阵</li>
<li>第i行中非∞元素的个数为顶点i的出度</li>
<li>第i列中非∞元素的个数为顶点i的入度</li>
<li>矩阵中非∞元素的个数为网络中弧的数目</li>
</ol>
<p>邻接矩阵的存储结构:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITY 65535 <span class="comment">//用65535表示∞</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVEX 100 <span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;<span class="comment">//顶点类型由用户定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType;<span class="comment">//边上的权值类型由用户定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    VertexType vexs[MAXVEX];<span class="comment">//顶点表</span></span><br><span class="line">    EdgeType arc[MAXVEX][MAXVEX];<span class="comment">//邻接矩阵,可看作边表</span></span><br><span class="line">    <span class="keyword">int</span> numVertexs,numEdges;<span class="comment">//图中当前的顶点和边数</span></span><br><span class="line">&#125;Mgraph;</span><br></pre></td></tr></table></figure>
<p>无向网图的邻接矩阵表示:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatMGraph</span><span class="params">(MGraph *G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k,w;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入顶点数和边数:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;G-&gt;numVertexs,&amp;G-&gt;numEdges);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;numVertexs;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(&amp;G-&gt;vexs[i]);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;numVertexs;i++)</span><br><span class="line">        <span class="keyword">for</span>(j<span class="number">-0</span>;j&lt;G-&gt;numVertexs;j++)</span><br><span class="line">            G-&gt;arc[i][j]=INFINITY;<span class="comment">//邻接矩阵初始化</span></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G-&gt;numEdges;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入边(vi,vj)上的下标i,下标j和权w:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d,%d&quot;</span>,&amp;i,&amp;j,&amp;w);</span><br><span class="line">        G-&gt;arc[i][j]=w;</span><br><span class="line">        G-&gt;arc[j][i]=G-&gt;arc[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="邻接表表示法"><a href="#邻接表表示法" class="headerlink" title="邻接表表示法"></a>邻接表表示法</h4><h2 id="八-查找"><a href="#八-查找" class="headerlink" title="八.查找"></a>八.查找</h2><h2 id="九-排序"><a href="#九-排序" class="headerlink" title="九.排序"></a>九.排序</h2><h3 id="排序的概念"><a href="#排序的概念" class="headerlink" title="排序的概念"></a>排序的概念</h3><p>排序(Sorting)就是按照某种规则,将一组数据对象(记录)排列次序,其主要目的是提高数据检索的效率.</p>
<h3 id="排序的分类"><a href="#排序的分类" class="headerlink" title="排序的分类"></a>排序的分类</h3><p>按照排序过程中所使用存储器情况,可将排序方法分为两大类:</p>
<p>1.内部排序</p>
<p>在排序过程中,整个待排序列都是存放于内存中进行处理,无内外存储器之间的数据交换问题.内部排序速度快,适合少量数据的排序处理.</p>
<p>2.外部排序</p>
<p>在排序过程中,由于待排序记录数据量相当大,不可能也不允许全部驻留在内存中,而必须存放在外部存储器上,然后根据排序过程中的要求,不断在内外存之间进行数据交换来完成排序工作.外部排序速度慢,适合大量数据的排序问处理.</p>
<p>内部排序的方法较多,按照实现策略的不同,可以将内部排序分五大类.</p>
<ol>
<li>插入排序.直接插入排序,希尔排序.</li>
<li>交换排序.冒泡排序,快速排序.</li>
<li>选择排序.直接选择排序,堆排序.</li>
<li>归并排序.</li>
<li>基数排序.</li>
</ol>
<p>假设待排序序列中记录的数据类型定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    ElementType otherinfo;<span class="comment">//排序记录中的其他所有数据项</span></span><br><span class="line">&#125;RecordType;</span><br><span class="line"><span class="keyword">typedef</span> RecordType SeqList[MaxSize+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>数组的第0个元素既可以用来作暂存空间使用,也可以作”监测哨兵”使用,但不用其存放待排序记录.在本章均要求排成递增序.</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p>思想:</p>
<p>1.将待排序序列分为有序区和无序区,初始时,有序区为[R1],无序区为[R2…Rn],令i指向无序区第一个元素,初值i=2</p>
<p>2.当i&lt;=n时,重复执行:将当前无序区第一个记录插入到有序区合适位置</p>
<p>3.当i&gt;n时,排序结束</p>
<p>算法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(SeqList R,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//length为待排序列长度</span></span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(R[i].key&lt;R[i<span class="number">-1</span>].key)</span><br><span class="line">        &#123;</span><br><span class="line">            R[<span class="number">0</span>]=R[i];</span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;R[<span class="number">0</span>].key&lt;R[j].key;j--)</span><br><span class="line">                R[j+<span class="number">1</span>]=R[j];<span class="comment">//记录后移</span></span><br><span class="line">            R[j+<span class="number">1</span>]=R[<span class="number">0</span>];</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哨兵的作用:</p>
<p>1.进入查找(插入位置)循环之前,它保存了R[i]的副本,使不至于记录后移而丢失R[i]的内容.</p>
<p>2.在查找循环中”监视”下标j是否越界.</p>
<p>直接插入排序的时间复杂度为O(n^2),空间复杂度为O(1),直接插入排序是稳定的</p>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>希尔排序也叫缩小增量排序,是插入排序的一种,在时间复杂度上比直接插入排序好.</p>
<p>思想:</p>
<p>1.先将整个待排序列以d1(d1&lt;n)为步长分成若干子序列,把所有相隔为d1的记录放在同一组</p>
<p>2.在每个分组内进行直接插入排序</p>
<p>3.再将整个待排序记录以d2(d2&lt;d1&lt;n)为步长重新分组,并在每组内进行直接插入排序</p>
<p>4.重复上步,直至dt=1,即所有记录放进一个组中进行直接插入排序,其最终结果为有序序列</p>
<p>算法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellPass</span><span class="params">(SeqList R,<span class="keyword">int</span> length,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//希尔排序的一次排序,length为待排序列长度,d为当前增量</span></span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=d+<span class="number">1</span>;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(R[i].key&lt;R[i-d].key)&#123;</span><br><span class="line">            R[<span class="number">0</span>]=R[i];</span><br><span class="line">            j=i-d;</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                R[j+d]=R[j];</span><br><span class="line">                j=j-d;</span><br><span class="line">            &#125;<span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;R[<span class="number">0</span>].key&lt;R[j].key)</span><br><span class="line">                R[j+d]=R[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(SeqList R,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//对序列R进行希尔排序,length为待排序长度</span></span><br><span class="line">    <span class="keyword">int</span> increment=length;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        increment=(increment+<span class="number">1</span>)/<span class="number">3</span>;</span><br><span class="line">        ShellPass(R,length,increment);</span><br><span class="line">    &#125;<span class="keyword">while</span>(increment&gt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>希尔排序时间复杂度可达到O(n^1.25),空间复杂度为O(1),希尔排序不稳定</p>
<h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><p>交换排序的基本思想是两两比较待排序记录的关键字,如果发现两个关键字逆序,则将两个记录位置互换,重复此过程,直到该系列所有关键字都有序为止.</p>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>思想:</p>
<p>1.将第一个记录的关键字与第二个记录的关键字比较,若二者为逆序(R[1].key&gt;R[2].key),则交换两记录位置,然后比较第二个记录与第三个记录,若两关键字为逆序,同样交换位置</p>
<p>2.依次类推,直至第n-1个记录与第n个记录比较完为止.上述过程称为第一趟冒泡排序,其结果使n个记录中关键字最大的记录被移动到最后一个位置</p>
<p>3.然后进行第二次冒泡排序,即对前n-1个记录重复与第一趟冒泡排序类似的过程,结果使关键字次大的记录被移到第n-1个记录位置</p>
<p>4.重复上述过程,直到”在一趟排序过程中没有进行交换记录的操作”为止</p>
<p>算法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(SeqList R,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,exchange=<span class="number">1</span>;<span class="comment">//exchange为发生交换的标志</span></span><br><span class="line">    <span class="keyword">for</span>(i=length;i&gt;<span class="number">1</span>&amp;&amp;exchange;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        exchange=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(R[j].key&lt;R[j+<span class="number">1</span>].key)</span><br><span class="line">            &#123;</span><br><span class="line">                R[<span class="number">0</span>]=R[j];</span><br><span class="line">                R[j]=R[j+<span class="number">1</span>];</span><br><span class="line">                R[j+<span class="number">1</span>]=R[<span class="number">0</span>];</span><br><span class="line">                exchange=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冒泡排序时间复杂度为O(n²),空间复杂度为O(1),且冒泡排序是稳定的</p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>快速排序采用一种分治的策略,通常称为分治法.分治的基本思想是:将原问题分解为若干规模更小但将结构与原问题相似的子问题,采用递归方法求解这些子问题,然后将这些子问题的解组合成原问题的解.</p>
<p>思想:</p>
<p>1.从待排序列中任取一个记录(例如)的关键字作为枢轴(pivot),按照枢轴,将整个待排序列划分为左右两个子序列,其中左子序列中所有关键字都小于等于枢轴,而右子序列中所有的关键字都大于枢轴,枢轴记录则排在这两个子序列中间(这也是该记录的最终位置).此过程称为一趟快速排序(或一次划分).</p>
<p>2.对左右两个子序列分别重复实施上述方法,直到所有的记录都排在相应的位置上为止(每个子序列只含一个记录)</p>
<p>算法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuickPass</span><span class="params">(SeqList R,<span class="keyword">int</span> b,<span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//对R[b],...R[e]作一趟划分,并返回枢轴记录的位置</span></span><br><span class="line">    <span class="keyword">int</span> i=b,j=e;</span><br><span class="line">    R[<span class="number">0</span>]=R[i];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">while</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux C编程</title>
    <url>/article/34877.html</url>
    <content><![CDATA[<h1 id="Linux-C编程"><a href="#Linux-C编程" class="headerlink" title="Linux C编程"></a>Linux C编程</h1><p>C语言的源代码文件是一个普通的文本文件,但扩展名是c.而且源代码文件是不能直接执行的,需要编译,编译后的可执行文件只能在指定操作系统下运行.</p>
<p>Linux编译后的可执行程序只能在linux运行,windows编译后的程序只能在windows下运行</p>
<p>64位的linux编译后的程序只能在64位linux下运行,32位linux编译后的程序只能在32位的linux运行.</p>
<p>64位的windows编译后的程序只能在64位windows下运行,32位windows编译后的程序可以在64位的windows运行.</p>
<h2 id="头文件包含"><a href="#头文件包含" class="headerlink" title="头文件包含"></a>头文件包含</h2><p>include有两种写法</p>
<p>#include &lt;文件名&gt;,如果文件在系统目录下,那么需要用&lt;&gt;</p>
<p>#include “文件名”,如果文件在当前目录下，那么用””</p>
<h2 id="System系统调用"><a href="#System系统调用" class="headerlink" title="System系统调用"></a>System系统调用</h2><p>在使用system之前需要包含stdlib.h这个头文件,system主要的功能是通过程序执行另外一个程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">system(<span class="string">&quot;命令&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>如果在命令行执行一个程序，那么这个程序的调用者就是操作系统，如果在代码中通过system执行一个程序，那么这个程序的调用者就是自己写的代码本身.</p>
<p>C语言所有的库函数调用，只能保证语法是一致的，但不能保证执行结果是一致的，同样的库函数在不同的操作系统下执行结果可能是一样的，也可能是不一样的。</p>
<h2 id="POSIX标准"><a href="#POSIX标准" class="headerlink" title="POSIX标准"></a>POSIX标准</h2><p>POSIX是一个标准，只要符合这个标准的函数，在不同的系统下执行的结果就可以一致。</p>
<p>Unix和Linux很多库函数都是支持POSIX的，但windows支持的比较差。</p>
<p>如果将unix代码移植到linux一般代价很小，如果把windows代码移植到unix或者linux就比较麻烦.</p>
<h2 id="C语言处理过程"><a href="#C语言处理过程" class="headerlink" title="C语言处理过程"></a>C语言处理过程</h2><p>C代码编译成可执行程序经过4步:<br>1)预处理:宏定义展开、头文件展开、条件编译等，同时将代码中的注释删除，这里并不会检查语法<br>2)编译:检查语法，将预处理后文件编译生成汇编文件<br>3)汇编:将汇编文件生成目标文件(二进制文件)<br>4)链接: C语言写的程序是需要依赖各种库的，所以编译之后还需要把库链接到最终的可执行程序中去</p>
<p>预处理:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure>
<p>编译:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure>
<p>汇编:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure>
<p>链接:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc hello.o -o hello</span><br></pre></td></tr></table></figure>
<p>查看程序所需动态库:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ldd hello   //linux</span><br></pre></td></tr></table></figure>
<p>交换文件说明:<br>1) vi写文件，没有保存就关闭，自动生成一个后缀为. swp交换文件， 保存了之前写的内容<br>2)先恢复，再删除.swp交换文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi -r &#123;your file name&#125; //恢复</span><br><span class="line">rm &#123;your file name&#125;.swp   //删除</span><br></pre></td></tr></table></figure>
<h2 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h2><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p><strong>C的关键字共有32个</strong></p>
<ul>
<li><p>数据类型关键字(12个)</p>
<p>char, short, int, long, float, double,unsigned, signed, struct, union, enum, void</p>
</li>
<li><p>控制语句关键字(12个)</p>
<p>if, else, switch, case, default,for , do, while, break, continue, goto, return</p>
</li>
<li><p>存储类关键字(5个)</p>
<p>auto,extern,register, static,const</p>
</li>
<li><p>其他关键字(3个)</p>
<p>sizeof, typedef, volatile</p>
</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>数据类型的作用:编译器预算对象(变量)分配的内存空间大小</p>
<p><img src="https://i.loli.net/2021/01/11/JgoTpVBjXIPWQLD.png" alt="image-20210111193755278"></p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul>
<li>在程序运行过程中，其值不能被改变的量</li>
<li>常量一般出现在表达式或赋值语句中</li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul>
<li>在程序运行过程中，其值可以改变</li>
<li>变量在使用前必须先定义，定义变量前必须有相应的数据类型</li>
</ul>
<p>标识符命名规则:</p>
<ul>
<li><p>标识符不能是关键字</p>
</li>
<li><p>标识符只能由字母、数字、下划线组成</p>
</li>
<li>第一个字符必须为字母或下划线</li>
<li>标识符中字母区分大小写</li>
</ul>
<p>变量特点:</p>
<ul>
<li>变量在编译时为其分配相应的内存空间</li>
<li>可以通过其名字和地址访问相应内存</li>
</ul>
<p>声明和定义区别:</p>
<ul>
<li>声明变量不需要建立存储空间，如: extern int a;(a不能赋值)</li>
<li>定义变量需要建立存储空间，如: int b;</li>
<li>-般的情况下，把建立存储空间的声明称之为“定义”，而把不需要建立存储空间的声明称之为”声明”.</li>
</ul>
<h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h3><h4 id="C语言如何表示相应的进制数"><a href="#C语言如何表示相应的进制数" class="headerlink" title="C语言如何表示相应的进制数"></a>C语言如何表示相应的进制数</h4><div class="table-container">
<table>
<thead>
<tr>
<th>十进制</th>
<th>以正常数字1-9开头,如123</th>
</tr>
</thead>
<tbody>
<tr>
<td>八进制</td>
<td>以0(零)开头,如0123</td>
</tr>
<tr>
<td>十六进制</td>
<td>以0x开头,如0x123</td>
</tr>
<tr>
<td>二进制</td>
<td>C语言不能直接书写二进制数</td>
</tr>
</tbody>
</table>
</div>
<h3 id="计算机内存数值存储方式"><a href="#计算机内存数值存储方式" class="headerlink" title="计算机内存数值存储方式"></a>计算机内存数值存储方式</h3><p>在计算机系统中，数值一律用补码来存储。</p>
<h4 id="原码"><a href="#原码" class="headerlink" title="原码:"></a>原码:</h4><p>最高位为符号位:0代表正数,1代表负数​</p>
<p>原码存储导致2个问题:</p>
<ol>
<li>0有两种存储方式</li>
<li>正数和负数相加结果不正确</li>
</ol>
<h4 id="反码"><a href="#反码" class="headerlink" title="反码:"></a>反码:</h4><p>反码是为了算补码.正数的原码和反码是一样的,负数的反码在原码基础上,符号位不变,其它位取反(0为1,1变0 ).</p>
<p>反码存储导致1个问题:</p>
<ol>
<li>0有两种存储方式</li>
</ol>
<h4 id="补码"><a href="#补码" class="headerlink" title="补码:"></a>补码:</h4><p>正数的原码,反码,补码都一样</p>
<p>负数的补码为其反码加1</p>
<p>十进制数,站在用户角度看,<strong>原码</strong>;二进制,八进制,十六进制,要站在计算机角度看,<strong>补码</strong>.</p>
<p>原码求补码:</p>
<ol>
<li>正数原,反,补码均相同</li>
<li>负数原码最高位不变,其他位取反得反码</li>
<li>反码加1得补码</li>
</ol>
<p>补码求原码(同上面类似):</p>
<ol>
<li>正数原,反,补码均相同</li>
<li>负数补码最高位不变,其他位取反得反码</li>
<li>反码加1得原码</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> a=<span class="number">0x81</span>;<span class="comment">//a是值为十六进制数的字符,在计算机看来是补码</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);<span class="comment">//%d为输出十进制数,在用户看来是原码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序运行结果如下:</p>
<p><img src="https://i.loli.net/2021/01/12/l23jvtQaPwTHyWG.png" alt=""></p>
<p>按照十六进制转十进制,0x81等于129而不是-127</p>
<p>分析:</p>
<ol>
<li>0x81在计算机角度看来应为补码存储,其二进制形式为10000001</li>
<li>输出%d即输出十进制数,十进制数在用户角度为原码</li>
<li>由(1)(2)知,该程序即将0x81的补码转换为原码</li>
<li>其原码为11111111,即-127</li>
</ol>
<p>有符号和无符号的区别:</p>
<ul>
<li>%d,默认以有符号的方式打印</li>
<li>%u,默认以无符号的方式打印</li>
<li>有符号，最高位是符号位，如果是1代表为负数，如果为0代表为正数</li>
<li>无符号，最高位不是符号位，是数的一部分，无符号不可能是负数</li>
</ul>
<p>数据类型范围:</p>
<p>char    1个字节</p>
<p><img src="https://i.loli.net/2021/01/12/UNxsfOjRD2cu9eY.png" alt="image-20210112214358475" style="zoom:80%;" /></p>
<p>数值越界:</p>
<p>通过以下代码解释</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">//情况1 有符号</span></span><br><span class="line">        <span class="comment">//char 范围 -128~127</span></span><br><span class="line">        <span class="keyword">char</span> a=<span class="number">127</span>+<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/* a=129,转换二进制为1000 0001,</span></span><br><span class="line"><span class="comment">          二进制(1000 0001)以补码形式存储,</span></span><br><span class="line"><span class="comment">          输出为%d,要求得原码(11111111),</span></span><br><span class="line"><span class="comment">          即-127</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);<span class="comment">//输出-127</span></span><br><span class="line">        <span class="comment">//情况2 无符号</span></span><br><span class="line">        <span class="comment">//无符号 范围 0~255</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> b=<span class="number">255</span>+<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/* b=257,转换二进制为1 0000 0001,</span></span><br><span class="line"><span class="comment">           舍弃最高位为0000 0001,</span></span><br><span class="line"><span class="comment">           二进制(0000 0001)以补码形式存储,</span></span><br><span class="line"><span class="comment">           转为原码(0000 0001),</span></span><br><span class="line"><span class="comment">           即1</span></span><br><span class="line"><span class="comment">           注意编译时会警告,之后./文件名运行即可</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>,b);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下:</p>
<p><img src="https://i.loli.net/2021/01/13/GL8cpTQzUtFu7n1.png" alt="image-20210113191321188"></p>
<h4 id="sizeof关键字"><a href="#sizeof关键字" class="headerlink" title="sizeof关键字"></a>sizeof关键字</h4><ul>
<li>sizeof不是函数，所以不需要包含任何头文件，它的功能是计算一个数据类型的大小，单位为字节</li>
<li>sizeof的返回值为size_ t</li>
<li>size_t 类型在32位操作系统下是unsigned int,是一个无符号的整数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*数据类型的作用:告诉编译器,</span></span><br><span class="line"><span class="comment">    定义此类型变量需要分配多大空间*/</span>					<span class="built_in">printf</span>(<span class="string">&quot;sizeof(char)=%lu\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">   	<span class="built_in">printf</span>(<span class="string">&quot;sizeof(a)=%lu\n&quot;</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下:</p>
<p><img src="https://i.loli.net/2021/01/13/3VmSN7iDcPkwLsY.png" style="zoom:150%;" /></p>
<p>%d,%o,%x,%u等均以四个字节形式打印.</p>
<p>short占两个字节,short a;与short int a;等价.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据类型</th>
<th>占用空间</th>
</tr>
</thead>
<tbody>
<tr>
<td>short (短整型)</td>
<td>2字节</td>
</tr>
<tr>
<td>int (整型)</td>
<td>4字节</td>
</tr>
<tr>
<td>1ong(长整形)</td>
<td>Windows为4字节，Linux为 4字节(32位)，8字节(64位)</td>
</tr>
<tr>
<td>long long (长长整形)</td>
<td>8字节</td>
</tr>
</tbody>
</table>
</div>
<h3 id="字符型变量"><a href="#字符型变量" class="headerlink" title="字符型变量"></a>字符型变量</h3><p>字符型变量用于存储一个单一字符，在C语言中用char 表示，其中每个字符变量都会占用1个字节。在给字符型变量赋值时，需要用一对英文半角格式的单引号(‘ ‘)把字符括起来。<br>字符变量实际上并不是把该字符本身放到变量的内存单元中去，而是将该字符对应的ASCII 编码放到变量的存储单元中。char 的本质就是一个1 字节大小的整型。</p>
<p>使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man ascii</span><br></pre></td></tr></table></figure>
<p>查看ASCII码</p>
<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>字符在单引号内,原则上’ ‘内部只有一个字符,转义字符除外,不能char a=’abc’</p>
<p>转义字符由反斜杠\组成的多个字符</p>
<p>例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> a=<span class="string">&#x27;\r&#x27;</span>;<span class="comment">//光标移到句首</span></span><br><span class="line">        <span class="keyword">char</span> b=<span class="string">&#x27;\b&#x27;</span>;<span class="comment">//退格</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;12345%c6789\n&quot;</span>,a);<span class="comment">//先打印12345,之后光标移到句首再依次打印6789,其中1234被覆盖,留下5,结果为67895</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;abcde%cfghi\n&quot;</span>,b);<span class="comment">//先打印abcde之后打印\b,退一格,e就没了,结果为abcdfghi</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/22/wYUVzd2mpNqX3LQ.png" alt=""></p>
<h3 id="浮点型-实型"><a href="#浮点型-实型" class="headerlink" title="浮点型(实型)"></a>浮点型(实型)</h3><p>实型变量也可以称为浮点型变量，浮点型变量是用来存储小数数值的。在C语言中，浮点型变量分为两种:单精度浮点数(float)、双精度浮点数(double)，但是double型变量所表示的浮点数比float 型变量更精确。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据类型</th>
<th>占用空间</th>
<th>有效数字范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>float</td>
<td>4字节</td>
<td>7位有效数字</td>
</tr>
<tr>
<td>double</td>
<td>8字节</td>
<td>15~ 16位有效数字</td>
</tr>
</tbody>
</table>
</div>
<p>float存储不准确</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">float</span> a=<span class="number">100.9</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,a);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/22/pT1JRNYS97IyjM4.png" alt=""></p>
<h3 id="类型限定符"><a href="#类型限定符" class="headerlink" title="类型限定符"></a>类型限定符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>限定符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>extern</td>
<td>声明一个变量，extexn 声明的变量没有建立存储空间。extern int a;</td>
</tr>
<tr>
<td>const</td>
<td>定义一个常量，常量的值不能修改。const int a 10;</td>
</tr>
<tr>
<td>vo1atile</td>
<td>防止编译器优化代码</td>
</tr>
<tr>
<td>register</td>
<td>定义寄存器变量，提高效率。 register是建议型的指令，而不是命令型的指令，如果CPU有空闲寄存器，那么register就生效， 如果没有空闲寄存器，那么register无效。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>字符串常量与字符常量的不同:<br>‘a’为字符常量，”a”为字符串常量</p>
<p><img src="https://i.loli.net/2021/01/22/hAXpsqiEMktCuyn.png" alt="image-20210113191321188"></p>
<p>每个字符串的结尾，编译器会自动的添加一一个结束标志位’\0’,即”a” 包含<br>两个字符’a’和’\0’。</p>
<p>%%在屏幕输出一个%，后面的d也会输出</p>
<p>%5d,以5个字符输出,没有的字符以空字符填充,默认是右对齐</p>
<p>%05d,以5个字符输出,没有的字符以0填充,默认是右对齐</p>
<p>%-5d,以5个字符输出,没有的字符以空字符填充,-代表指定为左对齐</p>
<p>0和-不能同时使用</p>
<p><img src="https://i.loli.net/2021/01/22/ts6idzBZGxWJveY.png" alt=""></p>
<h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><blockquote>
<p>遇到”\0”停止</p>
</blockquote>
<h3 id="puts"><a href="#puts" class="headerlink" title="puts()"></a>puts()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[]=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">puts</span>(buf);<span class="comment">//把buf内容输出到屏幕,自动在屏幕加换行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);<span class="comment">//没有加换行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/29/u4frlgbByp9IMoT.png" alt=""></p>
<h3 id="fputs"><a href="#fputs" class="headerlink" title="fputs()"></a>fputs()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[]=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="comment">//向stdout(代表屏幕,标准输出)输出buf的内容</span></span><br><span class="line">    <span class="built_in">fputs</span>(buf,<span class="built_in">stdout</span>);<span class="comment">//没有加换行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/29/r64eO1HkSZt9JXd.png" alt="image-20210129141616052"></p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><h3 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h3><p>scanf()的缺陷，不做越界检查,不允许有空格</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入字符串:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%s\n&quot;</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/29/foM25d9lpc8aQUR.png" alt=""></p>
<h3 id="gets"><a href="#gets" class="headerlink" title="gets()"></a>gets()</h3><p>gets()从键盘读取字符串，放在指定的数组<br>gets()允许有空格，不做越界检查，此函数不安全</p>
<h3 id="fgets"><a href="#fgets" class="headerlink" title="fgets()"></a>fgets()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">//从stdin(代表标准输入,键盘)读取内容</span></span><br><span class="line">        <span class="comment">/*如果输入内容大于sizeof(buf)-1,只取	</span></span><br><span class="line"><span class="comment">        sizeof(buf)-1,放在buf所在数组;</span></span><br><span class="line"><span class="comment">        当不足sizeof(buf)-1,会把换行符读进去*/</span></span><br><span class="line">        fgets(buf,<span class="keyword">sizeof</span>(buf),<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buf=%s\n&quot;</span>,buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/29/qgh4QbsSC7MvWfd.png" alt=""></p>
<p>fgets()允许有空格</p>
<p><img src="https://i.loli.net/2021/01/29/6vIXpuY7SQeEKUM.png" alt=""></p>
<p>当不足sizeof(buf)-1,会把换行符读进去</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    fgets(buf,<span class="keyword">sizeof</span>(buf),<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf=#%s#\n&quot;</span>,buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/29/3gJLWmkOlP8fQKI.png" alt=""></p>
<h3 id="输入字符"><a href="#输入字符" class="headerlink" title="输入字符"></a>输入字符</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入字符:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;a);<span class="comment">//假设输入c</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a=&#x27;%c&#x27;\n&quot;</span>,a);</span><br><span class="line">        <span class="keyword">char</span> b;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入字符:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;b);<span class="comment">//假设输入d</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;b=&#x27;%c&#x27;\n&quot;</span>,b);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个程序看似简单,结果为a=c,b=d,其实不然,结果如下:</p>
<p><img src="https://i.loli.net/2021/01/22/itzxmayI15d6uqO.png" alt=""></p>
<p>无需输入d直接出结果</p>
<p>原因:</p>
<p>当用户输入字符时,编译器默认把输入的内容先放在一块内存中(缓冲区) , scanf()自动在缓冲区读内容(只读一个字符).第一次输入时输入了c\n(回车),scanf取走了c,留下\n还在缓存区,第2次scanf ,由于缓冲区还有内容,所以直接取内容,无需再输入</p>
<p>所以,上面的程序可以这样写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入字符:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;a);<span class="comment">//假设输入c</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a=&#x27;%c&#x27;\n&quot;</span>,a);</span><br><span class="line">        <span class="comment">//吃掉上一步的\n,不做处理</span></span><br><span class="line">        <span class="keyword">char</span> b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;b);</span><br><span class="line">        <span class="keyword">char</span> t;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入字符:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;t);<span class="comment">//假设输入d</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;t=&#x27;%c&#x27;\n&quot;</span>,t);</span><br><span class="line">    	<span class="comment">//或者都在一个scanf中写</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输入字符串"><a href="#输入字符串" class="headerlink" title="输入字符串"></a>输入字符串</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入字符串a:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);<span class="comment">//假设输入hello world</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%s\n&quot;</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入字符串b:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b=%s\n&quot;</span>,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下:</p>
<p><img src="https://i.loli.net/2021/01/29/OUtFhK74fAaNsj5.png" alt=""></p>
<p>原因:</p>
<p>当输入hello world时,第一个scanf取走第一个空格前的字符串,即hello;第二个scanf取第一个空格后第二个空格前的内容,\\n不取</p>
<p>switch语句</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">        <span class="comment">//1、switch是关键字， switch() 后面没有分号</span></span><br><span class="line">        <span class="comment">//2、switch()中() 里只能放整型变量或字符型变量</span></span><br><span class="line">        <span class="keyword">switch</span>(num)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;1楼\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;2楼\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;3楼\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;其他楼层\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>goto语句</p>
<p>goto(只能跳转到同一作用域)任意地方都能使用,无条件跳转,不能滥用,代码会很乱</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">goto</span> hello;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1111111111\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2222222222\n&quot;</span>);</span><br><span class="line">        hello:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;3333333333\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/28/fNUX46T5h1YqSc9.png" alt="image-20210122205440917" style="zoom:150%;" /></p>
<p>类型转换:</p>
<p>1.隐式转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> a;</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//编译器自动转换，把b转 换为double类型后， 再给a赋值(隐式转换)</span></span><br><span class="line">a= b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>，b) ;</span><br></pre></td></tr></table></figure>
<p>2.强制类型转换  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="comment">//a只有在此语句执行时，才强制转换为double类型，其它地址还是为int类型</span></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%lf\n&quot;</span>，(<span class="keyword">double</span>)a) ;<span class="comment">//(类型)变量名</span></span><br></pre></td></tr></table></figure>
<p>转换原则:占用内存字节数少(值域小)的类型，向占用内存字节数多(值域大)的类型转换，以保证精度不降低。</p>
<p>3.浮点型和整型打印问题<br>a)不要直接通过%d，打印一个浮点型变量，得不到想要的结果，要想得到结果，强制类型转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> a = <span class="number">11.11</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(<span class="keyword">int</span>)a) ;</span><br></pre></td></tr></table></figure>
<p>b)不要直接通过%f或%lf，打印一个整型变量，得不到想要的结果，要想得到结果，强制类型转换</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol>
<li>数组内部的变量或数组,不初始化,它的值为随机数</li>
<li>部分初始化，其它自动初始化为0<br>0~2(前3个元素)分别为1，2， 3， 其 它初始化为0<br>int a1[10] = {1, 2, 3};</li>
<li>数组全部元素初始化为0<br>int a2[10] = {0} ;</li>
<li>如果定义时同时初始化，第1个[]内部可以不写内容<br>编译器会根据用户初始化的元素来确定数组的大小<br>int a3[]={1,2,3,4,5,6,7,8,9,10};</li>
<li>如果第1个[]内容不写，必须初始化，否则语法错误</li>
</ol>
<h3 id="数组名"><a href="#数组名" class="headerlink" title="数组名"></a>数组名</h3><ul>
<li>数组名是常量,不能修改</li>
<li>数组名是数组首元素地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a=%p,&amp;a[0]=%p\n&quot;</span>,a,&amp;a[<span class="number">0</span>]);<span class="comment">//%p输出地址</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sizeof(a)=%lu\n&quot;</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/23/EFTYRgCKmLP263d.png" alt=""></p>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>内存中没有多维,只有一维,多维数组是特殊的一维数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果定义时，同时初始化，第1个[]可以不写内容</span></span><br><span class="line"><span class="keyword">int</span> a1[][<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;<span class="comment">//正确</span></span><br><span class="line"><span class="comment">//如果第1个[]不写，必须初始化</span></span><br><span class="line"><span class="keyword">int</span> a3[][<span class="number">4</span>]; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3><ol>
<li>C语言没有字符串类型,用字符数组模拟</li>
<li>字符串一定是字符数组,字符数组就不一定是字符串</li>
<li>如果字符数组以字符’\0’ (‘\0’等级于数字0)结尾,那么这个字符数组就是字符串</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、C语言没有字符串类型，用字符数组模拟</span></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//2、字符串一定是字符数组，字符数组就不一定是字符串</span></span><br><span class="line"><span class="comment">//3、如果字符数组以字符&#x27;\0&#x27;(&#x27;\0&#x27;等级于数字0)结尾，那么这个字符数组就是字符串</span></span><br><span class="line"><span class="keyword">char</span> b[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;; <span class="comment">//字符数组,方括号中不能填数字,否则会自动补零,就变成字符串</span></span><br><span class="line"><span class="keyword">char</span> c[<span class="number">10</span>] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;; <span class="comment">//字符串</span></span><br><span class="line"><span class="keyword">char</span> d[<span class="number">10</span>] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="number">0</span>&#125;; <span class="comment">//字符串</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[]=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%s\n&quot;</span>,a);<span class="comment">//会乱码,没有结束符</span></span><br><span class="line">    <span class="keyword">char</span> b[]=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b=%s\n&quot;</span>,b);<span class="comment">//输出abc,遇到\0就停止</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/27/Re83qQAwDB7K42Y.png" alt=""></p>
<p>字符数组初始化(常用)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>]=<span class="string">&quot;abcde&quot;</span>;<span class="comment">//最多写9个字符,留一个放结束符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%s\n&quot;</span>,a);</span><br><span class="line"><span class="keyword">char</span> b[]=<span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b=%s\n&quot;</span>,b);<span class="comment">//sizeof()测数据类型大小，不会因为结束符提前结束</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(b)=%lu\n&quot;</span>,<span class="keyword">sizeof</span>(b));<span class="comment">//输出6,b这个数组有5个字符,会自动补加结束符(隐藏)</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/27/iDy86UJt1X2r3ZK.png" alt=""></p>
<p>\0后面最好不要跟数字,有可能组成转义字符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[]=<span class="string">&quot;\0abc&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%s\n&quot;</span>,a);<span class="comment">//输出为空,含有结束符\0</span></span><br><span class="line">    <span class="keyword">char</span> b[]=<span class="string">&quot;\0417abcde&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b=%s\n&quot;</span>,b);<span class="comment">//输出非空,\0与其后数字组成转义字符\041,通过man ascii命令查到\041对应!(感叹号)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/27/VJXSilNmnR6wyhB.png" alt=""></p>
<p>函数的调用:产生随机数</p>
<p>当调用函数时，需要关心5要素:</p>
<ul>
<li>头文件:包含指定的头文件</li>
<li>函数名字:函数名字必须和头文件声明的名字一样</li>
<li>功能:需要知道此函数功能后再调用</li>
<li>参数:参数类型要匹配</li>
<li>返回值:根据需要接收返回值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;//产生随机数的函数包含在此</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;//获取当前系统时间的函数包含在此</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">//先设置种子,种子设置一次即可</span></span><br><span class="line">        <span class="comment">//srand(10);</span></span><br><span class="line">        <span class="comment">/*如果srand()参数一样,则每次产生的随机数一样,</span></span><br><span class="line"><span class="comment">        每次启动计算机以后，种子就是定值了，</span></span><br><span class="line"><span class="comment">        所以根据公式推算出来的结果</span></span><br><span class="line"><span class="comment">        （也就是生成的随机数）就是固定的*/</span></span><br><span class="line">        <span class="comment">/*time(NULL)用来获取系统当前时间,</span></span><br><span class="line"><span class="comment">        由于时间会变,srand()也会改变*/</span></span><br><span class="line">        srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">                num=rand();<span class="comment">//rand()产生随机数</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;num=%d\n&quot;</span>,num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/27/lTzVDuG41P6RUr7.png" alt=""></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h3><blockquote>
<p>strlen需要使用返回值,返回值就是字符串的长度,从首元素开始,到结束符为止的长度,结束符不算(遇到’\0’结束)</p>
</blockquote>
<h3 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h3><blockquote>
<p>拷贝原理:从首元素开始,到结束符(\0)为止的长度</p>
</blockquote>
<h3 id="strncpy"><a href="#strncpy" class="headerlink" title="strncpy"></a>strncpy</h3><blockquote>
<p>可以把”\0”拷贝过去,但是”\0”后面的就不能了</p>
</blockquote>
]]></content>
      <categories>
        <category>C&amp;C++</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Web学习</title>
    <url>/article/22773.html</url>
    <content><![CDATA[<h1 id="Web学习"><a href="#Web学习" class="headerlink" title="Web学习"></a>Web学习</h1><a id="more"></a>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><h4 id="input控件"><a href="#input控件" class="headerlink" title="input控件"></a>input控件</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;属性值&quot;</span> <span class="attr">value</span>=<span class="string">&quot;你好&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<table>
    <tr>
        <th>属性</th>
        <th>属性值</th>
        <th>描述</th>  
    </tr >
    <tr >
        <td rowspan="16">type</td>
        <td>text</td>
        <td>单行文本输入框</td>
    </tr>
    <tr>
        <td>password</td>
        <td>密码输入框</td>
    </tr>
    <tr>
        <td>radio</td>
        <td>单选按钮</td>
    </tr>
    <tr>
        <td>CheckBox</td>
        <td>复选按钮</td>
    </tr>
    <tr><td>button</td>
        <td>普通按钮</td>
    </tr>
    <tr>
        <td>submit</td>
        <td>提交按钮</td>
    </tr>
    <tr>
        <td>reset</td>
        <td>重置按钮</td>
    </tr>
    <tr>
        <td>image</td>
        <td>图像形式的提交按钮</td>
    </tr>
    <tr>
        <td >file</td>
        <td>文件域</td>
    </tr>
    <tr>
        <td>number</td>
        <td>数字框,只能输入数字,右侧多出加减符号</td>
    </tr>
    <tr>
        <td>url</td>
        <td>网址输入框</td>
    </tr>
    <tr>
        <td>email</td>
        <td>邮箱输入框</td>
    </tr>
    <tr>
        <td>date</td>
        <td>日期</td>
    </tr>
    <tr>
        <td>color</td>
        <td>颜色选择表单</td>
    </tr>
    <tr>
        <td>tel</td>
        <td>手机号码</td>
    </tr>
    <tr>
        <td>search</td>
        <td>搜索框</td>
    </tr>
    <tr>
        <td >name</td>
        <td>用户自定义</td>
        <td>控件名称</td>
    </tr>
    <tr>
        <td >value</td>
        <td >用户自定义</td>
        <td >默认文本值</td>
    </tr>
    <tr>
        <td >size</td>
        <td >正整数</td>
        <td >控件在页面中的显示宽度</td>
    </tr>
    <tr>
        <td >checked</td>
        <td >checked</td>
        <td >定义选择控件默认被选中项</td>
    </tr>
    <tr>
        <td >maxlength</td>
        <td >正整数</td>
        <td >控件允许输入的最多字符</td>
    </tr>
    <tr>
        <td >placeholder</td>
        <td >自定义</td>
        <td >占位符</td>
    </tr>
    <tr>
        <td >required</td>
        <td >required</td>
        <td >内容不能为空,必填</td>
    </tr>
    <tr>
        <td >autofocus</td>
        <td >autofocus</td>
        <td >自动聚焦属性,页面加载完成自动聚焦到指定表单</td>
    </tr>
    <tr>
        <td >multiple</td>
        <td >multiple</td>
        <td >可以多选文件提交</td>
    </tr>
    <tr>
        <td >autocomplete</td>
        <td >on/off(默认为on[开启])</td>
        <td >当用户在字段开始键入时,浏览器基于之前键入过的值,显示出在字段中填写过的选项。使用要求:1.需要放在表单内同时加上name属性2.同时成功提交(off用得多)
</td>
    </tr>
</table>

<h4 id="label标签"><a href="#label标签" class="headerlink" title="label标签"></a>label标签</h4><p>label标签不会向用户呈现任何特殊效果，它的作用是为鼠标用户改进了可用性。如果你在 label 标签内点击文本，就会触发此控件。就是说，当用户单击选中该label标签时，浏览器就会自动将焦点转到和标签相关的表单控件上（就自动选中和该label标签相关连的表单控件上）。</p>
<p>语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;控件id名称&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：标签的 for 属性中的值应当与相关控件的 id 属性值一定要相同。</p>
<p>例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;email&quot;</span>&gt;</span>输入你的邮箱地址<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">id</span>=<span class="string">&quot;email&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter email&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="textarea控件-文本域"><a href="#textarea控件-文本域" class="headerlink" title="textarea控件(文本域)"></a>textarea控件(文本域)</h4><p>当用户需要在表单中输入大段文字时，需要用到文本输入域。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">&quot;行数&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;列数&quot;</span>&gt;</span>文本<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>1、<strong>cols ：</strong>多行输入域的<strong>列数</strong>。</p>
<p>2、<strong>rows ：</strong>多行输入域的<strong>行数</strong>。</p>
<p><strong>举例：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;save.php&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">label</span>&gt;</span>联系我们<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">cols</span>=<span class="string">&quot;50&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span> &gt;</span>在这里输入内容...<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="select下拉列表"><a href="#select下拉列表" class="headerlink" title="select下拉列表"></a>select下拉列表</h4><p>下拉列表:</p>
<p>下拉列表在网页中也常会用到，它可以有效的节省网页空间。既可以单选、又可以多选。如下代码：</p>
<p><img src="https://i.loli.net/2021/01/10/1cExMyhR3dkTeKi.png" alt=""></p>
<p><strong>讲解：</strong></p>
<p>1、select和option标签都是双标签，它总是成对出现的，需要首标签和尾标签。</p>
<p>2、select标签里面只能放option标签，表示下拉列表的选项。</p>
<p>3、option标签放选项内容，不放置其他标签。</p>
<p>4、value：</p>
<p><img src="https://i.loli.net/2021/01/10/VAhEQFzT7dNoMO8.png" alt=""></p>
<p>5、selected=”selected”：</p>
<p>设置selected=”selected”属性，则该选项就被默认选中。</p>
<p>在浏览器中显示的结果：</p>
<p><img src="https://i.loli.net/2021/01/10/p8nCDEVleONLkjg.png" alt=""></p>
<h4 id="form表单域"><a href="#form表单域" class="headerlink" title="form表单域"></a>form表单域</h4><p>网站怎样与用户进行交互？答案是使用HTML表单(form)。表单是可以把浏览者输入的数据传送到服务器端，这样服务器端程序就可以处理表单传过来的数据。</p>
<p>语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;服务器文件/url地址&quot;</span> <span class="attr">method</span>=<span class="string">&quot;传送方式&quot;</span> <span class="attr">name</span>=<span class="string">&quot;表单名称&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>讲解：</strong></p>
<p>1.<strong>action</strong> <strong>：</strong>浏览者输入的数据被传送到的地方,比如一个PHP页面(save.php)。</p>
<p>2.<strong>method</strong> <strong>：</strong> 数据传送的方式（get/post）。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>  <span class="attr">action</span>=<span class="string">&quot;save.php&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>用户名:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;pass&quot;</span>&gt;</span>密码:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pass&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<p><strong>1、所有表单控件（文本框、文本域、按钮、单选框、复选框等）都必须放在 form 标签之间（否则用户输入的信息可提交不到服务器上哦！）。</strong></p>
<p><strong>2、method : post/get 的区别这一部分内容属于后端程序员考虑的问题。</strong></p>
<h3 id="html5语义化标签"><a href="#html5语义化标签" class="headerlink" title="html5语义化标签"></a>html5语义化标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span> :头部标签</span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span> :导航标签</span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span> :内容标签</span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span> : 块级标签</span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span> :侧边栏标签</span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span> :尾部标签</span><br></pre></td></tr></table></figure>
<ul>
<li>这种语义化标准主要针对搜索引擎的</li>
<li>这些标签页面中可以使用多次</li>
<li>在IE9中,需要把这些元素转换为块级元素</li>
<li>移动端更喜欢使用这些标签</li>
</ul>
<h3 id="多媒体标签"><a href="#多媒体标签" class="headerlink" title="多媒体标签"></a>多媒体标签</h3><p>谷歌浏览器把音频和规频自动播放禁止了</p>
<h4 id="音频标签"><a href="#音频标签" class="headerlink" title="音频标签"></a>音频标签</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;文件地址&quot;</span> <span class="attr">controls</span>=<span class="string">&quot;controls&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>=<span class="string">&quot;controls&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;mp3格式视频&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/mpeg&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;ogg格式视频&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/ogg&quot;</span>&gt;</span></span><br><span class="line">	您的浏览器暂不支持audio标签播放音频.</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h5><p>Internet Explorer 9+, Firefox, Opera, Chrome, 和 Safari 都支持 <audio> 元素.</p>
<p><strong>注意:</strong> Internet Explorer 8 及更早IE版本不支持 \<audio> 元素.</p>
<h5 id="音频格式及浏览器支持"><a href="#音频格式及浏览器支持" class="headerlink" title="音频格式及浏览器支持"></a>音频格式及浏览器支持</h5><p>目前, \<audio>元素支持三种音频格式文件: MP3, Wav和Ogg:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">浏览器</th>
<th style="text-align:left">MP3</th>
<th style="text-align:left">Wav</th>
<th style="text-align:left">Ogg</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Internet Explorer 9+</td>
<td style="text-align:left">YES</td>
<td style="text-align:left">NO</td>
<td style="text-align:left">NO</td>
</tr>
<tr>
<td style="text-align:left">Chrome 6+</td>
<td style="text-align:left">YES</td>
<td style="text-align:left">YES</td>
<td style="text-align:left">YES</td>
</tr>
<tr>
<td style="text-align:left">Firefox 3.6+</td>
<td style="text-align:left">YES</td>
<td style="text-align:left">YES</td>
<td style="text-align:left">YES</td>
</tr>
<tr>
<td style="text-align:left">Safari 5+</td>
<td style="text-align:left">YES</td>
<td style="text-align:left">YES</td>
<td style="text-align:left">NO</td>
</tr>
<tr>
<td style="text-align:left">Opera 10+</td>
<td style="text-align:left">YES</td>
<td style="text-align:left">YES</td>
<td style="text-align:left">YES</td>
</tr>
</tbody>
</table>
</div>
<p>因为不同浏览器支持不同格式，采取的解决方案是为这个音频准备多个格式</p>
<h5 id="音频标签常见属性"><a href="#音频标签常见属性" class="headerlink" title="音频标签常见属性"></a>音频标签常见属性</h5><div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>autoplay</td>
<td>autoplay</td>
<td>如果出现该属性，则音频在就绪后马上播放。</td>
</tr>
<tr>
<td>controls</td>
<td>controls</td>
<td>如果出现该属性，则向用户显示控件，比如播放按钮。</td>
</tr>
<tr>
<td>loop</td>
<td>loop</td>
<td>如果出现该属性，则每当音频结束时重新开始播放。</td>
</tr>
<tr>
<td>src</td>
<td>url</td>
<td>要播放的音频的URL。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="视频标签"><a href="#视频标签" class="headerlink" title="视频标签"></a>视频标签</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;文件地址&quot;</span> <span class="attr">controls</span>=<span class="string">&quot;controls&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;mp4文件&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;ogg文件&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/ogg&quot;</span>&gt;</span></span><br><span class="line">    您的浏览器暂不支持video标签播放视频.</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="浏览器支持-1"><a href="#浏览器支持-1" class="headerlink" title="浏览器支持"></a>浏览器支持</h5><p>Internet Explorer 9+, Firefox, Opera, Chrome, 和 Safari 支持 \<video> 元素.</p>
<p><strong>注意:</strong> Internet Explorer 8 或者更早的IE版本不支持 \<video> 元素。</p>
<p>当前， \<video> 元素支持三种视频格式： MP4, WebM和 Ogg:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">浏览器</th>
<th style="text-align:left">MP4</th>
<th style="text-align:left">WebM</th>
<th style="text-align:left">Ogg</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Internet Explorer</td>
<td style="text-align:left">YES</td>
<td style="text-align:left">NO</td>
<td style="text-align:left">NO</td>
</tr>
<tr>
<td style="text-align:left">Chrome</td>
<td style="text-align:left">YES</td>
<td style="text-align:left">YES</td>
<td style="text-align:left">YES</td>
</tr>
<tr>
<td style="text-align:left">Firefox</td>
<td style="text-align:left">YES</td>
<td style="text-align:left">YES</td>
<td style="text-align:left">YES</td>
</tr>
<tr>
<td style="text-align:left">Safari</td>
<td style="text-align:left">YES</td>
<td style="text-align:left">NO</td>
<td style="text-align:left">NO</td>
</tr>
<tr>
<td style="text-align:left">Opera</td>
<td style="text-align:left">YES (从 Opera 25 起)</td>
<td style="text-align:left">YES</td>
<td style="text-align:left">YES</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>MP4 = 带有 H.264 视频编码和 AAC 音频编码的 MPEG 4 文件</li>
<li>WebM = 带有 VP8 视频编码和 Vorbis 音频编码的 WebM 文件</li>
<li>Ogg = 带有 Theora 视频编码和 Vorbis 音频编码的 Ogg 文件</li>
</ul>
<h5 id="视频标签常见属性"><a href="#视频标签常见属性" class="headerlink" title="视频标签常见属性"></a>视频标签常见属性</h5><div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>autoplay</td>
<td>autoplay</td>
<td>视频就绪自动播放(谷歌浏览器需要添加muted来解决自动播放问题)</td>
</tr>
<tr>
<td>controls</td>
<td>controls</td>
<td>向用户显示播放控件</td>
</tr>
<tr>
<td>width</td>
<td>pixels(像素)</td>
<td>设置播放器宽度</td>
</tr>
<tr>
<td>height</td>
<td>pixels(像素)</td>
<td>设置播放器高度</td>
</tr>
<tr>
<td>loop</td>
<td>loop</td>
<td>播放完是否继续播放该视频，循环播放</td>
</tr>
<tr>
<td>preload</td>
<td>auto<br/>metadata<br/>none</td>
<td>如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。</td>
</tr>
<tr>
<td>src</td>
<td>url</td>
<td>视频url地址</td>
</tr>
<tr>
<td>poster</td>
<td>url</td>
<td>加载等待的画面图片地址</td>
</tr>
<tr>
<td>muted</td>
<td>muted</td>
<td>静音播放</td>
</tr>
</tbody>
</table>
</div>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="CSS的三种引用方式"><a href="#CSS的三种引用方式" class="headerlink" title="CSS的三种引用方式"></a>CSS的三种引用方式</h3><ol>
<li>内联样式(行内式)</li>
<li>嵌入样式(内部式)</li>
<li>外部样式(外链式)</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>样式表</th>
<th>优点</th>
<th>缺点</th>
<th>使用情况</th>
<th>控制范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>行内样式表</td>
<td>书写方便,权重高</td>
<td>没有实现结构和样式相分离</td>
<td>较少</td>
<td>控制一个标签</td>
</tr>
<tr>
<td>内部样式表</td>
<td>部分结构和样式相分离</td>
<td>没有彻底分离</td>
<td>较多</td>
<td>控制一个页面</td>
</tr>
<tr>
<td>外部样式表</td>
<td>完全实现结构和样式相分离</td>
<td>需要引入</td>
<td>最多</td>
<td>控制多个站点</td>
</tr>
</tbody>
</table>
</div>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><h4 id="font-family"><a href="#font-family" class="headerlink" title="font-family"></a>font-family</h4><p>可同时指定多个字体,中间以逗号隔开,表示如果浏览器不支持第一个字体,则会尝试下一个,直到找到合适的字体</p>
<h4 id="CSS-Unicode字体"><a href="#CSS-Unicode字体" class="headerlink" title="CSS Unicode字体"></a>CSS Unicode字体</h4><ul>
<li><p>为什么使用Unicode字休</p>
<ul>
<li>在CSS中设置字体名称，直接写中文是可以的。但是在文件编码(GB2312、 UTF 8等)不匹配时会产生乱码的错误。</li>
<li>xp系统不支持类似微软雅黑的中文。</li>
</ul>
</li>
<li><p>解决:</p>
<ul>
<li>方案一:你可以使用英文来替代。比如font-family: “Microsoft Yahei”。</li>
<li>方案二:在CSS直接使用Unicode编码来写字体名称可以避免这些错误。使用Unicode写中文字体名称，浏览器是可以正确的解析的。</li>
</ul>
</li>
</ul>
<h4 id="font-weight"><a href="#font-weight" class="headerlink" title="font-weight"></a>font-weight</h4><ul>
<li>在html中将字体加粗我们可以用标签来实现<ul>
<li>使用b和strong标签进行文本加粗。</li>
</ul>
</li>
<li>可以使用CSS来实现，但是CSS 是没有语义的。I</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>normal</td>
<td>默认值(不加粗的)</td>
</tr>
<tr>
<td>bold</td>
<td>定义粗体(加粗的)</td>
</tr>
<tr>
<td>100~900</td>
<td>400等同于normal,而700等同于bold</td>
</tr>
</tbody>
</table>
</div>
<p>提倡:<br>    我们平时更喜欢用数字来表示加粗和不加粗。 </p>
<h4 id="font-style"><a href="#font-style" class="headerlink" title="font-style"></a>font-style</h4><ul>
<li><p>在html中将字体倾斜我们可以用标签来实现，</p>
<ul>
<li>字体倾斜可以用i和em标签。</li>
</ul>
</li>
<li><p>可以使用CSS来实现，但是CSS是没有语义的</p>
</li>
</ul>
<p>font-style属性用于定义字体风格，如设置斜体、倾斜或正常字体，其可用属性值如下:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>normal</td>
<td>默认值，浏览器会显示标准的字体样式(常用)</td>
</tr>
<tr>
<td>italic</td>
<td>浏览箭会显示斜体的字体样式。</td>
</tr>
</tbody>
</table>
</div>
<p>小技巧:<br>平时我们很少给文字加斜体，反而喜欢给斜体标签(em, i)改为普通模式。   </p>
<h4 id="font综合写法"><a href="#font综合写法" class="headerlink" title="font综合写法"></a>font综合写法</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器&#123;<span class="attribute">font</span>:font-style font-weight font-size/line-height font-family&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用font属性时，必须按上面语法格式中的顺序书写，不能更换顺序，各个属性以空格隔开。</p>
</li>
<li><p>其中不需要设置的属性可以省略(取默认值)，但必须保留font-size和font-amily属性， 否则font属性将不起作用。</p>
</li>
</ul>
<h4 id="CSS外观属性总结"><a href="#CSS外观属性总结" class="headerlink" title="CSS外观属性总结"></a>CSS外观属性总结</h4><div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>表示</th>
<th>注意点</th>
</tr>
</thead>
<tbody>
<tr>
<td>color</td>
<td>颜色</td>
<td>我们通常用十六进制比如而且是简写形式#fff</td>
</tr>
<tr>
<td>line-height</td>
<td>行高</td>
<td>控制行与行之间的距离</td>
</tr>
<tr>
<td>text-align</td>
<td>水平对齐</td>
<td>可以设定文字水平的对齐方式</td>
</tr>
<tr>
<td>text-indent</td>
<td>首行缩进</td>
<td>通常我们用于段落首行缩进2个字的距离 text-indent: 2em;</td>
</tr>
<tr>
<td>text-decoration</td>
<td>文本修饰</td>
<td>记住添加下划线underline 取消下划线none</td>
</tr>
</tbody>
</table>
</div>
<h3 id="快捷操作"><a href="#快捷操作" class="headerlink" title="快捷操作"></a>快捷操作</h3><p>1.如果想要生成多个相同标签加上*就可以了比如  div*3 就可以快速生成3个div<br>2.如果有父子级关系的标签，可以用&gt;比如ul&gt;li就可以了<br>4.如果有兄弟关系的标签，用+就可以了比如div+p<br>5.如果生成带有类名或者id名字的，直接写.demo 或者#two  tab键就可以了<br>6.如果生成的div类名是有顺序的，可以用自增符号$.</p>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><h4 id="子元素选择器"><a href="#子元素选择器" class="headerlink" title="子元素选择器"></a>子元素选择器</h4><ul>
<li>子元素选择器只能选择作为某元素子元素(亲儿子)的元素。</li>
<li>其写法就是把父级标签写在前面，子级标签写在后面，中间跟一个&gt;进行连接</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.class</span>&gt;<span class="selector-tag">h3</span>&#123;<span class="attribute">color</span>:red; <span class="attribute">font-size</span>:<span class="number">14px</span>;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="交集选择器"><a href="#交集选择器" class="headerlink" title="交集选择器"></a>交集选择器</h4><ul>
<li>交集选择器由两个选择器构成，找到的标签必须满足:既有标签1的特点， 也有标签2的特点。(不常用)</li>
</ul>
<p><img src="https://i.loli.net/2021/01/12/YI8MDdCfHBEUa9O.png" alt="image-20210112132645395"></p>
<h4 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h4><ul>
<li><p>如果某些选择器定义的相同样式，就可以利用并集选择器，可以让代码更简清。</p>
</li>
<li><p>各个标签用逗号分开,通常用于集体声明</p>
</li>
</ul>
<h4 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h4><ul>
<li><p>伪类选择器（简称：伪类）通过冒号来定义，它定义了元素的状态，如点击按下，点击完成等，通过伪类可以为元素的状态修改样式。</p>
</li>
<li><p>伪类的功能和一般的DOM中的元素样式相似，但和一般的DOM中的元素样式不一样，它并不改变任何DOM内容。只是插入了一些修饰类的元素，这些元素对于用户来说是可见的，但是对于DOM来说不可见。伪类的效果可以通过添加一个实际的类来达到。</p>
</li>
<li>类选择器是一个点,比如.demo{},而我们的伪类用2个点就是冒号,比如:link{}</li>
<li>用于向某些选挥器添加特殊的效果。比如给链接添加特殊效果，比如可以选挥第1个，第n个元素。</li>
</ul>
<h5 id="链接伪类选择器"><a href="#链接伪类选择器" class="headerlink" title="链接伪类选择器"></a>链接伪类选择器</h5><ul>
<li>a:link   /*未访问的链接*/</li>
<li>a:visited   /*已访问的链接*/</li>
<li>a:hover    /*鼠标移动到链接上*/</li>
<li>a:active    /*选定的链接*/</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li><p>写的时候，他们的顺序尽量不要颠倒,按照lvha的顺序,否则可能引起错误。</p>
</li>
<li><p>记忆法</p>
<ul>
<li><strong>l</strong>o<strong>v</strong>e <strong>ha</strong>te  爱上了讨厌</li>
<li><strong>lv</strong>包包   非常<strong>ha</strong>o</li>
</ul>
</li>
<li><p>因为a链接浏览器具有默认样式，所以我们实际工作中需要给链接单独指定样式。</p>
</li>
</ul>
<h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">标签[属性] &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>选择符</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td>E[att]</td>
<td>选择具有att属性的E元素</td>
</tr>
<tr>
<td>E[att=”val”]</td>
<td>选择具有att属性且属性值等于val的E元素</td>
</tr>
<tr>
<td>E[att^=”val”]</td>
<td>匹配具有att属性且值以val开头的E元素</td>
</tr>
<tr>
<td>E[att$=”val”]</td>
<td>匹配具有att属性且值以val结尾的E元素</td>
</tr>
<tr>
<td>E[att*=”val”]</td>
<td>匹配具有att属性且值中含有val的E元素</td>
</tr>
</tbody>
</table>
</div>
<p>类选择器、属性选择器、伪类选择器,权重为10</p>
<h4 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h4><div class="table-container">
<table>
<thead>
<tr>
<th>选择符</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td>E:first-child</td>
<td>匹配父元素中的第一个子元素E</td>
</tr>
<tr>
<td>E:last-child</td>
<td>匹配父元素中最后一个E元素</td>
</tr>
<tr>
<td>E:nth-child(n)</td>
<td>匹配父元素中的第n个子元素E</td>
</tr>
<tr>
<td>E:first-of-type</td>
<td>指定类型E的第一个</td>
</tr>
<tr>
<td>E:last-of-type</td>
<td>指定类型E的最后一个</td>
</tr>
<tr>
<td>E:nth-of-type(n)</td>
<td>指定类型E的第n个</td>
</tr>
</tbody>
</table>
</div>
<h5 id="nth-child-n"><a href="#nth-child-n" class="headerlink" title="nth-child(n)"></a>nth-child(n)</h5><ul>
<li>n可以是数字、关键字和公式</li>
<li>n如果是数字,就是选择第几个</li>
<li>常见的关键词有even(偶数)odd(奇数)</li>
<li>常见的公式如下(如果n是公式,则从0开始计算)</li>
<li>但是第0个元素或者超出了元素的个数会被忽略)</li>
<li>nth-child(n)只负责选中第几个孩子,而不管孩子的类型是否相同</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>公式</th>
<th>取值</th>
</tr>
</thead>
<tbody>
<tr>
<td>2n</td>
<td>偶数</td>
</tr>
<tr>
<td>2n+1</td>
<td>奇数</td>
</tr>
<tr>
<td>5n</td>
<td>5、10、15…</td>
</tr>
<tr>
<td>n+5</td>
<td>从第5个开始(包含第五个)到最后</td>
</tr>
<tr>
<td>-n+5</td>
<td>前5个(包含第5个)</td>
</tr>
</tbody>
</table>
</div>
<h4 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h4><div class="table-container">
<table>
<thead>
<tr>
<th>选择符</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td>::before</td>
<td>在元素内部的前面插入内容</td>
</tr>
<tr>
<td>::after</td>
<td>在元素内部的后面插入内容</td>
</tr>
</tbody>
</table>
</div>
<p>注意:</p>
<ul>
<li>before和after必须有content属性</li>
<li>before在内容的前面, after在内容的后面</li>
<li>before和after创建一个元素,但是属于行内元素</li>
<li>因为在dom里面看不见刚才创建的元素,所以我们称为伪元素</li>
<li>伪元素和标签选择器一样,权重为1</li>
</ul>
<h3 id="标签显示模式"><a href="#标签显示模式" class="headerlink" title="标签显示模式"></a>标签显示模式</h3><h4 id="块级元素-block-level"><a href="#块级元素-block-level" class="headerlink" title="块级元素(block-level)"></a>块级元素(block-level)</h4><ul>
<li><p>常见的块元素有\<h1>~\<h6>、\<p>、\<div>、\<ul>、\<ol>、\<li>等，其中\<div>标签是最典型的块元素。</p>
</li>
<li><p>块级元素的特点:</p>
<ol>
<li>比较霸道，自己独占一行</li>
<li>高度、宽度、外边距以及内边距都可以控制。</li>
<li>宽度默认是容器(父级宽度)的100%</li>
<li>是一个容器及盒子，里面可以放行内或者块级元素。</li>
</ol>
</li>
<li><p>注意:</p>
<ul>
<li>只有文字才能组成段落,因此p里面不能放块级元素，特别是p不能放div。</li>
<li>同理还有这些标签h1,h2,h3,h4,h5,h6,dt， 他们都是文字类块级标签，里面不能放其他块级元素。</li>
</ul>
</li>
</ul>
<h4 id="行内元素-inline-level"><a href="#行内元素-inline-level" class="headerlink" title="行内元素(inline-level)"></a>行内元素(inline-level)</h4><p>常见的行内元素有\<a>、\<strong>、\<b>、\<em>、\<i>、\<del>、\<s>、\<ins>、\<u>、 \<span>等， 其中\<span>标签是最典型的行内元素。有的地方也称内联元素。</p>
<ul>
<li><p>行内元素的特点:</p>
<ol>
<li>相邻行内元素在一行上，一行可以显示多个。</li>
<li>高、宽直接设置是无效的。</li>
<li>默认宽度就是它本身内容的宽度。</li>
<li>行内元素只能容纳文本或者其他行内元素。</li>
</ol>
</li>
<li><p>注意:</p>
<ol>
<li>链接里面不能再放链接。</li>
<li>特殊情况a里面可以放块级元素，但是给a转换一下块级模式最安全。</li>
</ol>
</li>
</ul>
<h4 id="行内块元素-inline-block"><a href="#行内块元素-inline-block" class="headerlink" title="行内块元素(inline-block)"></a>行内块元素(inline-block)</h4><p>在行内元素中有几个特殊的标签\<img />、\<input />、\<td>， 可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块元素。</p>
<ul>
<li>行内块元素的特点:<ol>
<li>和相邻行内元素(行内块)在一行上,但是之间会有空白缝隙,一行可以显示多个。</li>
<li>默认宽度就是它本身内容的宽度。</li>
<li>高度、行高、外边距以及内边距都可以控制。</li>
</ol>
</li>
</ul>
<h4 id="三种模式总结"><a href="#三种模式总结" class="headerlink" title="三种模式总结"></a>三种模式总结</h4><p><img src="https://i.loli.net/2021/01/12/KbigExyl5cmav6B.png" alt="image-20210112151920674"></p>
<h4 id="标签显示模式转换-display"><a href="#标签显示模式转换-display" class="headerlink" title="标签显示模式转换 display"></a>标签显示模式转换 display</h4><ul>
<li>块转行内: display: inline;</li>
<li>行内转块: display: block;</li>
<li>块、行内元素转换为行内块: display: inline-block;</li>
</ul>
<h3 id="单行文本垂直居中"><a href="#单行文本垂直居中" class="headerlink" title="单行文本垂直居中"></a>单行文本垂直居中</h3><p>行高(基线与基线的距离)我们利用最多的一个地方是:可以让单行文本在盒子中垂直居中对齐。<br><strong>文字的行高等于盒子的高度</strong>即可实现垂直对齐,可近似看作:<strong>行高=上距离+内容高度+下距离</strong></p>
<p>行高和高度的三种关系:</p>
<ul>
<li>如果行高等高度文字会重直居中</li>
<li>如果行高大于高度文字会偏下</li>
<li>如果行高小于高度文字会偏上</li>
</ul>
<h3 id="CSS背景"><a href="#CSS背景" class="headerlink" title="CSS背景"></a>CSS背景</h3><h4 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h4><p>语法:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background-color</span>: 颜色值; //默认的值是 <span class="selector-tag">transparent</span> 透明的</span><br></pre></td></tr></table></figure>
<h4 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h4><p>语法:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">background-image: none | url(url);</span><br></pre></td></tr></table></figure>
<h4 id="背景平铺"><a href="#背景平铺" class="headerlink" title="背景平铺"></a>背景平铺</h4><p>语法:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">background-repeat: repeat(默认) | no-repeat | repeat-x | repeat-y;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>repeat</td>
<td>平铺</td>
</tr>
<tr>
<td>no-repeat</td>
<td>不平铺</td>
</tr>
<tr>
<td>repeat-x</td>
<td>横向平铺</td>
</tr>
<tr>
<td>repeat-y</td>
<td>纵向平铺</td>
</tr>
</tbody>
</table>
</div>
<h4 id="背景位置"><a href="#背景位置" class="headerlink" title="背景位置"></a>背景位置</h4><p>语法:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">background-position: length || length;</span><br><span class="line">background-position: position || position;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>length</td>
<td>百分数\</td>
<td>由浮点数字和单位标识符组成的长度值</td>
</tr>
<tr>
<td>position</td>
<td>center \</td>
<td>top \</td>
<td>bottom \</td>
<td>left \</td>
<td>right 方位名词</td>
</tr>
</tbody>
</table>
</div>
<p>注意:</p>
<ul>
<li>必须先指定background-image属性</li>
<li>position后面是x坐标和y坐标，可以使用方位名词或者精确单位。</li>
<li>如果只指定了一个方位名词，另一个值默认居中，为50%。</li>
<li>如果只指定一个数值,那该数值用于x坐标，另一个默认是y坐标，默认居中</li>
<li>如果指定两个值，两个值都是方位名字，则两个值前后顺序无关，比如left top和top left效果一致</li>
<li>如果指定两个值，精确单位和方位名字混合使用，则第一个值是x坐标，第二个值是y坐标</li>
</ul>
<h4 id="背景附着"><a href="#背景附着" class="headerlink" title="背景附着"></a>背景附着</h4><p>背景附着就是背景是滚动还是固定的</p>
<p>语法:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">background-attachment: scroll | fixed;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>scroll</td>
<td>背景图像随对象内容滚动</td>
</tr>
<tr>
<td>fixed</td>
<td>背景图像固定</td>
</tr>
</tbody>
</table>
</div>
<h4 id="背景简写"><a href="#背景简写" class="headerlink" title="背景简写"></a>背景简写</h4><p>背景简写和字体简写不同的是背景简写没有强制要求,建议按下面方式写 </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>:背景颜色 背景图片地址 背景平铺 背景滚动 背景位置;</span><br></pre></td></tr></table></figure>
<h4 id="背景透明"><a href="#背景透明" class="headerlink" title="背景透明"></a>背景透明</h4><p>语法:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">rgba</span>(0, 0，0，0.3);</span><br></pre></td></tr></table></figure>
<ul>
<li>最后一个参数是alpha透明度取值范围0~1之间</li>
<li>我们习惯把0.3的0省略掉这样写background: rgba(0, 0, 0, .3);</li>
<li>注意:背景半透明是指盒子背景半透明，盒子里面的内容不受影响</li>
<li>因为是CSS3,所以低于ie9的版本是不支持的。</li>
</ul>
<h3 id="CSS三大特性"><a href="#CSS三大特性" class="headerlink" title="CSS三大特性"></a>CSS三大特性</h3><h4 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h4><p>概念:</p>
<ul>
<li>所谓层叠性是指多种CSS样式的叠加。是浏览器处理冲突的一个能力，如果一个属性通过两个相同选择器设置到同一个元素上,那么这个时候一个属性就会将另一 个属性层叠掉</li>
</ul>
<p>原则: </p>
<ul>
<li>样式冲突,遵循的原则是就近原则.那个样式离结构近,就执行那个样式</li>
<li>样式不冲突,不会层叠</li>
</ul>
<h4 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h4><p>概念:</p>
<ul>
<li>子标签会继承父标签的某些样式，如文本颜色和字号。</li>
<li>想要设置一个可继承的属性，只需将它应用于父元素即可。</li>
</ul>
<p>注意:</p>
<ul>
<li>恰当地使用继承可以简化代码，降低CSS样式的复杂性。比如有很多子级孩子都需要某个样式，可以给父级指定一个，这些孩子继承过来就好了</li>
<li>子元素可以继承父元素的样式(text-, font-, line-这些元素开头的可以继承，以及color属性)</li>
</ul>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>定义CSS样式时，经常出现两个或更多规则成用在同一元素上，此时，</p>
<ul>
<li>选择器相同，则执行层叠性</li>
<li>选择器不同，就会出现优先级的问题。</li>
</ul>
<p>权重计算公式:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标签选择器</th>
<th>权重</th>
</tr>
</thead>
<tbody>
<tr>
<td>继承或 *</td>
<td>0,0,0,0</td>
</tr>
<tr>
<td>元素(标签选择器)</td>
<td>0,0,0,1</td>
</tr>
<tr>
<td>类,伪类,属性</td>
<td>0,0,1,0</td>
</tr>
<tr>
<td>ID</td>
<td>0,1,0,0</td>
</tr>
<tr>
<td>行内样式 style=””</td>
<td>1,0,0,0</td>
</tr>
<tr>
<td>!important</td>
<td>∞ 无穷大</td>
</tr>
</tbody>
</table>
</div>
<p><strong>继承的权重为0</strong></p>
<p>我们修改样式，一 定要看该标签有没有被选中。</p>
<ol>
<li>如果选中了,那么以上面的公式来计权重.</li>
<li>如果没有选中,那么权重是0,因为继承的权重为0.</li>
</ol>
<h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p>盒子模型由内容、边框(border) 、内边距(padding) 、和外边距(margin) 组成。</p>
<h4 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h4><p>语法:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">border: border-width(宽度) | border-style(样式) | border-color(颜色)</span><br></pre></td></tr></table></figure>
<p>边框样式:</p>
<ul>
<li><strong>none :</strong> 　无边框。 </li>
<li><strong>dotted :</strong>  点线 </li>
<li><strong>dashed :</strong>  虚线</li>
<li><strong>solid :</strong> 实线</li>
</ul>
<p>边框简写:</p>
<p>无顺序,一般按宽度,样式,颜色顺序写.各边可分别指定样式.</p>
<p>表格的细线边框:</p>
<ul>
<li><p>通过表格的cellspacing=”0”,将单元格与单元格之间的距离设置为0，</p>
</li>
<li><p>但是两个单元格之间的边框会出现重叠，从而使边框变粗</p>
</li>
<li><p>通过css属性:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">table</span>&#123; <span class="attribute">border-collapse</span>:collapse; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>collapse 单词是合并的意思.</li>
<li>border-collapse:collapse;表示相邻边框合并在一起.</li>
</ul>
</li>
</ul>
<p><strong>盒子实际大小=内容的宽度(高度)+内边距+边框</strong></p>
<p>内边距不影响盒子大小的情况:</p>
<p>如果盒子没有宽度(高度),则padding不会撑开盒子.</p>
<h4 id="文字居中和盒子居中的区别"><a href="#文字居中和盒子居中的区别" class="headerlink" title="文字居中和盒子居中的区别"></a>文字居中和盒子居中的区别</h4><ol>
<li>文字水平居中是text-align: center,而且还可以让行内元素和行内块居中对齐</li>
<li>块级盒子水平居中,左右margin改为auto</li>
</ol>
<h4 id="插入图片和背景图片的区别"><a href="#插入图片和背景图片的区别" class="headerlink" title="插入图片和背景图片的区别"></a>插入图片和背景图片的区别</h4><ol>
<li>插入图片我们用的最多比如产品展示类移动位置只能靠盒模型padding margin</li>
<li>背票图片我们一 般用于小图标背景或者超大背景图片背景图片只能通过background-position</li>
</ol>
<h4 id="清除元素默认的内外边距"><a href="#清除元素默认的内外边距" class="headerlink" title="清除元素默认的内外边距"></a>清除元素默认的内外边距</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123;<span class="attribute">padding</span>:<span class="number">0</span>;<span class="attribute">margin</span>:<span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>注意:</p>
<ul>
<li>行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下内外边距。</li>
</ul>
<h4 id="外边距的合并"><a href="#外边距的合并" class="headerlink" title="外边距的合并"></a>外边距的合并</h4><p>使用margin定义块元素的垂直外边距时，可能会出现外边距的合并。<br>(1).相邻块元素垂直外边距的合并</p>
<ul>
<li>当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom</li>
<li>下面的元素有上外边距margin-top,则他们之间的垂直间距不是margin-bottom与margin-top之和</li>
<li>取两个值中的较大者这种现象被称为相邻块元素垂直外边距的合并(也称外边距塌陷)。</li>
</ul>
<p>(2).嵌套块元素垂直外边距的合并(塌陷)</p>
<ul>
<li>对于两个嵌套关系的块元素，如果父元素没有上内边距及边框</li>
<li>父元素的上外边距会与子元素的上外边距发生合并</li>
<li>合并后的外边距为两者中的较大者</li>
</ul>
<p>解决方案:<br>1.可以为父元素定义上边框<br>2.可以为父元索定义上内边距<br>3.可以为父元素添加overflow:hidden</p>
<h4 id="盒子模型布局稳定性"><a href="#盒子模型布局稳定性" class="headerlink" title="盒子模型布局稳定性"></a>盒子模型布局稳定性</h4><p>问题:什么情况下用内边距，什么情况下用外边距?<br>大部分情况下是可以混用的。 就是说，你用内边距也可以，用外边距也可以。<br>我们根据稳定性来分，建议如下:<br>按照优先便用宽度(width) ,其次使用内边距(padding),再次外边距(margin)。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">width</span> &gt; <span class="selector-tag">padding</span> &gt; <span class="selector-tag">margin</span></span><br></pre></td></tr></table></figure>
<p>原因:</p>
<ul>
<li>margin 会有外边距合并还有IE6下面margin加倍的bug ,所以最后使用</li>
<li>padding 会影响盒子大小，需要进行加减计算,其次使用</li>
<li>width 我们经常使用宽度剩余法,高度剩余法来做</li>
</ul>
<h3 id="CSS书写规范"><a href="#CSS书写规范" class="headerlink" title="CSS书写规范"></a>CSS书写规范</h3><h4 id="空格规范"><a href="#空格规范" class="headerlink" title="空格规范"></a>空格规范</h4><ol>
<li>选择器与{之间必须包含空格</li>
<li>属性名与之后的:之间不允许包含空格，:与属性值之间必须包含空格</li>
</ol>
<h4 id="选择器规范"><a href="#选择器规范" class="headerlink" title="选择器规范"></a>选择器规范</h4><ul>
<li><p>并集选择器，每个选择器声明独占一行</p>
</li>
<li><p>一般情况下，选择器的嵌套层级应不大于3级，位置靠后的限定条件应尽可能精确</p>
</li>
</ul>
<h4 id="属性规范"><a href="#属性规范" class="headerlink" title="属性规范"></a>属性规范</h4><ul>
<li>属性定义必须另起行</li>
<li>属性定义后必须以分号结尾</li>
</ul>
<h3 id="CSS布局的三种机制"><a href="#CSS布局的三种机制" class="headerlink" title="CSS布局的三种机制"></a>CSS布局的三种机制</h3><p>CSS提供了3种机制来设置盒子的摆放位置，分别是普通流(标准流)、浮动和定位，其中:<br>1.普通流(标准流)</p>
<ul>
<li><p>块级元素会独占一行，从上向下顺序排列;</p>
<ul>
<li>常用元素: div、hr、p、h1-h6、ul、ol、dl、form、table</li>
</ul>
</li>
<li><p>行内元索会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行;</p>
<ul>
<li>常用元素: span、a、i、em等</li>
</ul>
</li>
</ul>
<p>2.浮动</p>
<ul>
<li>让盒子从普通流中浮起来,主要作用让多个块级盒子一行显示。</li>
</ul>
<p>3.定位</p>
<ul>
<li>将盒子定在浏览器的某一个位置，CSS离不开定位，特别是后面的js特效。</li>
</ul>
<h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><p>问题:如何将多个盒子(div)水平排列成一行?如何实现盒子靠左靠右对齐?</p>
<p>如果将div转为inline-block可以达到将多个盒子(div)水平排列成一行,但是盒子之间有空隙,且非常难去掉,即使能去掉兼容性极差.无法靠左靠右对齐.</p>
<p>概念:元素的浮动是指设置了浮动属性的元素会</p>
<ol>
<li>脱离标准普通流的控制</li>
<li>移动到指定位置。</li>
</ol>
<p>作用:</p>
<ol>
<li>让多个盒子(div)水平排列成一行，使得浮动成为布局的重要手段。</li>
<li>可以实现盒子的左右对齐等等…</li>
<li>浮动最早是用来控制图片，实现文字环绕图片的效果。</li>
</ol>
<h4 id="清除浮动的本质"><a href="#清除浮动的本质" class="headerlink" title="清除浮动的本质:"></a>清除浮动的本质:</h4><p>清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0的问题。清除浮动之后，父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了。</p>
<h4 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法:"></a>清除浮动的方法:</h4><p>在CSS中，clear属性用于清除浮动，<br>语法:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器&#123;<span class="attribute">clear</span>:属性值;&#125; <span class="selector-tag">clear</span> 清除</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>left</td>
<td>不允许左侧有浮动元素(清除左侧浮动的影响)</td>
</tr>
<tr>
<td>right</td>
<td>不允许右侧有浮动元素(清除右侧浮动的影响)</td>
</tr>
<tr>
<td>both</td>
<td>同时清除左右两侧浮动的影响</td>
</tr>
</tbody>
</table>
</div>
<p>实际工作几乎只用clear:both;</p>
<h5 id="1-额外标签法-隔墙法"><a href="#1-额外标签法-隔墙法" class="headerlink" title="1.额外标签法(隔墙法)"></a>1.额外标签法(隔墙法)</h5><p>在浮动元表末尾添加一个空的标签例如\<div style:"clear:both">\&lt;/d1v&gt;, 或者其他标签br等</p>
<ul>
<li>优点:通俗易懂，书写方便</li>
<li>缺点:添加许多无意义的标签,结构化较差</li>
</ul>
<h5 id="2-父级添加overflow属性方法"><a href="#2-父级添加overflow属性方法" class="headerlink" title="2.父级添加overflow属性方法"></a>2.父级添加overflow属性方法</h5><figure class="highlight"><table><tr><td class="code"><pre><span class="line">overflow:hidden | auto |scroll(均可清除浮动)</span><br></pre></td></tr></table></figure>
<ul>
<li>优点:代码简洁</li>
<li>缺点:内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素(溢出隐藏)</li>
</ul>
<h5 id="3-使用after伪元素清除浮动"><a href="#3-使用after伪元素清除浮动" class="headerlink" title="3.使用after伪元素清除浮动"></a>3.使用after伪元素清除浮动</h5><p>:after方式为空元素额外标签法的升级版,好处是不用单独加标签了<br>使用方法:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123; </span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block; </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>; </span><br><span class="line">    <span class="attribute">clear</span>: both; </span><br><span class="line">    <span class="attribute">visibility</span>: hidden; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">    <span class="attribute">*zoom</span>: <span class="number">1</span>;</span><br><span class="line">&#125; <span class="comment">/* IE6、7专门清除浮动*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>优点:符合闭合浮动思想结构语义化正确</li>
<li>缺点:由于IE6-7不支持:after, 使用*zoom:1触发hasLayout</li>
<li>代表网站:百度、沟宝网、网易等</li>
</ul>
<h5 id="4-使用双伪元素清除浮动"><a href="#4-使用双伪元素清除浮动" class="headerlink" title="4.使用双伪元素清除浮动"></a>4.使用双伪元素清除浮动</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:before</span>,<span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">	<span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="attribute">display</span>:table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">	<span class="attribute">clear</span>:both;</span><br><span class="line">]</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">	<span class="attribute">*zoom</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>优点:代码更简洁</li>
<li>缺点:由于IE6-7不支持:after, 使用zoom:1触发hasLayout</li>
<li>代表网站:小米，腾讯等</li>
</ul>
<h3 id="PS知识"><a href="#PS知识" class="headerlink" title="PS知识"></a>PS知识</h3><p>常见图片格式:</p>
<ol>
<li>jpg图像格式:<br>JPEG (.JPG) 对色彩的信息保留较好，高清，颜色较多，我们产品类的图片经常用jpg格式的</li>
<li>gif图像格式:<br>GIF格式最多只能储存256色，所以通常用来显示简单图形及字体，但是可以保存透明背景和动画效果</li>
<li>png图像格式<br>是一种新兴的网络图形格式，结合了GIF和JPEG的优点，具有存储形式丰富的特点，能够保持透明背景</li>
<li>PSD图像格式<br>PSD格式是Photoshop的专用格式，里面可以存放图层、通道、遮罩等多种设计草稿</li>
</ol>
<h3 id="CSS属性书写顺序"><a href="#CSS属性书写顺序" class="headerlink" title="CSS属性书写顺序"></a>CSS属性书写顺序</h3><p>建议遵循以下顺序:</p>
<ol>
<li>布局定位属性: display/position/ float/clear /visbility/overflow (建议display第一个写,毕竟关系到模式)</li>
<li>自身属性: width/height/ margin/padding/border/background</li>
<li>文本属性: color/font/text-decoration/tex-align/vertial-align/white- space/break-word</li>
<li>其他属性(CSS3) : content/cursor/border-radius/box-shadow/text-shadow/ background:linear-gradient</li>
</ol>
<h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>定位的盒子会压住标准流和浮动的盒子</p>
<p>定位=定位模式+边偏移</p>
<h4 id="定位模式"><a href="#定位模式" class="headerlink" title="定位模式"></a>定位模式</h4><div class="table-container">
<table>
<thead>
<tr>
<th>值</th>
<th>语义</th>
</tr>
</thead>
<tbody>
<tr>
<td>static</td>
<td>静态定位</td>
</tr>
<tr>
<td>relative</td>
<td>相对定位(不脱标)</td>
</tr>
<tr>
<td>absolute</td>
<td>绝对定位(脱标)</td>
</tr>
<tr>
<td>flxed</td>
<td>固定定位(脱标)</td>
</tr>
</tbody>
</table>
</div>
<h4 id="绝对定位的居中对齐"><a href="#绝对定位的居中对齐" class="headerlink" title="绝对定位的居中对齐"></a>绝对定位的居中对齐</h4><p>绝对定位或者固定定位的盒子不能通过设置margin: auto设置水平居中。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">left</span>: 50%;</span><br><span class="line"><span class="selector-tag">margin-left</span>: <span class="selector-tag">-</span>(自己宽度一半);</span><br></pre></td></tr></table></figure>
<h4 id="堆叠顺序"><a href="#堆叠顺序" class="headerlink" title="堆叠顺序"></a>堆叠顺序</h4><p>在使用定位布局时，可能会出现<strong>盒子重叠</strong>的情况.加了定位的盒子，默认<strong>后来者居上</strong>，后面的盒子会压住前面的盒子。应用z-index层叠等级属性可以调整盒子的堆叠顺序。</p>
<p>z-index的特性:</p>
<p>1.属性值:正整数、负整数或0,默认值是0,数值越大,盒子越靠上<br>2.如果属性值相同,则按照书写顺序,后来居上<br>3.数宇后面不能加单位<br>注意: z-index只能应用于相对定位、绝对定位和固定定位的元素，其他标准流、浮动和静态定位无效。</p>
<h4 id="定位改变display属性"><a href="#定位改变display属性" class="headerlink" title="定位改变display属性"></a>定位改变display属性</h4><p>display 是显示模式，可以改变显示模式有以下方式</p>
<ul>
<li>可以用inline-block 转换为行内块</li>
<li>可以用浮动float默认转换为行内块(类似，并不完全一样，因为浮动是脱标的)</li>
<li>绝对定位和固定定位也和浮动类似， 默认转换的特性转换为行内块</li>
</ul>
<p>所以说，一个行内的盒子，如果加了浮动、固定定位和绝对定位，不用转换，就可以给这个盒子直接设置宽度和高度等。<br>同时注意:<br>浮动元素、绝对定位元素的都不会触发外边距合并的问题。(我们以前是用padding border overflow解决的)<br>也就是说，我们给盒子改为了浮动或者定位，就不会有垂直外边距合并的问题了。</p>
<h3 id="元素的显示与隐藏"><a href="#元素的显示与隐藏" class="headerlink" title="元素的显示与隐藏"></a>元素的显示与隐藏</h3><h4 id="display显示"><a href="#display显示" class="headerlink" title="display显示"></a>display显示</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">display:none;   隐藏对象</span><br><span class="line">display:block;  除了转换为块级元素之外,同时还有显示元素的意思</span><br></pre></td></tr></table></figure>
<p>特点:隐藏之后不再保留位置</p>
<h4 id="visibility可见性"><a href="#visibility可见性" class="headerlink" title="visibility可见性"></a>visibility可见性</h4><p>设置或检索是否显示对象</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">viaibility: visable;  对象可见</span><br><span class="line">visibility: hidden;   对象隐藏</span><br></pre></td></tr></table></figure>
<p>特点:隐藏之后继续保留位置</p>
<h4 id="overflow溢出"><a href="#overflow溢出" class="headerlink" title="overflow溢出"></a>overflow溢出</h4><p>检索或设置当对象的内容超过其指定高度及竞度时如何管理内容。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>visible</td>
<td>不剪切内容也不添加滚动条</td>
</tr>
<tr>
<td>hidden</td>
<td>不显示超过对象尺寸的内容,超出的部分隐藏掉(溢出隐藏)</td>
</tr>
<tr>
<td>scroll</td>
<td>不管是否超出内容,总是显示滚动条</td>
</tr>
<tr>
<td>auto</td>
<td>超出自动显示滚动条,不超出不显示滚动条</td>
</tr>
</tbody>
</table>
</div>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>区别</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>display</td>
<td>隐藏对象,不保留位置</td>
<td>配合后面JS做特效,比如下拉菜单,原先没有,鼠标经过,显示下拉菜单,应用极为广泛</td>
</tr>
<tr>
<td>visipility</td>
<td>隐藏对象,保留位置</td>
<td>使用较少</td>
</tr>
<tr>
<td>overflow</td>
<td>只是隐藏超出大小的部分</td>
<td>1.可以清除浮动2.保证盒子里面的内容不会超出该盒子范围</td>
</tr>
</tbody>
</table>
</div>
<h3 id="CSS用户界面样式"><a href="#CSS用户界面样式" class="headerlink" title="CSS用户界面样式"></a>CSS用户界面样式</h3><p>所谓的界面样式,就是更改一些用户操作样式，</p>
<ul>
<li>更改用户的鼠标样式(滚动条兼容性较差,暂不考虑)</li>
<li>表单轮廓等</li>
<li>防止表单域拖拽</li>
</ul>
<h4 id="鼠标样式cursor"><a href="#鼠标样式cursor" class="headerlink" title="鼠标样式cursor"></a>鼠标样式cursor</h4><p>设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>default</td>
<td>默认</td>
</tr>
<tr>
<td>pointer</td>
<td>手形</td>
</tr>
<tr>
<td>move</td>
<td>移动</td>
</tr>
<tr>
<td>text</td>
<td>文本</td>
</tr>
<tr>
<td>not-allowed</td>
<td>禁止</td>
</tr>
</tbody>
</table>
</div>
<h4 id="轮廓线outline"><a href="#轮廓线outline" class="headerlink" title="轮廓线outline"></a>轮廓线outline</h4><p>轮廓线是绘制于元素周围的一条线,位于边框边缘的外围,可起到突出元素的作用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">outline: outline-color || outline-style || outline-width</span><br></pre></td></tr></table></figure>
<p>但是一般都是去掉的,最直接的写法是: outline: 0; 或者outline: none;</p>
<h4 id="防止拖拽文本域resize"><a href="#防止拖拽文本域resize" class="headerlink" title="防止拖拽文本域resize"></a>防止拖拽文本域resize</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;textarea style=&quot;resize:none;&quot;&gt;&lt;/textarea&gt;</span><br></pre></td></tr></table></figure>
<h4 id="用户界面样式总结"><a href="#用户界面样式总结" class="headerlink" title="用户界面样式总结"></a>用户界面样式总结</h4><div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>用途</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>鼠标样式</td>
<td>更改鼠标样式cursor</td>
<td>样式很多,重点记住pointer</td>
</tr>
<tr>
<td>轮廓线</td>
<td>表单默认outline</td>
<td>outline轮廊线,我们一般直接去掉,border是边框,我们会经常用</td>
</tr>
<tr>
<td>防止拖拽</td>
<td>主要针对文本域resize</td>
<td>防止用户随意拖拽文本域,造成页面布局混乱,我们resize:none;</td>
</tr>
</tbody>
</table>
</div>
<h4 id="vertical-align垂直对齐"><a href="#vertical-align垂直对齐" class="headerlink" title="vertical-align垂直对齐"></a>vertical-align垂直对齐</h4><ul>
<li>有宽度的块级元素居中对齐,是margin: 0 auto;</li>
<li>让文字居中对齐,是text-align: center;</li>
<li>vertical-align垂直对齐,它只针对于行内元素或者行内块元素</li>
<li>通常用来控制图片/表单与文字的对齐</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vertical-align:baseline|top|middle|bottom;</span><br></pre></td></tr></table></figure>
<h4 id="去除图片底侧空白缝隙"><a href="#去除图片底侧空白缝隙" class="headerlink" title="去除图片底侧空白缝隙"></a>去除图片底侧空白缝隙</h4><p>原因:</p>
<ul>
<li>图片或者表单等行内块元素,它的底线会和父级盒子的基线对齐,就是图片底侧会有一个空白缝隙</li>
</ul>
<p>解决的方法就是:</p>
<ul>
<li>给img vertical-align:middle | top等等.让图片不要和基线对齐</li>
<li>将图片转换为block</li>
</ul>
<h4 id="溢出的文字省略号显示"><a href="#溢出的文字省略号显示" class="headerlink" title="溢出的文字省略号显示"></a>溢出的文字省略号显示</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*1.强制一行内显示文本*/</span></span><br><span class="line"><span class="selector-tag">white-space</span>: <span class="selector-tag">nowrap</span>;</span><br><span class="line"><span class="comment">/*2.超出的部分隐藏*/</span></span><br><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br><span class="line"><span class="comment">/*3.文字用省略号替代代超出的部分*/</span></span><br><span class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">ellipsis</span>;</span><br></pre></td></tr></table></figure>
<h5 id="white-space"><a href="#white-space" class="headerlink" title="white-space"></a>white-space</h5><p>white-space设置或检索对象内文本显示方式.通常我们使用于强制一行显示内容</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">white-space</span><span class="selector-pseudo">:normal</span>;   //默认处理方式,显示不开自动换行</span><br><span class="line"><span class="selector-tag">white-space</span><span class="selector-pseudo">:nowrap</span>;   //强制在同一行内显示所有文本,直到文本结束或者遭遇<span class="selector-tag">br</span>标签对象才换行</span><br></pre></td></tr></table></figure>
<h5 id="text-overflow文字溢出"><a href="#text-overflow文字溢出" class="headerlink" title="text-overflow文字溢出"></a>text-overflow文字溢出</h5><p>设置或检索是否使用一个省略标记(…)标示对象内文本的溢出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">text-overflow:clip;   不显示省略标记(...)而是简单的裁切</span><br><span class="line">text-overflow:ellipsis; 当对象内文本溢出时,显示省略标记(...)</span><br></pre></td></tr></table></figure>
<h3 id="CSS精灵技术-sprite"><a href="#CSS精灵技术-sprite" class="headerlink" title="CSS精灵技术(sprite)"></a>CSS精灵技术(sprite)</h3><p>为了有效地减少服务器接受和发送请求的次数,提高页面的加载速度.</p>
<p>CSS精灵其实是将网页中的一些背景图像整合到一张大图中(精灵图) ,然而,各个网页元素通常只需要精灵图中不同位置的某个小图,要精确定位到精灵图中的某个小图.</p>
<p>利用background-position来精准定位.</p>
<h3 id="滑动门"><a href="#滑动门" class="headerlink" title="滑动门"></a>滑动门</h3><p>为了使各种特殊形状的背景能够自适应元素中文本内容的多少,出现了CSS滑动门技术.它从新的角度构建页面,使各种特殊形状的背景能够自由拉伸滑动,以适应元素内部的文本内容,可用性更强.最常见于各种导航栏的滑动门.</p>
<p>核心技术就是利用CSS精灵(主要是背景位置)和盒子padding撑开宽度,以便能适应不同字数的导航栏.</p>
<ol>
<li>a设置背景左侧,padding撑开合适宽度</li>
<li>span设置背景右侧,padding撑开合适宽度,剩下由文字继续撑开</li>
<li>之所以a包含span就是因为整个导航都是可以点击的</li>
<li>a和span都要转换为行内块(因为是滑动门,左右推拉,跟文字内容多少有关系,此时需要用文字撑开盒子, 就要用到行内块)</li>
</ol>
<h3 id="2D转换"><a href="#2D转换" class="headerlink" title="2D转换"></a>2D转换</h3><h4 id="2D移动"><a href="#2D移动" class="headerlink" title="2D移动"></a>2D移动</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translate</span>(<span class="selector-tag">x</span>,<span class="selector-tag">y</span>); </span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateX</span>(<span class="selector-tag">n</span>);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateY</span>(<span class="selector-tag">n</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>定义2D转换中的移动,沿着X和Y轴移动元素</li>
<li>translate最大的优点:不会影响到其他元素的位置</li>
<li>translate中的百分比单位是相对于自身元素的translate(50%,50%);</li>
<li>对行内标签没有效果</li>
</ul>
<h4 id="2D旋转"><a href="#2D旋转" class="headerlink" title="2D旋转"></a>2D旋转</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transform</span><span class="selector-pseudo">:rotate(</span>度数);</span><br></pre></td></tr></table></figure>
<ul>
<li>rotate里面跟度数,单位是deg,比如rotate(45deg)</li>
<li>角度为正时,为顺时针;负时,为逆时针</li>
<li>默认旋转的中心点是元素的中心点</li>
</ul>
<h4 id="2D转换中心点"><a href="#2D转换中心点" class="headerlink" title="2D转换中心点"></a>2D转换中心点</h4><p>设置元素转换的中心点</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transfrom-origin</span>: <span class="selector-tag">x</span> <span class="selector-tag">y</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意后面的参数x和y用空格隔开</li>
<li>x,y默认转换的中心点是元素的中心点(50% 50%)</li>
<li>还可以给x,y设置像素或者方位名词( top,bottom,left,right,center )</li>
</ul>
<h4 id="2D缩放"><a href="#2D缩放" class="headerlink" title="2D缩放"></a>2D缩放</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transfrom</span>: <span class="selector-tag">scale</span>(<span class="selector-tag">x</span>,<span class="selector-tag">y</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>注意其中的x和y用逗号分隔</li>
<li>transform:scale(1,1) :宽和高都放大一倍,相对于没有放大</li>
<li>transform:scale(2,2) : 宽和高都放大了2倍</li>
<li>transform:scale(2) : 只写一个参数,第二个参数则和第一个参数一样,相当于scale(2,2)</li>
<li>transform:scale(0.5,0.5) :缩小</li>
<li>sacle缩放最大的优势:可以设置转换中心点缩放,默认以中心点缩放的,而且不影响其他盒子</li>
</ul>
<h4 id="2D转换综合写法"><a href="#2D转换综合写法" class="headerlink" title="2D转换综合写法"></a>2D转换综合写法</h4><ol>
<li>同时使用多个转换,其格式为: transform: translate() rotate() scale()等</li>
<li>其顺序会影转换的效果(先旋转会改变坐标轴方向)</li>
<li>当我们同时有位移和其他属性的时候,记得要将位移放到最前</li>
</ol>
<h3 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h3><p>动画(animation)是CSS3中具有颠覆性的特征之一, 可通过设置多个节点来精确控制一个或一组动画,常用来实现复杂的动画效果.<br>相比较过渡,动画可以实现更多变化,更多控制,连续自动播放等效果.</p>
<h4 id="动画的基本使用"><a href="#动画的基本使用" class="headerlink" title="动画的基本使用"></a>动画的基本使用</h4><ol>
<li>定义动画</li>
<li>调用动画</li>
</ol>
<h5 id="用keyframes定义动画"><a href="#用keyframes定义动画" class="headerlink" title="用keyframes定义动画"></a>用keyframes定义动画</h5><p>(类似定义类选择器)</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> 动画名称 &#123;</span><br><span class="line">    0%&#123;</span><br><span class="line">        <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    100%&#123;</span><br><span class="line">        <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="动画序列"><a href="#动画序列" class="headerlink" title="动画序列"></a>动画序列</h5><ul>
<li>0%是动画的开始,100%是动画的完成,这样的规则就是动画序列</li>
<li>在@keyframes中规定某项CSS样式,就能创建由当前样式逐渐改为新样式的动画效果</li>
<li>动画是使元素从一种样式逐渐变化为另一种样式的效果,可以改变任意多的样式任意多的次数</li>
<li>用百分比来规定变化发生的时间,或用关键词”from”和”to”,等同于0%和100%</li>
</ul>
<h5 id="调用动画"><a href="#调用动画" class="headerlink" title="调用动画"></a>调用动画</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">animation-name</span>: 动画名称;</span><br><span class="line">    <span class="attribute">animation-duration</span>: 持续时间;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="动画常用属性"><a href="#动画常用属性" class="headerlink" title="动画常用属性"></a>动画常用属性</h5><div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>@keyframes</td>
<td>规定动画</td>
</tr>
<tr>
<td>animation</td>
<td>所有动画属性的简写属性,除了animation-play-state属性</td>
</tr>
<tr>
<td>animation-name</td>
<td>规定@keyframes动画的名称(必须的)</td>
</tr>
<tr>
<td>animation-duration</td>
<td>规定动画完成一个周期所花费的秒或亳秒 ,默认是0(必须的)</td>
</tr>
<tr>
<td>animation-timing-function</td>
<td>规定动画的速度曲线,默认是”ease”</td>
</tr>
<tr>
<td>animation-delay</td>
<td>规定动画何时开始,默认是0</td>
</tr>
<tr>
<td>animation-iteration-count</td>
<td>规定动画被播放的次数,默认是1,还有infinite(无限)</td>
</tr>
<tr>
<td>animation-direction</td>
<td>规定动画是否在下一周期逆向播放,默认是”normal”,alternate逆播放</td>
</tr>
<tr>
<td>animation-play-state</td>
<td>规定动画是否正在运行或暂停,默认是”running”,还有”paused”</td>
</tr>
<tr>
<td>animation-fill-mode</td>
<td>规定动画结束后状态,保持forwards 回到起始backwards</td>
</tr>
</tbody>
</table>
</div>
<h6 id="速度曲线"><a href="#速度曲线" class="headerlink" title="速度曲线"></a>速度曲线</h6><p>animation-timing-function:规定动画的速度曲线,默认是”ease”</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>linear</td>
<td>动画从头到尾的速度是相同的,匀速</td>
</tr>
<tr>
<td>ease</td>
<td>默认,动画以低速开始,然后加快,在结束前变慢</td>
</tr>
<tr>
<td>ease-in</td>
<td>动画以低速开始</td>
</tr>
<tr>
<td>ease-out</td>
<td>动画以低速结束</td>
</tr>
<tr>
<td>ease-in-out</td>
<td>动画以低速开始和结束</td>
</tr>
<tr>
<td>steps()</td>
<td>指定了时间函数中的间隔数量(步长)</td>
</tr>
</tbody>
</table>
</div>
<h5 id="动画简写"><a href="#动画简写" class="headerlink" title="动画简写"></a>动画简写</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">animation</span>:动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 动画起始或者结束的状态;</span><br><span class="line"><span class="comment">/*动画名称和持续时间必须写*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>简写属性里面不包含animation-play-state</li>
<li>暂停动画: animation-play-state: puased; 经常和鼠标经过等其他配合使用</li>
<li>想要动画走回来,而不是直接跳回来: animation-direction: alternate;</li>
<li>盒子动画结束后,停在结束位置: animation-fill-mode: forwards;</li>
</ul>
<h3 id="3D转换"><a href="#3D转换" class="headerlink" title="3D转换"></a>3D转换</h3><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="JavaScript概述"><a href="#JavaScript概述" class="headerlink" title="JavaScript概述"></a>JavaScript概述</h3><ul>
<li>JavaScript是世界上最流行的语言之一, 是一种运行在<strong>客户端</strong>的脚本语言( Script是脚本的意思)</li>
<li>脚本语言:不需要编译,运行过程中由js解释器(js引擎)逐行来进行解释并执行</li>
<li>现在也可以基于Node.js技术进行服务器端编程</li>
</ul>
<h3 id="JavaScript作用"><a href="#JavaScript作用" class="headerlink" title="JavaScript作用"></a>JavaScript作用</h3><ul>
<li>表单动态校验(密码强度检测) ( JS 产生最初的目的)</li>
<li>网页特效</li>
<li>服务端开发(Node.js)</li>
<li>桌面程序(Electron)</li>
<li>App(Cordova)</li>
<li>控制硬件-物联网(Ruff)</li>
<li>游戏开发(cocos2d-js)</li>
</ul>
<h3 id="HTML-CSS-JS的关系"><a href="#HTML-CSS-JS的关系" class="headerlink" title="HTML/CSS/JS的关系"></a>HTML/CSS/JS的关系</h3><p><strong>HTML/CSS标记语言—描述类语言</strong></p>
<ul>
<li>HTML决定网页结构和内容(决定看到什么) ,相当于人的身体</li>
<li>CSS 决定网页呈现给用户的模样(决定好不好看)，相当于给人穿衣服、化妆</li>
</ul>
<p><strong>JS脚本语言—编程类语言</strong></p>
<ul>
<li>实现业务逻辑和页面控制(决定功能) ,相当于人的各种动作</li>
</ul>
<h3 id="浏览器执行JS简介"><a href="#浏览器执行JS简介" class="headerlink" title="浏览器执行JS简介"></a>浏览器执行JS简介</h3><p>浏览器分成两部分:渲染引擎和JS引擎</p>
<ul>
<li>渲染引擎:用来解析HTML与CSS ,俗称内核，比如chrome浏览器的blink ,老版本的webkit</li>
<li>JS引擎:也称为JS解释器。 用来读取网页中的JavaScript代码,对其处理后运行,比如chrome浏览器的V8</li>
</ul>
<p>浏览器本身并不会执行JS代码,而是通过内置JavaScript引擎(解释器)来执行JS代码。JS 引擎执行代码时逐行解释每一句源码(转换为机器语言) , 然后由计算机去执行,所以JavaScript语言归为脚本语言,会逐行解释执行。</p>
<h3 id="JS的组成"><a href="#JS的组成" class="headerlink" title="JS的组成"></a>JS的组成</h3><p><img src="https://i.loli.net/2021/01/22/U6JwymbY3egkIWt.png" alt=""></p>
<p>1.ECMAScript<br>ECMAScript是由ECMA国际(原欧洲计算机制造商协会)进行标准化的一门编程语言,这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript ,但实际上后两者是ECMAScript语言的实现和扩展。ECMAScript规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的-套JS语法工业标准。</p>
<p><img src="https://i.loli.net/2021/01/22/AaJXE4x537D2oHP.png" alt=""></p>
<p>2.DOM—文档对象模型<br>文档对象模型( Document Object Model ,简称DOM) , 是W3C组织推荐的处理可展标记语言的标准编程接口。通过DOM提供的接口可以对页面上的各种元素进行操作(大小、位置、颜色等) .</p>
<p>3.BOM—浏览器对象模型<br>BOM (Browser Object Model ,简称BOM)是指浏览器对象模型,它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口,比如弹出框、控制浏览器跳转、获取分辨率等。</p>
<h3 id="JS书写位置"><a href="#JS书写位置" class="headerlink" title="JS书写位置"></a>JS书写位置</h3><p>JS有3种书写位置,分别为行内、内嵌和外部.</p>
<h4 id="1-行内式JS"><a href="#1-行内式JS" class="headerlink" title="1.行内式JS"></a>1.行内式JS</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>= <span class="string">&quot;button&quot;</span> <span class="attr">value</span>= <span class="string">&quot;点我试试”&quot;</span> <span class="attr">onclick</span>= <span class="string">&quot;alert(&#x27;Hello world&#x27;)&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以将单行或少量JS代码写在HTML标签的事件属性中(以on开头的属性) ,如: onclick</li>
<li>注意单双引号的使用:在HTML中我们推荐使用双引号, JS中我们推荐使用单引号</li>
<li>可读性差，在html中编写JS大量代码时,不方便阅读;</li>
<li>引号易错，引号多层嵌套匹配时,非常容易弄混; </li>
<li>特殊情况下使用</li>
</ul>
<h4 id="2-内嵌JS"><a href="#2-内嵌JS" class="headerlink" title="2.内嵌JS"></a>2.内嵌JS</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">	alert(<span class="string">&#x27;Hello wiorld~!&#x27;</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以将多行JS代码写到\<script>标签中</li>
<li>内嵌JS是学习时常用的方式</li>
</ul>
<h4 id="3-外部JS文件"><a href="#3-外部JS文件" class="headerlink" title="3.外部JS文件"></a>3.外部JS文件</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;my.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>利于HTML页面代码结构化,把大段JS代码独立到HTML页面之外,既美观,也方便文件级别的复用</li>
<li>引用外部JS文件的script标签中间不可以写代码</li>
<li>适合于JS代码量比较大的情况</li>
</ul>
<h3 id="JS注释"><a href="#JS注释" class="headerlink" title="JS注释"></a>JS注释</h3><p>1.单行注释</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单行注释</span></span><br></pre></td></tr></table></figure>
<p>2.多行注释</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多行</span></span><br><span class="line"><span class="comment">注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="JS输入输出语句"><a href="#JS输入输出语句" class="headerlink" title="JS输入输出语句"></a>JS输入输出语句</h3><p>为了方便信息的输入输出, JS中提供了一些输入输出语句 ，其常用的语句如下:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>归属</th>
</tr>
</thead>
<tbody>
<tr>
<td>alert(msg)</td>
<td>浏览器弹出警示框</td>
<td>浏览器</td>
</tr>
<tr>
<td>console.log(msg)</td>
<td>浏览器控制台打印输出信息</td>
<td>浏览器</td>
</tr>
<tr>
<td>prompt(info)</td>
<td>浏览器弹出输入框,用户可以输入,取过来的值是字符型的</td>
<td>浏览器</td>
</tr>
</tbody>
</table>
</div>
<h3 id="JS变量"><a href="#JS变量" class="headerlink" title="JS变量"></a>JS变量</h3><p>本质:变量是程序在内存中申请的一块用来存放数据的空间。</p>
<p>1.声明变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明变量</span></span><br><span class="line"><span class="keyword">var</span> age;<span class="comment">//声明一个名称为age的变量</span></span><br></pre></td></tr></table></figure>
<ul>
<li>name在浏览器中有含义,最好不用name作为变量名</li>
<li>变量名以字母和下划线开头(也可以以$开头)</li>
</ul>
<p>2.赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">age = <span class="number">10</span>; <span class="comment">//给age这个变量赋值为10</span></span><br></pre></td></tr></table></figure>
<ul>
<li>= 用来把右边的值赋给左边的变量空间中此处代表赋值的意思</li>
<li>变量值是程序员保存到变量空间里的值</li>
</ul>
<p>3.同时声明多个变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">18</span>,</span><br><span class="line">	address = <span class="string">&#x27;北京&#x27;</span>,</span><br><span class="line">	name = <span class="string">&#x27;Tom&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>同时声明多个变量时,只需要写一个var,多个变量名之间使用英文逗号隔开.</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>变量是用来存储值的所在处,它们有名字和数据类型.变量的数据类型决定了如何将代表这些值的位存储到计算机的内存中.<strong>JavaScript 是一种弱类型或者说动态语言.</strong>这意味着不用提前声明变量的类型,在程序运行过程中,类型会被自动确定。</p>
<p>JS把数据类型分为两类:</p>
<ul>
<li>简单数据类型( Number, string, Boolean, Undefined, Null )</li>
<li>复杂数据类型( object)</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>简单数据类型</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>Number</td>
<td>数字型，包含整型值和浮点型值，如21、0.21</td>
<td>0</td>
</tr>
<tr>
<td>Boolean</td>
<td>布尔值类型，如true、false, 等价于1和0</td>
<td>false</td>
</tr>
<tr>
<td>String</td>
<td>字符串类型，如“张三”，字符串都带引号</td>
<td>‘’</td>
</tr>
<tr>
<td>Undefined</td>
<td>var a;声明了变量a但是没有给值，此时a = undefined</td>
<td>undefined</td>
</tr>
<tr>
<td>Null</td>
<td>var a= null;声明了变量a为空值</td>
<td>null</td>
</tr>
</tbody>
</table>
</div>
<h4 id="数字型Number"><a href="#数字型Number" class="headerlink" title="数字型Number"></a>数字型Number</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(<span class="literal">Infinity</span>); <span class="comment">// Infinity</span></span><br><span class="line">alert(-<span class="literal">Infinity</span>); <span class="comment">// -Infinity</span></span><br><span class="line">alert(<span class="literal">NaN</span>) ;<span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Infinity ,代表无穷大,大于任何数值</li>
<li>-Infinity ,代表无穷小,小于任何数值</li>
<li>NaN , Not a number,代表一个非数值</li>
</ul>
<p>isNaN()方法:</p>
<p>isNaN()这个方法用来判断非数字并且返回一个值,如果是数字返回的是false,如果不是数字返回的是true</p>
<h4 id="字符串型String"><a href="#字符串型String" class="headerlink" title="字符串型String"></a>字符串型String</h4><p>字符串型可以是引号中的任意文本,其语法为<strong>双引号””</strong>和<strong>单引号’’</strong>,推荐使用单引号</p>
<h5 id="字符串转义符"><a href="#字符串转义符" class="headerlink" title="字符串转义符"></a>字符串转义符</h5><p>类似HTML里面的特殊字符,字符串中也有特殊字符,我们称之为转义符。转义符都是\\开头的,常用的转义符及其说明如下:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>转义符</th>
<th>解释说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>\n</td>
<td>换行符，n是newline的意思</td>
</tr>
<tr>
<td>\\\\</td>
<td>斜杠\</td>
</tr>
<tr>
<td>\\’</td>
<td>单引号</td>
</tr>
<tr>
<td>\\”</td>
<td>双引号</td>
</tr>
<tr>
<td>\\t</td>
<td>tab缩进</td>
</tr>
<tr>
<td>\\b</td>
<td>空格,b是blank的意思</td>
</tr>
</tbody>
</table>
</div>
<h5 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h5><p>字符串是由若干字符组成的,这些字符的数量就是字符串的长度.通过字符串的<strong>length</strong>属性可以获取整个字符串的长度.</p>
<h5 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h5><ul>
<li>多个字符串之间可以使用+进行拼接,其拼接方式为<strong>字符串+任何类型=拼接之后的新字符串</strong></li>
<li>拼接前会把与字符串相加的任何类型转成字符串,再拼接成一个新的字符串</li>
</ul>
<h4 id="布尔型Boolean"><a href="#布尔型Boolean" class="headerlink" title="布尔型Boolean"></a>布尔型Boolean</h4><p>布尔类型有两个值: true和false,其中true表示真(对),而false表示假(错).<br>布尔型和数字型相加的时候,true的值为1, false的值为0.</p>
<h4 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">undefined</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a + <span class="string">&#x27;abc&#x27;</span>); <span class="comment">// undefinedabc</span></span><br><span class="line"><span class="built_in">console</span>.log(a + <span class="number">1</span>); <span class="comment">// NaN undefined和数字相加最后的结果是NaN</span></span><br></pre></td></tr></table></figure>
<h4 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a + <span class="string">&#x27;abc&#x27;</span>); <span class="comment">// nullabc</span></span><br><span class="line"><span class="built_in">console</span>.log(a + <span class="number">1</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h4 id="检测变量数据类型"><a href="#检测变量数据类型" class="headerlink" title="检测变量数据类型"></a>检测变量数据类型</h4><p>使用typeof检测变量的数据类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">// number</span></span><br><span class="line"><span class="keyword">var</span> b=<span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b); <span class="comment">// string</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> c); <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="literal">undefined</span> ;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> d); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> e = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> e); <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
<h4 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h4><p>使用表单、prompt 获取过来的数据默认是字符串类型的,此时就不能直接简单的进行加法运算,而需要转换变量的数据类型.通俗来说,就是<strong>把一种数据类型的变量转换成另外一种数据类型</strong>.</p>
<h5 id="转换为字符串类型"><a href="#转换为字符串类型" class="headerlink" title="转换为字符串类型"></a>转换为字符串类型</h5><div class="table-container">
<table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
<th>案例</th>
</tr>
</thead>
<tbody>
<tr>
<td>toString()</td>
<td>转成字符串</td>
<td>var num= 1; alert(num.toString());</td>
</tr>
<tr>
<td>String()强制转换</td>
<td>转成字符串</td>
<td>var num = 1; alert(String(num));</td>
</tr>
<tr>
<td>加号拼接字符串(隐式转换)</td>
<td>和字符串拼接的结果都是字符串</td>
<td>var num = 1; alert(num+“字符串”);</td>
</tr>
</tbody>
</table>
</div>
<h5 id="转换为数字型"><a href="#转换为数字型" class="headerlink" title="转换为数字型"></a>转换为数字型</h5><div class="table-container">
<table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
<th>案例</th>
</tr>
</thead>
<tbody>
<tr>
<td>parseInt(string)函数</td>
<td>将string类型转成整数数值型(将小数点后数值直接删除,同时会去掉单位)</td>
<td>parseInt(‘78’)</td>
</tr>
<tr>
<td>parseFloat(string)函数</td>
<td>将string类型转成浮点数数值型</td>
<td>parseFloat(‘78.21’)</td>
</tr>
<tr>
<td>Number()强制转换函数</td>
<td>将string类型转换为数值型</td>
<td>Number(‘12’)</td>
</tr>
<tr>
<td>js隐式转换(- * /)</td>
<td>利用算术运算隐式转换为数值型</td>
<td>‘12’-0</td>
</tr>
</tbody>
</table>
</div>
<h5 id="转换为布尔型"><a href="#转换为布尔型" class="headerlink" title="转换为布尔型"></a>转换为布尔型</h5><div class="table-container">
<table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
<th>案例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Boolean()函数</td>
<td>其他类型转成布尔值</td>
<td>Boolean(‘true’);</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>代表空、否定的值会被转换为false，如’’、0、NaN、null、undefined</li>
<li>其余值都会被转换为true</li>
</ul>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span>); <span class="comment">// 0.30000000000000004</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0.07</span>*<span class="number">100</span>); <span class="comment">// 7.000000000000001</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="number">0.1</span>+<span class="number">0.2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a==<span class="number">0.3</span>)<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>浮点数值的最高精度是17位小数,但在进行算术计算时其精确度远远不如整数</li>
<li>我们不能直接拿着浮点数来进行相比较是否相等</li>
</ul>
<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>概念:比较运算符(关系运算符)是两个数据进行比较时所使用的运算符,比较运算后,会返回一个布尔值( true / false )作为比较运算的结果。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>运算符名称</th>
<th>说明</th>
<th>案例</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;</td>
<td>小于号</td>
<td>1 &lt;2</td>
<td>true</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于号</td>
<td>1&gt;2</td>
<td>false</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于号(大于或者等于)</td>
<td>2&gt;=2</td>
<td>true</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于号(小于或者等于)</td>
<td>3&lt;=2</td>
<td>false</td>
</tr>
<tr>
<td>==</td>
<td>判等号(会转型)</td>
<td>37==37</td>
<td>true</td>
</tr>
<tr>
<td>!=</td>
<td>不等号</td>
<td>37!= 37</td>
<td>false</td>
</tr>
<tr>
<td>\===    !==</td>
<td>全等要求值和数据类型都一致</td>
<td>37 === ‘37’</td>
<td>false</td>
</tr>
</tbody>
</table>
</div>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>概念:逻辑运算符是用来进行布尔值运算的运算符,其返回值也是布尔值.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>逻辑运算符</th>
<th>说明</th>
<th>案例</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;&amp;</td>
<td>“逻辑与”，简称”与”and</td>
<td>true &amp;&amp; false</td>
</tr>
<tr>
<td>\</td>
<td>\</td>
<td></td>
<td>“逻辑或”，简称”或”or</td>
<td>true \</td>
<td>\</td>
<td>false</td>
</tr>
<tr>
<td>!</td>
<td>“逻辑非”，简称”非”not</td>
<td>! true</td>
</tr>
</tbody>
</table>
</div>
<h4 id="短路运算-逻辑中断"><a href="#短路运算-逻辑中断" class="headerlink" title="短路运算(逻辑中断)"></a>短路运算(逻辑中断)</h4><p>短路运算的原理:当有多个表达式(值)时,左边的表达式值可以确定结果时就不再继续运算右边的表达式的值</p>
<p>1.逻辑与</p>
<ul>
<li>语法:表达式1&amp;&amp;表达式2</li>
<li>如果第一个表达式的值为真,则返回表达式2</li>
<li>如果第一个表达式的值为假,则返回表达式1</li>
</ul>
<p>2.逻辑或</p>
<ul>
<li>语法:表达式1||表达式2</li>
<li>如果第一个表达式的值为真,则返回表达式1</li>
<li>如果第一个表达式的值为假,则返回表达式2</li>
</ul>
<h4 id="switch语句和if-else-if语句的区别"><a href="#switch语句和if-else-if语句的区别" class="headerlink" title="switch语句和if else if语句的区别"></a>switch语句和if else if语句的区别</h4><ol>
<li>一般情况下 ,它们两个语句可以相互替换.</li>
<li>switch…case语句通常处理case为比较确定值的情况,而if…else…语句更加灵活,常用于范围判断(大于、等于某个范国).</li>
<li>switch语句进行条件判断后直接执行到程序的条件语句,效率更高.而if…else 语句有几种条件,就得判断多少次.</li>
<li>当分支比较少时，if…else语句的执行效率比switch语句高.</li>
<li>当分支比较多时, switch语句的执行效率比较高,而且结构更清晰.</li>
</ol>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>与C语言类似</p>
<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>双for循环打印九九乘法表</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">        str=str+j+<span class="string">&#x27;×&#x27;</span>+i+<span class="string">&#x27;=&#x27;</span>+i*j+<span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    str=str+<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br></pre></td></tr></table></figure>
<p>结果如下:</p>
<p><img src="https://i.loli.net/2021/01/27/Wdv2AhMRQTE1K5m.png" alt=""></p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是指一组数据的集合,其中的每个数据被称作元素,在数组中可以存放任意类型的元素。数组是一种将一组数据存储在单个变量名下的优雅方式。</p>
<h4 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h4><p>JS中创建数组有两种方式:</p>
<ul>
<li>利用new创建数组</li>
<li>利用数组字面量创建数组(常用)</li>
</ul>
<h5 id="利用new创建数组"><a href="#利用new创建数组" class="headerlink" title="利用new创建数组"></a>利用new创建数组</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组名 = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();<span class="comment">//创建一个空数组</span></span><br></pre></td></tr></table></figure>
<h5 id="利用数组字面量创建数组"><a href="#利用数组字面量创建数组" class="headerlink" title="利用数组字面量创建数组"></a>利用数组字面量创建数组</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.使用数组字面量(方括号)方式创建空的数组</span></span><br><span class="line"><span class="keyword">var</span> 数组名 = [] ;</span><br><span class="line"><span class="comment">//2.使用数组字面量方式创建带初始值的数组</span></span><br><span class="line"><span class="keyword">var</span> 数组名 = [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>] ;</span><br></pre></td></tr></table></figure>
<h4 id="数组元素的类型"><a href="#数组元素的类型" class="headerlink" title="数组元素的类型"></a>数组元素的类型</h4><p>数组中可以存放任意类型的数据,例如字符串,数字,布尔值等.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;小白&#x27;</span>,<span class="number">123</span>,<span class="literal">true</span>,<span class="number">2.5</span>] ;</span><br></pre></td></tr></table></figure>
<h4 id="数组中新增元素"><a href="#数组中新增元素" class="headerlink" title="数组中新增元素"></a>数组中新增元素</h4><p>可以通过修改length长度以及索引号增加数组元素</p>
<h5 id="通过修改length长度新增数组元素"><a href="#通过修改length长度新增数组元素" class="headerlink" title="通过修改length长度新增数组元素"></a>通过修改length长度新增数组元素</h5><ul>
<li>可以通过修改 length长度来实现数组扩容的目的</li>
<li>length属性是可读写的</li>
<li>新增元素没有给值,默认为undefined</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>,<span class="string">&#x27;green&#x27;</span>] ;</span><br><span class="line"><span class="built_in">console</span>.log(arr.length);</span><br><span class="line">arr.length=<span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">3</span>]);<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">4</span>]);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/27/T8VcRdq5ZsKwOvU.png" alt=""></p>
<h5 id="通过修改数组索引号新增数组元素"><a href="#通过修改数组索引号新增数组元素" class="headerlink" title="通过修改数组索引号新增数组元素"></a>通过修改数组索引号新增数组元素</h5><ul>
<li>可以通过修改数组索引的方式追加数组元素</li>
<li>不能直接给数组名赋值,否则会覆盖掉以前的数据</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>,<span class="string">&#x27;green&#x27;</span>] ;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line">arr[<span class="number">3</span>]=<span class="string">&#x27;pink&#x27;</span>;<span class="comment">//新增索引号为3的元素</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line">arr[<span class="number">1</span>]=<span class="string">&#x27;yellow&#x27;</span>;<span class="comment">//修改索引号为1的元素值,由blue改为yellow</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line">arr=<span class="string">&#x27;skyblue&#x27;</span>;<span class="comment">//直接给数组名赋值,覆盖掉以前的数据</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//skyblue</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/01/27/lGt1pmcWziJkL6x.png" alt=""></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>在JS里面,可能会定义非常多的相同代码或者功能相似的代码,这些代码可能需要大量重复使用.虽然for循环语句也能实现一些简单的重复操作,但是比较具有局限性,此时我们就可以使用JS中的函数.</p>
<p>函数就是封装了一段可被重复调用执行的代码块.通过此代码块可以实现大量代码的重复使用.</p>
<h2 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h2><p>SEO是由英文Search Engine Optimization缩写而来，中文意译为”搜索引擎优化”!<br>常见的搜索引擎，比如百度，谷歌，雅虎，搜狗等等..<br>SEO是指通过对网站进行站内优化、网站结构调整、网站内容建设、网站代码优化等)和站外优化，从而提高网站的关键词排名以及公司产品的曝光度。</p>
<p>SEO三大标签:title,description,keywords</p>
<h3 id="title-网页标题"><a href="#title-网页标题" class="headerlink" title="title 网页标题"></a>title 网页标题</h3><p>title具有不可替代性，是我们的网页第一个重要标签， 是搜索引擎了解网页的入口，和对网页主题归属的最佳判断</p>
<p><img src="https://i.loli.net/2021/01/30/n14b7DSpK6tHVWl.png" alt=""></p>
<h4 id="建议"><a href="#建议" class="headerlink" title="建议:"></a>建议:</h4><p>首页标题: 网站名 (产品名)-网站的介绍</p>
<h3 id="description-网站说明"><a href="#description-网站说明" class="headerlink" title="description 网站说明"></a>description 网站说明</h3><p>对于关键词的作用明显降低，但由于很多搜索引擎，仍然大量采用网页的MATA标签中描述部分作为搜索结果的”内容摘要”。就是简要说明我们网站的主要做什么的。<br>提倡，description作为网站的总体业务和主题概括，多采用”我们是..”,”我们提供..”,”xxx网作为..”,”电话:0.0..”之类语句。</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h4><ol>
<li>描述中出现关键词,与正文内容相关,要写的详细,让人感兴趣,吸引用户点击</li>
<li>同样遵循简短原则,字符数含空格在内不要超过120个汉字</li>
<li>补充在title和keywords中未能充分表述的说明</li>
</ol>
<h3 id="keywords-关键词"><a href="#keywords-关键词" class="headerlink" title="keywords 关键词"></a>keywords 关键词</h3><p>keywords是页面关键词，是搜索引擎关注点之一。keywords应该限制在6~8个关键词左右，电商类网站可以多少许。</p>
<h2 id="字体图标-iconfont"><a href="#字体图标-iconfont" class="headerlink" title="字体图标(iconfont)"></a>字体图标(iconfont)</h2><p>图片是有诸多优点的,但是缺点很明显,比如图片不但增加了总文件的大小,还增加了很多额外的http请求”,这都会大大降低网页的性能的.更重要的是图片不能很好的进行“缩放”.因为图片放大和缩小会失真.</p>
<h3 id="字体图标优点"><a href="#字体图标优点" class="headerlink" title="字体图标优点"></a>字体图标优点</h3><ul>
<li>可以做出跟图片一样可以做的事情,改交透明度、旋转度等..</li>
<li>本质其实是文字,可以很随意的改变颜色、产生阴影、透明效果等</li>
<li>本身体积更小,但携带的信息并没有削减</li>
<li>几乎支持所有的浏览器</li>
<li>移动端设备必备良药</li>
</ul>
<h3 id="字体图标使用流程"><a href="#字体图标使用流程" class="headerlink" title="字体图标使用流程"></a>字体图标使用流程</h3><p><img src="https://i.loli.net/2021/01/30/tSbUcI9yjOEqhdR.png" alt="20190923204211903"></p>
<p>点击<a href="https://blog.csdn.net/zdd522/article/details/101224768">链接</a>查看详细介绍</p>
<h3 id="常见字体格式"><a href="#常见字体格式" class="headerlink" title="常见字体格式"></a>常见字体格式</h3><p>不同浏览器所支持的字体格式是不一样的，我们有必要了解一下有关字体格式的知识。</p>
<ol>
<li>TureTyet(.ttf)格式<br>.ttf字体是Windows和Mac最常见的字体，是一种RAW格式，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome4+、Safari3+、Opera10+、iOS Mobile、Safari4.2+;</li>
<li>OpenType(.otf)格式<br>.otf字体被认为是一种原始的字体格式，其内置在TureType的基础上，支持这种字体的浏览器有Firefox3.5+、Chrome4.0+、Safari3.1+、Opera10.0+、iOS Mobile、Safari4.2+;</li>
<li>Web Open Font Format(.woff)格式<br>.woff字体是Web字体中最佳格式，它是一个开放的TrueType/OpenType的压缩版本，同时也支持元数据包的分离，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome6+、Safari3.6+、Opera11.1+;</li>
<li>Embedded Open Type(.eot)格式<br>.eot字体是IE专用字体，可以从TrueType创建此格式字体，支持这种字体的浏览器有IE4+;</li>
<li>SVG(.svg)格式<br>.svg字体是基于SVG字体演染的一种格式，支持这种字休的浏览器有Chrome4+、Safari3.1+、Opera10.0+、iOS Mobile、Safar3.2+;</li>
</ol>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>自建网盘搜索引擎</title>
    <url>/article/57501.html</url>
    <content><![CDATA[<h1 id="教你如何自建网盘资源搜索引擎"><a href="#教你如何自建网盘资源搜索引擎" class="headerlink" title="教你如何自建网盘资源搜索引擎"></a>教你如何自建网盘资源搜索引擎</h1><a id="more"></a>
<h3 id="1-利用Google-要能科学上网"><a href="#1-利用Google-要能科学上网" class="headerlink" title="1.利用Google(要能科学上网)"></a>1.利用Google(要能科学上网)</h3><p><a href="https://cse.google.com/cse/" class="LinkCard" target="_blank">点击这里直达</a></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7559cf809c4cf41e9f0c6c79d7db4885.png" alt="image-20201114100907681"></p>
<h3 id="2-点击开始吧"><a href="#2-点击开始吧" class="headerlink" title="2.点击开始吧"></a>2.点击开始吧</h3><p>进入如下界面</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/1ae2e326d170098cd6399ebb6914aaa8.png" alt="image-20201114100937412"></p>
<h3 id="3-点击新建搜索引擎"><a href="#3-点击新建搜索引擎" class="headerlink" title="3.点击新建搜索引擎"></a>3.点击新建搜索引擎</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/56e6799e4eb5d859ce4c14e988318eda.png" alt="image-20201114101047442"></p>
<h3 id="4-依次进行配置"><a href="#4-依次进行配置" class="headerlink" title="4.依次进行配置"></a>4.依次进行配置</h3><p>注意第一个是要搜索的网站</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c2c6d2ec8573ddbe46875698e95678b9.png" alt="image-20201114101417580"></p>
<h3 id="5-创建完毕后-点击修改搜索引擎-选择刚才创建的-找到搜索引擎ID-也可以点击获取代码-插入代码即可"><a href="#5-创建完毕后-点击修改搜索引擎-选择刚才创建的-找到搜索引擎ID-也可以点击获取代码-插入代码即可" class="headerlink" title="5.创建完毕后,点击修改搜索引擎,选择刚才创建的,找到搜索引擎ID(也可以点击获取代码,插入代码即可)"></a>5.创建完毕后,点击修改搜索引擎,选择刚才创建的,找到搜索引擎ID(也可以点击获取代码,插入代码即可)</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/46d801c5e960346b65910892afbf9cc7.png" alt="image-20201114103410456"></p>
<p>外观不满意的话可以自行修改,最后附上代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#main</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">width</span><span class="selector-pseudo">:750px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">margin</span><span class="selector-pseudo">:20px</span> <span class="selector-tag">auto</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-id">#main</span> <span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">text-align</span><span class="selector-pseudo">:center</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">font-size</span><span class="selector-pseudo">:25px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">font-weight</span><span class="selector-pseudo">:bold</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">margin-button</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">百度网盘资源搜索器</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> cx = <span class="string">&#x27;你的搜索引擎ID&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> gcse = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    gcse.type = <span class="string">&#x27;text/javascript&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    gcse.async = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">    gcse.src = <span class="string">&#x27;https://cse.google.com/cse.js?cx=&#x27;</span> + cx;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> s = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;script&#x27;</span>)[<span class="number">0</span>];</span></span><br><span class="line">    s.parentNode.insertBefore(gcse, s);</span><br><span class="line">  &#125;)();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">gcse:search</span>&gt;</span><span class="tag">&lt;/<span class="name">gcse:search</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>无处安放</category>
      </categories>
      <tags>
        <tag>搜索引擎</tag>
        <tag>网盘</tag>
      </tags>
  </entry>
  <entry>
    <title>解决谷歌浏览器卸载后无法重新安装的问题</title>
    <url>/article/30147.html</url>
    <content><![CDATA[<h1 id="解决谷歌浏览器卸载后无法重新安装的问题"><a href="#解决谷歌浏览器卸载后无法重新安装的问题" class="headerlink" title="解决谷歌浏览器卸载后无法重新安装的问题"></a>解决谷歌浏览器卸载后无法重新安装的问题</h1><a id="more"></a>
<p>你是否在卸载Google后重装的路上焦头烂额？下载一遍又一遍却无法安装？（这可真是一时卸载一时爽，卸载容易重装难啊）</p>
<p>Google下载后无论怎么弄都安装不上，你焦急的求助度娘，百度出来一堆教程，却不知那个有效，只好一个个尝试搞不懂的操作（嘿嘿，不要急着否认，曾经的我就是这样）。</p>
<p>这些方法也有道理，<strong><em>Google出现安装不上的情况，一般是由于电脑之前安装过谷歌浏览器，使谷歌浏览器的注册表仍然残留在系统中，导致重新安装失败。</em></strong></p>
<p>照着网上给出的教程，我是一顿操作猛如虎（管它是什么，一顿乱删），再来安装Google，还是安装不上（当时我试了一遍又一遍，都不管用，快要崩溃），有一种想砸键盘的冲动（再也不用Google了，让你欺负我）。</p>
<p>不过说实话，Google确实好用，不舍得抛弃，我鼓捣来鼓捣去，最终找到解决方法。在这里，我把我的尝试也给列出来了。</p>
<p>解决办法如下：</p>
<h2 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a><strong>方法一：</strong></h2><p>1、打开电脑“运行”（快捷键windows+R，也可以鼠标右键点击电脑左下角“开始”键再点击“运行”）。然后输入“regedit”点击“确定”（会出来一个注册表编辑器的东西，点击“是”即可）</p>
<p>2、依次进入“计算机\HKEY_CURRENT_USER\Software\Google”文件夹并将其删除</p>
<p>3、如果无法查看到谷歌文件，可以尝试在注册列表中按住快捷键Ctrl+F，就可以进行查找看，然后再将谷歌浏览器的相关项目删除，这样就能将谷歌注册表清理干净了，有关谷歌浏览器的残留文件删除完后，您就可以尝试再次谷歌浏览器安装操作了</p>
<h2 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a><strong><em>方法二：</em></strong></h2><p>1.打开360安全卫士，选择电脑清理</p>
<p>2.点击单项清理，选择“清理注册表”</p>
<p>3.点击“一键清理”，再安装Google（如果还报错，尝试重启电脑）</p>
<h2 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h2><p>1.新建一个文本文件（不建议使用记事本，我用的是notepad++,直接在桌面建了一个）</p>
<p>2.将以下代码复制粘贴在该文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">;WARNING, this file will remove Google Chrome registry entries  </span><br><span class="line"></span><br><span class="line">;from your Windows Registry. Consider backing up your registry before</span><br><span class="line"></span><br><span class="line">; using this file: http://support.microsoft.com/kb/322756</span><br><span class="line"></span><br><span class="line">; To run this file, save it as <span class="string">&#x27;remove.reg&#x27;</span> on your desktop and double-click it.</span><br><span class="line"></span><br><span class="line">[-HKEY_LOCAL_MACHINE\SOFTWARE\Classes\ChromeHTML] </span><br><span class="line"></span><br><span class="line">[-HKEY_LOCAL_MACHINE\SOFTWARE\Clients\StartMenuInternet\chrome.exe] </span><br><span class="line"></span><br><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\RegisteredApplications]</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Chrome&quot;</span>=-</span><br><span class="line"></span><br><span class="line">[-HKEY_CURRENT_USER\SOFTWARE\Classes\ChromeHTML] </span><br><span class="line"></span><br><span class="line">[-HKEY_CURRENT_USER\SOFTWARE\Clients\StartMenuInternet\chrome.exe] </span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\SOFTWARE\RegisteredApplications]</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Chrome&quot;</span>=-</span><br><span class="line"></span><br><span class="line">[-HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Uninstall\Chrome]</span><br><span class="line"></span><br><span class="line">[-HKEY_CURRENT_USER\Software\Google\Update\Clients\&#123;8A69D345-D564-463c-AFF1-A69D9E530F96&#125;]</span><br><span class="line"></span><br><span class="line">[-HKEY_CURRENT_USER\Software\Google\Update\ClientState\&#123;8A69D345-D564-463c-AFF1-A69D9E530F96&#125;]</span><br><span class="line"></span><br><span class="line">[-HKEY_CURRENT_USER\Software\Google\Update\Clients\&#123;00058422-BABE-4310-9B8B-B8DEB5D0B68A&#125;]</span><br><span class="line"></span><br><span class="line">[-HKEY_CURRENT_USER\Software\Google\Update\ClientState\&#123;00058422-BABE-4310-9B8B-B8DEB5D0B68A&#125;]</span><br><span class="line"></span><br><span class="line">[-HKEY_LOCAL_MACHINE\SOFTWARE\Google\Update\ClientStateMedium\&#123;8A69D345-D564-463c-AFF1-A69D9E530F96&#125;]</span><br><span class="line"></span><br><span class="line">[-HKEY_LOCAL_MACHINE\SOFTWARE\Google\Update\Clients\&#123;8A69D345-D564-463c-AFF1-A69D9E530F96&#125;]</span><br><span class="line"></span><br><span class="line">[-HKEY_LOCAL_MACHINE\SOFTWARE\Google\Update\ClientState\&#123;8A69D345-D564-463c-AFF1-A69D9E530F96&#125;]</span><br><span class="line"></span><br><span class="line">[-HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Google\Update\Clients\&#123;8A69D345-D564-463c-AFF1-A69D9E530F96&#125;]</span><br></pre></td></tr></table></figure>
<p>3.将该文件命名为rm.reg</p>
<p>4.双击运行（可能会出来一些选项，我默认了），再重装Google即可</p>
<h2 id="方法四"><a href="#方法四" class="headerlink" title="方法四:"></a>方法四:</h2><p>听闻geek卸载软件可以删除注册表，所以可以用它卸载Google，且重装不会有问题。（可能对大部分人，此方法意义不大）<br>给出链接<br> 链接:<a href="https://pan.baidu.com/s/1qaDZ05A9yD1jhOcUeQppuA">https://pan.baidu.com/s/1qaDZ05A9yD1jhOcUeQppuA</a><br> 提取码:386a</p>
<h2 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h2><p>该文仅为记载我在重装Google的艰辛历程，以上方法均为网络收集，如果和我有相同问题的朋友可以尝试一下，节约你百度的时间。如果对于第三种方法不懂这里有现成的文件，下面给出链接：<a href="https://download.csdn.net/download/moshangduanchang/12354433">点这里呀</a></p>
]]></content>
      <categories>
        <category>无处安放</category>
      </categories>
      <tags>
        <tag>Google</tag>
      </tags>
  </entry>
</search>
